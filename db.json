{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechat-qcode.jpg","path":"images/wechat-qcode.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/love.js","path":"js/src/love.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508779580},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1524821066652},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1524821066651},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1524821066653},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1524821066659},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1524821066662},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1524821066660},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1524821066663},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1524821066664},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1524821066665},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1524821066666},{"_id":"themes/next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1524821066668},{"_id":"themes/next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1524821066670},{"_id":"themes/next/_config.yml","hash":"9dbc6f425395bea0b3d33f4de6f98171e9fe9e46","modified":1553678581555},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1524821066673},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1524821066675},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1524821066800},{"_id":"source/about/index.md","hash":"06b881312dac26b8e0866f2450d5630b331e533f","modified":1525359665161},{"_id":"source/categories/index.md","hash":"bec8e393fbb6e037b3da97046bc849410500aa7d","modified":1506508779585},{"_id":"source/tags/index.md","hash":"2a841f1fac2f2256353c16b72bb5083b659fc8af","modified":1506508779586},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1524821066655},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1524821066656},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1524821066657},{"_id":"themes/next/.git/config","hash":"8e94cc015a498d35202e9fd57e44b3c51e1e5634","modified":1524821066615},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1524821066658},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1524820572443},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1524821066597},{"_id":"themes/next/.git/index","hash":"366a17d9ae3379bef51d4e7dc3a4c06a65547792","modified":1553677366357},{"_id":"themes/next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1524821066583},{"_id":"themes/next/layout/_layout.swig","hash":"b778a849035a0ade4dc01f68c81e57fbb83f29d9","modified":1525440550530},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1524821066794},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1524821066795},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1524821066795},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1524821066796},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1524821066797},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1524821066798},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1524821066799},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1524821066676},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1524821066678},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1524821066680},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1524821066681},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1524821066682},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1524821066685},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1524821066686},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1524821066683},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1524821066687},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1524821066689},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1524821066690},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1524821066691},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1524821066691},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1524821066692},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1524821066694},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1524821066801},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1524821066695},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1524821066804},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1524821067235},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1524821067236},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1524821067237},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524821066951},{"_id":"source/_posts/ES6/ES6：apply、call和bind.md","hash":"65055ca56ba3fd6bbe1b5ea11ca167e0a139c821","modified":1584435664854},{"_id":"source/_posts/ES6/ES6：let和const.md","hash":"21065fb1880c94c01ed144792494a8bfb1c0f34b","modified":1584435648288},{"_id":"source/_posts/ES6/ES6：promise.md","hash":"979c41713601c5a2177b0ca03c6c471c0786f31c","modified":1584435608898},{"_id":"source/_posts/ES6/ES6：箭头函数.md","hash":"077cbb0ca957a5147d408b069c25398fedd6d567","modified":1584435630883},{"_id":"source/_posts/css/css：BFC.md","hash":"80048c93128501d34ce433449cd37995b88d4f1b","modified":1589446242536},{"_id":"source/_posts/css/css：line-height.md","hash":"6510c98407658f4022bdb823605a12d1a2d7a404","modified":1589446303974},{"_id":"source/_posts/css/css：margin塌陷.md","hash":"3ed3c79b9536a79da92eaad0de3ba5d933d82e7d","modified":1553586320128},{"_id":"source/_posts/css/css：flex布局.md","hash":"2c5d80a57cd1cabecc1fd2b8f0deb12164a8b6da","modified":1556029248736},{"_id":"source/_posts/css/css：margin塌陷和margin合并.md","hash":"6c258bfad0b16993919ecfc399f35adb26b06a79","modified":1589446257101},{"_id":"source/_posts/css/css：position.md","hash":"a30c6f38dd87323e7026671835da988751bdfce6","modified":1589446206797},{"_id":"source/_posts/css/css：优先级.md","hash":"d4610c736c07dc8cb68f1ad0aabf4f3ea54ef828","modified":1556029265914},{"_id":"source/_posts/css/css：positon.md","hash":"44a6a9d00a51e17dc07b3e4227bd069b7c5d6f23","modified":1553571837303},{"_id":"source/_posts/css/css：各种单位.md","hash":"42453e57b378f50eec1d38e6cc22ee8b05be6a87","modified":1589446223755},{"_id":"source/_posts/css/css：圣杯布局和双飞翼布局.md","hash":"aa5f6a3287b64dcb24284f5e8072b2daf0cebe3a","modified":1589446326865},{"_id":"source/_posts/css/css：垂直水平居中.md","hash":"bcfffe379ec6e41bb6ef6f8fd7c0d4e597604b6e","modified":1589446296343},{"_id":"source/_posts/css/css：模块化.md","hash":"0474a4d5acc79b49eb024f1df3a8b8e1a6557e06","modified":1589446188858},{"_id":"source/_posts/css/css：盒模型.md","hash":"2141e7c77789dcf7e604111cd2ad0b5f34f9fbde","modified":1589446282268},{"_id":"source/_posts/css/css：垂直居中.md","hash":"8c33c57a74a8d8b857d93b029434c22d7a73835e","modified":1553590045983},{"_id":"source/_posts/css/css：清除浮动.md","hash":"351e046b5eb63b72035e390be4ed0962e3ecea25","modified":1553571866710},{"_id":"source/_posts/css/css：等宽的三栏布局.md","hash":"3442b93a034b7c2285aeb7c256ad198a8473d70c","modified":1589446268515},{"_id":"source/_posts/css/css：隐藏元素.md","hash":"893dbc82f253cf344526391682c9acd9fff33374","modified":1589446234053},{"_id":"source/_posts/css/css：选择器.md","hash":"98b9ff41d7ef2c9c2599a2c85300a0176c2728d6","modified":1589446336653},{"_id":"source/_posts/git/git：关于回退版本的一些小技巧.md","hash":"fdcaa7956a1cb06445e4f62b391c1bd0b1899ea0","modified":1584435399656},{"_id":"source/_posts/git/git：git fetch和git pull.md","hash":"9ba9b9954079cbc5898234ca8de3ad2021595897","modified":1584435367135},{"_id":"source/_posts/git/git：分支管理之合并.md","hash":"97d9f6cd2097fe17c98d791b4c51bccab47fe2ce","modified":1584435227289},{"_id":"source/_posts/git/git：git使用.md","hash":"ac5eb34541e0efbb9b5458ffd828ac8b860b0646","modified":1584435266116},{"_id":"source/_posts/git/git：将在master分支上做的修改提交到分支.md","hash":"6ebd49e059e3ea5e8e09b12b448f19f263d36997","modified":1584435335723},{"_id":"source/_posts/git/git：添加到远程github仓库的一个错误.md","hash":"55ced18f5dcdbd77badaaea6570adeb0bbf967a8","modified":1584435313710},{"_id":"source/_posts/git/npm清理缓存.md","hash":"61603223f23e617459b6f6fe2b5bc094179bd94b","modified":1525356121334},{"_id":"source/_posts/git/npm install 出错.md","hash":"eacab187848c82075b4e7a52e6fa17f455593ad8","modified":1551171329394},{"_id":"source/_posts/js高级程序设计/DOM.md","hash":"e82e89de149374dfdfe849b7db3e3d83fc524055","modified":1525359522408},{"_id":"source/_posts/js高级程序设计/JSON与Ajax.md","hash":"ddf50e3947b76f22b2cf4b79764368d25051ae8b","modified":1525359498549},{"_id":"source/_posts/js高级程序设计/事件.md","hash":"f04aee4029291f3eb6c04c0ae1d9c6b6e7fcd39e","modified":1525359463623},{"_id":"source/_posts/js高级程序设计/引用类型.md","hash":"300c628cd36b59451f6e4f40a3a2dbf57fe93657","modified":1584433738215},{"_id":"source/_posts/js高级程序设计/面向对象的程序设计.md","hash":"3033d7edf4f4a9eb6c5e8b5a2607acd01a409a25","modified":1584433720285},{"_id":"source/_posts/js高级程序设计/函数表达式.md","hash":"17a2d77db603465d6b2647eb508db49aad267997","modified":1525359484237},{"_id":"source/_posts/vue/vue+axios解决文件上传问题.md","hash":"d889de31694339e4c69b5ad28b0f93e514328454","modified":1551171418156},{"_id":"source/_posts/vue/vue：MVVM、MVC、MVP.md","hash":"58c9997f8ec883d9508a5bf4c03f23af357e05f3","modified":1584433444970},{"_id":"source/_posts/vue/Vue-cli脚手架.md","hash":"4642f08f2dcfb0bcfb95694a514f54154fcd1d4d","modified":1584433389556},{"_id":"source/_posts/vue/vue：其他.md","hash":"1f8ae298aa8370419bfa54bfae9c729200351991","modified":1553590947965},{"_id":"source/_posts/vue/vue：数据双向绑定原理.md","hash":"156fa82735e7f1db522734365f08d355dadf0e19","modified":1584433474280},{"_id":"source/_posts/vue/vue：生命周期.md","hash":"a842bbd6535460e44d1b263fa00c844be1f973ad","modified":1584433336966},{"_id":"source/_posts/vue/vue：组件间的传值.md","hash":"b01ffe787fd95420071fe2647eac175bd85a548c","modified":1584433498795},{"_id":"source/_posts/vue/vue：移动端适配.md","hash":"31b9046a94f2d39b0e5870d7a252f91d0c7980c9","modified":1584433423840},{"_id":"source/_posts/vue/vue：路由原理.md","hash":"b86db87a91d438ce5c4d1f4a0f053ef7605b28c8","modified":1584433518097},{"_id":"source/_posts/其他/Electron进阶：打开新窗口.md","hash":"fa2adabe7532f8a38a813f198b465c936751f060","modified":1551171524371},{"_id":"source/_posts/其他/Electron：从零到完成一个桌面应用.md","hash":"187ece8f21c575bd4bd09a521c57e1d7e2372822","modified":1551171465811},{"_id":"source/_posts/其他/Electron：结合vue创建桌面应用.md","hash":"e2489004c6cd07b494f06a7319451efb9c801197","modified":1551171500061},{"_id":"source/_posts/其他/Hexo+Github 搭建属于自己的博客（基础）.md","hash":"ddff76d41cfbb38aa3df7b32b495271a7e6abe08","modified":1525445844269},{"_id":"source/_posts/其他/Hexo+Github 搭建属于自己的博客（进阶）NexT主题.md","hash":"3823f9df2be6a7ec2dbcd763bd1b88ab494a6bfa","modified":1525441630007},{"_id":"source/_posts/其他/hello-world.md","hash":"ce685b69cfc4483cb5ab70100191ef201b5f1183","modified":1525359515712},{"_id":"source/_posts/其他/安全：XSS和CSRF.md","hash":"8b10faa85ab2cd601c858e786114b1802a5129d7","modified":1589449719240},{"_id":"source/_posts/其他/安全：cookie和session.md","hash":"f5b1ff0bcc089636de30099f1009380ad4454244","modified":1589449518896},{"_id":"source/_posts/其他/操作系统：进程、线程、程序.md","hash":"ca845c0decd0b22e26de157ecfc0faec5c4c254f","modified":1589445941669},{"_id":"source/_posts/其他/数据结构：树的深度遍历和广度遍历.md","hash":"6a2920fddfd3851ffbabd3521404c438b49a7bc2","modified":1589445982226},{"_id":"source/_posts/其他/数据类型：json和xml.md","hash":"4c5ff9ecb903749516fe286c6cb0ea6da3888d86","modified":1589445960396},{"_id":"source/_posts/js/js：Math的常用方法.md","hash":"db714fe1e4b8ed5dc7ec3baee35c2d90fba3938a","modified":1589447321570},{"_id":"source/_posts/js/js：==和===.md","hash":"0a91de03abe32c910b5adf2fc90779cc73670145","modified":1589446812304},{"_id":"source/_posts/js/js：__proto__和prototype.md","hash":"7683e55405f113c38ed9fdc67204daec238921ce","modified":1589447182118},{"_id":"source/_posts/js/js：ajax.md","hash":"0449ddb792106976e3f1c2f536022817ffb4b395","modified":1589446919213},{"_id":"source/_posts/js/js：setTimeout和setInterval.md","hash":"12cccf3bc46c21c9bcb20c93c14acf72fb92c400","modified":1589447332551},{"_id":"source/_posts/js/js：new一个函数发生了什么.md","hash":"b4b1fd6d5d8c6524567728e161d1e5cba598db25","modified":1589446836372},{"_id":"source/_posts/js/js：this指向.md","hash":"96bfe023853bbb11812ca5d259c840870ec9d9f1","modified":1589447207760},{"_id":"source/_posts/js/js：typeof和instanceof.md","hash":"095e1e2aac182f8d0510bcb96a63065cc6a55733","modified":1589446884628},{"_id":"source/_posts/js/js：一些关于date的获取方法.md","hash":"aa1015df5013cfc85c04b8afb848e43b392349b6","modified":1589446969185},{"_id":"source/_posts/js/js：不同类型之间的比较与运算.md","hash":"f549a3d0aeba60cd59daf41228d798ce2a0e453d","modified":1589446985756},{"_id":"source/_posts/js/js：事件委托.md","hash":"9086aa2ea1edb3f43f51fd79a9efa2f285f67094","modified":1589447150443},{"_id":"source/_posts/js/js：事件循环机制Event Loop.md","hash":"0d6901603491e5aa4e22f29fde01199dd6788c34","modified":1589446788843},{"_id":"source/_posts/js/js：作用域.md","hash":"47237cc83f4f176a9c61951e63baa75671df27e9","modified":1589447142096},{"_id":"source/_posts/js/js：关于闭包.md","hash":"2a28416f27952aa81316e21155d5d27dae4e8752","modified":1589447129342},{"_id":"source/_posts/js/js：判断一个空对象或空数组.md","hash":"eaf9f517b10050666e79739a61318aee279f076b","modified":1589447011237},{"_id":"source/_posts/js/js：事件模型.md","hash":"6415701d7551d2c788a09624a605e628ebf51b92","modified":1589447081315},{"_id":"source/_posts/js/js：发布-订阅和观察者.md","hash":"3ce83728bb69ba1fb093d22ccf2b5c433b96f741","modified":1589447355795},{"_id":"source/_posts/js/js：内存泄漏.md","hash":"75cf477176629e93f2773853fa0a907eba3fd309","modified":1589447089958},{"_id":"source/_posts/js/js：实现给数字添加千分位符的方法.md","hash":"cef05cebba7ce44f459b50285a3fa76f73c72a4c","modified":1589447439651},{"_id":"source/_posts/js/js：图片预加载和懒加载.md","hash":"373183b75fa48a5d96610b7005233fd7a36a64fc","modified":1589446803512},{"_id":"source/_posts/js/js：字符串常用的方法.md","hash":"84eed1e62f7380f6ae08a956c8217c8ab7f695a3","modified":1589446933112},{"_id":"source/_posts/js/js：数组去重.md","hash":"4e64a35756871c6eea93b78d6fda84c42b870ec7","modified":1589446822266},{"_id":"source/_posts/js/js：基础类型和引用类型.md","hash":"c0b5453d88b5999f6f5eb7707e54f91f33042ce3","modified":1589447062735},{"_id":"source/_posts/js/js：数组的常用方法.md","hash":"7fa3b508181b74c11939e0221560ddcc2b9f8847","modified":1589447120565},{"_id":"source/_posts/js/js：时间复杂度.md","hash":"e131a79765a3bd9e85ffde2bfab8c44bb2f891cb","modified":1589447431725},{"_id":"source/_posts/js/js：数组和链表.md","hash":"4aa77a41355dd6428a059c0c3c59932d78b53ba3","modified":1589447073375},{"_id":"source/_posts/js/js：正则表达式.md","hash":"04ca4f22555acbd027cdd10db10f2487541b51ec","modified":1589447190322},{"_id":"source/_posts/js/js：文件上传.md","hash":"2e980d1aa5523aab8d7bb588f4ab51b013e1fad7","modified":1589447044724},{"_id":"source/_posts/js/js：瀑布流布局.md","hash":"9e2d6e75260497b5095034a36701d6a487dd95f8","modified":1589447420315},{"_id":"source/_posts/js/js：立即执行函数.md","hash":"f0cf16f542cfb42f10df5f17bc5b2c1923b84191","modified":1589447407368},{"_id":"source/_posts/js/js：浅拷贝与深拷贝.md","hash":"c319ccdf09ce0a883b0bfb75259ba5ae2565eaba","modified":1589447036810},{"_id":"source/_posts/js/js：简化运算.md","hash":"3b393cefeb3fc284e104e8dcbc56a46e69119e80","modified":1589447197730},{"_id":"source/_posts/js/js：递归和非递归实现中序遍历.md","hash":"917e6ba7f83289fe409bc56f47ba0972d4ede6bf","modified":1589446949299},{"_id":"source/_posts/js/js：类数组对象.md","hash":"26ee802a6e0b693554446602d468871be3e459e3","modified":1589448210433},{"_id":"source/_posts/js/js：防抖和节流.md","hash":"b837284789280001f7d3c56b73b89d74d272e9fe","modified":1589446996070},{"_id":"source/_posts/前端/BOM和DOM.md","hash":"f1ec9c7823fe8457dca87d0b243a51c58e37819f","modified":1556029415866},{"_id":"source/_posts/前端/WebSocket.md","hash":"17d3dc2d2d0a4fa9c2d6863b96940ae895a421f7","modified":1589445008976},{"_id":"source/_posts/前端/canvas.md","hash":"02d3b342fea5304ba4b57c25ad4d6c0972bec6f2","modified":1589444904167},{"_id":"source/_posts/前端/h5和css3的新特性.md","hash":"24e7616eac2cd1a7053f90d371d3ea7a6bb34561","modified":1553571899306},{"_id":"source/_posts/前端/web页面性能优化.md","hash":"7e25592cef644b89d28b6562916af6c5eadac6e8","modified":1589444977088},{"_id":"source/_posts/前端/一些调试小技巧.md","hash":"ff9b57e194d8fa730b3a80167abdb73622598cdd","modified":1589444957784},{"_id":"source/_posts/前端/前端SEO（搜索引擎优化）和语义化.md","hash":"176d9e841064cb2d9bd85027559e6ee085956ed5","modified":1589445110499},{"_id":"source/_posts/前端/回流（Reflow）和重绘（Repaint）.md","hash":"f40bce2f023c45ef87380f913f03ee99dc78db86","modified":1589445033561},{"_id":"source/_posts/前端/前端学习路线规划.md","hash":"c83003c4d16b9efc98063cbb5b869b8a1c880c90","modified":1525356155206},{"_id":"source/_posts/前端/本地存储方式.md","hash":"5444fc27c166c86a81698445b8655a02bf095985","modified":1553571927355},{"_id":"source/_posts/前端/浏览器兼容问题.md","hash":"8886aea9110330bc62e5fc0a890c95693938b90a","modified":1589444923167},{"_id":"source/_posts/前端/浏览器本地缓存.md","hash":"30593cdb880e8069dac82c5e82201d31330d53fa","modified":1589445068407},{"_id":"source/_posts/前端/浏览器渲染机制.md","hash":"1ef3895d61f02aeb792e5b3422e720a498057ad2","modified":1589444991892},{"_id":"source/_posts/前端/渐进增强和优雅降级.md","hash":"df259d39c3e1b455d352b39e6578147fa1a6db0d","modified":1589444884028},{"_id":"source/_posts/前端/行内元素、块元素、行内块元素.md","hash":"5acb80be83feb75f6d6b6b4bdd7343836eba8902","modified":1589445088612},{"_id":"source/_posts/前端/虚拟dom.md","hash":"f08916a9c350df6a4110e7a8860fce32dbdaadde","modified":1556028988213},{"_id":"source/_posts/前端/页面渲染过程（输入一个url）.md","hash":"1e052ea8c991c014358ccd6aa32e9aeae25846a1","modified":1589445128254},{"_id":"source/_posts/算法/LeetCode算法题（一）.md","hash":"026e01ed4fca80861109ba182eebf7c7c9890863","modified":1584436309417},{"_id":"source/_posts/算法/C：冒泡法和选择法.md","hash":"78cac071390fa6eef266dd57753c30acfe063145","modified":1584436107266},{"_id":"source/_posts/算法/LeetCode：有效的括号.md","hash":"75ff72f11e91808987fe14a69455c933973b5c68","modified":1584436276163},{"_id":"source/_posts/算法/LeetCode：罗马数字转整数.md","hash":"f7720e7f16536682fd3f489dc583a8de0242bda2","modified":1584436286106},{"_id":"source/_posts/算法/LeetCode：验证回文串.md","hash":"f41752f1b175ceb78f50385da0e53de9ce321c44","modified":1584436265915},{"_id":"source/_posts/算法/各种算法（一）.md","hash":"4c757ae4af5e0d343d85ac782e4f535da0e4b7d9","modified":1553672094838},{"_id":"source/_posts/算法/各种算法（三）.md","hash":"10231d8348367f15bc6aaa89e30138d22ac2f77f","modified":1553672342515},{"_id":"source/_posts/算法/各种算法（二）.md","hash":"5323249c817b89a0a39aa065420c2fbb901a23db","modified":1553672319075},{"_id":"source/_posts/算法/算法：两数相加为0.md","hash":"89a497bc8143d7e88874c6ca711a1a466067d552","modified":1584436204134},{"_id":"source/_posts/算法/算法：二分查找.md","hash":"60026bc231ed75197be4ad08c984dc7acbeb436b","modified":1556029298334},{"_id":"source/_posts/算法/算法：二进制转十进制.md","hash":"862990457883a1be46b08a5f03a3be4570623f98","modified":1584436341563},{"_id":"source/_posts/算法/算法：多层数组转化为一层.md","hash":"0676ef75ac4cf3f53a516700fcac1819b0b25e39","modified":1584436181764},{"_id":"source/_posts/算法/算法：如何找出单链表中的倒数第k个元素.md","hash":"f890a33ac211ce2978d372cdf21c214389e2c421","modified":1584436298924},{"_id":"source/_posts/算法/算法：快速排序.md","hash":"aa3927f3ccb37f8e5e2b400fe148f5671c964e7e","modified":1584436129113},{"_id":"source/_posts/算法/算法：把十六进制的ip地址转换为十进制的.md","hash":"661757b78dc71a4e082407ecd73f425e9ef16086","modified":1584436154117},{"_id":"source/_posts/算法/算法：青蛙跳台阶和斐波那契数列.md","hash":"af867ff17810780419b326a320d0bb5e80932888","modified":1584436339809},{"_id":"source/_posts/计网/计网：DNS查询过程.md","hash":"c8d65b492a314432fecc346fe700c88d91554735","modified":1581662706002},{"_id":"source/_posts/计网/计网：TCP.md","hash":"d424b6e7b4f67e3ac98abe90efb175f7afeee513","modified":1589445631503},{"_id":"source/_posts/计网/计网：cdn.md","hash":"5ef6170554bc91e4d49eac1d3a1de0fd071f504a","modified":1589445622240},{"_id":"source/_posts/计网/计网：http和https.md","hash":"656b51e9d9d286047587e0562bdfeb5c80b34139","modified":1589445613311},{"_id":"source/_posts/计网/计网：http报文结构.md","hash":"85b0b5031577b5df85c66fa0792f1b9aece57e05","modified":1589445603650},{"_id":"source/_posts/计网/计网：http的header字段.md","hash":"c45e7191407f53b0450d2b41e886c75abb473074","modified":1589445643078},{"_id":"source/_posts/计网/计网：计算机网络体系结构.md","hash":"b720803a720ba37fa922cee0bf88158bf15197d3","modified":1589445653881},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1524820572446},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1524820572445},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1524820572448},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1524820572447},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1524820572449},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1524820572450},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1524820572452},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1524820572455},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1524820572454},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1524820572456},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1524820572457},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1524820572458},{"_id":"themes/next/.git/logs/HEAD","hash":"32054c052436333fa4adc3a9fd1abb300cf10580","modified":1524821066603},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1524821066697},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1524821066699},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1524821066711},{"_id":"themes/next/layout/_partials/footer.swig","hash":"b07155fed9c90367f0487ec81a1d534a077a42fd","modified":1525441564525},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1524821066714},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1524821066718},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1524821066720},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1524821066721},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1524821066721},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1524821066734},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1524821066736},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1524821066745},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1524821066776},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1524821066778},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1524821066778},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1524821066780},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1524821066779},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1524821066782},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1524821066783},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"396feef13c2f0a2241d70b28a304e6583d3d32f8","modified":1525441033915},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1524821066702},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1553677364455},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1524821066706},{"_id":"themes/next/layout/_macro/post.swig","hash":"c96b1734c9f762b682302227fec158354b065aca","modified":1525441169809},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1524821066708},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1524821066709},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1524821066806},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1524821066808},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1524821066809},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1524821066810},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1524821066812},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1524821066813},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1524821066813},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1524821066814},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1524821066815},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1524821066949},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1524821066953},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1524821066954},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1524821066954},{"_id":"themes/next/source/images/alipay.jpg","hash":"fcb6d9fa1fd854704c4d05f08075dcf0d7be5794","modified":1553673805459},{"_id":"themes/next/source/images/avatar.jpg","hash":"d9e60786d78e4aef645e074ca96e6129213b12df","modified":1553673585688},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1524821066956},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1524821066959},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1524821066957},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1524821066960},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1524821066961},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1524821066962},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1524821066965},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1524821066963},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1524821066966},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1524821066967},{"_id":"themes/next/source/images/favicon.ico","hash":"d9e60786d78e4aef645e074ca96e6129213b12df","modified":1553673623791},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1524821066969},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1524821066968},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1524821066970},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1524821066971},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1524821066971},{"_id":"themes/next/source/images/wechat-qcode.jpg","hash":"7832c859090367020320581690625c021d428b56","modified":1524832808534},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"04437df4744747f13578f4aa5fe8dda336dfa98b","modified":1524832667794},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524821066739},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524821066741},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524821066909},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524821066910},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524821066912},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524821066944},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524821066947},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1524821066603},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1524821066716},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1524821066717},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1524821066723},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1524821066725},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1524821066726},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1524821066728},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1524821066729},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1524821066730},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1524821066732},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1524821066737},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1524821066739},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1524821066743},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1524821066747},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1524821066749},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1524821066751},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1524821066752},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1524821066748},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1524821066753},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1524821066755},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1524821066754},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1524821066756},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1524821066759},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1524821066761},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1524821066758},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1524821066762},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1524821066764},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1524821066765},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1524821066767},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1524821066768},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1524821066770},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1524821066769},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1524821066774},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1524821066771},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1524821066772},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1524821066787},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1524821066788},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1524821066793},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1524821066790},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1524821066907},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1524821066909},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1524821066911},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1524821066912},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1524821066944},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1524821066943},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1524821066946},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1524821066947},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1524821066974},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1524821066975},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1524821066976},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1524821066977},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1524821066978},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1524821066979},{"_id":"themes/next/source/js/src/love.js","hash":"e8e69e9107c0d32d77094915ec8f2c21c80ad4dd","modified":1524831411556},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1524821066981},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1524821066982},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1524821066985},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1524821066986},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1524821066987},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1524821067008},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1524821067019},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1524821067021},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1524821067017},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1524821067022},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1524821067048},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1524821067049},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1524821067052},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1524821067050},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1524821067060},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1524821067062},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1524821067059},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1524821067063},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1524821067064},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1524821067102},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1524821067111},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1524821067113},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1524821067110},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1524821067108},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1524821067115},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1524821067116},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1524821067120},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1524821067118},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1524821067122},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1524821067125},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1524821067127},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1524821067131},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1524821067130},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1524821067133},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1524821067135},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1524821067148},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1524821067140},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1524821067143},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1524821067154},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1524821067150},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1524821067152},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1524821067153},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1524821067155},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1524821067160},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1524821067162},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1524821067163},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1524821067216},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1524821067213},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1524821067228},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1524821067230},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1524821067231},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"32054c052436333fa4adc3a9fd1abb300cf10580","modified":1524821066606},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1524821066594},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1524821066786},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1524821066785},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1524821066818},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1524821066819},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1524821066821},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1524821066820},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1524821066823},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1524821066846},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1524821066875},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1524821066898},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1524821066899},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1524821066900},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1524821066902},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1524821066905},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1524821066904},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1524821066905},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1524821066915},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1524821066920},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1524821066916},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1524821066917},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1524821066918},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1524821066922},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1524821066921},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1524821066931},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1524821066928},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1524821066923},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1524821066929},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1524821066932},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1524821066930},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1524821066940},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1524821066936},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1524821066941},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1524821066937},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1524821066941},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1524821066938},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1524821066984},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1524821067001},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1524821067005},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1524821067007},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1524821067025},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1524821067026},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1524821067030},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1524821067031},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1524821067028},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1524821067033},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1524821067042},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1524821067046},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1524821067044},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1524821067054},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1524821067056},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1524821067068},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1524821067067},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1524821067070},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1524821067105},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1524821067211},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1524821067209},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1524821067003},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1524821067098},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1524821067100},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1524821067224},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"32054c052436333fa4adc3a9fd1abb300cf10580","modified":1524821066594},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1524821066825},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1524821066834},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1524821066835},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1524821066827},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1524821066837},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1524821066828},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1524821066832},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1524821066839},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1524821066830},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1524821066829},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1524821066840},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1524821066842},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1524821066843},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1524821066845},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1524821066847},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1524821066850},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1524821066849},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1524821066848},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1524821066852},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1524821066851},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1524821066854},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1524821066857},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1524821066858},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1524821066853},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1524821066856},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1524821066860},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1524821066859},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1524821066861},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1524821066863},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1524821066862},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1524821066866},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1524821066867},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1524821066864},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1524821066868},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1524821066870},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1524821066869},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1524821066873},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1524821066878},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1524821066872},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1524821066874},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1524821066879},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1524821066877},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1524821066881},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1524821066880},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1524821066882},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1524821066885},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1524821066883},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1524821066884},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1524821066889},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1524821066891},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1524821066888},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1524821066894},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1524821066894},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1524821066892},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1524821066896},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1524821066895},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1524821066897},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1524821066893},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1524821066925},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1524821066926},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1524821066934},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1524821066994},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1524821066992},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1524821066999},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1524821066995},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1524821066997},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1524821067036},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1524821067034},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1524821067037},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1524821067039},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1524821067038},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1524821067041},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1524821067075},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1524821067096},{"_id":"themes/next/.git/objects/pack/pack-d258fa1f2c5e7883ae4ad56137897435c083f34c.idx","hash":"3bf4e7a7818532e249eb3076a1cf03e01e1c58ae","modified":1524821066400},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1524821067081},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1524821067016},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1524821067204},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1524821067091},{"_id":"themes/next/.git/objects/pack/pack-d258fa1f2c5e7883ae4ad56137897435c083f34c.pack","hash":"942c4f76bc16782c1ca1f7d358236acb6111014c","modified":1524821066468},{"_id":"public/search.xml","hash":"932fa4c8863a30613072118242c5f1db54930c6b","modified":1589449776834},{"_id":"public/about/index.html","hash":"eca97f37a075ad9c9abd4acc491c8b9898784bdb","modified":1589449777570},{"_id":"public/categories/index.html","hash":"0a13426503c8a3ef78d9771d235cf7718f96a9c0","modified":1589449777580},{"_id":"public/tags/index.html","hash":"1a9a2f8473e985cd28df13373c0183f78a0311a5","modified":1589449777580},{"_id":"public/2020/03/17/算法/算法：青蛙跳台阶和斐波那契数列/index.html","hash":"61ea15b3ea1ddfc5d64e8768dc18368673a31388","modified":1589449777590},{"_id":"public/2020/03/17/算法/算法：二进制转十进制/index.html","hash":"d033d43801a52bd311088663632dad721b65ddc5","modified":1589449777590},{"_id":"public/2020/03/17/算法/算法：多层数组转化为一层/index.html","hash":"bcc1ba7df9eee7f6a855a767a5d0f9fe76bb40b8","modified":1589449777590},{"_id":"public/2020/03/17/算法/算法：两数相加为0/index.html","hash":"bd8f693fda6c485277c23346e23acb79f5c936cf","modified":1589449777590},{"_id":"public/2020/03/17/算法/LeetCode：验证回文串/index.html","hash":"b18017681b4d39d095d19b439e9b574618ab9945","modified":1589449777590},{"_id":"public/2020/03/17/算法/LeetCode：有效的括号/index.html","hash":"3e47e1f55a2f5baf5087b22b0b42957c377713d1","modified":1589449777590},{"_id":"public/2020/03/17/算法/LeetCode：罗马数字转整数/index.html","hash":"01c09889b0347cf73e144dcc16842149dc1fcdaf","modified":1589449777590},{"_id":"public/2020/03/17/算法/算法：如何找出单链表中的倒数第k个元素/index.html","hash":"299fae9d726fe012d6f85680b4b735d451e5df51","modified":1589449777590},{"_id":"public/2020/03/17/算法/LeetCode算法题（一）/index.html","hash":"8907e13d500c1442365ef60f8e260807b572c6c8","modified":1589449777590},{"_id":"public/2020/03/17/算法/算法：把十六进制的ip地址转换为十进制的/index.html","hash":"d7ba3af22e97f7388d3b3845ba937ea0775e6fdf","modified":1589449777590},{"_id":"public/2020/03/17/算法/算法：快速排序/index.html","hash":"221fd0b0a8a4449957a9b9206ca93df9191d248c","modified":1589449777590},{"_id":"public/2020/03/17/算法/C：冒泡法和选择法/index.html","hash":"421460389480db31031842c8e63c51277b74c07f","modified":1589449777590},{"_id":"public/2020/03/17/ES6/ES6：apply、call和bind/index.html","hash":"92e9b1915dcfefa0bd9a452c7d4f5dd383e8195f","modified":1589449777590},{"_id":"public/2020/03/17/ES6/ES6：let和const/index.html","hash":"208a1bbbea0bbe58b63a3d2f5c643d00bbe97d26","modified":1589449777590},{"_id":"public/2020/03/17/ES6/ES6：箭头函数/index.html","hash":"69847ffbcd6f23a6c7bb42941787f5e5c5a7c4e8","modified":1589449777590},{"_id":"public/2020/03/17/ES6/ES6：promise/index.html","hash":"b5d6a8a01a3afa44897b9c825b5f4804ae909fe4","modified":1589449777590},{"_id":"public/2020/03/17/git/git：关于回退版本的一些小技巧/index.html","hash":"ee6f888524e308fa2c5020bedf61261137e34f98","modified":1589449777590},{"_id":"public/2020/03/17/git/git：git fetch和git pull/index.html","hash":"1060c0d346dff710fff630e18ada4198a3e7fe5a","modified":1589449777590},{"_id":"public/2020/03/17/git/git：将在master分支上做的修改提交到分支/index.html","hash":"b1e1392b89a088553f912deaa631bcf138cdad22","modified":1589449777590},{"_id":"public/2020/03/17/git/git：添加到远程github仓库的一个错误/index.html","hash":"0b660ef2026ee431482dd2298b67ffa894169cf9","modified":1589449777590},{"_id":"public/2020/03/17/git/git：git使用/index.html","hash":"cb1d5321880f819cad089b804afe228ee225d027","modified":1589449777590},{"_id":"public/2020/03/17/git/git：分支管理之合并/index.html","hash":"bd1733e2d8ca50d43cc089d2eded4c85b4516dc3","modified":1589449777590},{"_id":"public/2020/03/17/js高级程序设计/面向对象的程序设计/index.html","hash":"c10242df0455707a0616ceb4fe33a2de36f8eade","modified":1589449777590},{"_id":"public/2020/03/17/js高级程序设计/引用类型/index.html","hash":"e7bd325a6949d7a9b642e2b474016d051efebf17","modified":1589449777590},{"_id":"public/2020/03/17/vue/vue：数据双向绑定原理/index.html","hash":"8ad613f2bee4e160f11f0a1cb401b83657331932","modified":1589449777590},{"_id":"public/2020/03/17/vue/vue：路由原理/index.html","hash":"137ae1642af5a7d4f418b1c39f9f9423df635e07","modified":1589449777590},{"_id":"public/2020/03/17/vue/vue：组件间的传值/index.html","hash":"6a1728327609e6d61e463042a7f1ee6686ddefc3","modified":1589449777590},{"_id":"public/2020/03/17/vue/vue：MVVM、MVC、MVP/index.html","hash":"f3187e74734ac3c6db56a8a191d80e600df8ac84","modified":1589449777590},{"_id":"public/2020/03/17/vue/vue：移动端适配/index.html","hash":"c775579d56e79fa77864aab4847cf73e93199ce9","modified":1589449777590},{"_id":"public/2020/03/17/vue/Vue-cli脚手架/index.html","hash":"fb44b543bb95886e33ef52b8133452792b671607","modified":1589449777590},{"_id":"public/2020/03/17/vue/vue：生命周期/index.html","hash":"63d39adbb6f6eb3ba3d8726199698aa14952a974","modified":1589449777590},{"_id":"public/2019/04/23/js/js：立即执行函数/index.html","hash":"cc35fe190e2282ba6f4bcd0f7440a1629fb4fe4d","modified":1589449777590},{"_id":"public/2019/04/23/js/js：setTimeout和setInterval/index.html","hash":"a5c5dcce80b403c2a6d12a73ed71262bded3650a","modified":1589449777590},{"_id":"public/2019/04/23/前端/BOM和DOM/index.html","hash":"76e4d8d92fa92544acbae129672ce6726312d1a9","modified":1589449777590},{"_id":"public/2019/04/23/算法/算法：二分查找/index.html","hash":"429a54b83d34387c95c85315ea1ca8aed7a393b6","modified":1589449777590},{"_id":"public/2019/04/23/css/css：优先级/index.html","hash":"4a5941c7c4f09f31d1f855dd549b414e625c9078","modified":1589449777590},{"_id":"public/2019/04/23/前端/虚拟dom/index.html","hash":"7a731a44c9c2293390884b9284f4f1ff27bada9b","modified":1589449777590},{"_id":"public/2019/04/23/js/js：时间复杂度/index.html","hash":"e96a8e45f23ba089757710d0708587a97953abdc","modified":1589449777590},{"_id":"public/2019/03/27/算法/各种算法（三）/index.html","hash":"d90efa6414e1e206c03133bbe8e676feaec31459","modified":1589449777590},{"_id":"public/2019/03/27/算法/各种算法（二）/index.html","hash":"140d91defc673285d36f7fc0b41c06074f6a0b7d","modified":1589449777590},{"_id":"public/2019/03/27/前端/浏览器本地缓存/index.html","hash":"3e00e6982026486b2408ff684cc6ce36c6ad0f06","modified":1589449777590},{"_id":"public/2019/03/27/算法/各种算法（一）/index.html","hash":"781dbae10c53a197e7c2989c9cfbad720651b3a2","modified":1589449777590},{"_id":"public/2019/03/27/前端/渐进增强和优雅降级/index.html","hash":"9a828e5196fdcb4956fcf68fa734bb10fbcb6720","modified":1589449777590},{"_id":"public/2019/03/27/js/js：瀑布流布局/index.html","hash":"932e13166346ea0f9c45bc648463a5543fcb11bb","modified":1589449777590},{"_id":"public/2019/03/26/vue/vue：其他/index.html","hash":"65ee61ae4aef4d534e60b8ce0eed88a3be670e5a","modified":1589449777590},{"_id":"public/2019/03/26/js/js：实现给数字添加千分位符的方法/index.html","hash":"3b3a31d0f1310218a10a2ac92d53653447f9719a","modified":1589449777590},{"_id":"public/2019/03/26/js/js：发布-订阅和观察者/index.html","hash":"5543c4c2a6c25fb30075fb3a5bbd8fd889100d75","modified":1589449777600},{"_id":"public/2019/03/26/js/js：Math的常用方法/index.html","hash":"ac0bc0cc979a24f5f2653e092caa982aedf64282","modified":1589449777600},{"_id":"public/2019/03/26/css/css：margin塌陷/index.html","hash":"530350e3bff580a5031cefde321aaae12ba54a9a","modified":1589449777600},{"_id":"public/2019/04/23/css/css：flex布局/index.html","hash":"57c09182a4a9db7a13b77ae2b0476b916be37b18","modified":1589449777590},{"_id":"public/2019/03/26/css/css：垂直居中/index.html","hash":"1f87e92563778ec2b1a5030d087f968c8927dd21","modified":1589449777600},{"_id":"public/2019/03/26/前端/h5和css3的新特性/index.html","hash":"1d6ad1a66078e8b5f03c100a31e87910b75ed36d","modified":1589449777600},{"_id":"public/2019/03/26/前端/本地存储方式/index.html","hash":"98d16ae68f37f2c37f151907166ad058d9431eb6","modified":1589449777600},{"_id":"public/2019/02/26/vue/vue+axios解决文件上传问题/index.html","hash":"9ee6b366485fc2c91d25cf8c4e21f1263298322d","modified":1589449777600},{"_id":"public/2019/02/26/git/npm install 出错/index.html","hash":"72d4375ae8d8f197e3c3bd1ded5f150aa48ebe9c","modified":1589449777600},{"_id":"public/2018/05/03/js高级程序设计/事件/index.html","hash":"c8a41fe6c3bd5531f27573c95e4b43f14b3d52c2","modified":1589449777600},{"_id":"public/2018/05/03/js高级程序设计/函数表达式/index.html","hash":"306f321af15276156481df26e03ac704292bb4b8","modified":1589449777600},{"_id":"public/2018/05/03/js高级程序设计/JSON与Ajax/index.html","hash":"6f070f01b08ab5a66832b37de676da56bb512660","modified":1589449777600},{"_id":"public/2018/05/03/js高级程序设计/DOM/index.html","hash":"cc09d7f112814d903758f85de821e566c9f27980","modified":1589449777600},{"_id":"public/2018/05/03/前端/前端学习路线规划/index.html","hash":"671f63dcf06e2d80dd1f1fc4eca6e38552490c01","modified":1589449777600},{"_id":"public/2018/05/03/git/npm清理缓存/index.html","hash":"0cc390531ceb9b0ecb55c13273c98273682c6146","modified":1589449777600},{"_id":"public/archives/index.html","hash":"76df5723ccb30d5adb6389765ab79f3795457f82","modified":1589449777600},{"_id":"public/archives/page/2/index.html","hash":"5713c1ed43c8c4ec070b91c7d27ffb47332b7ad2","modified":1589449777600},{"_id":"public/archives/page/3/index.html","hash":"b2bf64eaca7622713747b1dd401428896eb35fdf","modified":1589449777600},{"_id":"public/archives/page/4/index.html","hash":"d2a9385b218c240ad9708795c65a48c1e6f36d62","modified":1589449777600},{"_id":"public/archives/page/5/index.html","hash":"ba74f4965366788595ef9f13b071bb844bebd364","modified":1589449777600},{"_id":"public/archives/page/6/index.html","hash":"79bf5d82781ec8a37c77f8c58c3582b7c486328e","modified":1589449777600},{"_id":"public/archives/page/7/index.html","hash":"425071178e69d4388954fb710413ba83c430fd39","modified":1589449777600},{"_id":"public/archives/page/8/index.html","hash":"5e427058268f8e81a7f119ceed16468da75bdecd","modified":1589449777600},{"_id":"public/archives/page/9/index.html","hash":"27e5683bf03278fe04e123be3a5f8b5fe3bc3c3e","modified":1589449777600},{"_id":"public/archives/2018/index.html","hash":"5beac5512034e23f36d17dee4beba2f8e204f659","modified":1589449777600},{"_id":"public/archives/2018/05/index.html","hash":"bd57ad7db9b677dd62630bf25bf383c35f441913","modified":1589449777600},{"_id":"public/2019/03/26/css/css：positon/index.html","hash":"8d942c231de7fa0308144803abab2ab0d72209e0","modified":1589449777600},{"_id":"public/archives/2019/page/2/index.html","hash":"e35aac5d75ae19320b583d595153cdfa6cfe7595","modified":1589449777600},{"_id":"public/archives/2019/index.html","hash":"fdeaac470c2732a68a73f6317fddae8ae2b9238a","modified":1589449777600},{"_id":"public/archives/2019/02/index.html","hash":"7aff97af70cc380e7c9bc8b93149a394144fce6d","modified":1589449777600},{"_id":"public/archives/2019/page/3/index.html","hash":"f62d5bb0c0c105029521bf26a5adac46c7b02a70","modified":1589449777600},{"_id":"public/archives/2019/03/index.html","hash":"10e67b8f21e905e233bcc1166b26af7180e88d35","modified":1589449777600},{"_id":"public/archives/2019/04/index.html","hash":"742bce51456673b1587080ef5c88f50dd02af431","modified":1589449777600},{"_id":"public/archives/2020/index.html","hash":"9e8ec4f5858f98bbdd9fa446b5075e20efa57470","modified":1589449777600},{"_id":"public/archives/2019/03/page/2/index.html","hash":"6fc2f6c1a45cb2a134cfe5b89b49fa56805e5b3c","modified":1589449777600},{"_id":"public/archives/2020/page/2/index.html","hash":"c20b76ed3aa7d531a81be3f2187286a00a6989d6","modified":1589449777600},{"_id":"public/archives/2020/page/3/index.html","hash":"c4cd1395a9695b28490a054f00580ef2b2598b77","modified":1589449777600},{"_id":"public/archives/2020/page/4/index.html","hash":"60c3466065808d9faf35712cc45ef7f36ddeb65f","modified":1589449777600},{"_id":"public/archives/2020/03/index.html","hash":"514c9fbfc55312ee926cac00821eac9fb1d1bacf","modified":1589449777600},{"_id":"public/archives/2020/03/page/2/index.html","hash":"2ad7fd47659b32f6901d1a28c54da5d258ce4568","modified":1589449777600},{"_id":"public/archives/2020/03/page/3/index.html","hash":"ded8f8f7dfab78e9cc835f13bc660748c0123836","modified":1589449777600},{"_id":"public/archives/2020/03/page/4/index.html","hash":"c2f0f0bcda2ce0a072afcf3371cecaebba065d51","modified":1589449777610},{"_id":"public/2019/03/26/css/css：清除浮动/index.html","hash":"eea8f811af52d665af4ed4ba0b83f3748e213d54","modified":1589449777600},{"_id":"public/categories/ES6/index.html","hash":"044bf406ebf4eb06988fa3ec69295eacf47dcee2","modified":1589449777610},{"_id":"public/categories/CSS/index.html","hash":"678a0734597689d758821bdb29e0c0cdbabd0e7e","modified":1589449777610},{"_id":"public/categories/git/index.html","hash":"fdf6e5042189a55839f422226151e91450dcebc9","modified":1589449777610},{"_id":"public/categories/npm/index.html","hash":"e6177f9a85dd93f7cfcf35a598ca95cbfa4b5583","modified":1589449777610},{"_id":"public/categories/红宝书/index.html","hash":"8923e6a3b1aa2a58b9da25c9020e95f4fdeff837","modified":1589449777610},{"_id":"public/categories/vue/index.html","hash":"d3a071045d59b5df52bb5439186dc21712011bc9","modified":1589449777610},{"_id":"public/categories/JS/index.html","hash":"b8cde6ac38d4c12ded66f041a152c468746c4194","modified":1589449777610},{"_id":"public/categories/JS/page/2/index.html","hash":"b686811da210c9a0784a1f38ac53431a1a324189","modified":1589449777610},{"_id":"public/categories/前端/index.html","hash":"fadd98be34373d60e462794d9f3cf14fb026014a","modified":1589449777610},{"_id":"public/categories/算法/index.html","hash":"131a904f837c62c19b966535d2f665c0356c057c","modified":1589449777610},{"_id":"public/categories/算法/page/2/index.html","hash":"7b2bf6a6f3ecf9c85d8a5842d117e4c2cba901cc","modified":1589449777610},{"_id":"public/categories/计网/index.html","hash":"30b7f9ce233319ce1be5459ce154ea9dd5f2b60b","modified":1589449777610},{"_id":"public/index.html","hash":"59592392cb08a07d307c85a45b688f7ad090f2f1","modified":1589449777610},{"_id":"public/page/2/index.html","hash":"6daf97cd886fdacfed0dd25caabb1fae1a97171e","modified":1589449777610},{"_id":"public/page/3/index.html","hash":"498debd7faee1b765d03ab57781ef24c3dc5fadf","modified":1589449777610},{"_id":"public/page/4/index.html","hash":"18801ad1931c34a939ea84202b29186bbbaaa146","modified":1589449777610},{"_id":"public/page/5/index.html","hash":"d91a17e7cb55647295a7a97f6c82f73a3d6defa9","modified":1589449777610},{"_id":"public/page/6/index.html","hash":"9406393dde801440bd2091ceefe3658ccb8866f3","modified":1589449777610},{"_id":"public/page/7/index.html","hash":"44d1a96e8b99590774854dba84109f1f8963e2a7","modified":1589449777610},{"_id":"public/page/8/index.html","hash":"fb5242ab015aeb790942dcf8c3ee94bef2110e37","modified":1589449777610},{"_id":"public/page/9/index.html","hash":"cd1e5707aeb8e9ee4733cf2e4ad3e871a74697d9","modified":1589449777610},{"_id":"public/tags/ES6/index.html","hash":"4a40e76d89de8700550b55a40f395cedfee4786c","modified":1589449777610},{"_id":"public/tags/CSS/index.html","hash":"a9e5b146801b661d965088ff4c3027c2426762f1","modified":1589449777610},{"_id":"public/tags/git/index.html","hash":"5f0d0105a14748d5d1ecb1142a76944a5ca289ad","modified":1589449777610},{"_id":"public/tags/npm/index.html","hash":"a4971b471dbce4f2a2a252a34c9cfd98c0ec0904","modified":1589449777610},{"_id":"public/tags/红宝书/index.html","hash":"7ac67af827675f0d42df744a92d122122cd2ee56","modified":1589449777610},{"_id":"public/tags/vue/index.html","hash":"f85ed8fe5bc50d30226b2aeccb74db77ee94a277","modified":1589449777610},{"_id":"public/tags/JS/index.html","hash":"c018162b84f34059abfd0c09bcbb91fe9a057319","modified":1589449777620},{"_id":"public/tags/JS/page/2/index.html","hash":"0d8bb7731e5e24b1b1f8e4194cb9467255136762","modified":1589449777620},{"_id":"public/tags/前端/index.html","hash":"2f4febb02358f70b5d9fb708dc6eb6162790c4f7","modified":1589449777620},{"_id":"public/tags/算法/index.html","hash":"29bb5af217463fc557894c510c6dd8793aac6344","modified":1589449777620},{"_id":"public/tags/算法/page/2/index.html","hash":"101829151a0a4136dae5ca967cdb39af288b7fbb","modified":1589449777620},{"_id":"public/tags/计网/index.html","hash":"362011aaa91280f9347ced33fdcd2e786ba74cee","modified":1589449777620},{"_id":"public/2020/05/14/js/js：类数组对象/index.html","hash":"06e85beab1cbdb9580c9f5faeb1b7b5701a27c91","modified":1589449777580},{"_id":"public/2020/05/14/js/js：关于闭包/index.html","hash":"c21dc392c43656368e2fcbff8e50bdb575426091","modified":1589449777580},{"_id":"public/2020/05/14/js/js：作用域/index.html","hash":"c6da16f7b62bbd96f3cf31216747198f316fb94d","modified":1589449777580},{"_id":"public/2020/05/14/js/js：浅拷贝与深拷贝/index.html","hash":"bfaf22de20529a4c01b599fa208e9c210733db2d","modified":1589449777580},{"_id":"public/2020/05/14/js/js：文件上传/index.html","hash":"b23e70b3aecdc4d84cc36ad892418225e6d7d24e","modified":1589449777580},{"_id":"public/2020/05/14/js/js：事件委托/index.html","hash":"002f15d97b96b6fd7d5525c2c5cf771c7b3453cc","modified":1589449777580},{"_id":"public/2020/05/14/js/js：__proto__和prototype/index.html","hash":"47cfa86820d44497610dcbc92c1ca33ef84b627b","modified":1589449777580},{"_id":"public/2020/05/14/js/js：基础类型和引用类型/index.html","hash":"bdaa9b95f1f15fdfeb409d1fc07ae7892609f38f","modified":1589449777580},{"_id":"public/2020/05/14/js/js：数组和链表/index.html","hash":"1c8a7609a1aeffeeffdde40185c009f9c3ea2f0d","modified":1589449777580},{"_id":"public/2020/05/14/js/js：正则表达式/index.html","hash":"bc9b503939c6e2a53d59177e73deecb2ded0a530","modified":1589449777580},{"_id":"public/2020/05/14/js/js：简化运算/index.html","hash":"033b6bb8a96f1586ef8140b380ba395cec262bdf","modified":1589449777580},{"_id":"public/2020/05/14/js/js：this指向/index.html","hash":"4637f49666a6db1c379bde30a1f5548c7a833153","modified":1589449777580},{"_id":"public/2020/05/14/js/js：事件模型/index.html","hash":"d3d19ffda4200a3d4f195e9a46c8a856a96dcd1b","modified":1589449777580},{"_id":"public/2020/05/14/js/js：内存泄漏/index.html","hash":"7e0fa9c5518cd69f172385a69241d20a5d2a4338","modified":1589449777580},{"_id":"public/2020/05/14/js/js：ajax/index.html","hash":"d38e06703ab9c51631d49a3f1212bf0935bd73a9","modified":1589449777580},{"_id":"public/2020/05/14/js/js：字符串常用的方法/index.html","hash":"77fcac362771d0bca9b59ae9582d6a61d08ddb0f","modified":1589449777580},{"_id":"public/2020/05/14/js/js：递归和非递归实现中序遍历/index.html","hash":"c5ca0d724211fd27eeaeb60e84d73dc3799de8b8","modified":1589449777580},{"_id":"public/2020/05/14/js/js：一些关于date的获取方法/index.html","hash":"c0ac385c5d459a878cff23a725293ecdfed7e2cb","modified":1589449777580},{"_id":"public/2020/05/14/js/js：不同类型之间的比较与运算/index.html","hash":"629c3700839c32812d30b6015671dfe9b5820d69","modified":1589449777580},{"_id":"public/2020/05/14/js/js：防抖和节流/index.html","hash":"17cbb62781381529d20239eff4f6d2551308d389","modified":1589449777580},{"_id":"public/2020/05/14/js/js：判断一个空对象或空数组/index.html","hash":"63bdc324da019e2800942b5076d79bce103a9a1a","modified":1589449777580},{"_id":"public/2020/05/14/js/js：typeof和instanceof/index.html","hash":"7cc2129b8ac393909f9d854673de90e5abb4b7c5","modified":1589449777580},{"_id":"public/2020/05/14/js/js：new一个函数发生了什么/index.html","hash":"3ad15175b67b36044fe498a47f83acf56feda869","modified":1589449777580},{"_id":"public/2020/05/14/js/js：数组去重/index.html","hash":"ebb80692719234dcad7a63a98e4b80f1b1da4214","modified":1589449777580},{"_id":"public/2020/05/14/js/js：==和===/index.html","hash":"cceefd24788feb659a74a86c026c1be180bec96b","modified":1589449777580},{"_id":"public/2020/05/14/js/js：图片预加载和懒加载/index.html","hash":"391ea04bbab9b23ab56749b85b956cc4de871014","modified":1589449777580},{"_id":"public/2020/05/14/js/js：事件循环机制Event Loop/index.html","hash":"b360cb811adba02adb5ea708b51e708eb4f260b0","modified":1589449777580},{"_id":"public/2020/05/14/js/js：数组的常用方法/index.html","hash":"1d45786fb21226705c7d4841293e17937a5c011a","modified":1589449777580},{"_id":"public/2020/05/14/css/css：垂直水平居中/index.html","hash":"f61bdf0e5f147c8da1141c2acc296d1acee2c825","modified":1589449777580},{"_id":"public/2020/05/14/css/css：line-height/index.html","hash":"61236098d70ae9cdb8cc6b6511d6f3f1ee0d2f4c","modified":1589449777580},{"_id":"public/2020/05/14/css/css：圣杯布局和双飞翼布局/index.html","hash":"876bf0d02c4be2f7925a661e5687364daa6652cf","modified":1589449777580},{"_id":"public/2020/05/14/css/css：选择器/index.html","hash":"c1b65dbcdab4c6fca3d3abaffe225a5f2ffc7e7e","modified":1589449777580},{"_id":"public/2020/05/14/css/css：各种单位/index.html","hash":"5e5421207488c4a0e178a9802a85e36e6a6a37c1","modified":1589449777580},{"_id":"public/2020/05/14/css/css：隐藏元素/index.html","hash":"0543ad1a8e00f94cf7db7266ec281b4541672b11","modified":1589449777580},{"_id":"public/2020/05/14/css/css：BFC/index.html","hash":"9c627d629073fed8cffd051a1558c8dcb3df6e18","modified":1589449777580},{"_id":"public/2020/05/14/css/css：margin塌陷和margin合并/index.html","hash":"802939203430db8495639e82444a014f13818283","modified":1589449777580},{"_id":"public/2020/05/14/css/css：等宽的三栏布局/index.html","hash":"8bf5d98921ed2d9880c33b493997747174b2bb48","modified":1589449777580},{"_id":"public/2020/05/14/css/css：position/index.html","hash":"1df0d34242388b81c6434ef001adf0bc737273a8","modified":1589449777580},{"_id":"public/2020/05/14/css/css：模块化/index.html","hash":"88fb6da0cc715c5e857b2728f8d7fc1138c69bcb","modified":1589449777580},{"_id":"public/2020/05/14/css/css：盒模型/index.html","hash":"9d9048890a6d65c759f9ea1516c5817daf37c5ed","modified":1589449777580},{"_id":"public/2020/05/14/计网/计网：计算机网络体系结构/index.html","hash":"3e914d593240d3ac93f3804ea8e18c32847d0e8b","modified":1589449777580},{"_id":"public/2020/05/14/计网/计网：http的header字段/index.html","hash":"8712b0300cc02199117b2f848e8e73b3957f34e4","modified":1589449777580},{"_id":"public/2020/05/14/计网/计网：TCP/index.html","hash":"3a7096337f0c9222f22aea8dc4aa44f5f281d28b","modified":1589449777580},{"_id":"public/2020/05/14/计网/计网：DNS查询过程/index.html","hash":"a5c9451f4a783f30e4c684665d944997660f322e","modified":1589449777580},{"_id":"public/2020/05/14/计网/计网：cdn/index.html","hash":"3340522f62e8499dc2de9b80561bbe161a2c00c8","modified":1589449777580},{"_id":"public/2020/05/14/计网/计网：http和https/index.html","hash":"040d08bdb62f4218ebfaffbab45ecc9fde33ac1e","modified":1589449777580},{"_id":"public/2020/05/14/计网/计网：http报文结构/index.html","hash":"1932300e7d000072936389178a015abacf8225c8","modified":1589449777580},{"_id":"public/2020/05/14/前端/web页面性能优化/index.html","hash":"db2ee117b71e2d254d8af7862bb0d76e295a8ce0","modified":1589449777580},{"_id":"public/2020/05/14/前端/一些调试小技巧/index.html","hash":"53ffdac3d84b95bec75cdb92c17ea275ea736fdd","modified":1589449777580},{"_id":"public/2020/05/14/前端/浏览器兼容问题/index.html","hash":"67d221ad3c84840767fea7be78cdd73fbccadf08","modified":1589449777580},{"_id":"public/2020/05/14/前端/canvas/index.html","hash":"8686cb73d14abbffb8ef571adfbb707602dcb716","modified":1589449777580},{"_id":"public/2020/05/14/前端/页面渲染过程（输入一个url）/index.html","hash":"8a3b0c8f817fa2f0486c0ea45e94c87bb0deace2","modified":1589449777590},{"_id":"public/2020/05/14/前端/前端SEO（搜索引擎优化）和语义化/index.html","hash":"cbe7be031e0736d4d9119f9af958964b9b528388","modified":1589449777580},{"_id":"public/2020/05/14/前端/行内元素、块元素、行内块元素/index.html","hash":"e5c75fe3914350701f15d188c30b7bb3198bc701","modified":1589449777590},{"_id":"public/2020/05/14/前端/回流（Reflow）和重绘（Repaint）/index.html","hash":"12f2b76a33f47d737f6a79a4322150241187983f","modified":1589449777590},{"_id":"public/2020/05/14/前端/WebSocket/index.html","hash":"5ab086d1b842ab3e7241444bf122b24833582f49","modified":1589449777590},{"_id":"public/2020/05/14/前端/浏览器渲染机制/index.html","hash":"11f9a4f3606b35119570491e8c0c488cb72fd6af","modified":1589449777590},{"_id":"public/archives/page/10/index.html","hash":"f3274ca62cfb79e10717b83e9afb7214da6da72e","modified":1589449777600},{"_id":"public/archives/page/11/index.html","hash":"fd01e722e991fe7928c387af395e745cee7a88e4","modified":1589449777600},{"_id":"public/archives/2020/page/5/index.html","hash":"6ac04273c1286cf4118b61fcb3b7c1602d9715b4","modified":1589449777600},{"_id":"public/archives/2020/page/6/index.html","hash":"cdbc34c0cef89825327f35b0ad5bbfa155c9cb25","modified":1589449777600},{"_id":"public/archives/2020/page/7/index.html","hash":"af97953bbca53bbe0919b04ff598adf40379e153","modified":1589449777600},{"_id":"public/archives/2020/page/9/index.html","hash":"0cb0d25c113a8c7ccb98ddc01794a1dc40b79af0","modified":1589449777600},{"_id":"public/archives/2020/page/8/index.html","hash":"595e4baa92e2d0d20e63917fd9830cbb9c4f0185","modified":1589449777600},{"_id":"public/archives/page/12/index.html","hash":"6e3e50f74e16a52834f7a60fd5299c0c97ff1b59","modified":1589449777600},{"_id":"public/archives/2020/05/index.html","hash":"aea8ec572dae55048c0189a9ca2cf1a8966ec8cd","modified":1589449777610},{"_id":"public/archives/2020/05/page/2/index.html","hash":"8a1c168026d59197702787c59347a16b95c72a48","modified":1589449777610},{"_id":"public/archives/2020/05/page/3/index.html","hash":"dd48924f5291e3c5ce9ce0b144c3cfab0fe528f6","modified":1589449777610},{"_id":"public/archives/2020/05/page/4/index.html","hash":"aa5132dd3b01f5c2d939811689da55accfce9ab1","modified":1589449777610},{"_id":"public/archives/2020/05/page/5/index.html","hash":"a977baa2d07a6f088ae26778391d39c79975f614","modified":1589449777610},{"_id":"public/archives/2020/05/page/6/index.html","hash":"43745c6ba51bbb652a96756d03675e1d84cfc04f","modified":1589449777610},{"_id":"public/categories/CSS/page/2/index.html","hash":"841cb28e4bbed925d1f80c506cd7fcbd17a2209e","modified":1589449777610},{"_id":"public/categories/JS/page/3/index.html","hash":"4f0c11c77c5020571c9057fde644abda08162bf6","modified":1589449777610},{"_id":"public/categories/JS/page/4/index.html","hash":"0f88b8bdd90edef19388c3e35a80c9415035c5c0","modified":1589449777610},{"_id":"public/categories/前端/page/2/index.html","hash":"51ce3ada599829df869bcfdc3473cc80964566b0","modified":1589449777610},{"_id":"public/page/10/index.html","hash":"a9c25059842b4a626e41be1648046fefafd249a3","modified":1589449777610},{"_id":"public/page/11/index.html","hash":"6dd148d509a8adfa529086a55e7e963986e475dd","modified":1589449777610},{"_id":"public/page/12/index.html","hash":"205f014d74d791e52390c8af8a69814c79152f31","modified":1589449777610},{"_id":"public/tags/CSS/page/2/index.html","hash":"279cbe7eecc9d1b085a473193f9a7781584f2ba4","modified":1589449777610},{"_id":"public/tags/JS/page/3/index.html","hash":"33f76342badd990544faf36bf2b60d87dbdcbc16","modified":1589449777620},{"_id":"public/tags/JS/page/4/index.html","hash":"f006de060932b210624d116e8c18f87a617e66cd","modified":1589449777620},{"_id":"public/tags/前端/page/2/index.html","hash":"3f5d3a4f70306055f1f6e26ee94e0f8ffe4e9532","modified":1589449777620},{"_id":"public/archives/2018/04/index.html","hash":"95714b48e5e0256c58268bc20b673ced21775d6e","modified":1589449777600},{"_id":"public/categories/Electron/index.html","hash":"d93a491dd7c7a7cc439b264a55d3a62fd8c4ffef","modified":1589449777610},{"_id":"public/categories/博客搭建/index.html","hash":"6e5265acd31c4d3d81c521bec0b7c7bd5ede625f","modified":1589449777610},{"_id":"public/categories/demo/index.html","hash":"4b80392e8f288070113df2a1cb564e8fc15c10cc","modified":1589449777610},{"_id":"public/tags/Electron/index.html","hash":"fb64eaf2c59cd323155732144615de11966b739a","modified":1589449777610},{"_id":"public/tags/博客搭建/index.html","hash":"497f1c74396de067709f889900b8cbb306ef615f","modified":1589449777610},{"_id":"public/tags/demo/index.html","hash":"c7b95889a11e6251fbfeb6bc38fa2f1056ad5a70","modified":1589449777610},{"_id":"public/2020/05/14/其他/数据结构：树的深度遍历和广度遍历/index.html","hash":"838dcf9574c6887638001287901ff740d36b580e","modified":1589449777580},{"_id":"public/2020/05/14/其他/操作系统：进程、线程、程序/index.html","hash":"c099fe556e82600842899ab8878d7664b8140d8e","modified":1589449777580},{"_id":"public/2020/05/14/其他/数据类型：json和xml/index.html","hash":"8899f9c7dd66b35a0bec5f7bfc0cec64445f8448","modified":1589449777580},{"_id":"public/2019/02/26/其他/Electron进阶：打开新窗口/index.html","hash":"c5d7fae0b22c44b4ce5d9a455884a258cf5ed20b","modified":1589449777600},{"_id":"public/2019/02/26/其他/Electron：结合vue创建桌面应用/index.html","hash":"5e74092a0cf5fc7af0467f711943faeefb1ff7e4","modified":1589449777600},{"_id":"public/2019/02/26/其他/Electron：从零到完成一个桌面应用/index.html","hash":"b488e96177e3021f6b068699d91164fac63225a6","modified":1589449777600},{"_id":"public/2018/05/04/其他/Hexo+Github 搭建属于自己的博客（进阶）NexT主题/index.html","hash":"6858fd600a090cff01e2121aa8a390bd48e2a450","modified":1589449777600},{"_id":"public/2018/05/03/其他/Hexo+Github 搭建属于自己的博客（基础）/index.html","hash":"ff339e12b8967d370bda542ad2a7bb0cdc6d2910","modified":1589449777600},{"_id":"public/2018/04/27/其他/hello-world/index.html","hash":"493a5ed9ceb8b6776bcd21e83db937eceedb94de","modified":1589449777600},{"_id":"public/archives/page/13/index.html","hash":"83366e76ac02c74d9c4608a57db9fab022bebc6d","modified":1589449777600},{"_id":"public/archives/2020/page/10/index.html","hash":"d9a0df9c694d8edf3807c153af703b0f6ead84f9","modified":1589449777600},{"_id":"public/categories/操作系统/index.html","hash":"a0e4629cfd4579ec4444e81d77ab01a68b5426cb","modified":1589449777610},{"_id":"public/categories/数据结构/index.html","hash":"b369c2614d6515887a22739d88f955a25a1ff639","modified":1589449777610},{"_id":"public/categories/数据类型/index.html","hash":"d143518a53e22a711fb169f356fffd02ac16a45e","modified":1589449777610},{"_id":"public/page/13/index.html","hash":"615746707d3524ba7896577c7f2921fc050cb411","modified":1589449777610},{"_id":"public/tags/操作系统/index.html","hash":"7996cc8d504dfbdb486180b4bfe17e32740c9788","modified":1589449777620},{"_id":"public/tags/数据结构/index.html","hash":"e20a7f3567eaa7c0f09b264ece8fd86d8cf78121","modified":1589449777620},{"_id":"public/tags/数据类型/index.html","hash":"d538b0202f329713003eba791a6dbb4889366f75","modified":1589449777620},{"_id":"public/2020/05/14/其他/安全：cookie和session/index.html","hash":"597cd8ed426a51352fb16930bdf3f97baf2f40a2","modified":1589449777580},{"_id":"public/archives/2020/05/page/7/index.html","hash":"58e9cf8031b65c8e7feb0dafcacf03d0f897ff4f","modified":1589449777610},{"_id":"public/categories/安全/index.html","hash":"285ea5703fc41139c10c98c4dac412bcfda4d111","modified":1589449777610},{"_id":"public/tags/安全/index.html","hash":"5edabec15a3d2070bc456cf82a19c354fe55e5bb","modified":1589449777610},{"_id":"public/2020/05/14/其他/安全：XSS和CSRF/index.html","hash":"fd5faf6f3a14a3b4c4a1a73725ce9ecf3c08e1c9","modified":1589449777630},{"_id":"public/archives/page/14/index.html","hash":"6f27626ff76782913b66faf731583c64c3b308ae","modified":1589449777630},{"_id":"public/page/14/index.html","hash":"ae2b9478e369147cf58f9dde1b63fedfdb8f0c3a","modified":1589449777630}],"Category":[{"name":"ES6","_id":"cka6kimwn0005qgu9w9j1zmty"},{"name":"CSS","_id":"cka6kimyb000nqgu96kf3ebw5"},{"name":"git","_id":"cka6kin130021qgu98qmw1jl0"},{"name":"npm","_id":"cka6kin27002rqgu9rau830xe"},{"name":"红宝书","_id":"cka6kin310038qgu9mawsunca"},{"name":"vue","_id":"cka6kin45003wqgu94v49vmur"},{"name":"Electron","_id":"cka6kin77005eqgu92rregwei"},{"name":"博客搭建","_id":"cka6kin8b005xqgu9fpj1m5sv"},{"name":"demo","_id":"cka6kin8v0069qgu9d207njy7"},{"name":"安全","_id":"cka6kin95006gqgu9utkiruqn"},{"name":"操作系统","_id":"cka6kin9f006mqgu9jake6g4v"},{"name":"数据结构","_id":"cka6kin9z006tqgu9p2r2thtr"},{"name":"数据类型","_id":"cka6kina9006zqgu9ghhapyeb"},{"name":"JS","_id":"cka6kinaj0075qgu9eb32y32k"},{"name":"前端","_id":"cka6kinjg00c2qgu9dlre4cqm"},{"name":"算法","_id":"cka6kinlp00duqgu94t80ui9k"},{"name":"计网","_id":"cka6kinnr00fiqgu9lp1mza8n"}],"Data":[],"Page":[{"title":"about","date":"2018-05-02T16:00:00.000Z","_content":"\n##关于我\n\n\n一只学习前端的小菜鸟，欢迎分享知识\n\nFrom Sivan\n\nQQ：1014270057\nEmail：1014270057@qq.com","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-05-03\n---\n\n##关于我\n\n\n一只学习前端的小菜鸟，欢迎分享知识\n\nFrom Sivan\n\nQQ：1014270057\nEmail：1014270057@qq.com","updated":"2018-05-03T15:01:05.161Z","path":"about/index.html","comments":1,"layout":"page","_id":"cka6kimrg0000qgu96i9fn9g9","content":"<p>##关于我</p>\n<p>一只学习前端的小菜鸟，欢迎分享知识</p>\n<p>From Sivan</p>\n<p>QQ：1014270057<br>Email：<a href=\"mailto:1014270057@qq.com\" target=\"_blank\" rel=\"noopener\">1014270057@qq.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>##关于我</p>\n<p>一只学习前端的小菜鸟，欢迎分享知识</p>\n<p>From Sivan</p>\n<p>QQ：1014270057<br>Email：<a href=\"mailto:1014270057@qq.com\" target=\"_blank\" rel=\"noopener\">1014270057@qq.com</a></p>\n"},{"title":"categories","date":"2017-08-03T11:43:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-08-03 19:43:20\ntype: \"categories\"\n---\n","updated":"2017-09-27T10:39:39.585Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cka6kimrn0001qgu99urz11sm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-08-03T11:41:49.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-08-03 19:41:49\ntype: \"tags\"\n---\n","updated":"2017-09-27T10:39:39.586Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cka6kimru0002qgu9t5hxcsr3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES6：apply、call和bind","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n- 都是为了改变某个函数运行时的上下文，即改变函数里的this的指向。将一个函数应用在其他对象上。\n- 第一个参数要绑定给this的值，为nul或undefined时指向window。\n- apply、call绑定后会立即调用，bind绑定后不会立即调用。\n- apply第二个参数为数组，call后面为参数列表。","source":"_posts/ES6/ES6：apply、call和bind.md","raw":"---\ntitle: ES6：apply、call和bind\nDate: 2020-03-17\ntags: [ES6]\ncategories: ES6\ncomments: true\n---\n\n- 都是为了改变某个函数运行时的上下文，即改变函数里的this的指向。将一个函数应用在其他对象上。\n- 第一个参数要绑定给this的值，为nul或undefined时指向window。\n- apply、call绑定后会立即调用，bind绑定后不会立即调用。\n- apply第二个参数为数组，call后面为参数列表。","slug":"ES6/ES6：apply、call和bind","published":1,"date":"2020-03-17T08:59:15.355Z","updated":"2020-03-17T09:01:04.854Z","layout":"post","photos":[],"link":"","_id":"cka6kimw30003qgu91eyuks3u","content":"<ul>\n<li>都是为了改变某个函数运行时的上下文，即改变函数里的this的指向。将一个函数应用在其他对象上。</li>\n<li>第一个参数要绑定给this的值，为nul或undefined时指向window。</li>\n<li>apply、call绑定后会立即调用，bind绑定后不会立即调用。</li>\n<li>apply第二个参数为数组，call后面为参数列表。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>都是为了改变某个函数运行时的上下文，即改变函数里的this的指向。将一个函数应用在其他对象上。</li>\n<li>第一个参数要绑定给this的值，为nul或undefined时指向window。</li>\n<li>apply、call绑定后会立即调用，bind绑定后不会立即调用。</li>\n<li>apply第二个参数为数组，call后面为参数列表。</li>\n</ul>\n"},{"title":"ES6：let和const","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n1. let是定义变量\n2. const是定义常量。若定义基本数据类型，则不能再次改变；若定义复杂数据类型，如对象，则可以修改或者添加属性，但指针是不会变的。\n3. let和const都不会变量提升，在声明之前使用会形成死区。\n\n> 使用babel工具将es6转换为es5","source":"_posts/ES6/ES6：let和const.md","raw":"---\ntitle: ES6：let和const\nDate: 2020-03-17\ntags: [ES6]\ncategories: ES6\ncomments: true\n---\n\n1. let是定义变量\n2. const是定义常量。若定义基本数据类型，则不能再次改变；若定义复杂数据类型，如对象，则可以修改或者添加属性，但指针是不会变的。\n3. let和const都不会变量提升，在声明之前使用会形成死区。\n\n> 使用babel工具将es6转换为es5","slug":"ES6/ES6：let和const","published":1,"date":"2020-03-17T08:59:11.000Z","updated":"2020-03-17T09:00:48.288Z","layout":"post","photos":[],"link":"","_id":"cka6kimwd0004qgu9ha1lp1vh","content":"<ol>\n<li>let是定义变量</li>\n<li>const是定义常量。若定义基本数据类型，则不能再次改变；若定义复杂数据类型，如对象，则可以修改或者添加属性，但指针是不会变的。</li>\n<li>let和const都不会变量提升，在声明之前使用会形成死区。</li>\n</ol>\n<blockquote>\n<p>使用babel工具将es6转换为es5</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>let是定义变量</li>\n<li>const是定义常量。若定义基本数据类型，则不能再次改变；若定义复杂数据类型，如对象，则可以修改或者添加属性，但指针是不会变的。</li>\n<li>let和const都不会变量提升，在声明之前使用会形成死区。</li>\n</ol>\n<blockquote>\n<p>使用babel工具将es6转换为es5</p>\n</blockquote>\n"},{"title":"ES6：promise","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### 一句话概述什么是promise\nPromise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。\n### 为什么用promise\n用于异步操作，除了promise还可以用异步回调解决异步操作。\n\n那为什么有异步回调还要promise，promise可以多重链式调用，可以避免层层嵌套回调。可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。\n### 注意\n- Promise在生命周期内有三种状态，分别是pending、fulfilled 和 rejected。\n- 状态改变只能是pending->fulfilled(成功)，或者pending->rejected(失败)。而且状态一旦改变，就不能再次改变。\n- Promise中调用resolve或reject并不会终结 Promise 的参数函数的执行。\n- Promise的构造函数中代码是同步执行的，但是then方法是异步执行的，then方法需要等到resolve函数执行时才得到执行。\n- reject 和 catch 的区别\n\n在resolve中发生异常的话，在reject中是捕获不到这个异常的。\n.then中产生的异常能在.catch中捕获\n\n- 如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误。且catch之前的函数都不会执行。\n- 每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据。\n- 在异步回调中抛错，不会被catch到。\n- promise状态变为resolve或reject，就凝固了，不会再改变。\n- Promise一旦执行了resolve函数后，就不会再执行reject和其他的resolve函数了。一旦Promise执行了reject函数，将会被catch函数捕获，执行catch中的代码。\n\n### 如何处理异步\n1. promise\n2. 回调函数\n```\nfunction f1(callback){\n　　setTimeout(function () {\n　　　　// f1的任务代码\n　　　　callback();\n　　}, 1000);\n}\n// 执行\nf1(f2)\n```\n3. 发布订阅\n4. 事件监听\n5. async/await\n\n一个简单的promise对象\n```\nnew Promise(test).then(function (result) {\n    console.log('成功：' + result);\n}).catch(function (reason) {\n    console.log('失败：' + reason);\n});\n```\n","source":"_posts/ES6/ES6：promise.md","raw":"---\ntitle: ES6：promise\nDate: 2020-03-17\ntags: [ES6]\ncategories: ES6\ncomments: true\n---\n\n### 一句话概述什么是promise\nPromise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。\n### 为什么用promise\n用于异步操作，除了promise还可以用异步回调解决异步操作。\n\n那为什么有异步回调还要promise，promise可以多重链式调用，可以避免层层嵌套回调。可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。\n### 注意\n- Promise在生命周期内有三种状态，分别是pending、fulfilled 和 rejected。\n- 状态改变只能是pending->fulfilled(成功)，或者pending->rejected(失败)。而且状态一旦改变，就不能再次改变。\n- Promise中调用resolve或reject并不会终结 Promise 的参数函数的执行。\n- Promise的构造函数中代码是同步执行的，但是then方法是异步执行的，then方法需要等到resolve函数执行时才得到执行。\n- reject 和 catch 的区别\n\n在resolve中发生异常的话，在reject中是捕获不到这个异常的。\n.then中产生的异常能在.catch中捕获\n\n- 如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误。且catch之前的函数都不会执行。\n- 每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据。\n- 在异步回调中抛错，不会被catch到。\n- promise状态变为resolve或reject，就凝固了，不会再改变。\n- Promise一旦执行了resolve函数后，就不会再执行reject和其他的resolve函数了。一旦Promise执行了reject函数，将会被catch函数捕获，执行catch中的代码。\n\n### 如何处理异步\n1. promise\n2. 回调函数\n```\nfunction f1(callback){\n　　setTimeout(function () {\n　　　　// f1的任务代码\n　　　　callback();\n　　}, 1000);\n}\n// 执行\nf1(f2)\n```\n3. 发布订阅\n4. 事件监听\n5. async/await\n\n一个简单的promise对象\n```\nnew Promise(test).then(function (result) {\n    console.log('成功：' + result);\n}).catch(function (reason) {\n    console.log('失败：' + reason);\n});\n```\n","slug":"ES6/ES6：promise","published":1,"date":"2020-03-17T08:58:58.189Z","updated":"2020-03-17T09:00:08.898Z","layout":"post","photos":[],"link":"","_id":"cka6kimwx0007qgu90x9i04jq","content":"<h3 id=\"一句话概述什么是promise\"><a href=\"#一句话概述什么是promise\" class=\"headerlink\" title=\"一句话概述什么是promise\"></a>一句话概述什么是promise</h3><p>Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p>\n<h3 id=\"为什么用promise\"><a href=\"#为什么用promise\" class=\"headerlink\" title=\"为什么用promise\"></a>为什么用promise</h3><p>用于异步操作，除了promise还可以用异步回调解决异步操作。</p>\n<p>那为什么有异步回调还要promise，promise可以多重链式调用，可以避免层层嵌套回调。可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ul>\n<li>Promise在生命周期内有三种状态，分别是pending、fulfilled 和 rejected。</li>\n<li>状态改变只能是pending-&gt;fulfilled(成功)，或者pending-&gt;rejected(失败)。而且状态一旦改变，就不能再次改变。</li>\n<li>Promise中调用resolve或reject并不会终结 Promise 的参数函数的执行。</li>\n<li>Promise的构造函数中代码是同步执行的，但是then方法是异步执行的，then方法需要等到resolve函数执行时才得到执行。</li>\n<li>reject 和 catch 的区别</li>\n</ul>\n<p>在resolve中发生异常的话，在reject中是捕获不到这个异常的。<br>.then中产生的异常能在.catch中捕获</p>\n<ul>\n<li>如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误。且catch之前的函数都不会执行。</li>\n<li>每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据。</li>\n<li>在异步回调中抛错，不会被catch到。</li>\n<li>promise状态变为resolve或reject，就凝固了，不会再改变。</li>\n<li>Promise一旦执行了resolve函数后，就不会再执行reject和其他的resolve函数了。一旦Promise执行了reject函数，将会被catch函数捕获，执行catch中的代码。</li>\n</ul>\n<h3 id=\"如何处理异步\"><a href=\"#如何处理异步\" class=\"headerlink\" title=\"如何处理异步\"></a>如何处理异步</h3><ol>\n<li>promise</li>\n<li><p>回调函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(callback)&#123;</span><br><span class=\"line\">　　setTimeout(function () &#123;</span><br><span class=\"line\">　　　　// f1的任务代码</span><br><span class=\"line\">　　　　callback();</span><br><span class=\"line\">　　&#125;, 1000);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 执行</span><br><span class=\"line\">f1(f2)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布订阅</p>\n</li>\n<li>事件监听</li>\n<li>async/await</li>\n</ol>\n<p>一个简单的promise对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise(test).then(function (result) &#123;</span><br><span class=\"line\">    console.log(&apos;成功：&apos; + result);</span><br><span class=\"line\">&#125;).catch(function (reason) &#123;</span><br><span class=\"line\">    console.log(&apos;失败：&apos; + reason);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一句话概述什么是promise\"><a href=\"#一句话概述什么是promise\" class=\"headerlink\" title=\"一句话概述什么是promise\"></a>一句话概述什么是promise</h3><p>Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p>\n<h3 id=\"为什么用promise\"><a href=\"#为什么用promise\" class=\"headerlink\" title=\"为什么用promise\"></a>为什么用promise</h3><p>用于异步操作，除了promise还可以用异步回调解决异步操作。</p>\n<p>那为什么有异步回调还要promise，promise可以多重链式调用，可以避免层层嵌套回调。可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ul>\n<li>Promise在生命周期内有三种状态，分别是pending、fulfilled 和 rejected。</li>\n<li>状态改变只能是pending-&gt;fulfilled(成功)，或者pending-&gt;rejected(失败)。而且状态一旦改变，就不能再次改变。</li>\n<li>Promise中调用resolve或reject并不会终结 Promise 的参数函数的执行。</li>\n<li>Promise的构造函数中代码是同步执行的，但是then方法是异步执行的，then方法需要等到resolve函数执行时才得到执行。</li>\n<li>reject 和 catch 的区别</li>\n</ul>\n<p>在resolve中发生异常的话，在reject中是捕获不到这个异常的。<br>.then中产生的异常能在.catch中捕获</p>\n<ul>\n<li>如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误。且catch之前的函数都不会执行。</li>\n<li>每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据。</li>\n<li>在异步回调中抛错，不会被catch到。</li>\n<li>promise状态变为resolve或reject，就凝固了，不会再改变。</li>\n<li>Promise一旦执行了resolve函数后，就不会再执行reject和其他的resolve函数了。一旦Promise执行了reject函数，将会被catch函数捕获，执行catch中的代码。</li>\n</ul>\n<h3 id=\"如何处理异步\"><a href=\"#如何处理异步\" class=\"headerlink\" title=\"如何处理异步\"></a>如何处理异步</h3><ol>\n<li>promise</li>\n<li><p>回调函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(callback)&#123;</span><br><span class=\"line\">　　setTimeout(function () &#123;</span><br><span class=\"line\">　　　　// f1的任务代码</span><br><span class=\"line\">　　　　callback();</span><br><span class=\"line\">　　&#125;, 1000);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 执行</span><br><span class=\"line\">f1(f2)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布订阅</p>\n</li>\n<li>事件监听</li>\n<li>async/await</li>\n</ol>\n<p>一个简单的promise对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise(test).then(function (result) &#123;</span><br><span class=\"line\">    console.log(&apos;成功：&apos; + result);</span><br><span class=\"line\">&#125;).catch(function (reason) &#123;</span><br><span class=\"line\">    console.log(&apos;失败：&apos; + reason);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"ES6：箭头函数","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n- 箭头函数体内的this对象是定义时所在的对象，而不是使用时所在的对象。\n- this指向调用箭头函数外层函数的对象（即箭头函数所在作用域的父级作用域），没有外层函数则指向window。\n- 箭头函数相当于匿名函数。\n- 箭头函数不可以当作构造函数，即不可以用new命令。\n- 箭头函数不可以使用arguments对象，该对象在函数体内不存在。要用，就用rest参数代替。\n- 箭头函数的this指向其上下文的this，通过call、apply也无法修改其指向。","source":"_posts/ES6/ES6：箭头函数.md","raw":"---\ntitle: ES6：箭头函数\nDate: 2020-03-17\ntags: [ES6]\ncategories: ES6\ncomments: true\n---\n\n- 箭头函数体内的this对象是定义时所在的对象，而不是使用时所在的对象。\n- this指向调用箭头函数外层函数的对象（即箭头函数所在作用域的父级作用域），没有外层函数则指向window。\n- 箭头函数相当于匿名函数。\n- 箭头函数不可以当作构造函数，即不可以用new命令。\n- 箭头函数不可以使用arguments对象，该对象在函数体内不存在。要用，就用rest参数代替。\n- 箭头函数的this指向其上下文的this，通过call、apply也无法修改其指向。","slug":"ES6/ES6：箭头函数","published":1,"date":"2020-03-17T08:59:04.613Z","updated":"2020-03-17T09:00:30.883Z","layout":"post","photos":[],"link":"","_id":"cka6kimwx0008qgu9x5hi91c1","content":"<ul>\n<li>箭头函数体内的this对象是定义时所在的对象，而不是使用时所在的对象。</li>\n<li>this指向调用箭头函数外层函数的对象（即箭头函数所在作用域的父级作用域），没有外层函数则指向window。</li>\n<li>箭头函数相当于匿名函数。</li>\n<li>箭头函数不可以当作构造函数，即不可以用new命令。</li>\n<li>箭头函数不可以使用arguments对象，该对象在函数体内不存在。要用，就用rest参数代替。</li>\n<li>箭头函数的this指向其上下文的this，通过call、apply也无法修改其指向。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>箭头函数体内的this对象是定义时所在的对象，而不是使用时所在的对象。</li>\n<li>this指向调用箭头函数外层函数的对象（即箭头函数所在作用域的父级作用域），没有外层函数则指向window。</li>\n<li>箭头函数相当于匿名函数。</li>\n<li>箭头函数不可以当作构造函数，即不可以用new命令。</li>\n<li>箭头函数不可以使用arguments对象，该对象在函数体内不存在。要用，就用rest参数代替。</li>\n<li>箭头函数的this指向其上下文的this，通过call、apply也无法修改其指向。</li>\n</ul>\n"},{"title":"git：关于回退版本的一些小技巧","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n1. 先通过 git log 查看某次提交的id\n2. 使用git reset --hard [id] 回退到某一次提交\n\n若不想保留原来的提交记录，可把原来的分支删除\n\n```\ngit push origin --delete [branchName]\n```\n3. 再把本地的修改提交到新的分支\n\n> 版本回退仅仅是本地版本回退\n","source":"_posts/git/git：关于回退版本的一些小技巧.md","raw":"---\ntitle: git：关于回退版本的一些小技巧\nDate: 2020-03-17\ntags: [git]\ncategories: git\ncomments: true\n---\n\n1. 先通过 git log 查看某次提交的id\n2. 使用git reset --hard [id] 回退到某一次提交\n\n若不想保留原来的提交记录，可把原来的分支删除\n\n```\ngit push origin --delete [branchName]\n```\n3. 再把本地的修改提交到新的分支\n\n> 版本回退仅仅是本地版本回退\n","slug":"git/git：关于回退版本的一些小技巧","published":1,"date":"2020-03-17T08:53:11.642Z","updated":"2020-03-17T08:56:39.656Z","layout":"post","photos":[],"link":"","_id":"cka6kin0t001wqgu9wd1xpye8","content":"<ol>\n<li>先通过 git log 查看某次提交的id</li>\n<li>使用git reset –hard [id] 回退到某一次提交</li>\n</ol>\n<p>若不想保留原来的提交记录，可把原来的分支删除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete [branchName]</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>再把本地的修改提交到新的分支</li>\n</ol>\n<blockquote>\n<p>版本回退仅仅是本地版本回退</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>先通过 git log 查看某次提交的id</li>\n<li>使用git reset –hard [id] 回退到某一次提交</li>\n</ol>\n<p>若不想保留原来的提交记录，可把原来的分支删除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete [branchName]</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>再把本地的修改提交到新的分支</li>\n</ol>\n<blockquote>\n<p>版本回退仅仅是本地版本回退</p>\n</blockquote>\n"},{"title":"git：git fetch和git pull","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n- git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。\n- git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。","source":"_posts/git/git：git fetch和git pull.md","raw":"---\ntitle: git：git fetch和git pull\nDate: 2020-03-17\ntags: [git]\ncategories: git\ncomments: true\n---\n\n- git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。\n- git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。","slug":"git/git：git fetch和git pull","published":1,"date":"2020-03-17T08:53:04.755Z","updated":"2020-03-17T08:56:07.135Z","layout":"post","photos":[],"link":"","_id":"cka6kin0t001zqgu9834fiinh","content":"<ul>\n<li>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</li>\n<li>git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</li>\n<li>git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</li>\n</ul>\n"},{"title":"git：分支管理之合并","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n假设已存在分支dev，且修改部分代码\n1. 先把已修改的推上分支dev\n2. 把切换回主分支，下拉\n3. 运行合并指令\n\n```\ngit merge dev\n```\n4. 合并后在本地修改冲突\n5. 再次commit并提交到主分支\n","source":"_posts/git/git：分支管理之合并.md","raw":"---\ntitle: git：分支管理之合并\nDate: 2020-03-17\ntags: [git]\ncategories: git\ncomments: true\n---\n\n假设已存在分支dev，且修改部分代码\n1. 先把已修改的推上分支dev\n2. 把切换回主分支，下拉\n3. 运行合并指令\n\n```\ngit merge dev\n```\n4. 合并后在本地修改冲突\n5. 再次commit并提交到主分支\n","slug":"git/git：分支管理之合并","published":1,"date":"2020-03-17T08:52:42.098Z","updated":"2020-03-17T08:53:47.289Z","layout":"post","photos":[],"link":"","_id":"cka6kin130024qgu9899r15rb","content":"<p>假设已存在分支dev，且修改部分代码</p>\n<ol>\n<li>先把已修改的推上分支dev</li>\n<li>把切换回主分支，下拉</li>\n<li>运行合并指令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>合并后在本地修改冲突</li>\n<li>再次commit并提交到主分支</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>假设已存在分支dev，且修改部分代码</p>\n<ol>\n<li>先把已修改的推上分支dev</li>\n<li>把切换回主分支，下拉</li>\n<li>运行合并指令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>合并后在本地修改冲突</li>\n<li>再次commit并提交到主分支</li>\n</ol>\n"},{"title":"git：将在master分支上做的修改提交到分支","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n## 前提\n我在master上修复了某个bug，但是master被锁定了，我想提交到dev分支，那么使用 cherry-pick可以满足我们的要求\n\n```\n//先从主分支记下id\n$ git log\n//切换到dev分支上\n$ git cherry-pick <id>\n```\n","source":"_posts/git/git：将在master分支上做的修改提交到分支.md","raw":"---\ntitle: git：将在master分支上做的修改提交到分支\nDate: 2020-03-17\ntags: [git]\ncategories: git\ncomments: true\n---\n\n## 前提\n我在master上修复了某个bug，但是master被锁定了，我想提交到dev分支，那么使用 cherry-pick可以满足我们的要求\n\n```\n//先从主分支记下id\n$ git log\n//切换到dev分支上\n$ git cherry-pick <id>\n```\n","slug":"git/git：将在master分支上做的修改提交到分支","published":1,"date":"2020-03-17T08:52:59.112Z","updated":"2020-03-17T08:55:35.723Z","layout":"post","photos":[],"link":"","_id":"cka6kin1d0027qgu9jqw0ow2w","content":"<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>我在master上修复了某个bug，但是master被锁定了，我想提交到dev分支，那么使用 cherry-pick可以满足我们的要求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//先从主分支记下id</span><br><span class=\"line\">$ git log</span><br><span class=\"line\">//切换到dev分支上</span><br><span class=\"line\">$ git cherry-pick &lt;id&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>我在master上修复了某个bug，但是master被锁定了，我想提交到dev分支，那么使用 cherry-pick可以满足我们的要求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//先从主分支记下id</span><br><span class=\"line\">$ git log</span><br><span class=\"line\">//切换到dev分支上</span><br><span class=\"line\">$ git cherry-pick &lt;id&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"git：添加到远程github仓库的一个错误","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n## 问题\n今天使用git 添加到远程github仓库的时候    \n提示错误：fatal: remote origin already exists. \n\n## 解决办法\n1. 先删除远程 Git 仓库\n\n```\n$ git remote rm origin\n\n```\n2. 再添加远程 Git 仓库\n\n```\n$ git remote add origin 仓库地址\n\n```\n\n\n\n","source":"_posts/git/git：添加到远程github仓库的一个错误.md","raw":"---\ntitle: git：添加到远程github仓库的一个错误\nDate: 2020-03-17\ntags: [git]\ncategories: git\ncomments: true\n---\n\n## 问题\n今天使用git 添加到远程github仓库的时候    \n提示错误：fatal: remote origin already exists. \n\n## 解决办法\n1. 先删除远程 Git 仓库\n\n```\n$ git remote rm origin\n\n```\n2. 再添加远程 Git 仓库\n\n```\n$ git remote add origin 仓库地址\n\n```\n\n\n\n","slug":"git/git：添加到远程github仓库的一个错误","published":1,"date":"2020-03-17T08:52:53.668Z","updated":"2020-03-17T08:55:13.710Z","layout":"post","photos":[],"link":"","_id":"cka6kin1d002aqgu9mqwkausn","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>今天使用git 添加到远程github仓库的时候<br>提示错误：fatal: remote origin already exists. </p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><ol>\n<li>先删除远程 Git 仓库</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote rm origin</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>再添加远程 Git 仓库</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin 仓库地址</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>今天使用git 添加到远程github仓库的时候<br>提示错误：fatal: remote origin already exists. </p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><ol>\n<li>先删除远程 Git 仓库</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote rm origin</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>再添加远程 Git 仓库</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin 仓库地址</span><br></pre></td></tr></table></figure>\n"},{"title":"npm清理缓存","Date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"\n## 旧版本（4及以下）\n\n```\n$ npm cache clean \n```\n\n## 新版本（5）\n\n先尝试\n```\n$ npm cache clean --force \n```\n若不行则使用下面的命令\n\n```\n$ npm cache clear --force && npm install --no-shrinkwrap --update-binary\n```\n","source":"_posts/git/npm清理缓存.md","raw":"---\ntitle: npm清理缓存\nDate: 2018-05-03\ntags: [npm]\ncategories: npm\ncomments: true\n---\n\n## 旧版本（4及以下）\n\n```\n$ npm cache clean \n```\n\n## 新版本（5）\n\n先尝试\n```\n$ npm cache clean --force \n```\n若不行则使用下面的命令\n\n```\n$ npm cache clear --force && npm install --no-shrinkwrap --update-binary\n```\n","slug":"git/npm清理缓存","published":1,"date":"2018-05-03T13:46:59.331Z","updated":"2018-05-03T14:02:01.334Z","layout":"post","photos":[],"link":"","_id":"cka6kin1n002fqgu984mee98y","content":"<h2 id=\"旧版本（4及以下）\"><a href=\"#旧版本（4及以下）\" class=\"headerlink\" title=\"旧版本（4及以下）\"></a>旧版本（4及以下）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm cache clean</span><br></pre></td></tr></table></figure>\n<h2 id=\"新版本（5）\"><a href=\"#新版本（5）\" class=\"headerlink\" title=\"新版本（5）\"></a>新版本（5）</h2><p>先尝试<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm cache clean --force</span><br></pre></td></tr></table></figure></p>\n<p>若不行则使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm cache clear --force &amp;&amp; npm install --no-shrinkwrap --update-binary</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"旧版本（4及以下）\"><a href=\"#旧版本（4及以下）\" class=\"headerlink\" title=\"旧版本（4及以下）\"></a>旧版本（4及以下）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm cache clean</span><br></pre></td></tr></table></figure>\n<h2 id=\"新版本（5）\"><a href=\"#新版本（5）\" class=\"headerlink\" title=\"新版本（5）\"></a>新版本（5）</h2><p>先尝试<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm cache clean --force</span><br></pre></td></tr></table></figure></p>\n<p>若不行则使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm cache clear --force &amp;&amp; npm install --no-shrinkwrap --update-binary</span><br></pre></td></tr></table></figure>\n"},{"title":"npm install 出错","Date":"2019-02-25T16:00:00.000Z","comments":1,"_content":"\n## 第一种\n### 问题\n\n```\n$ npm install\nnpm WARN registry Unexpected warning for or http://registry.cnpmjs.org/: Mis Miscellaneous Warning ECONNRESET: request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/acorn/-/acorn-5.7.1.tgz fai failed, reason: read ECONNRESET\nnpm WARN registry Using stale package data from om http://registry.cnpmjs.org/ du/ due to a request error during revalidation.\n\n```\n### 解决方法\n\n```\n$ npm config set registry ry http://registry.cnpmjs.org\n$ npm install\n\n```\n## 第二种\n### 问题\n\n```\n$ npm install\nnpm ERR! code ECONNRESET\nnpm ERR! errno ECONNRESET\nnpm ERR! network request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/arrify/-/arrify-1.0.1.tgz fai failed, reason: read ECONNRESET\nnpm ERR! network This is a problem related to network connectivity.\nnpm ERR! network In most cases you are behind a proxy or have bad network settings.\nnpm ERR! network\nnpm ERR! network If you are behind a proxy, please make sure that the\nnpm ERR! network 'proxy' config is set properly.  See: 'npm help config'\n\nnpm ERR! A complete log of this run can be found in:\n\n```\n### 解决方法\n\n```\n$ npm config delete proxy\n$ npm install\n\n```\n## 第三种\n### 问题\n\n```\n$ npm install\nnpm ERR! write after end \n\n```\n### 解决方法\n降低版本\n\n```\nnpm i -g npm@5.6.0\n\n```\n","source":"_posts/git/npm install 出错.md","raw":"---\ntitle: npm install 出错\nDate: 2019-02-26\ntags: [npm]\ncategories: npm\ncomments: true\n---\n\n## 第一种\n### 问题\n\n```\n$ npm install\nnpm WARN registry Unexpected warning for or http://registry.cnpmjs.org/: Mis Miscellaneous Warning ECONNRESET: request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/acorn/-/acorn-5.7.1.tgz fai failed, reason: read ECONNRESET\nnpm WARN registry Using stale package data from om http://registry.cnpmjs.org/ du/ due to a request error during revalidation.\n\n```\n### 解决方法\n\n```\n$ npm config set registry ry http://registry.cnpmjs.org\n$ npm install\n\n```\n## 第二种\n### 问题\n\n```\n$ npm install\nnpm ERR! code ECONNRESET\nnpm ERR! errno ECONNRESET\nnpm ERR! network request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/arrify/-/arrify-1.0.1.tgz fai failed, reason: read ECONNRESET\nnpm ERR! network This is a problem related to network connectivity.\nnpm ERR! network In most cases you are behind a proxy or have bad network settings.\nnpm ERR! network\nnpm ERR! network If you are behind a proxy, please make sure that the\nnpm ERR! network 'proxy' config is set properly.  See: 'npm help config'\n\nnpm ERR! A complete log of this run can be found in:\n\n```\n### 解决方法\n\n```\n$ npm config delete proxy\n$ npm install\n\n```\n## 第三种\n### 问题\n\n```\n$ npm install\nnpm ERR! write after end \n\n```\n### 解决方法\n降低版本\n\n```\nnpm i -g npm@5.6.0\n\n```\n","slug":"git/npm install 出错","published":1,"date":"2019-02-26T08:37:44.486Z","updated":"2019-02-26T08:55:29.394Z","layout":"post","photos":[],"link":"","_id":"cka6kin1n002iqgu9mk4ly2et","content":"<h2 id=\"第一种\"><a href=\"#第一种\" class=\"headerlink\" title=\"第一种\"></a>第一种</h2><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\">npm WARN registry Unexpected warning for or http://registry.cnpmjs.org/: Mis Miscellaneous Warning ECONNRESET: request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/acorn/-/acorn-5.7.1.tgz fai failed, reason: read ECONNRESET</span><br><span class=\"line\">npm WARN registry Using stale package data from om http://registry.cnpmjs.org/ du/ due to a request error during revalidation.</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config set registry ry http://registry.cnpmjs.org</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二种\"><a href=\"#第二种\" class=\"headerlink\" title=\"第二种\"></a>第二种</h2><h3 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题\"></a>问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\">npm ERR! code ECONNRESET</span><br><span class=\"line\">npm ERR! errno ECONNRESET</span><br><span class=\"line\">npm ERR! network request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/arrify/-/arrify-1.0.1.tgz fai failed, reason: read ECONNRESET</span><br><span class=\"line\">npm ERR! network This is a problem related to network connectivity.</span><br><span class=\"line\">npm ERR! network In most cases you are behind a proxy or have bad network settings.</span><br><span class=\"line\">npm ERR! network</span><br><span class=\"line\">npm ERR! network If you are behind a proxy, please make sure that the</span><br><span class=\"line\">npm ERR! network &apos;proxy&apos; config is set properly.  See: &apos;npm help config&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! A complete log of this run can be found in:</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决方法-1\"><a href=\"#解决方法-1\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config delete proxy</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三种\"><a href=\"#第三种\" class=\"headerlink\" title=\"第三种\"></a>第三种</h2><h3 id=\"问题-2\"><a href=\"#问题-2\" class=\"headerlink\" title=\"问题\"></a>问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\">npm ERR! write after end</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决方法-2\"><a href=\"#解决方法-2\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>降低版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g npm@5.6.0</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第一种\"><a href=\"#第一种\" class=\"headerlink\" title=\"第一种\"></a>第一种</h2><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\">npm WARN registry Unexpected warning for or http://registry.cnpmjs.org/: Mis Miscellaneous Warning ECONNRESET: request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/acorn/-/acorn-5.7.1.tgz fai failed, reason: read ECONNRESET</span><br><span class=\"line\">npm WARN registry Using stale package data from om http://registry.cnpmjs.org/ du/ due to a request error during revalidation.</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config set registry ry http://registry.cnpmjs.org</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二种\"><a href=\"#第二种\" class=\"headerlink\" title=\"第二种\"></a>第二种</h2><h3 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题\"></a>问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\">npm ERR! code ECONNRESET</span><br><span class=\"line\">npm ERR! errno ECONNRESET</span><br><span class=\"line\">npm ERR! network request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/arrify/-/arrify-1.0.1.tgz fai failed, reason: read ECONNRESET</span><br><span class=\"line\">npm ERR! network This is a problem related to network connectivity.</span><br><span class=\"line\">npm ERR! network In most cases you are behind a proxy or have bad network settings.</span><br><span class=\"line\">npm ERR! network</span><br><span class=\"line\">npm ERR! network If you are behind a proxy, please make sure that the</span><br><span class=\"line\">npm ERR! network &apos;proxy&apos; config is set properly.  See: &apos;npm help config&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! A complete log of this run can be found in:</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决方法-1\"><a href=\"#解决方法-1\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config delete proxy</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三种\"><a href=\"#第三种\" class=\"headerlink\" title=\"第三种\"></a>第三种</h2><h3 id=\"问题-2\"><a href=\"#问题-2\" class=\"headerlink\" title=\"问题\"></a>问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\">npm ERR! write after end</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决方法-2\"><a href=\"#解决方法-2\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>降低版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g npm@5.6.0</span><br></pre></td></tr></table></figure>\n"},{"title":"DOM","Date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"\n# 节点层次\n### 小结\n- DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。\n- 节点之间的关系构成层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构\n- 文档节点是每个文档的根节点，通过文档节点表示的元素称之为文档元素\n-  文档元素是文档的最外层元素，文档中的其他元素都包含在文档元素中\n- 每个文档只能有一个文档元素，在HTML页面中，文档元素始终都是<html>元素\n- HTML元素通过元素节点表示，特性(属性）通过特性节点表示，注释通过注释节点表示......\n\n\n---\n\n>  以下类型属性和方法的详细内容可参考红宝书，也可参考第19章DOM基础的pdf，在这里就不一一列出了\n\n### Node类型 \n\nJavaScript中的所有节点类型都继承自Node类型\n- 节点属性（所有节点都有）\n\n属性 | 用途\n---|---\nnodeName | 获取元素的标签名\nnodeValue | 返回节点的节点值\nchildNodes | 获取当前元素节点的所有子节点\nfirstChild | 获取当前元素节点的第一个子节点\nlastChild | 获取当前元素节点的最后一个子节点\nownerDocument | 获取该文档的文档根节点\nparentNode | 获取当前节点的父节点\npreviousSibling | 获取当前节点的前一个同级节点\nnextSibling | 获取当前节点的后一个同级节点\n\n- childNodes属性保存着一个NodeList对象，是一种类数组对象，用于保存一组有序的节点\n\n- 操作节点（所有节点都可用）\n\n方法 | 用途\n---|---\nappendChild() | 将新节点追加到子节点列表的末尾\ninsertBefore() | 将新节点插入到参考节点的前面\nreplaceChild() | 将新节点替换掉旧节点\nremoveChild() | 移除节点\ncloneNode() |复制节点\n\n\n\n### Document类型\nJavaScript通过Document类型表示文档\n\n- 查找元素\n\n方法| 作用\n---|---\ngetElementsByTagName() | 获取相同元素的节点列表\ngetElementByName() | 获取相同名称的节点列表\ngetElementById()| 获取特定id元素的节点\n\n- 文档写入\n\n方法 | 用途\n---|---\nwrite() | 原样写入\nwriteln() | 在字符串末尾添加换行符（\\n）\nopen() | 打开网页的输出流\nclose() |关闭网页的输出流\n\n\n\n### Element类型\n- 在HTML中，标签名始终都以全部大写表示\n\n```\nalert(div.tagname);//DIV\n\n```\n- title特性：鼠标移动到该元素之上时显示的内容\n\n- 操作特性\n\n方法 | 用途\n---|---\ngetAttribute() | 获取特定元素节点属性的值\nsetAttribute() | 设置特定元素节点属性的值\nremoveAttribute()| 移除特定元素节点属性\n- attributes属性   \nElement类型是使用attributes属性的唯一一个DOM节点类型。\nattributes属性中包含一个NameNodeMap，是一个“动态”的集合，里面每一项为元素的特性\n\n- 创建元素\n\n```\ndocument.createElement(要创建元素的标签名);\n\n```\n创建的新元素尚未被添加在文档树中，因此浏览器无法显示  \n可以用appendChild()等方法把其添加到文档树中\n\n### Text类型\n文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容\n- 创建文本节点\n\n```\ndocument.createTextNode(要插入节点中的文本);\n\n```\n同样，除非把新节点添加到文档树中已经存在的节点中，否则不会在浏览器看到新节点\n\n- 规范文本节点   \nnormalize()   将所有文本节点合并成一个节点\n- 分割文本节点  \nsplitText()将一个文本节点分为两个文本节点\n\n### Comment类型\n表示注释\n\n### CDATASection类型\n表示CDATA区域，只针对基于XML的文档\n\n### DocumentType类型\n包含着与文档的doctype有关的所有信息，不常用\n\n### DocumentFragment类型\n表示文档片段\n\n### Attr类型\n表示元素的特性\n\n# DOM操作技术\n\n以下两种技术均建议插入外部文件\n\n### 动态脚本\n- 使用script元素包含js代码直接插入head元素中\n- 插入外部文件（建议）   \n可添加到head元素中，也可添加到页面中\n\n```\n<scripr type=\"text/javascript\" src=\"URL\"></script>\n```\n### 动态样式\n- 使用style元素包含指定嵌入的样式插入head元素中\n- 插入外部文件（建议）   \n**必须将link元素添加到head元素中**\n\n```\n<link rel=\"stylesheet\" type=\"text/css\" href=\"URL\"/>\n\n```\n","source":"_posts/js高级程序设计/DOM.md","raw":"---\ntitle: DOM\nDate: 2018-05-03\ntags: [红宝书]\ncategories: 红宝书\ncomments: true\n---\n\n# 节点层次\n### 小结\n- DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。\n- 节点之间的关系构成层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构\n- 文档节点是每个文档的根节点，通过文档节点表示的元素称之为文档元素\n-  文档元素是文档的最外层元素，文档中的其他元素都包含在文档元素中\n- 每个文档只能有一个文档元素，在HTML页面中，文档元素始终都是<html>元素\n- HTML元素通过元素节点表示，特性(属性）通过特性节点表示，注释通过注释节点表示......\n\n\n---\n\n>  以下类型属性和方法的详细内容可参考红宝书，也可参考第19章DOM基础的pdf，在这里就不一一列出了\n\n### Node类型 \n\nJavaScript中的所有节点类型都继承自Node类型\n- 节点属性（所有节点都有）\n\n属性 | 用途\n---|---\nnodeName | 获取元素的标签名\nnodeValue | 返回节点的节点值\nchildNodes | 获取当前元素节点的所有子节点\nfirstChild | 获取当前元素节点的第一个子节点\nlastChild | 获取当前元素节点的最后一个子节点\nownerDocument | 获取该文档的文档根节点\nparentNode | 获取当前节点的父节点\npreviousSibling | 获取当前节点的前一个同级节点\nnextSibling | 获取当前节点的后一个同级节点\n\n- childNodes属性保存着一个NodeList对象，是一种类数组对象，用于保存一组有序的节点\n\n- 操作节点（所有节点都可用）\n\n方法 | 用途\n---|---\nappendChild() | 将新节点追加到子节点列表的末尾\ninsertBefore() | 将新节点插入到参考节点的前面\nreplaceChild() | 将新节点替换掉旧节点\nremoveChild() | 移除节点\ncloneNode() |复制节点\n\n\n\n### Document类型\nJavaScript通过Document类型表示文档\n\n- 查找元素\n\n方法| 作用\n---|---\ngetElementsByTagName() | 获取相同元素的节点列表\ngetElementByName() | 获取相同名称的节点列表\ngetElementById()| 获取特定id元素的节点\n\n- 文档写入\n\n方法 | 用途\n---|---\nwrite() | 原样写入\nwriteln() | 在字符串末尾添加换行符（\\n）\nopen() | 打开网页的输出流\nclose() |关闭网页的输出流\n\n\n\n### Element类型\n- 在HTML中，标签名始终都以全部大写表示\n\n```\nalert(div.tagname);//DIV\n\n```\n- title特性：鼠标移动到该元素之上时显示的内容\n\n- 操作特性\n\n方法 | 用途\n---|---\ngetAttribute() | 获取特定元素节点属性的值\nsetAttribute() | 设置特定元素节点属性的值\nremoveAttribute()| 移除特定元素节点属性\n- attributes属性   \nElement类型是使用attributes属性的唯一一个DOM节点类型。\nattributes属性中包含一个NameNodeMap，是一个“动态”的集合，里面每一项为元素的特性\n\n- 创建元素\n\n```\ndocument.createElement(要创建元素的标签名);\n\n```\n创建的新元素尚未被添加在文档树中，因此浏览器无法显示  \n可以用appendChild()等方法把其添加到文档树中\n\n### Text类型\n文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容\n- 创建文本节点\n\n```\ndocument.createTextNode(要插入节点中的文本);\n\n```\n同样，除非把新节点添加到文档树中已经存在的节点中，否则不会在浏览器看到新节点\n\n- 规范文本节点   \nnormalize()   将所有文本节点合并成一个节点\n- 分割文本节点  \nsplitText()将一个文本节点分为两个文本节点\n\n### Comment类型\n表示注释\n\n### CDATASection类型\n表示CDATA区域，只针对基于XML的文档\n\n### DocumentType类型\n包含着与文档的doctype有关的所有信息，不常用\n\n### DocumentFragment类型\n表示文档片段\n\n### Attr类型\n表示元素的特性\n\n# DOM操作技术\n\n以下两种技术均建议插入外部文件\n\n### 动态脚本\n- 使用script元素包含js代码直接插入head元素中\n- 插入外部文件（建议）   \n可添加到head元素中，也可添加到页面中\n\n```\n<scripr type=\"text/javascript\" src=\"URL\"></script>\n```\n### 动态样式\n- 使用style元素包含指定嵌入的样式插入head元素中\n- 插入外部文件（建议）   \n**必须将link元素添加到head元素中**\n\n```\n<link rel=\"stylesheet\" type=\"text/css\" href=\"URL\"/>\n\n```\n","slug":"js高级程序设计/DOM","published":1,"date":"2018-05-03T14:23:56.321Z","updated":"2018-05-03T14:58:42.408Z","layout":"post","photos":[],"link":"","_id":"cka6kin1x002nqgu9a4j9m651","content":"<h1 id=\"节点层次\"><a href=\"#节点层次\" class=\"headerlink\" title=\"节点层次\"></a>节点层次</h1><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。</li>\n<li>节点之间的关系构成层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构</li>\n<li>文档节点是每个文档的根节点，通过文档节点表示的元素称之为文档元素</li>\n<li>文档元素是文档的最外层元素，文档中的其他元素都包含在文档元素中</li>\n<li>每个文档只能有一个文档元素，在HTML页面中，文档元素始终都是<html>元素</html></li>\n<li>HTML元素通过元素节点表示，特性(属性）通过特性节点表示，注释通过注释节点表示……</li>\n</ul>\n<hr>\n<blockquote>\n<p> 以下类型属性和方法的详细内容可参考红宝书，也可参考第19章DOM基础的pdf，在这里就不一一列出了</p>\n</blockquote>\n<h3 id=\"Node类型\"><a href=\"#Node类型\" class=\"headerlink\" title=\"Node类型\"></a>Node类型</h3><p>JavaScript中的所有节点类型都继承自Node类型</p>\n<ul>\n<li>节点属性（所有节点都有）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nodeName</td>\n<td>获取元素的标签名</td>\n</tr>\n<tr>\n<td>nodeValue</td>\n<td>返回节点的节点值</td>\n</tr>\n<tr>\n<td>childNodes</td>\n<td>获取当前元素节点的所有子节点</td>\n</tr>\n<tr>\n<td>firstChild</td>\n<td>获取当前元素节点的第一个子节点</td>\n</tr>\n<tr>\n<td>lastChild</td>\n<td>获取当前元素节点的最后一个子节点</td>\n</tr>\n<tr>\n<td>ownerDocument</td>\n<td>获取该文档的文档根节点</td>\n</tr>\n<tr>\n<td>parentNode</td>\n<td>获取当前节点的父节点</td>\n</tr>\n<tr>\n<td>previousSibling</td>\n<td>获取当前节点的前一个同级节点</td>\n</tr>\n<tr>\n<td>nextSibling</td>\n<td>获取当前节点的后一个同级节点</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>childNodes属性保存着一个NodeList对象，是一种类数组对象，用于保存一组有序的节点</p>\n</li>\n<li><p>操作节点（所有节点都可用）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appendChild()</td>\n<td>将新节点追加到子节点列表的末尾</td>\n</tr>\n<tr>\n<td>insertBefore()</td>\n<td>将新节点插入到参考节点的前面</td>\n</tr>\n<tr>\n<td>replaceChild()</td>\n<td>将新节点替换掉旧节点</td>\n</tr>\n<tr>\n<td>removeChild()</td>\n<td>移除节点</td>\n</tr>\n<tr>\n<td>cloneNode()</td>\n<td>复制节点</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Document类型\"><a href=\"#Document类型\" class=\"headerlink\" title=\"Document类型\"></a>Document类型</h3><p>JavaScript通过Document类型表示文档</p>\n<ul>\n<li>查找元素</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getElementsByTagName()</td>\n<td>获取相同元素的节点列表</td>\n</tr>\n<tr>\n<td>getElementByName()</td>\n<td>获取相同名称的节点列表</td>\n</tr>\n<tr>\n<td>getElementById()</td>\n<td>获取特定id元素的节点</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>文档写入</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>write()</td>\n<td>原样写入</td>\n</tr>\n<tr>\n<td>writeln()</td>\n<td>在字符串末尾添加换行符（\\n）</td>\n</tr>\n<tr>\n<td>open()</td>\n<td>打开网页的输出流</td>\n</tr>\n<tr>\n<td>close()</td>\n<td>关闭网页的输出流</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Element类型\"><a href=\"#Element类型\" class=\"headerlink\" title=\"Element类型\"></a>Element类型</h3><ul>\n<li>在HTML中，标签名始终都以全部大写表示</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(div.tagname);//DIV</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>title特性：鼠标移动到该元素之上时显示的内容</p>\n</li>\n<li><p>操作特性</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getAttribute()</td>\n<td>获取特定元素节点属性的值</td>\n</tr>\n<tr>\n<td>setAttribute()</td>\n<td>设置特定元素节点属性的值</td>\n</tr>\n<tr>\n<td>removeAttribute()</td>\n<td>移除特定元素节点属性</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>attributes属性<br>Element类型是使用attributes属性的唯一一个DOM节点类型。<br>attributes属性中包含一个NameNodeMap，是一个“动态”的集合，里面每一项为元素的特性</p>\n</li>\n<li><p>创建元素</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.createElement(要创建元素的标签名);</span><br></pre></td></tr></table></figure>\n<p>创建的新元素尚未被添加在文档树中，因此浏览器无法显示<br>可以用appendChild()等方法把其添加到文档树中</p>\n<h3 id=\"Text类型\"><a href=\"#Text类型\" class=\"headerlink\" title=\"Text类型\"></a>Text类型</h3><p>文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容</p>\n<ul>\n<li>创建文本节点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.createTextNode(要插入节点中的文本);</span><br></pre></td></tr></table></figure>\n<p>同样，除非把新节点添加到文档树中已经存在的节点中，否则不会在浏览器看到新节点</p>\n<ul>\n<li>规范文本节点<br>normalize()   将所有文本节点合并成一个节点</li>\n<li>分割文本节点<br>splitText()将一个文本节点分为两个文本节点</li>\n</ul>\n<h3 id=\"Comment类型\"><a href=\"#Comment类型\" class=\"headerlink\" title=\"Comment类型\"></a>Comment类型</h3><p>表示注释</p>\n<h3 id=\"CDATASection类型\"><a href=\"#CDATASection类型\" class=\"headerlink\" title=\"CDATASection类型\"></a>CDATASection类型</h3><p>表示CDATA区域，只针对基于XML的文档</p>\n<h3 id=\"DocumentType类型\"><a href=\"#DocumentType类型\" class=\"headerlink\" title=\"DocumentType类型\"></a>DocumentType类型</h3><p>包含着与文档的doctype有关的所有信息，不常用</p>\n<h3 id=\"DocumentFragment类型\"><a href=\"#DocumentFragment类型\" class=\"headerlink\" title=\"DocumentFragment类型\"></a>DocumentFragment类型</h3><p>表示文档片段</p>\n<h3 id=\"Attr类型\"><a href=\"#Attr类型\" class=\"headerlink\" title=\"Attr类型\"></a>Attr类型</h3><p>表示元素的特性</p>\n<h1 id=\"DOM操作技术\"><a href=\"#DOM操作技术\" class=\"headerlink\" title=\"DOM操作技术\"></a>DOM操作技术</h1><p>以下两种技术均建议插入外部文件</p>\n<h3 id=\"动态脚本\"><a href=\"#动态脚本\" class=\"headerlink\" title=\"动态脚本\"></a>动态脚本</h3><ul>\n<li>使用script元素包含js代码直接插入head元素中</li>\n<li>插入外部文件（建议）<br>可添加到head元素中，也可添加到页面中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;scripr type=&quot;text/javascript&quot; src=&quot;URL&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态样式\"><a href=\"#动态样式\" class=\"headerlink\" title=\"动态样式\"></a>动态样式</h3><ul>\n<li>使用style元素包含指定嵌入的样式插入head元素中</li>\n<li>插入外部文件（建议）<br><strong>必须将link元素添加到head元素中</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;URL&quot;/&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"节点层次\"><a href=\"#节点层次\" class=\"headerlink\" title=\"节点层次\"></a>节点层次</h1><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。</li>\n<li>节点之间的关系构成层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构</li>\n<li>文档节点是每个文档的根节点，通过文档节点表示的元素称之为文档元素</li>\n<li>文档元素是文档的最外层元素，文档中的其他元素都包含在文档元素中</li>\n<li>每个文档只能有一个文档元素，在HTML页面中，文档元素始终都是<html>元素</html></li>\n<li>HTML元素通过元素节点表示，特性(属性）通过特性节点表示，注释通过注释节点表示……</li>\n</ul>\n<hr>\n<blockquote>\n<p> 以下类型属性和方法的详细内容可参考红宝书，也可参考第19章DOM基础的pdf，在这里就不一一列出了</p>\n</blockquote>\n<h3 id=\"Node类型\"><a href=\"#Node类型\" class=\"headerlink\" title=\"Node类型\"></a>Node类型</h3><p>JavaScript中的所有节点类型都继承自Node类型</p>\n<ul>\n<li>节点属性（所有节点都有）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nodeName</td>\n<td>获取元素的标签名</td>\n</tr>\n<tr>\n<td>nodeValue</td>\n<td>返回节点的节点值</td>\n</tr>\n<tr>\n<td>childNodes</td>\n<td>获取当前元素节点的所有子节点</td>\n</tr>\n<tr>\n<td>firstChild</td>\n<td>获取当前元素节点的第一个子节点</td>\n</tr>\n<tr>\n<td>lastChild</td>\n<td>获取当前元素节点的最后一个子节点</td>\n</tr>\n<tr>\n<td>ownerDocument</td>\n<td>获取该文档的文档根节点</td>\n</tr>\n<tr>\n<td>parentNode</td>\n<td>获取当前节点的父节点</td>\n</tr>\n<tr>\n<td>previousSibling</td>\n<td>获取当前节点的前一个同级节点</td>\n</tr>\n<tr>\n<td>nextSibling</td>\n<td>获取当前节点的后一个同级节点</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>childNodes属性保存着一个NodeList对象，是一种类数组对象，用于保存一组有序的节点</p>\n</li>\n<li><p>操作节点（所有节点都可用）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appendChild()</td>\n<td>将新节点追加到子节点列表的末尾</td>\n</tr>\n<tr>\n<td>insertBefore()</td>\n<td>将新节点插入到参考节点的前面</td>\n</tr>\n<tr>\n<td>replaceChild()</td>\n<td>将新节点替换掉旧节点</td>\n</tr>\n<tr>\n<td>removeChild()</td>\n<td>移除节点</td>\n</tr>\n<tr>\n<td>cloneNode()</td>\n<td>复制节点</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Document类型\"><a href=\"#Document类型\" class=\"headerlink\" title=\"Document类型\"></a>Document类型</h3><p>JavaScript通过Document类型表示文档</p>\n<ul>\n<li>查找元素</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getElementsByTagName()</td>\n<td>获取相同元素的节点列表</td>\n</tr>\n<tr>\n<td>getElementByName()</td>\n<td>获取相同名称的节点列表</td>\n</tr>\n<tr>\n<td>getElementById()</td>\n<td>获取特定id元素的节点</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>文档写入</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>write()</td>\n<td>原样写入</td>\n</tr>\n<tr>\n<td>writeln()</td>\n<td>在字符串末尾添加换行符（\\n）</td>\n</tr>\n<tr>\n<td>open()</td>\n<td>打开网页的输出流</td>\n</tr>\n<tr>\n<td>close()</td>\n<td>关闭网页的输出流</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Element类型\"><a href=\"#Element类型\" class=\"headerlink\" title=\"Element类型\"></a>Element类型</h3><ul>\n<li>在HTML中，标签名始终都以全部大写表示</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(div.tagname);//DIV</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>title特性：鼠标移动到该元素之上时显示的内容</p>\n</li>\n<li><p>操作特性</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getAttribute()</td>\n<td>获取特定元素节点属性的值</td>\n</tr>\n<tr>\n<td>setAttribute()</td>\n<td>设置特定元素节点属性的值</td>\n</tr>\n<tr>\n<td>removeAttribute()</td>\n<td>移除特定元素节点属性</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>attributes属性<br>Element类型是使用attributes属性的唯一一个DOM节点类型。<br>attributes属性中包含一个NameNodeMap，是一个“动态”的集合，里面每一项为元素的特性</p>\n</li>\n<li><p>创建元素</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.createElement(要创建元素的标签名);</span><br></pre></td></tr></table></figure>\n<p>创建的新元素尚未被添加在文档树中，因此浏览器无法显示<br>可以用appendChild()等方法把其添加到文档树中</p>\n<h3 id=\"Text类型\"><a href=\"#Text类型\" class=\"headerlink\" title=\"Text类型\"></a>Text类型</h3><p>文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容</p>\n<ul>\n<li>创建文本节点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.createTextNode(要插入节点中的文本);</span><br></pre></td></tr></table></figure>\n<p>同样，除非把新节点添加到文档树中已经存在的节点中，否则不会在浏览器看到新节点</p>\n<ul>\n<li>规范文本节点<br>normalize()   将所有文本节点合并成一个节点</li>\n<li>分割文本节点<br>splitText()将一个文本节点分为两个文本节点</li>\n</ul>\n<h3 id=\"Comment类型\"><a href=\"#Comment类型\" class=\"headerlink\" title=\"Comment类型\"></a>Comment类型</h3><p>表示注释</p>\n<h3 id=\"CDATASection类型\"><a href=\"#CDATASection类型\" class=\"headerlink\" title=\"CDATASection类型\"></a>CDATASection类型</h3><p>表示CDATA区域，只针对基于XML的文档</p>\n<h3 id=\"DocumentType类型\"><a href=\"#DocumentType类型\" class=\"headerlink\" title=\"DocumentType类型\"></a>DocumentType类型</h3><p>包含着与文档的doctype有关的所有信息，不常用</p>\n<h3 id=\"DocumentFragment类型\"><a href=\"#DocumentFragment类型\" class=\"headerlink\" title=\"DocumentFragment类型\"></a>DocumentFragment类型</h3><p>表示文档片段</p>\n<h3 id=\"Attr类型\"><a href=\"#Attr类型\" class=\"headerlink\" title=\"Attr类型\"></a>Attr类型</h3><p>表示元素的特性</p>\n<h1 id=\"DOM操作技术\"><a href=\"#DOM操作技术\" class=\"headerlink\" title=\"DOM操作技术\"></a>DOM操作技术</h1><p>以下两种技术均建议插入外部文件</p>\n<h3 id=\"动态脚本\"><a href=\"#动态脚本\" class=\"headerlink\" title=\"动态脚本\"></a>动态脚本</h3><ul>\n<li>使用script元素包含js代码直接插入head元素中</li>\n<li>插入外部文件（建议）<br>可添加到head元素中，也可添加到页面中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;scripr type=&quot;text/javascript&quot; src=&quot;URL&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态样式\"><a href=\"#动态样式\" class=\"headerlink\" title=\"动态样式\"></a>动态样式</h3><ul>\n<li>使用style元素包含指定嵌入的样式插入head元素中</li>\n<li>插入外部文件（建议）<br><strong>必须将link元素添加到head元素中</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;URL&quot;/&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"JSON与Ajax","Date":"2018-05-02T16:00:00.000Z","_content":"\n# JSON\n## 语法\n- #### 简单值\n字符串、数值、布尔值、null，但不支持undefined\n> JSON字符串必须使用**双引号**\n- #### 对象\n\n```\nJavaScript:     var object={\n                   name:\"Greg\",\n                   age:27\n                };\n\n\nJSON:           {\n                   \"name\":\"Greg\",\n                   \"age\":27\n                }\n                \n```\n> 1、JSON对象没有声明变量（JSON没有变量）  \n> 2、JSON对象没有末尾的分号 \n\nPS：JSON对象的属性必须加**双引号**\n- #### 数组\n\n```\nJavaScript：   var values=[25,\"hi\",true];\nJSON:          [25,\"hi\",true]\n\n```\n> JSON数组没有变量和分号\n\n## 解析与序列化\n全局对象JSON有两个方法：  \n**stringify()**  把JavaScript对象序列化成JSON字符串  \n**parse()**  把JSON字符串解析为原生JavaScript值\n\n### 序列化选项\n- #### stringify()参数：   \n##### 第一个是过滤器\n数组过滤器：JSON.stringify()的结果中只包含数组中列出的属性    \n函数过滤器：函数接收属性（键）名和属性值，返回结果为相应值\n##### 第二个是一个选项\n表示是否在JSON字符串中保留缩进\n##### 第三个控制结果中的缩进和空白符\n- #### toJSON()方法\n可以给对象定义toJSON()方法，返回其自身的JSON数据格式\n\n### 解析选项\nJSON.parse()接收一个参数：还原函数  \n与JSON.stringify()接收的替换（过滤）函数，两者签名相同\n\n---\n\n## JSON小结\n- JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据\n- JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量\n- JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式\n- JSON**字符串**和JSON**对象属性**必须加**双引号**\n\n---\n\n# Ajax\n还没学JQ，暂用原生JS   \n\n\n\n```\n兼容\nfunction createXHR(){\n    if(typeof XMLHttpRequest !=\"undefined\"){\n        return new XMLHttpRequest();\n    }else if(typeof ActiveXObject !=\"undefined\"){\n        var version=[\n        \"MSXML2.XMLHttp6.0\",\n        \"MSXML2.XMLHttp3.0\",\n        \"MSXML2.XMLHttp\"\n        ];\n        for(var i=0;i<version.length;i++){\n            try{\n                return new ActiveXObject(version[i]);\n            }catch(e){\n                //跳过\n            }\n        }\n    }else{\n        throw new Error(\"您的系统浏览器不支持XHR对象!\")\n    }\n}\n\n```\n\n\n## XMLHttpRequest\n\n\n属性 | 说明\n---|---\nresponseText | 作为响应主体被返回的文本\nresponseXML | ......\nstatus | 响应HTTP状态（200为成功）\nstatusText | HTTP状态的说明\n- HTTP状态码  \n2字头：成功  \n3字头：重定向  \n4字头：请求错误   \n5、6字头：服务器错误\n- HTTP两种头部信息  \n响应头部信息：服务器返回的信息，客户端可以获取但不可以设置  \n请求头部信息：客户端发送的信息，客户端可以设置但不可以获取\n\n## 同步与异步\n\n- ### 同步\n\n```\naddEvent(document,\"click\",function(){\n   var xhr=createXHR();\n   xhr.open(\"get\",demo.txt,false);\n   xhr.send(null);\n   if(xhr.status==200){\n       alert(xhr.respenseText);\n   }else{\n       alert(\"获取数据错误  错误代号：\"+xhr.status+\",错误信息：\"+xhr.statusText);\n   }\n});\n\n```\n-  ### 异步\n\n```\naddEvent(document,\"click\",function(){\n   var xhr=createXHR();\n   xhr.onreadystatechange=function(){\n       if(xhr.readyState==4){\n           if(xhr.status==200){\n               alert(xhr.respenseText);\n           }else{\n               alert(\"获取数据错误  错误代号：\"+xhr.status+\",错误信息：\"+xhr.statusText);\n           }\n       }\n   };\n   xhr.open(\"get\",demo.txt,true);\n   //xhr.abort();  取消异步请求，在接收到响应之前使用\n   xhr.send(null);\n});\n\n```\n\n## GET与POST\n在Web程序上，  \nGET一般是URL提交请求，如demo.php?nme=Lee&age=27\nPOST一般是Web表单提交\n- ### GET请求\n\n```\ndemo1.php\n\n<?php\n$username = $_GET['username'];\n$age = $_GET['age'];\n\necho \"你的名字：{$username}，年龄：{$age}\";\n?>\n\n```\n\n\n```\naddEvent(document,\"click\",function(){\n   var xhr=createXHR();\n   xhr.onreadystatechange=function(){\n       if(xhr.readyState==4){\n           if(xhr.status==200){\n               alert(xhr.respenseText);\n           }else{\n               alert(\"获取数据错误  错误代号：\"+xhr.status+\",错误信息：\"+xhr.statusText);\n           }\n       }\n   };\n   xhr.open(\"get\",\"demo1.php?username=Lee&age=27\",true);\n   xhr.send(null);\n});\n\n```\n- ### POST请求\n\n```\ndemo2.php\n\n<?php\n$username = $_POST['username'];\n$age = $_POST['age'];\n\necho \"你的名字：{$username}，年龄：{$age}\";\n?>\n\n```\n\n\n```\naddEvent(document,\"click\",function(){\n   var xhr=createXHR();\n   xhr.onreadystatechange=function(){\n       if(xhr.readyState==4){\n           if(xhr.status==200){\n               alert(xhr.respenseText);\n           }else{\n               alert(\"获取数据错误  错误代号：\"+xhr.status+\",错误信息：\"+xhr.statusText);\n           }\n       }\n   };\n   //第一步：改为post\n   xhr.open(\"post\",\"demo2.php\",true);\n   //第三步：模拟表单提交，申明发送的数据类型\n   xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');\n   //第二步：将名值对放入send()方法里\n   xhr.send(\"username=Lee&age=27\");\n});\n\n```\n## Ajax步骤\n1. 创建对象\n2. 调用open()启动一个请求以备发送\n3. 调用send()发送请求\n4. 接收响应\n","source":"_posts/js高级程序设计/JSON与Ajax.md","raw":"---\ntitle: JSON与Ajax\nDate: 2018-05-03\ntags: [红宝书]\ncategories: 红宝书\n---\n\n# JSON\n## 语法\n- #### 简单值\n字符串、数值、布尔值、null，但不支持undefined\n> JSON字符串必须使用**双引号**\n- #### 对象\n\n```\nJavaScript:     var object={\n                   name:\"Greg\",\n                   age:27\n                };\n\n\nJSON:           {\n                   \"name\":\"Greg\",\n                   \"age\":27\n                }\n                \n```\n> 1、JSON对象没有声明变量（JSON没有变量）  \n> 2、JSON对象没有末尾的分号 \n\nPS：JSON对象的属性必须加**双引号**\n- #### 数组\n\n```\nJavaScript：   var values=[25,\"hi\",true];\nJSON:          [25,\"hi\",true]\n\n```\n> JSON数组没有变量和分号\n\n## 解析与序列化\n全局对象JSON有两个方法：  \n**stringify()**  把JavaScript对象序列化成JSON字符串  \n**parse()**  把JSON字符串解析为原生JavaScript值\n\n### 序列化选项\n- #### stringify()参数：   \n##### 第一个是过滤器\n数组过滤器：JSON.stringify()的结果中只包含数组中列出的属性    \n函数过滤器：函数接收属性（键）名和属性值，返回结果为相应值\n##### 第二个是一个选项\n表示是否在JSON字符串中保留缩进\n##### 第三个控制结果中的缩进和空白符\n- #### toJSON()方法\n可以给对象定义toJSON()方法，返回其自身的JSON数据格式\n\n### 解析选项\nJSON.parse()接收一个参数：还原函数  \n与JSON.stringify()接收的替换（过滤）函数，两者签名相同\n\n---\n\n## JSON小结\n- JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据\n- JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量\n- JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式\n- JSON**字符串**和JSON**对象属性**必须加**双引号**\n\n---\n\n# Ajax\n还没学JQ，暂用原生JS   \n\n\n\n```\n兼容\nfunction createXHR(){\n    if(typeof XMLHttpRequest !=\"undefined\"){\n        return new XMLHttpRequest();\n    }else if(typeof ActiveXObject !=\"undefined\"){\n        var version=[\n        \"MSXML2.XMLHttp6.0\",\n        \"MSXML2.XMLHttp3.0\",\n        \"MSXML2.XMLHttp\"\n        ];\n        for(var i=0;i<version.length;i++){\n            try{\n                return new ActiveXObject(version[i]);\n            }catch(e){\n                //跳过\n            }\n        }\n    }else{\n        throw new Error(\"您的系统浏览器不支持XHR对象!\")\n    }\n}\n\n```\n\n\n## XMLHttpRequest\n\n\n属性 | 说明\n---|---\nresponseText | 作为响应主体被返回的文本\nresponseXML | ......\nstatus | 响应HTTP状态（200为成功）\nstatusText | HTTP状态的说明\n- HTTP状态码  \n2字头：成功  \n3字头：重定向  \n4字头：请求错误   \n5、6字头：服务器错误\n- HTTP两种头部信息  \n响应头部信息：服务器返回的信息，客户端可以获取但不可以设置  \n请求头部信息：客户端发送的信息，客户端可以设置但不可以获取\n\n## 同步与异步\n\n- ### 同步\n\n```\naddEvent(document,\"click\",function(){\n   var xhr=createXHR();\n   xhr.open(\"get\",demo.txt,false);\n   xhr.send(null);\n   if(xhr.status==200){\n       alert(xhr.respenseText);\n   }else{\n       alert(\"获取数据错误  错误代号：\"+xhr.status+\",错误信息：\"+xhr.statusText);\n   }\n});\n\n```\n-  ### 异步\n\n```\naddEvent(document,\"click\",function(){\n   var xhr=createXHR();\n   xhr.onreadystatechange=function(){\n       if(xhr.readyState==4){\n           if(xhr.status==200){\n               alert(xhr.respenseText);\n           }else{\n               alert(\"获取数据错误  错误代号：\"+xhr.status+\",错误信息：\"+xhr.statusText);\n           }\n       }\n   };\n   xhr.open(\"get\",demo.txt,true);\n   //xhr.abort();  取消异步请求，在接收到响应之前使用\n   xhr.send(null);\n});\n\n```\n\n## GET与POST\n在Web程序上，  \nGET一般是URL提交请求，如demo.php?nme=Lee&age=27\nPOST一般是Web表单提交\n- ### GET请求\n\n```\ndemo1.php\n\n<?php\n$username = $_GET['username'];\n$age = $_GET['age'];\n\necho \"你的名字：{$username}，年龄：{$age}\";\n?>\n\n```\n\n\n```\naddEvent(document,\"click\",function(){\n   var xhr=createXHR();\n   xhr.onreadystatechange=function(){\n       if(xhr.readyState==4){\n           if(xhr.status==200){\n               alert(xhr.respenseText);\n           }else{\n               alert(\"获取数据错误  错误代号：\"+xhr.status+\",错误信息：\"+xhr.statusText);\n           }\n       }\n   };\n   xhr.open(\"get\",\"demo1.php?username=Lee&age=27\",true);\n   xhr.send(null);\n});\n\n```\n- ### POST请求\n\n```\ndemo2.php\n\n<?php\n$username = $_POST['username'];\n$age = $_POST['age'];\n\necho \"你的名字：{$username}，年龄：{$age}\";\n?>\n\n```\n\n\n```\naddEvent(document,\"click\",function(){\n   var xhr=createXHR();\n   xhr.onreadystatechange=function(){\n       if(xhr.readyState==4){\n           if(xhr.status==200){\n               alert(xhr.respenseText);\n           }else{\n               alert(\"获取数据错误  错误代号：\"+xhr.status+\",错误信息：\"+xhr.statusText);\n           }\n       }\n   };\n   //第一步：改为post\n   xhr.open(\"post\",\"demo2.php\",true);\n   //第三步：模拟表单提交，申明发送的数据类型\n   xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');\n   //第二步：将名值对放入send()方法里\n   xhr.send(\"username=Lee&age=27\");\n});\n\n```\n## Ajax步骤\n1. 创建对象\n2. 调用open()启动一个请求以备发送\n3. 调用send()发送请求\n4. 接收响应\n","slug":"js高级程序设计/JSON与Ajax","published":1,"date":"2018-05-03T14:28:25.853Z","updated":"2018-05-03T14:58:18.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka6kin27002qqgu9w4aglbod","content":"<h1 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><ul>\n<li><h4 id=\"简单值\"><a href=\"#简单值\" class=\"headerlink\" title=\"简单值\"></a>简单值</h4>字符串、数值、布尔值、null，但不支持undefined<blockquote>\n<p>JSON字符串必须使用<strong>双引号</strong></p>\n</blockquote>\n</li>\n<li><h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript:     var object=&#123;</span><br><span class=\"line\">                   name:&quot;Greg&quot;,</span><br><span class=\"line\">                   age:27</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">JSON:           &#123;</span><br><span class=\"line\">                   &quot;name&quot;:&quot;Greg&quot;,</span><br><span class=\"line\">                   &quot;age&quot;:27</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1、JSON对象没有声明变量（JSON没有变量）<br>2、JSON对象没有末尾的分号 </p>\n</blockquote>\n<p>PS：JSON对象的属性必须加<strong>双引号</strong></p>\n<ul>\n<li><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript：   var values=[25,&quot;hi&quot;,true];</span><br><span class=\"line\">JSON:          [25,&quot;hi&quot;,true]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>JSON数组没有变量和分号</p>\n</blockquote>\n<h2 id=\"解析与序列化\"><a href=\"#解析与序列化\" class=\"headerlink\" title=\"解析与序列化\"></a>解析与序列化</h2><p>全局对象JSON有两个方法：<br><strong>stringify()</strong>  把JavaScript对象序列化成JSON字符串<br><strong>parse()</strong>  把JSON字符串解析为原生JavaScript值</p>\n<h3 id=\"序列化选项\"><a href=\"#序列化选项\" class=\"headerlink\" title=\"序列化选项\"></a>序列化选项</h3><ul>\n<li><h4 id=\"stringify-参数：\"><a href=\"#stringify-参数：\" class=\"headerlink\" title=\"stringify()参数：\"></a>stringify()参数：</h4><h5 id=\"第一个是过滤器\"><a href=\"#第一个是过滤器\" class=\"headerlink\" title=\"第一个是过滤器\"></a>第一个是过滤器</h5>数组过滤器：JSON.stringify()的结果中只包含数组中列出的属性<br>函数过滤器：函数接收属性（键）名和属性值，返回结果为相应值<h5 id=\"第二个是一个选项\"><a href=\"#第二个是一个选项\" class=\"headerlink\" title=\"第二个是一个选项\"></a>第二个是一个选项</h5>表示是否在JSON字符串中保留缩进<h5 id=\"第三个控制结果中的缩进和空白符\"><a href=\"#第三个控制结果中的缩进和空白符\" class=\"headerlink\" title=\"第三个控制结果中的缩进和空白符\"></a>第三个控制结果中的缩进和空白符</h5></li>\n<li><h4 id=\"toJSON-方法\"><a href=\"#toJSON-方法\" class=\"headerlink\" title=\"toJSON()方法\"></a>toJSON()方法</h4>可以给对象定义toJSON()方法，返回其自身的JSON数据格式</li>\n</ul>\n<h3 id=\"解析选项\"><a href=\"#解析选项\" class=\"headerlink\" title=\"解析选项\"></a>解析选项</h3><p>JSON.parse()接收一个参数：还原函数<br>与JSON.stringify()接收的替换（过滤）函数，两者签名相同</p>\n<hr>\n<h2 id=\"JSON小结\"><a href=\"#JSON小结\" class=\"headerlink\" title=\"JSON小结\"></a>JSON小结</h2><ul>\n<li>JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据</li>\n<li>JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量</li>\n<li>JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式</li>\n<li>JSON<strong>字符串</strong>和JSON<strong>对象属性</strong>必须加<strong>双引号</strong></li>\n</ul>\n<hr>\n<h1 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a>Ajax</h1><p>还没学JQ，暂用原生JS   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">兼容</span><br><span class=\"line\">function createXHR()&#123;</span><br><span class=\"line\">    if(typeof XMLHttpRequest !=&quot;undefined&quot;)&#123;</span><br><span class=\"line\">        return new XMLHttpRequest();</span><br><span class=\"line\">    &#125;else if(typeof ActiveXObject !=&quot;undefined&quot;)&#123;</span><br><span class=\"line\">        var version=[</span><br><span class=\"line\">        &quot;MSXML2.XMLHttp6.0&quot;,</span><br><span class=\"line\">        &quot;MSXML2.XMLHttp3.0&quot;,</span><br><span class=\"line\">        &quot;MSXML2.XMLHttp&quot;</span><br><span class=\"line\">        ];</span><br><span class=\"line\">        for(var i=0;i&lt;version.length;i++)&#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                return new ActiveXObject(version[i]);</span><br><span class=\"line\">            &#125;catch(e)&#123;</span><br><span class=\"line\">                //跳过</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        throw new Error(&quot;您的系统浏览器不支持XHR对象!&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a>XMLHttpRequest</h2><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>responseText</td>\n<td>作为响应主体被返回的文本</td>\n</tr>\n<tr>\n<td>responseXML</td>\n<td>……</td>\n</tr>\n<tr>\n<td>status</td>\n<td>响应HTTP状态（200为成功）</td>\n</tr>\n<tr>\n<td>statusText</td>\n<td>HTTP状态的说明</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>HTTP状态码<br>2字头：成功<br>3字头：重定向<br>4字头：请求错误<br>5、6字头：服务器错误</li>\n<li>HTTP两种头部信息<br>响应头部信息：服务器返回的信息，客户端可以获取但不可以设置<br>请求头部信息：客户端发送的信息，客户端可以设置但不可以获取</li>\n</ul>\n<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><ul>\n<li><h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h3></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document,&quot;click&quot;,function()&#123;</span><br><span class=\"line\">   var xhr=createXHR();</span><br><span class=\"line\">   xhr.open(&quot;get&quot;,demo.txt,false);</span><br><span class=\"line\">   xhr.send(null);</span><br><span class=\"line\">   if(xhr.status==200)&#123;</span><br><span class=\"line\">       alert(xhr.respenseText);</span><br><span class=\"line\">   &#125;else&#123;</span><br><span class=\"line\">       alert(&quot;获取数据错误  错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document,&quot;click&quot;,function()&#123;</span><br><span class=\"line\">   var xhr=createXHR();</span><br><span class=\"line\">   xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">       if(xhr.readyState==4)&#123;</span><br><span class=\"line\">           if(xhr.status==200)&#123;</span><br><span class=\"line\">               alert(xhr.respenseText);</span><br><span class=\"line\">           &#125;else&#123;</span><br><span class=\"line\">               alert(&quot;获取数据错误  错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   xhr.open(&quot;get&quot;,demo.txt,true);</span><br><span class=\"line\">   //xhr.abort();  取消异步请求，在接收到响应之前使用</span><br><span class=\"line\">   xhr.send(null);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"GET与POST\"><a href=\"#GET与POST\" class=\"headerlink\" title=\"GET与POST\"></a>GET与POST</h2><p>在Web程序上，<br>GET一般是URL提交请求，如demo.php?nme=Lee&amp;age=27<br>POST一般是Web表单提交</p>\n<ul>\n<li><h3 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h3></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo1.php</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">$username = $_GET[&apos;username&apos;];</span><br><span class=\"line\">$age = $_GET[&apos;age&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;&quot;;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document,&quot;click&quot;,function()&#123;</span><br><span class=\"line\">   var xhr=createXHR();</span><br><span class=\"line\">   xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">       if(xhr.readyState==4)&#123;</span><br><span class=\"line\">           if(xhr.status==200)&#123;</span><br><span class=\"line\">               alert(xhr.respenseText);</span><br><span class=\"line\">           &#125;else&#123;</span><br><span class=\"line\">               alert(&quot;获取数据错误  错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   xhr.open(&quot;get&quot;,&quot;demo1.php?username=Lee&amp;age=27&quot;,true);</span><br><span class=\"line\">   xhr.send(null);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><h3 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h3></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo2.php</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">$username = $_POST[&apos;username&apos;];</span><br><span class=\"line\">$age = $_POST[&apos;age&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;&quot;;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document,&quot;click&quot;,function()&#123;</span><br><span class=\"line\">   var xhr=createXHR();</span><br><span class=\"line\">   xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">       if(xhr.readyState==4)&#123;</span><br><span class=\"line\">           if(xhr.status==200)&#123;</span><br><span class=\"line\">               alert(xhr.respenseText);</span><br><span class=\"line\">           &#125;else&#123;</span><br><span class=\"line\">               alert(&quot;获取数据错误  错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   //第一步：改为post</span><br><span class=\"line\">   xhr.open(&quot;post&quot;,&quot;demo2.php&quot;,true);</span><br><span class=\"line\">   //第三步：模拟表单提交，申明发送的数据类型</span><br><span class=\"line\">   xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class=\"line\">   //第二步：将名值对放入send()方法里</span><br><span class=\"line\">   xhr.send(&quot;username=Lee&amp;age=27&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Ajax步骤\"><a href=\"#Ajax步骤\" class=\"headerlink\" title=\"Ajax步骤\"></a>Ajax步骤</h2><ol>\n<li>创建对象</li>\n<li>调用open()启动一个请求以备发送</li>\n<li>调用send()发送请求</li>\n<li>接收响应</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><ul>\n<li><h4 id=\"简单值\"><a href=\"#简单值\" class=\"headerlink\" title=\"简单值\"></a>简单值</h4>字符串、数值、布尔值、null，但不支持undefined<blockquote>\n<p>JSON字符串必须使用<strong>双引号</strong></p>\n</blockquote>\n</li>\n<li><h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript:     var object=&#123;</span><br><span class=\"line\">                   name:&quot;Greg&quot;,</span><br><span class=\"line\">                   age:27</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">JSON:           &#123;</span><br><span class=\"line\">                   &quot;name&quot;:&quot;Greg&quot;,</span><br><span class=\"line\">                   &quot;age&quot;:27</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1、JSON对象没有声明变量（JSON没有变量）<br>2、JSON对象没有末尾的分号 </p>\n</blockquote>\n<p>PS：JSON对象的属性必须加<strong>双引号</strong></p>\n<ul>\n<li><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript：   var values=[25,&quot;hi&quot;,true];</span><br><span class=\"line\">JSON:          [25,&quot;hi&quot;,true]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>JSON数组没有变量和分号</p>\n</blockquote>\n<h2 id=\"解析与序列化\"><a href=\"#解析与序列化\" class=\"headerlink\" title=\"解析与序列化\"></a>解析与序列化</h2><p>全局对象JSON有两个方法：<br><strong>stringify()</strong>  把JavaScript对象序列化成JSON字符串<br><strong>parse()</strong>  把JSON字符串解析为原生JavaScript值</p>\n<h3 id=\"序列化选项\"><a href=\"#序列化选项\" class=\"headerlink\" title=\"序列化选项\"></a>序列化选项</h3><ul>\n<li><h4 id=\"stringify-参数：\"><a href=\"#stringify-参数：\" class=\"headerlink\" title=\"stringify()参数：\"></a>stringify()参数：</h4><h5 id=\"第一个是过滤器\"><a href=\"#第一个是过滤器\" class=\"headerlink\" title=\"第一个是过滤器\"></a>第一个是过滤器</h5>数组过滤器：JSON.stringify()的结果中只包含数组中列出的属性<br>函数过滤器：函数接收属性（键）名和属性值，返回结果为相应值<h5 id=\"第二个是一个选项\"><a href=\"#第二个是一个选项\" class=\"headerlink\" title=\"第二个是一个选项\"></a>第二个是一个选项</h5>表示是否在JSON字符串中保留缩进<h5 id=\"第三个控制结果中的缩进和空白符\"><a href=\"#第三个控制结果中的缩进和空白符\" class=\"headerlink\" title=\"第三个控制结果中的缩进和空白符\"></a>第三个控制结果中的缩进和空白符</h5></li>\n<li><h4 id=\"toJSON-方法\"><a href=\"#toJSON-方法\" class=\"headerlink\" title=\"toJSON()方法\"></a>toJSON()方法</h4>可以给对象定义toJSON()方法，返回其自身的JSON数据格式</li>\n</ul>\n<h3 id=\"解析选项\"><a href=\"#解析选项\" class=\"headerlink\" title=\"解析选项\"></a>解析选项</h3><p>JSON.parse()接收一个参数：还原函数<br>与JSON.stringify()接收的替换（过滤）函数，两者签名相同</p>\n<hr>\n<h2 id=\"JSON小结\"><a href=\"#JSON小结\" class=\"headerlink\" title=\"JSON小结\"></a>JSON小结</h2><ul>\n<li>JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据</li>\n<li>JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量</li>\n<li>JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式</li>\n<li>JSON<strong>字符串</strong>和JSON<strong>对象属性</strong>必须加<strong>双引号</strong></li>\n</ul>\n<hr>\n<h1 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a>Ajax</h1><p>还没学JQ，暂用原生JS   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">兼容</span><br><span class=\"line\">function createXHR()&#123;</span><br><span class=\"line\">    if(typeof XMLHttpRequest !=&quot;undefined&quot;)&#123;</span><br><span class=\"line\">        return new XMLHttpRequest();</span><br><span class=\"line\">    &#125;else if(typeof ActiveXObject !=&quot;undefined&quot;)&#123;</span><br><span class=\"line\">        var version=[</span><br><span class=\"line\">        &quot;MSXML2.XMLHttp6.0&quot;,</span><br><span class=\"line\">        &quot;MSXML2.XMLHttp3.0&quot;,</span><br><span class=\"line\">        &quot;MSXML2.XMLHttp&quot;</span><br><span class=\"line\">        ];</span><br><span class=\"line\">        for(var i=0;i&lt;version.length;i++)&#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                return new ActiveXObject(version[i]);</span><br><span class=\"line\">            &#125;catch(e)&#123;</span><br><span class=\"line\">                //跳过</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        throw new Error(&quot;您的系统浏览器不支持XHR对象!&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a>XMLHttpRequest</h2><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>responseText</td>\n<td>作为响应主体被返回的文本</td>\n</tr>\n<tr>\n<td>responseXML</td>\n<td>……</td>\n</tr>\n<tr>\n<td>status</td>\n<td>响应HTTP状态（200为成功）</td>\n</tr>\n<tr>\n<td>statusText</td>\n<td>HTTP状态的说明</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>HTTP状态码<br>2字头：成功<br>3字头：重定向<br>4字头：请求错误<br>5、6字头：服务器错误</li>\n<li>HTTP两种头部信息<br>响应头部信息：服务器返回的信息，客户端可以获取但不可以设置<br>请求头部信息：客户端发送的信息，客户端可以设置但不可以获取</li>\n</ul>\n<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><ul>\n<li><h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h3></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document,&quot;click&quot;,function()&#123;</span><br><span class=\"line\">   var xhr=createXHR();</span><br><span class=\"line\">   xhr.open(&quot;get&quot;,demo.txt,false);</span><br><span class=\"line\">   xhr.send(null);</span><br><span class=\"line\">   if(xhr.status==200)&#123;</span><br><span class=\"line\">       alert(xhr.respenseText);</span><br><span class=\"line\">   &#125;else&#123;</span><br><span class=\"line\">       alert(&quot;获取数据错误  错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document,&quot;click&quot;,function()&#123;</span><br><span class=\"line\">   var xhr=createXHR();</span><br><span class=\"line\">   xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">       if(xhr.readyState==4)&#123;</span><br><span class=\"line\">           if(xhr.status==200)&#123;</span><br><span class=\"line\">               alert(xhr.respenseText);</span><br><span class=\"line\">           &#125;else&#123;</span><br><span class=\"line\">               alert(&quot;获取数据错误  错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   xhr.open(&quot;get&quot;,demo.txt,true);</span><br><span class=\"line\">   //xhr.abort();  取消异步请求，在接收到响应之前使用</span><br><span class=\"line\">   xhr.send(null);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"GET与POST\"><a href=\"#GET与POST\" class=\"headerlink\" title=\"GET与POST\"></a>GET与POST</h2><p>在Web程序上，<br>GET一般是URL提交请求，如demo.php?nme=Lee&amp;age=27<br>POST一般是Web表单提交</p>\n<ul>\n<li><h3 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h3></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo1.php</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">$username = $_GET[&apos;username&apos;];</span><br><span class=\"line\">$age = $_GET[&apos;age&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;&quot;;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document,&quot;click&quot;,function()&#123;</span><br><span class=\"line\">   var xhr=createXHR();</span><br><span class=\"line\">   xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">       if(xhr.readyState==4)&#123;</span><br><span class=\"line\">           if(xhr.status==200)&#123;</span><br><span class=\"line\">               alert(xhr.respenseText);</span><br><span class=\"line\">           &#125;else&#123;</span><br><span class=\"line\">               alert(&quot;获取数据错误  错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   xhr.open(&quot;get&quot;,&quot;demo1.php?username=Lee&amp;age=27&quot;,true);</span><br><span class=\"line\">   xhr.send(null);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><h3 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h3></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo2.php</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">$username = $_POST[&apos;username&apos;];</span><br><span class=\"line\">$age = $_POST[&apos;age&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;&quot;;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document,&quot;click&quot;,function()&#123;</span><br><span class=\"line\">   var xhr=createXHR();</span><br><span class=\"line\">   xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">       if(xhr.readyState==4)&#123;</span><br><span class=\"line\">           if(xhr.status==200)&#123;</span><br><span class=\"line\">               alert(xhr.respenseText);</span><br><span class=\"line\">           &#125;else&#123;</span><br><span class=\"line\">               alert(&quot;获取数据错误  错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   //第一步：改为post</span><br><span class=\"line\">   xhr.open(&quot;post&quot;,&quot;demo2.php&quot;,true);</span><br><span class=\"line\">   //第三步：模拟表单提交，申明发送的数据类型</span><br><span class=\"line\">   xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class=\"line\">   //第二步：将名值对放入send()方法里</span><br><span class=\"line\">   xhr.send(&quot;username=Lee&amp;age=27&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Ajax步骤\"><a href=\"#Ajax步骤\" class=\"headerlink\" title=\"Ajax步骤\"></a>Ajax步骤</h2><ol>\n<li>创建对象</li>\n<li>调用open()启动一个请求以备发送</li>\n<li>调用send()发送请求</li>\n<li>接收响应</li>\n</ol>\n"},{"title":"事件","Date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"\n# 事件流\n- #### 事件冒泡\n 事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）\n- #### 事件捕获\n不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件\n事件捕获用意在于在事件到达预定目标之前捕获它\n- #### DOM事件流\n（事件流描述的是从页面中接收事件的顺序）\n1. 事件捕获阶段（从document开始）\n2. 处于目标阶段\n3. 事件冒泡阶段\n\n# 事件处理程序\n\n### HTMl事件处理程序\n\n某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定\n\n- 特性的值\n\n可以是能够执行的js代码\n\n```\n<input type=\"button\" value=\"按钮\" onclick=\"alert('Clicked')\"/>\n\n```\n也可以调用在页面其他地方定义的脚本\n\n```\n<input id=\"btn\" value=\"click me\" onclick=\"showMessage()\" />\n<script type=\"text/javascript\"> \n　　function showMessage(){\n　　 alert(\"clicked\");\n }\n</script>\n\n```\n- 扩展作用域\n\n```\nfunction(){\n    with(document){\n        eith(this){\n            //元素属性值\n        }\n    }\n}        在这个函数内部，可以像访问局部变量一样访问document\n         及该元素本身的成员\n         \n```\n\n### DOM0级事件处理程序（主要）\n\n通过JavaScript指定处理程序的传统方式，将一个函数赋值给一个事件处理程序属性。每个元素（包括document和window）都有自己的事件处理程序属性   \n以这种方式添加的事件处理程序会在事件流的*冒泡阶段*被处理\n\n```\nvar btn = document.getElementById(\"btn\");\nbtn.onclick = function(){\n   alert(\"Clicked\");       //指定事件处理程序\n};\nbtn.onclick=function(){\n  alert(this.id);//btn     //其作用域为元素的作用域\n}\n//想要取消事件处理程序的话，只需将事件处理程序属性设为null即可\nbtn.onclick = null;\n\n```\n\n### DOM2级事件处理程序\n\n用于处理指定和删除事件处理程序的操作：  \naddEventListener()和removeEventListener()\n\n```\n//指定事件处理程序 \nbtn.addEventListener(\"click\",fucntion(){\nalert(\"clicked\");},false);\n//取消事件处理程序\nbtn.removeEventListener(\"click\",function(){\nalert(\"clicked\");},false);//无效\n//指定和取消的参数必须完全相同才有效\n//而匿名函数是两个不同的函数，所以无效\n\n```\n为了能够取消，最好函数采用函数表达式\n\n```\nvar handler = function(){\n   alert(\"clicked\"); \n};\n//添加事件处理程序\nbtn.addEventListener(\"click\",handler,false);\n//取消事件处理程序\nbtn.removeEventListener(\"click\",handler,false);//有效\n\n```\n\n### IE事件处理程序\n用于处理指定和删除事件处理程序的操作：   \nattachEvent()和detachEvent() \n\nIE事件处理程序与DOM事件处理程序的最大区别：  \nDOM0/2级事件处理程序的作用域是元素作用域；  \n而IE事件处理程序是全局作用域，即*this等于widow*\n\n```\nvar handler = function(){\n   alert(\"clicked\"); \n};\n//指定事件处理程序\nbtn.attachEvent(\"onclick\",handler);\n//取消事件处理程序\nbtn.detachEvent(\"onclick\",handler);\n//取消参数必须与添加完全相同\n所以事件处理程序函数(同DOM2级事件中的分析一样)不要是匿名函数。\n\n```\n\n### 跨浏览器的事件处理程序\n用于处理指定和删除事件处理程序的操作：   \naddHandler()和removeHandler()  \n这两个方法属于一个名叫EventUtil的对象\n\n```\nvar handler = function(){\n            alert(\"Clicked\");\n};\n//指定事件处理程序\nEventUtil.addHandler(btn,\"click\",handler);\n//移除事件处理程序\nEventUtil.removeHandler(btn,\"click\",handler);\n\n```\n\n# 事件对象\n在触发DOM上的某个事件时，会产生一个事件对象event。这个对象中包含着所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息   \n所有浏览器都支持event对象，event对象会传入DOM0级，DOM2级，HTML指定的事件处理程序中，但支持的方式不同，所以也会涉及跨浏览器的部分\n\n### DOM中的事件对象\n> 相关属性方法详见书355\n\n#### 两个有点难区分的属性：\n- currentTarget：this对象始终是指向它的值，为其事件处理程序当前正在处理事件的那个元素\n- target：只包含事件的目标\n\n### IE中的事件对象\n> 相关属性方法详见书359\n\n### 跨浏览器的事件对象\n对前面介绍到的EventUtil对象加以增强  \n添加如下方法 ，写一个通用的事件侦听函数即可\n\n```\n听说面试会问到，这样写就可以了\nvar EventUtil={\ngetEvent:function(event){\n    return event||window.event;\n},\ngetTarget:function(event){\n    return event.target||event.srcElement;\n},\npreventDefault:function(){\n    if(event.preventDefault){\n        event.preventDefault();\n    }else{\n        event.returnValue=false;\n    }\n},\nstopPropagation:function(){\n    if(event.stopPropagation){\n        event.stopPropagation();\n    }else{\n        event.cancelBubble=true;\n    }\n},\naddHandler:function(element,type,handler){\n    if(element.addEventListener){\n        element.addEventListener(type,handler,false);\n    }else if(element.attachEvent){\n        element[\"e\"+type]=function(){\n            handler.call(element)\n        }\n        element.attachEvent(\"on\"+type,element[\"e\"+type]);\n    }else{\n            element[\"on\"+type]=handler;\n    }\n},\nremoveHandler:function(element,type,handler){\n    if(element.removeEventListener){\n        element.removeEventListener(type,handler,false);\n    }else if(element.detachEvent){\n        element.detachEvent(\"on\"+type,element[\"e\"+type]);\n        element[\"e\"+type]=null;   \n    }else{\n        element[\"on\"+type]=null;\n    }\n}\n \n};\n\n```\n\n# 事件类型\n\n> 好像没什么必要一一列出来了，详见书中362\n\n# 内存和性能\n### 事件委托\n- 利用冒泡的原理，把事件加到父级上，触发执行效果  \n- 通俗的讲，就是这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件  \n- 使用事件委托，只需在DOM树中尽量最高的层次上添加一个事件处理程序\n\n### 移除事件处理程序\n- 从文档中移除带有事件处理程序的元素时\n- 卸载页面时\n \n# 模拟事件\n\n### DOM中的事件模拟\n- 调用document.createEvent()方法创建event对象\n- 初始化对象，为对象添加相关信息\n- 调用dispatchEvent()方法触发事件\n\n### IE中的事件模拟\n- 调用document.createEventObject()方法创建event对象\n- 初始化对象，为对象添加相关信息\n- 调用fireEvent()方法触发事件","source":"_posts/js高级程序设计/事件.md","raw":"---\ntitle: 事件\nDate: 2018-05-03\ntags: [红宝书]\ncategories: 红宝书\ncomments: true\n---\n\n# 事件流\n- #### 事件冒泡\n 事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）\n- #### 事件捕获\n不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件\n事件捕获用意在于在事件到达预定目标之前捕获它\n- #### DOM事件流\n（事件流描述的是从页面中接收事件的顺序）\n1. 事件捕获阶段（从document开始）\n2. 处于目标阶段\n3. 事件冒泡阶段\n\n# 事件处理程序\n\n### HTMl事件处理程序\n\n某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定\n\n- 特性的值\n\n可以是能够执行的js代码\n\n```\n<input type=\"button\" value=\"按钮\" onclick=\"alert('Clicked')\"/>\n\n```\n也可以调用在页面其他地方定义的脚本\n\n```\n<input id=\"btn\" value=\"click me\" onclick=\"showMessage()\" />\n<script type=\"text/javascript\"> \n　　function showMessage(){\n　　 alert(\"clicked\");\n }\n</script>\n\n```\n- 扩展作用域\n\n```\nfunction(){\n    with(document){\n        eith(this){\n            //元素属性值\n        }\n    }\n}        在这个函数内部，可以像访问局部变量一样访问document\n         及该元素本身的成员\n         \n```\n\n### DOM0级事件处理程序（主要）\n\n通过JavaScript指定处理程序的传统方式，将一个函数赋值给一个事件处理程序属性。每个元素（包括document和window）都有自己的事件处理程序属性   \n以这种方式添加的事件处理程序会在事件流的*冒泡阶段*被处理\n\n```\nvar btn = document.getElementById(\"btn\");\nbtn.onclick = function(){\n   alert(\"Clicked\");       //指定事件处理程序\n};\nbtn.onclick=function(){\n  alert(this.id);//btn     //其作用域为元素的作用域\n}\n//想要取消事件处理程序的话，只需将事件处理程序属性设为null即可\nbtn.onclick = null;\n\n```\n\n### DOM2级事件处理程序\n\n用于处理指定和删除事件处理程序的操作：  \naddEventListener()和removeEventListener()\n\n```\n//指定事件处理程序 \nbtn.addEventListener(\"click\",fucntion(){\nalert(\"clicked\");},false);\n//取消事件处理程序\nbtn.removeEventListener(\"click\",function(){\nalert(\"clicked\");},false);//无效\n//指定和取消的参数必须完全相同才有效\n//而匿名函数是两个不同的函数，所以无效\n\n```\n为了能够取消，最好函数采用函数表达式\n\n```\nvar handler = function(){\n   alert(\"clicked\"); \n};\n//添加事件处理程序\nbtn.addEventListener(\"click\",handler,false);\n//取消事件处理程序\nbtn.removeEventListener(\"click\",handler,false);//有效\n\n```\n\n### IE事件处理程序\n用于处理指定和删除事件处理程序的操作：   \nattachEvent()和detachEvent() \n\nIE事件处理程序与DOM事件处理程序的最大区别：  \nDOM0/2级事件处理程序的作用域是元素作用域；  \n而IE事件处理程序是全局作用域，即*this等于widow*\n\n```\nvar handler = function(){\n   alert(\"clicked\"); \n};\n//指定事件处理程序\nbtn.attachEvent(\"onclick\",handler);\n//取消事件处理程序\nbtn.detachEvent(\"onclick\",handler);\n//取消参数必须与添加完全相同\n所以事件处理程序函数(同DOM2级事件中的分析一样)不要是匿名函数。\n\n```\n\n### 跨浏览器的事件处理程序\n用于处理指定和删除事件处理程序的操作：   \naddHandler()和removeHandler()  \n这两个方法属于一个名叫EventUtil的对象\n\n```\nvar handler = function(){\n            alert(\"Clicked\");\n};\n//指定事件处理程序\nEventUtil.addHandler(btn,\"click\",handler);\n//移除事件处理程序\nEventUtil.removeHandler(btn,\"click\",handler);\n\n```\n\n# 事件对象\n在触发DOM上的某个事件时，会产生一个事件对象event。这个对象中包含着所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息   \n所有浏览器都支持event对象，event对象会传入DOM0级，DOM2级，HTML指定的事件处理程序中，但支持的方式不同，所以也会涉及跨浏览器的部分\n\n### DOM中的事件对象\n> 相关属性方法详见书355\n\n#### 两个有点难区分的属性：\n- currentTarget：this对象始终是指向它的值，为其事件处理程序当前正在处理事件的那个元素\n- target：只包含事件的目标\n\n### IE中的事件对象\n> 相关属性方法详见书359\n\n### 跨浏览器的事件对象\n对前面介绍到的EventUtil对象加以增强  \n添加如下方法 ，写一个通用的事件侦听函数即可\n\n```\n听说面试会问到，这样写就可以了\nvar EventUtil={\ngetEvent:function(event){\n    return event||window.event;\n},\ngetTarget:function(event){\n    return event.target||event.srcElement;\n},\npreventDefault:function(){\n    if(event.preventDefault){\n        event.preventDefault();\n    }else{\n        event.returnValue=false;\n    }\n},\nstopPropagation:function(){\n    if(event.stopPropagation){\n        event.stopPropagation();\n    }else{\n        event.cancelBubble=true;\n    }\n},\naddHandler:function(element,type,handler){\n    if(element.addEventListener){\n        element.addEventListener(type,handler,false);\n    }else if(element.attachEvent){\n        element[\"e\"+type]=function(){\n            handler.call(element)\n        }\n        element.attachEvent(\"on\"+type,element[\"e\"+type]);\n    }else{\n            element[\"on\"+type]=handler;\n    }\n},\nremoveHandler:function(element,type,handler){\n    if(element.removeEventListener){\n        element.removeEventListener(type,handler,false);\n    }else if(element.detachEvent){\n        element.detachEvent(\"on\"+type,element[\"e\"+type]);\n        element[\"e\"+type]=null;   \n    }else{\n        element[\"on\"+type]=null;\n    }\n}\n \n};\n\n```\n\n# 事件类型\n\n> 好像没什么必要一一列出来了，详见书中362\n\n# 内存和性能\n### 事件委托\n- 利用冒泡的原理，把事件加到父级上，触发执行效果  \n- 通俗的讲，就是这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件  \n- 使用事件委托，只需在DOM树中尽量最高的层次上添加一个事件处理程序\n\n### 移除事件处理程序\n- 从文档中移除带有事件处理程序的元素时\n- 卸载页面时\n \n# 模拟事件\n\n### DOM中的事件模拟\n- 调用document.createEvent()方法创建event对象\n- 初始化对象，为对象添加相关信息\n- 调用dispatchEvent()方法触发事件\n\n### IE中的事件模拟\n- 调用document.createEventObject()方法创建event对象\n- 初始化对象，为对象添加相关信息\n- 调用fireEvent()方法触发事件","slug":"js高级程序设计/事件","published":1,"date":"2018-05-03T14:43:37.464Z","updated":"2018-05-03T14:57:43.623Z","layout":"post","photos":[],"link":"","_id":"cka6kin27002vqgu9xyz252fk","content":"<h1 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h1><ul>\n<li><h4 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h4>事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）</li>\n<li><h4 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h4>不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件<br>事件捕获用意在于在事件到达预定目标之前捕获它</li>\n<li><h4 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h4>（事件流描述的是从页面中接收事件的顺序）</li>\n</ul>\n<ol>\n<li>事件捕获阶段（从document开始）</li>\n<li>处于目标阶段</li>\n<li>事件冒泡阶段</li>\n</ol>\n<h1 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h1><h3 id=\"HTMl事件处理程序\"><a href=\"#HTMl事件处理程序\" class=\"headerlink\" title=\"HTMl事件处理程序\"></a>HTMl事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定</p>\n<ul>\n<li>特性的值</li>\n</ul>\n<p>可以是能够执行的js代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&apos;Clicked&apos;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>也可以调用在页面其他地方定义的脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;btn&quot; value=&quot;click me&quot; onclick=&quot;showMessage()&quot; /&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt; </span><br><span class=\"line\">　　function showMessage()&#123;</span><br><span class=\"line\">　　 alert(&quot;clicked&quot;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>扩展作用域</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function()&#123;</span><br><span class=\"line\">    with(document)&#123;</span><br><span class=\"line\">        eith(this)&#123;</span><br><span class=\"line\">            //元素属性值</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;        在这个函数内部，可以像访问局部变量一样访问document</span><br><span class=\"line\">         及该元素本身的成员</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM0级事件处理程序（主要）\"><a href=\"#DOM0级事件处理程序（主要）\" class=\"headerlink\" title=\"DOM0级事件处理程序（主要）\"></a>DOM0级事件处理程序（主要）</h3><p>通过JavaScript指定处理程序的传统方式，将一个函数赋值给一个事件处理程序属性。每个元素（包括document和window）都有自己的事件处理程序属性<br>以这种方式添加的事件处理程序会在事件流的<em>冒泡阶段</em>被处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var btn = document.getElementById(&quot;btn&quot;);</span><br><span class=\"line\">btn.onclick = function()&#123;</span><br><span class=\"line\">   alert(&quot;Clicked&quot;);       //指定事件处理程序</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">btn.onclick=function()&#123;</span><br><span class=\"line\">  alert(this.id);//btn     //其作用域为元素的作用域</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//想要取消事件处理程序的话，只需将事件处理程序属性设为null即可</span><br><span class=\"line\">btn.onclick = null;</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM2级事件处理程序\"><a href=\"#DOM2级事件处理程序\" class=\"headerlink\" title=\"DOM2级事件处理程序\"></a>DOM2级事件处理程序</h3><p>用于处理指定和删除事件处理程序的操作：<br>addEventListener()和removeEventListener()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指定事件处理程序 </span><br><span class=\"line\">btn.addEventListener(&quot;click&quot;,fucntion()&#123;</span><br><span class=\"line\">alert(&quot;clicked&quot;);&#125;,false);</span><br><span class=\"line\">//取消事件处理程序</span><br><span class=\"line\">btn.removeEventListener(&quot;click&quot;,function()&#123;</span><br><span class=\"line\">alert(&quot;clicked&quot;);&#125;,false);//无效</span><br><span class=\"line\">//指定和取消的参数必须完全相同才有效</span><br><span class=\"line\">//而匿名函数是两个不同的函数，所以无效</span><br></pre></td></tr></table></figure>\n<p>为了能够取消，最好函数采用函数表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handler = function()&#123;</span><br><span class=\"line\">   alert(&quot;clicked&quot;); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//添加事件处理程序</span><br><span class=\"line\">btn.addEventListener(&quot;click&quot;,handler,false);</span><br><span class=\"line\">//取消事件处理程序</span><br><span class=\"line\">btn.removeEventListener(&quot;click&quot;,handler,false);//有效</span><br></pre></td></tr></table></figure>\n<h3 id=\"IE事件处理程序\"><a href=\"#IE事件处理程序\" class=\"headerlink\" title=\"IE事件处理程序\"></a>IE事件处理程序</h3><p>用于处理指定和删除事件处理程序的操作：<br>attachEvent()和detachEvent() </p>\n<p>IE事件处理程序与DOM事件处理程序的最大区别：<br>DOM0/2级事件处理程序的作用域是元素作用域；<br>而IE事件处理程序是全局作用域，即<em>this等于widow</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handler = function()&#123;</span><br><span class=\"line\">   alert(&quot;clicked&quot;); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//指定事件处理程序</span><br><span class=\"line\">btn.attachEvent(&quot;onclick&quot;,handler);</span><br><span class=\"line\">//取消事件处理程序</span><br><span class=\"line\">btn.detachEvent(&quot;onclick&quot;,handler);</span><br><span class=\"line\">//取消参数必须与添加完全相同</span><br><span class=\"line\">所以事件处理程序函数(同DOM2级事件中的分析一样)不要是匿名函数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"跨浏览器的事件处理程序\"><a href=\"#跨浏览器的事件处理程序\" class=\"headerlink\" title=\"跨浏览器的事件处理程序\"></a>跨浏览器的事件处理程序</h3><p>用于处理指定和删除事件处理程序的操作：<br>addHandler()和removeHandler()<br>这两个方法属于一个名叫EventUtil的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handler = function()&#123;</span><br><span class=\"line\">            alert(&quot;Clicked&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//指定事件处理程序</span><br><span class=\"line\">EventUtil.addHandler(btn,&quot;click&quot;,handler);</span><br><span class=\"line\">//移除事件处理程序</span><br><span class=\"line\">EventUtil.removeHandler(btn,&quot;click&quot;,handler);</span><br></pre></td></tr></table></figure>\n<h1 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h1><p>在触发DOM上的某个事件时，会产生一个事件对象event。这个对象中包含着所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息<br>所有浏览器都支持event对象，event对象会传入DOM0级，DOM2级，HTML指定的事件处理程序中，但支持的方式不同，所以也会涉及跨浏览器的部分</p>\n<h3 id=\"DOM中的事件对象\"><a href=\"#DOM中的事件对象\" class=\"headerlink\" title=\"DOM中的事件对象\"></a>DOM中的事件对象</h3><blockquote>\n<p>相关属性方法详见书355</p>\n</blockquote>\n<h4 id=\"两个有点难区分的属性：\"><a href=\"#两个有点难区分的属性：\" class=\"headerlink\" title=\"两个有点难区分的属性：\"></a>两个有点难区分的属性：</h4><ul>\n<li>currentTarget：this对象始终是指向它的值，为其事件处理程序当前正在处理事件的那个元素</li>\n<li>target：只包含事件的目标</li>\n</ul>\n<h3 id=\"IE中的事件对象\"><a href=\"#IE中的事件对象\" class=\"headerlink\" title=\"IE中的事件对象\"></a>IE中的事件对象</h3><blockquote>\n<p>相关属性方法详见书359</p>\n</blockquote>\n<h3 id=\"跨浏览器的事件对象\"><a href=\"#跨浏览器的事件对象\" class=\"headerlink\" title=\"跨浏览器的事件对象\"></a>跨浏览器的事件对象</h3><p>对前面介绍到的EventUtil对象加以增强<br>添加如下方法 ，写一个通用的事件侦听函数即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">听说面试会问到，这样写就可以了</span><br><span class=\"line\">var EventUtil=&#123;</span><br><span class=\"line\">getEvent:function(event)&#123;</span><br><span class=\"line\">    return event||window.event;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">getTarget:function(event)&#123;</span><br><span class=\"line\">    return event.target||event.srcElement;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">preventDefault:function()&#123;</span><br><span class=\"line\">    if(event.preventDefault)&#123;</span><br><span class=\"line\">        event.preventDefault();</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.returnValue=false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">stopPropagation:function()&#123;</span><br><span class=\"line\">    if(event.stopPropagation)&#123;</span><br><span class=\"line\">        event.stopPropagation();</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.cancelBubble=true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">addHandler:function(element,type,handler)&#123;</span><br><span class=\"line\">    if(element.addEventListener)&#123;</span><br><span class=\"line\">        element.addEventListener(type,handler,false);</span><br><span class=\"line\">    &#125;else if(element.attachEvent)&#123;</span><br><span class=\"line\">        element[&quot;e&quot;+type]=function()&#123;</span><br><span class=\"line\">            handler.call(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        element.attachEvent(&quot;on&quot;+type,element[&quot;e&quot;+type]);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">            element[&quot;on&quot;+type]=handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">removeHandler:function(element,type,handler)&#123;</span><br><span class=\"line\">    if(element.removeEventListener)&#123;</span><br><span class=\"line\">        element.removeEventListener(type,handler,false);</span><br><span class=\"line\">    &#125;else if(element.detachEvent)&#123;</span><br><span class=\"line\">        element.detachEvent(&quot;on&quot;+type,element[&quot;e&quot;+type]);</span><br><span class=\"line\">        element[&quot;e&quot;+type]=null;   </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        element[&quot;on&quot;+type]=null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h1><blockquote>\n<p>好像没什么必要一一列出来了，详见书中362</p>\n</blockquote>\n<h1 id=\"内存和性能\"><a href=\"#内存和性能\" class=\"headerlink\" title=\"内存和性能\"></a>内存和性能</h1><h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><ul>\n<li>利用冒泡的原理，把事件加到父级上，触发执行效果  </li>\n<li>通俗的讲，就是这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件  </li>\n<li>使用事件委托，只需在DOM树中尽量最高的层次上添加一个事件处理程序</li>\n</ul>\n<h3 id=\"移除事件处理程序\"><a href=\"#移除事件处理程序\" class=\"headerlink\" title=\"移除事件处理程序\"></a>移除事件处理程序</h3><ul>\n<li>从文档中移除带有事件处理程序的元素时</li>\n<li>卸载页面时</li>\n</ul>\n<h1 id=\"模拟事件\"><a href=\"#模拟事件\" class=\"headerlink\" title=\"模拟事件\"></a>模拟事件</h1><h3 id=\"DOM中的事件模拟\"><a href=\"#DOM中的事件模拟\" class=\"headerlink\" title=\"DOM中的事件模拟\"></a>DOM中的事件模拟</h3><ul>\n<li>调用document.createEvent()方法创建event对象</li>\n<li>初始化对象，为对象添加相关信息</li>\n<li>调用dispatchEvent()方法触发事件</li>\n</ul>\n<h3 id=\"IE中的事件模拟\"><a href=\"#IE中的事件模拟\" class=\"headerlink\" title=\"IE中的事件模拟\"></a>IE中的事件模拟</h3><ul>\n<li>调用document.createEventObject()方法创建event对象</li>\n<li>初始化对象，为对象添加相关信息</li>\n<li>调用fireEvent()方法触发事件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h1><ul>\n<li><h4 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h4>事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）</li>\n<li><h4 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h4>不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件<br>事件捕获用意在于在事件到达预定目标之前捕获它</li>\n<li><h4 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h4>（事件流描述的是从页面中接收事件的顺序）</li>\n</ul>\n<ol>\n<li>事件捕获阶段（从document开始）</li>\n<li>处于目标阶段</li>\n<li>事件冒泡阶段</li>\n</ol>\n<h1 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h1><h3 id=\"HTMl事件处理程序\"><a href=\"#HTMl事件处理程序\" class=\"headerlink\" title=\"HTMl事件处理程序\"></a>HTMl事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定</p>\n<ul>\n<li>特性的值</li>\n</ul>\n<p>可以是能够执行的js代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&apos;Clicked&apos;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>也可以调用在页面其他地方定义的脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;btn&quot; value=&quot;click me&quot; onclick=&quot;showMessage()&quot; /&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt; </span><br><span class=\"line\">　　function showMessage()&#123;</span><br><span class=\"line\">　　 alert(&quot;clicked&quot;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>扩展作用域</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function()&#123;</span><br><span class=\"line\">    with(document)&#123;</span><br><span class=\"line\">        eith(this)&#123;</span><br><span class=\"line\">            //元素属性值</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;        在这个函数内部，可以像访问局部变量一样访问document</span><br><span class=\"line\">         及该元素本身的成员</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM0级事件处理程序（主要）\"><a href=\"#DOM0级事件处理程序（主要）\" class=\"headerlink\" title=\"DOM0级事件处理程序（主要）\"></a>DOM0级事件处理程序（主要）</h3><p>通过JavaScript指定处理程序的传统方式，将一个函数赋值给一个事件处理程序属性。每个元素（包括document和window）都有自己的事件处理程序属性<br>以这种方式添加的事件处理程序会在事件流的<em>冒泡阶段</em>被处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var btn = document.getElementById(&quot;btn&quot;);</span><br><span class=\"line\">btn.onclick = function()&#123;</span><br><span class=\"line\">   alert(&quot;Clicked&quot;);       //指定事件处理程序</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">btn.onclick=function()&#123;</span><br><span class=\"line\">  alert(this.id);//btn     //其作用域为元素的作用域</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//想要取消事件处理程序的话，只需将事件处理程序属性设为null即可</span><br><span class=\"line\">btn.onclick = null;</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM2级事件处理程序\"><a href=\"#DOM2级事件处理程序\" class=\"headerlink\" title=\"DOM2级事件处理程序\"></a>DOM2级事件处理程序</h3><p>用于处理指定和删除事件处理程序的操作：<br>addEventListener()和removeEventListener()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指定事件处理程序 </span><br><span class=\"line\">btn.addEventListener(&quot;click&quot;,fucntion()&#123;</span><br><span class=\"line\">alert(&quot;clicked&quot;);&#125;,false);</span><br><span class=\"line\">//取消事件处理程序</span><br><span class=\"line\">btn.removeEventListener(&quot;click&quot;,function()&#123;</span><br><span class=\"line\">alert(&quot;clicked&quot;);&#125;,false);//无效</span><br><span class=\"line\">//指定和取消的参数必须完全相同才有效</span><br><span class=\"line\">//而匿名函数是两个不同的函数，所以无效</span><br></pre></td></tr></table></figure>\n<p>为了能够取消，最好函数采用函数表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handler = function()&#123;</span><br><span class=\"line\">   alert(&quot;clicked&quot;); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//添加事件处理程序</span><br><span class=\"line\">btn.addEventListener(&quot;click&quot;,handler,false);</span><br><span class=\"line\">//取消事件处理程序</span><br><span class=\"line\">btn.removeEventListener(&quot;click&quot;,handler,false);//有效</span><br></pre></td></tr></table></figure>\n<h3 id=\"IE事件处理程序\"><a href=\"#IE事件处理程序\" class=\"headerlink\" title=\"IE事件处理程序\"></a>IE事件处理程序</h3><p>用于处理指定和删除事件处理程序的操作：<br>attachEvent()和detachEvent() </p>\n<p>IE事件处理程序与DOM事件处理程序的最大区别：<br>DOM0/2级事件处理程序的作用域是元素作用域；<br>而IE事件处理程序是全局作用域，即<em>this等于widow</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handler = function()&#123;</span><br><span class=\"line\">   alert(&quot;clicked&quot;); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//指定事件处理程序</span><br><span class=\"line\">btn.attachEvent(&quot;onclick&quot;,handler);</span><br><span class=\"line\">//取消事件处理程序</span><br><span class=\"line\">btn.detachEvent(&quot;onclick&quot;,handler);</span><br><span class=\"line\">//取消参数必须与添加完全相同</span><br><span class=\"line\">所以事件处理程序函数(同DOM2级事件中的分析一样)不要是匿名函数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"跨浏览器的事件处理程序\"><a href=\"#跨浏览器的事件处理程序\" class=\"headerlink\" title=\"跨浏览器的事件处理程序\"></a>跨浏览器的事件处理程序</h3><p>用于处理指定和删除事件处理程序的操作：<br>addHandler()和removeHandler()<br>这两个方法属于一个名叫EventUtil的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handler = function()&#123;</span><br><span class=\"line\">            alert(&quot;Clicked&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//指定事件处理程序</span><br><span class=\"line\">EventUtil.addHandler(btn,&quot;click&quot;,handler);</span><br><span class=\"line\">//移除事件处理程序</span><br><span class=\"line\">EventUtil.removeHandler(btn,&quot;click&quot;,handler);</span><br></pre></td></tr></table></figure>\n<h1 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h1><p>在触发DOM上的某个事件时，会产生一个事件对象event。这个对象中包含着所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息<br>所有浏览器都支持event对象，event对象会传入DOM0级，DOM2级，HTML指定的事件处理程序中，但支持的方式不同，所以也会涉及跨浏览器的部分</p>\n<h3 id=\"DOM中的事件对象\"><a href=\"#DOM中的事件对象\" class=\"headerlink\" title=\"DOM中的事件对象\"></a>DOM中的事件对象</h3><blockquote>\n<p>相关属性方法详见书355</p>\n</blockquote>\n<h4 id=\"两个有点难区分的属性：\"><a href=\"#两个有点难区分的属性：\" class=\"headerlink\" title=\"两个有点难区分的属性：\"></a>两个有点难区分的属性：</h4><ul>\n<li>currentTarget：this对象始终是指向它的值，为其事件处理程序当前正在处理事件的那个元素</li>\n<li>target：只包含事件的目标</li>\n</ul>\n<h3 id=\"IE中的事件对象\"><a href=\"#IE中的事件对象\" class=\"headerlink\" title=\"IE中的事件对象\"></a>IE中的事件对象</h3><blockquote>\n<p>相关属性方法详见书359</p>\n</blockquote>\n<h3 id=\"跨浏览器的事件对象\"><a href=\"#跨浏览器的事件对象\" class=\"headerlink\" title=\"跨浏览器的事件对象\"></a>跨浏览器的事件对象</h3><p>对前面介绍到的EventUtil对象加以增强<br>添加如下方法 ，写一个通用的事件侦听函数即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">听说面试会问到，这样写就可以了</span><br><span class=\"line\">var EventUtil=&#123;</span><br><span class=\"line\">getEvent:function(event)&#123;</span><br><span class=\"line\">    return event||window.event;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">getTarget:function(event)&#123;</span><br><span class=\"line\">    return event.target||event.srcElement;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">preventDefault:function()&#123;</span><br><span class=\"line\">    if(event.preventDefault)&#123;</span><br><span class=\"line\">        event.preventDefault();</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.returnValue=false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">stopPropagation:function()&#123;</span><br><span class=\"line\">    if(event.stopPropagation)&#123;</span><br><span class=\"line\">        event.stopPropagation();</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.cancelBubble=true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">addHandler:function(element,type,handler)&#123;</span><br><span class=\"line\">    if(element.addEventListener)&#123;</span><br><span class=\"line\">        element.addEventListener(type,handler,false);</span><br><span class=\"line\">    &#125;else if(element.attachEvent)&#123;</span><br><span class=\"line\">        element[&quot;e&quot;+type]=function()&#123;</span><br><span class=\"line\">            handler.call(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        element.attachEvent(&quot;on&quot;+type,element[&quot;e&quot;+type]);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">            element[&quot;on&quot;+type]=handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">removeHandler:function(element,type,handler)&#123;</span><br><span class=\"line\">    if(element.removeEventListener)&#123;</span><br><span class=\"line\">        element.removeEventListener(type,handler,false);</span><br><span class=\"line\">    &#125;else if(element.detachEvent)&#123;</span><br><span class=\"line\">        element.detachEvent(&quot;on&quot;+type,element[&quot;e&quot;+type]);</span><br><span class=\"line\">        element[&quot;e&quot;+type]=null;   </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        element[&quot;on&quot;+type]=null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h1><blockquote>\n<p>好像没什么必要一一列出来了，详见书中362</p>\n</blockquote>\n<h1 id=\"内存和性能\"><a href=\"#内存和性能\" class=\"headerlink\" title=\"内存和性能\"></a>内存和性能</h1><h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><ul>\n<li>利用冒泡的原理，把事件加到父级上，触发执行效果  </li>\n<li>通俗的讲，就是这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件  </li>\n<li>使用事件委托，只需在DOM树中尽量最高的层次上添加一个事件处理程序</li>\n</ul>\n<h3 id=\"移除事件处理程序\"><a href=\"#移除事件处理程序\" class=\"headerlink\" title=\"移除事件处理程序\"></a>移除事件处理程序</h3><ul>\n<li>从文档中移除带有事件处理程序的元素时</li>\n<li>卸载页面时</li>\n</ul>\n<h1 id=\"模拟事件\"><a href=\"#模拟事件\" class=\"headerlink\" title=\"模拟事件\"></a>模拟事件</h1><h3 id=\"DOM中的事件模拟\"><a href=\"#DOM中的事件模拟\" class=\"headerlink\" title=\"DOM中的事件模拟\"></a>DOM中的事件模拟</h3><ul>\n<li>调用document.createEvent()方法创建event对象</li>\n<li>初始化对象，为对象添加相关信息</li>\n<li>调用dispatchEvent()方法触发事件</li>\n</ul>\n<h3 id=\"IE中的事件模拟\"><a href=\"#IE中的事件模拟\" class=\"headerlink\" title=\"IE中的事件模拟\"></a>IE中的事件模拟</h3><ul>\n<li>调用document.createEventObject()方法创建event对象</li>\n<li>初始化对象，为对象添加相关信息</li>\n<li>调用fireEvent()方法触发事件</li>\n</ul>\n"},{"title":"引用类型","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n# 概述\n在学习引用类型之前，先弄清楚一些概念性的问题可能会比较好。\n接下来我就以已经学习过的类型来简单说明一下几个概念之间的关系：  \n首先，JavaScript包含数据类型和引用类型\n\n## 数据类型\n- 复杂数据类型：Object\n- 简单数据类型：Boolean、Number、String、Undefined、Null\n\n```\n可用typeof运算符检测给定变量的数据类型\n如：alert(typeof 95);//\"number\"\n\n```\n## 引用类型\n这是一个最大的概念，也称为本地对象或者类\n- 内置对象：Global、Math\n- 基本包装类型（特殊的引用类型）：Boolean、Number、String\n\n与其他引用类型相似：具有与各自的基本类型相应的特殊行为。  \n不同：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁。当然，可以使用new操作符显示创建对象，虽说绝对必要的情况才这样，但我觉得好像大多是这样做的（我的错觉？）\n- 其他：Object、Array、Date、RegExp、Function\n\n---\n\n每一个引用类型都有相应的属性和方法，其中又分为静态和实例      \n- 静态属性、方法：无需创建对象实例，可直接通过引用类型调用（内置对象中的都为静态属性和方法）\n- 实例属性、方法：每个对象实例都具有的（其他引用类型中常用的方法均为实例方法）\n\n---\n\n```\n由于无论引用的是什么类型的对象，typeof运算符都返回\"object\"\n可用instanceof运算符识别正在处理的对象的具体类型\n如：alert(95 instanceof Number);//true\n```\n## 数据类型和引用类型的不同\n在内存中的存储方式不同\n- 原始数据类型在内存中是栈存储。是自动分配的内存，由系统自动释放。\n- 引用类型在内存中是堆存储。是动态分配的内存，大小不定也不会自动释放。\n\n---\n# 引用类型\n## 内置对象 （不必实例化）\n\n- ### Global对象\n\n####  用法\n\n```\nwindow.属性(方法)/属性(方法)\n\n```\n\n#### 小结\n\n1、这是最特别的一个对象，不管从什么角度看，它都是不存在的  \n2、不属于任何其他对象的属性和方法，最终都是它的属性和方法\n3、在全局作用域中定义的属性和函数，都是Global对象的属性  \n4、Web浏览器将这个全局对象作为window对象的一部分加以实现，因此，在全局作用域中声明的所有变量和函数，都成为window对象的属性\n\n> 相关属性与方法详见书中131\n\n\n- ### Math对象\n \n#### 用法\n\n```\nMath.属性(方法)\n\n```\n\n\n为保存数学公式和信息提供了一个公共位置\n> 相关属性与方法详见书中134\n\n\n## 基本包装类型（使用new操作符）\n\n- ### Boolean类型\n\n#### 用法\n调用Boolean构造函数并传入true或false值\n\n```\nvar booleanObject=new Boolean(true);\n\n```\n\n> 相关属性与方法详见书中120\n\n- ### Number类型\n\n#### 用法\n调用Number构造函数时向其传递相应的数值\n\n```\nvar numberObject=new Number(10);\n\n```\n\n\n> 相关属性与方法详见书中120\n\n- ### String类型\n\n#### 用法\n\n```\nvar stringObject=new String(\"hello\");\n\n```\n\n\n> 相关属性与方法详见书中122\n\n\n ## 其他引用类型（使用new操作符）\n \n- ### Object类型\n#### 用法   \n1、使用Object构造函数\n\n```\nvar person=new Object();\nperson.name=\"greg\";\nperson.age=27;\n\n```\n2、使用字面量表示法\n\n```\nvar person={\n    name:\"greg\",\n    age:27\n};\n\n```\n> 相关属性与方法详见书中83\n\n- ### Array类型\n#### 用法\n1、使用Array构造函数\n\n```\n若知道数组要保存的项目数量，可传参，为length属性的值\nvar colors=new Array();\n可省略new操作符\nvar colors= Array();\n```\n2、使用数组字面量表示法\n\n```\nvar colors=[\"red\",\"yellow\"];\nvar names=[];//空数组\n```\n> 相关属性与方法详见书中86\n\n- ### Date类型\n#### 用法\n\n```\n不传参，即获得当前日期和时间\nvar now=new Date();\n传入表示某日期的毫秒数，返回该日期和时间\n其中有相应的方法可获取某日期的毫秒数Date.parse()和Date.UTC()\nvar someDate=new Date(Date.parse(\"July 14,2017\"));\n等价于var someDate=new Date(\"July 14,2017\");\nvar someDate=new Date(Date.UTC(2017,6,14));\n等价于var someDate=new Date(2017,6,14);//UTC时间\n\n```\n> 相关属性与方法详见书中98\n\n- ### RegExp类型\n#### 用法\n1、使用RegExp构造函数\n\n```\nvar pattern=new RegExp(\"pattern\",\"gim\");\n\n```\n2、使用字面量表达式（常用）\n\n```\nvar pattern =/pattern/gim;\ng:全局模式\ni:不区分大小写\nm:多行模式\n\n```\n> 相关元字符、实例属性、实例方法、静态属性详见书中103\n\n- ### Function类型\n#### 用法\n1、使用函数声明语法定义（常用）\n\n```\n解析器会率先读取函数声明，并使其在执行任何代码前可用\nfunction sum(num1,num2){\n    return num1+num2;\n}\n\n```\n2、使用函数表达式定义\n\n```\n必须等解析器执行到函数表达式所在的代码行，才会真正被解释执行\nvar sum=function(num1,num2){\n    return num1+num2;\n};\n无需函数名，通过变量即可引用函数\nPS：函数末尾有一个分号，同声明其他变量一样\n\n```\n3、使用Function构造函数（不推荐使用）\n\n```\nvar sum=new Function(\"num1\",\"num2\",\"return num1+num2\");\n\n```\n#### 小结\n1. 没有重载：当声明了两个同名函数时，后面的将覆盖前面的函数\n2. 作为值的函数：像传参一样把函数传递，即访问函数的指针，而不是执行函数  \n3. 内部属性：（有点绕有点难懂，我觉得很少用）\narguments.callee：指针，指向拥有 arguments对象的函数；arguments.callee.caller：指向（调用了（拥有arguments对象）的函数）的函数\n\n> 相关属性与方法详见书中110\n\n\n\n\n\n","source":"_posts/js高级程序设计/引用类型.md","raw":"---\ntitle: 引用类型\nDate: 2020-03-17\ntags: [红宝书]\ncategories: 红宝书\ncomments: true\n---\n\n# 概述\n在学习引用类型之前，先弄清楚一些概念性的问题可能会比较好。\n接下来我就以已经学习过的类型来简单说明一下几个概念之间的关系：  \n首先，JavaScript包含数据类型和引用类型\n\n## 数据类型\n- 复杂数据类型：Object\n- 简单数据类型：Boolean、Number、String、Undefined、Null\n\n```\n可用typeof运算符检测给定变量的数据类型\n如：alert(typeof 95);//\"number\"\n\n```\n## 引用类型\n这是一个最大的概念，也称为本地对象或者类\n- 内置对象：Global、Math\n- 基本包装类型（特殊的引用类型）：Boolean、Number、String\n\n与其他引用类型相似：具有与各自的基本类型相应的特殊行为。  \n不同：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁。当然，可以使用new操作符显示创建对象，虽说绝对必要的情况才这样，但我觉得好像大多是这样做的（我的错觉？）\n- 其他：Object、Array、Date、RegExp、Function\n\n---\n\n每一个引用类型都有相应的属性和方法，其中又分为静态和实例      \n- 静态属性、方法：无需创建对象实例，可直接通过引用类型调用（内置对象中的都为静态属性和方法）\n- 实例属性、方法：每个对象实例都具有的（其他引用类型中常用的方法均为实例方法）\n\n---\n\n```\n由于无论引用的是什么类型的对象，typeof运算符都返回\"object\"\n可用instanceof运算符识别正在处理的对象的具体类型\n如：alert(95 instanceof Number);//true\n```\n## 数据类型和引用类型的不同\n在内存中的存储方式不同\n- 原始数据类型在内存中是栈存储。是自动分配的内存，由系统自动释放。\n- 引用类型在内存中是堆存储。是动态分配的内存，大小不定也不会自动释放。\n\n---\n# 引用类型\n## 内置对象 （不必实例化）\n\n- ### Global对象\n\n####  用法\n\n```\nwindow.属性(方法)/属性(方法)\n\n```\n\n#### 小结\n\n1、这是最特别的一个对象，不管从什么角度看，它都是不存在的  \n2、不属于任何其他对象的属性和方法，最终都是它的属性和方法\n3、在全局作用域中定义的属性和函数，都是Global对象的属性  \n4、Web浏览器将这个全局对象作为window对象的一部分加以实现，因此，在全局作用域中声明的所有变量和函数，都成为window对象的属性\n\n> 相关属性与方法详见书中131\n\n\n- ### Math对象\n \n#### 用法\n\n```\nMath.属性(方法)\n\n```\n\n\n为保存数学公式和信息提供了一个公共位置\n> 相关属性与方法详见书中134\n\n\n## 基本包装类型（使用new操作符）\n\n- ### Boolean类型\n\n#### 用法\n调用Boolean构造函数并传入true或false值\n\n```\nvar booleanObject=new Boolean(true);\n\n```\n\n> 相关属性与方法详见书中120\n\n- ### Number类型\n\n#### 用法\n调用Number构造函数时向其传递相应的数值\n\n```\nvar numberObject=new Number(10);\n\n```\n\n\n> 相关属性与方法详见书中120\n\n- ### String类型\n\n#### 用法\n\n```\nvar stringObject=new String(\"hello\");\n\n```\n\n\n> 相关属性与方法详见书中122\n\n\n ## 其他引用类型（使用new操作符）\n \n- ### Object类型\n#### 用法   \n1、使用Object构造函数\n\n```\nvar person=new Object();\nperson.name=\"greg\";\nperson.age=27;\n\n```\n2、使用字面量表示法\n\n```\nvar person={\n    name:\"greg\",\n    age:27\n};\n\n```\n> 相关属性与方法详见书中83\n\n- ### Array类型\n#### 用法\n1、使用Array构造函数\n\n```\n若知道数组要保存的项目数量，可传参，为length属性的值\nvar colors=new Array();\n可省略new操作符\nvar colors= Array();\n```\n2、使用数组字面量表示法\n\n```\nvar colors=[\"red\",\"yellow\"];\nvar names=[];//空数组\n```\n> 相关属性与方法详见书中86\n\n- ### Date类型\n#### 用法\n\n```\n不传参，即获得当前日期和时间\nvar now=new Date();\n传入表示某日期的毫秒数，返回该日期和时间\n其中有相应的方法可获取某日期的毫秒数Date.parse()和Date.UTC()\nvar someDate=new Date(Date.parse(\"July 14,2017\"));\n等价于var someDate=new Date(\"July 14,2017\");\nvar someDate=new Date(Date.UTC(2017,6,14));\n等价于var someDate=new Date(2017,6,14);//UTC时间\n\n```\n> 相关属性与方法详见书中98\n\n- ### RegExp类型\n#### 用法\n1、使用RegExp构造函数\n\n```\nvar pattern=new RegExp(\"pattern\",\"gim\");\n\n```\n2、使用字面量表达式（常用）\n\n```\nvar pattern =/pattern/gim;\ng:全局模式\ni:不区分大小写\nm:多行模式\n\n```\n> 相关元字符、实例属性、实例方法、静态属性详见书中103\n\n- ### Function类型\n#### 用法\n1、使用函数声明语法定义（常用）\n\n```\n解析器会率先读取函数声明，并使其在执行任何代码前可用\nfunction sum(num1,num2){\n    return num1+num2;\n}\n\n```\n2、使用函数表达式定义\n\n```\n必须等解析器执行到函数表达式所在的代码行，才会真正被解释执行\nvar sum=function(num1,num2){\n    return num1+num2;\n};\n无需函数名，通过变量即可引用函数\nPS：函数末尾有一个分号，同声明其他变量一样\n\n```\n3、使用Function构造函数（不推荐使用）\n\n```\nvar sum=new Function(\"num1\",\"num2\",\"return num1+num2\");\n\n```\n#### 小结\n1. 没有重载：当声明了两个同名函数时，后面的将覆盖前面的函数\n2. 作为值的函数：像传参一样把函数传递，即访问函数的指针，而不是执行函数  \n3. 内部属性：（有点绕有点难懂，我觉得很少用）\narguments.callee：指针，指向拥有 arguments对象的函数；arguments.callee.caller：指向（调用了（拥有arguments对象）的函数）的函数\n\n> 相关属性与方法详见书中110\n\n\n\n\n\n","slug":"js高级程序设计/引用类型","published":1,"date":"2020-03-17T08:27:57.033Z","updated":"2020-03-17T08:28:58.215Z","layout":"post","photos":[],"link":"","_id":"cka6kin2h002yqgu9uv15gu9f","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在学习引用类型之前，先弄清楚一些概念性的问题可能会比较好。<br>接下来我就以已经学习过的类型来简单说明一下几个概念之间的关系：<br>首先，JavaScript包含数据类型和引用类型</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ul>\n<li>复杂数据类型：Object</li>\n<li>简单数据类型：Boolean、Number、String、Undefined、Null</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可用typeof运算符检测给定变量的数据类型</span><br><span class=\"line\">如：alert(typeof 95);//&quot;number&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>这是一个最大的概念，也称为本地对象或者类</p>\n<ul>\n<li>内置对象：Global、Math</li>\n<li>基本包装类型（特殊的引用类型）：Boolean、Number、String</li>\n</ul>\n<p>与其他引用类型相似：具有与各自的基本类型相应的特殊行为。<br>不同：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁。当然，可以使用new操作符显示创建对象，虽说绝对必要的情况才这样，但我觉得好像大多是这样做的（我的错觉？）</p>\n<ul>\n<li>其他：Object、Array、Date、RegExp、Function</li>\n</ul>\n<hr>\n<p>每一个引用类型都有相应的属性和方法，其中又分为静态和实例      </p>\n<ul>\n<li>静态属性、方法：无需创建对象实例，可直接通过引用类型调用（内置对象中的都为静态属性和方法）</li>\n<li>实例属性、方法：每个对象实例都具有的（其他引用类型中常用的方法均为实例方法）</li>\n</ul>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于无论引用的是什么类型的对象，typeof运算符都返回&quot;object&quot;</span><br><span class=\"line\">可用instanceof运算符识别正在处理的对象的具体类型</span><br><span class=\"line\">如：alert(95 instanceof Number);//true</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据类型和引用类型的不同\"><a href=\"#数据类型和引用类型的不同\" class=\"headerlink\" title=\"数据类型和引用类型的不同\"></a>数据类型和引用类型的不同</h2><p>在内存中的存储方式不同</p>\n<ul>\n<li>原始数据类型在内存中是栈存储。是自动分配的内存，由系统自动释放。</li>\n<li>引用类型在内存中是堆存储。是动态分配的内存，大小不定也不会自动释放。</li>\n</ul>\n<hr>\n<h1 id=\"引用类型-1\"><a href=\"#引用类型-1\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h1><h2 id=\"内置对象-（不必实例化）\"><a href=\"#内置对象-（不必实例化）\" class=\"headerlink\" title=\"内置对象 （不必实例化）\"></a>内置对象 （不必实例化）</h2><ul>\n<li><h3 id=\"Global对象\"><a href=\"#Global对象\" class=\"headerlink\" title=\"Global对象\"></a>Global对象</h3></li>\n</ul>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.属性(方法)/属性(方法)</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>1、这是最特别的一个对象，不管从什么角度看，它都是不存在的<br>2、不属于任何其他对象的属性和方法，最终都是它的属性和方法<br>3、在全局作用域中定义的属性和函数，都是Global对象的属性<br>4、Web浏览器将这个全局对象作为window对象的一部分加以实现，因此，在全局作用域中声明的所有变量和函数，都成为window对象的属性</p>\n<blockquote>\n<p>相关属性与方法详见书中131</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h3></li>\n</ul>\n<h4 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a>用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.属性(方法)</span><br></pre></td></tr></table></figure>\n<p>为保存数学公式和信息提供了一个公共位置</p>\n<blockquote>\n<p>相关属性与方法详见书中134</p>\n</blockquote>\n<h2 id=\"基本包装类型（使用new操作符）\"><a href=\"#基本包装类型（使用new操作符）\" class=\"headerlink\" title=\"基本包装类型（使用new操作符）\"></a>基本包装类型（使用new操作符）</h2><ul>\n<li><h3 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h3></li>\n</ul>\n<h4 id=\"用法-2\"><a href=\"#用法-2\" class=\"headerlink\" title=\"用法\"></a>用法</h4><p>调用Boolean构造函数并传入true或false值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var booleanObject=new Boolean(true);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中120</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h3></li>\n</ul>\n<h4 id=\"用法-3\"><a href=\"#用法-3\" class=\"headerlink\" title=\"用法\"></a>用法</h4><p>调用Number构造函数时向其传递相应的数值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numberObject=new Number(10);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中120</p>\n</blockquote>\n<ul>\n<li><h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3></li>\n</ul>\n<h4 id=\"用法-4\"><a href=\"#用法-4\" class=\"headerlink\" title=\"用法\"></a>用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringObject=new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中122</p>\n</blockquote>\n<h2 id=\"其他引用类型（使用new操作符）\"><a href=\"#其他引用类型（使用new操作符）\" class=\"headerlink\" title=\"其他引用类型（使用new操作符）\"></a>其他引用类型（使用new操作符）</h2><ul>\n<li><h3 id=\"Object类型\"><a href=\"#Object类型\" class=\"headerlink\" title=\"Object类型\"></a>Object类型</h3><h4 id=\"用法-5\"><a href=\"#用法-5\" class=\"headerlink\" title=\"用法\"></a>用法</h4>1、使用Object构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person=new Object();</span><br><span class=\"line\">person.name=&quot;greg&quot;;</span><br><span class=\"line\">person.age=27;</span><br></pre></td></tr></table></figure>\n<p>2、使用字面量表示法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person=&#123;</span><br><span class=\"line\">    name:&quot;greg&quot;,</span><br><span class=\"line\">    age:27</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中83</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Array类型\"><a href=\"#Array类型\" class=\"headerlink\" title=\"Array类型\"></a>Array类型</h3><h4 id=\"用法-6\"><a href=\"#用法-6\" class=\"headerlink\" title=\"用法\"></a>用法</h4>1、使用Array构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若知道数组要保存的项目数量，可传参，为length属性的值</span><br><span class=\"line\">var colors=new Array();</span><br><span class=\"line\">可省略new操作符</span><br><span class=\"line\">var colors= Array();</span><br></pre></td></tr></table></figure>\n<p>2、使用数组字面量表示法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var colors=[&quot;red&quot;,&quot;yellow&quot;];</span><br><span class=\"line\">var names=[];//空数组</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中86</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Date类型\"><a href=\"#Date类型\" class=\"headerlink\" title=\"Date类型\"></a>Date类型</h3><h4 id=\"用法-7\"><a href=\"#用法-7\" class=\"headerlink\" title=\"用法\"></a>用法</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不传参，即获得当前日期和时间</span><br><span class=\"line\">var now=new Date();</span><br><span class=\"line\">传入表示某日期的毫秒数，返回该日期和时间</span><br><span class=\"line\">其中有相应的方法可获取某日期的毫秒数Date.parse()和Date.UTC()</span><br><span class=\"line\">var someDate=new Date(Date.parse(&quot;July 14,2017&quot;));</span><br><span class=\"line\">等价于var someDate=new Date(&quot;July 14,2017&quot;);</span><br><span class=\"line\">var someDate=new Date(Date.UTC(2017,6,14));</span><br><span class=\"line\">等价于var someDate=new Date(2017,6,14);//UTC时间</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中98</p>\n</blockquote>\n<ul>\n<li><h3 id=\"RegExp类型\"><a href=\"#RegExp类型\" class=\"headerlink\" title=\"RegExp类型\"></a>RegExp类型</h3><h4 id=\"用法-8\"><a href=\"#用法-8\" class=\"headerlink\" title=\"用法\"></a>用法</h4>1、使用RegExp构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern=new RegExp(&quot;pattern&quot;,&quot;gim&quot;);</span><br></pre></td></tr></table></figure>\n<p>2、使用字面量表达式（常用）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern =/pattern/gim;</span><br><span class=\"line\">g:全局模式</span><br><span class=\"line\">i:不区分大小写</span><br><span class=\"line\">m:多行模式</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关元字符、实例属性、实例方法、静态属性详见书中103</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Function类型\"><a href=\"#Function类型\" class=\"headerlink\" title=\"Function类型\"></a>Function类型</h3><h4 id=\"用法-9\"><a href=\"#用法-9\" class=\"headerlink\" title=\"用法\"></a>用法</h4>1、使用函数声明语法定义（常用）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解析器会率先读取函数声明，并使其在执行任何代码前可用</span><br><span class=\"line\">function sum(num1,num2)&#123;</span><br><span class=\"line\">    return num1+num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、使用函数表达式定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">必须等解析器执行到函数表达式所在的代码行，才会真正被解释执行</span><br><span class=\"line\">var sum=function(num1,num2)&#123;</span><br><span class=\"line\">    return num1+num2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">无需函数名，通过变量即可引用函数</span><br><span class=\"line\">PS：函数末尾有一个分号，同声明其他变量一样</span><br></pre></td></tr></table></figure>\n<p>3、使用Function构造函数（不推荐使用）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ol>\n<li>没有重载：当声明了两个同名函数时，后面的将覆盖前面的函数</li>\n<li>作为值的函数：像传参一样把函数传递，即访问函数的指针，而不是执行函数  </li>\n<li>内部属性：（有点绕有点难懂，我觉得很少用）<br>arguments.callee：指针，指向拥有 arguments对象的函数；arguments.callee.caller：指向（调用了（拥有arguments对象）的函数）的函数</li>\n</ol>\n<blockquote>\n<p>相关属性与方法详见书中110</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在学习引用类型之前，先弄清楚一些概念性的问题可能会比较好。<br>接下来我就以已经学习过的类型来简单说明一下几个概念之间的关系：<br>首先，JavaScript包含数据类型和引用类型</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ul>\n<li>复杂数据类型：Object</li>\n<li>简单数据类型：Boolean、Number、String、Undefined、Null</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可用typeof运算符检测给定变量的数据类型</span><br><span class=\"line\">如：alert(typeof 95);//&quot;number&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>这是一个最大的概念，也称为本地对象或者类</p>\n<ul>\n<li>内置对象：Global、Math</li>\n<li>基本包装类型（特殊的引用类型）：Boolean、Number、String</li>\n</ul>\n<p>与其他引用类型相似：具有与各自的基本类型相应的特殊行为。<br>不同：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁。当然，可以使用new操作符显示创建对象，虽说绝对必要的情况才这样，但我觉得好像大多是这样做的（我的错觉？）</p>\n<ul>\n<li>其他：Object、Array、Date、RegExp、Function</li>\n</ul>\n<hr>\n<p>每一个引用类型都有相应的属性和方法，其中又分为静态和实例      </p>\n<ul>\n<li>静态属性、方法：无需创建对象实例，可直接通过引用类型调用（内置对象中的都为静态属性和方法）</li>\n<li>实例属性、方法：每个对象实例都具有的（其他引用类型中常用的方法均为实例方法）</li>\n</ul>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于无论引用的是什么类型的对象，typeof运算符都返回&quot;object&quot;</span><br><span class=\"line\">可用instanceof运算符识别正在处理的对象的具体类型</span><br><span class=\"line\">如：alert(95 instanceof Number);//true</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据类型和引用类型的不同\"><a href=\"#数据类型和引用类型的不同\" class=\"headerlink\" title=\"数据类型和引用类型的不同\"></a>数据类型和引用类型的不同</h2><p>在内存中的存储方式不同</p>\n<ul>\n<li>原始数据类型在内存中是栈存储。是自动分配的内存，由系统自动释放。</li>\n<li>引用类型在内存中是堆存储。是动态分配的内存，大小不定也不会自动释放。</li>\n</ul>\n<hr>\n<h1 id=\"引用类型-1\"><a href=\"#引用类型-1\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h1><h2 id=\"内置对象-（不必实例化）\"><a href=\"#内置对象-（不必实例化）\" class=\"headerlink\" title=\"内置对象 （不必实例化）\"></a>内置对象 （不必实例化）</h2><ul>\n<li><h3 id=\"Global对象\"><a href=\"#Global对象\" class=\"headerlink\" title=\"Global对象\"></a>Global对象</h3></li>\n</ul>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.属性(方法)/属性(方法)</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>1、这是最特别的一个对象，不管从什么角度看，它都是不存在的<br>2、不属于任何其他对象的属性和方法，最终都是它的属性和方法<br>3、在全局作用域中定义的属性和函数，都是Global对象的属性<br>4、Web浏览器将这个全局对象作为window对象的一部分加以实现，因此，在全局作用域中声明的所有变量和函数，都成为window对象的属性</p>\n<blockquote>\n<p>相关属性与方法详见书中131</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h3></li>\n</ul>\n<h4 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a>用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.属性(方法)</span><br></pre></td></tr></table></figure>\n<p>为保存数学公式和信息提供了一个公共位置</p>\n<blockquote>\n<p>相关属性与方法详见书中134</p>\n</blockquote>\n<h2 id=\"基本包装类型（使用new操作符）\"><a href=\"#基本包装类型（使用new操作符）\" class=\"headerlink\" title=\"基本包装类型（使用new操作符）\"></a>基本包装类型（使用new操作符）</h2><ul>\n<li><h3 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h3></li>\n</ul>\n<h4 id=\"用法-2\"><a href=\"#用法-2\" class=\"headerlink\" title=\"用法\"></a>用法</h4><p>调用Boolean构造函数并传入true或false值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var booleanObject=new Boolean(true);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中120</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h3></li>\n</ul>\n<h4 id=\"用法-3\"><a href=\"#用法-3\" class=\"headerlink\" title=\"用法\"></a>用法</h4><p>调用Number构造函数时向其传递相应的数值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numberObject=new Number(10);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中120</p>\n</blockquote>\n<ul>\n<li><h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3></li>\n</ul>\n<h4 id=\"用法-4\"><a href=\"#用法-4\" class=\"headerlink\" title=\"用法\"></a>用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringObject=new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中122</p>\n</blockquote>\n<h2 id=\"其他引用类型（使用new操作符）\"><a href=\"#其他引用类型（使用new操作符）\" class=\"headerlink\" title=\"其他引用类型（使用new操作符）\"></a>其他引用类型（使用new操作符）</h2><ul>\n<li><h3 id=\"Object类型\"><a href=\"#Object类型\" class=\"headerlink\" title=\"Object类型\"></a>Object类型</h3><h4 id=\"用法-5\"><a href=\"#用法-5\" class=\"headerlink\" title=\"用法\"></a>用法</h4>1、使用Object构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person=new Object();</span><br><span class=\"line\">person.name=&quot;greg&quot;;</span><br><span class=\"line\">person.age=27;</span><br></pre></td></tr></table></figure>\n<p>2、使用字面量表示法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person=&#123;</span><br><span class=\"line\">    name:&quot;greg&quot;,</span><br><span class=\"line\">    age:27</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中83</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Array类型\"><a href=\"#Array类型\" class=\"headerlink\" title=\"Array类型\"></a>Array类型</h3><h4 id=\"用法-6\"><a href=\"#用法-6\" class=\"headerlink\" title=\"用法\"></a>用法</h4>1、使用Array构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若知道数组要保存的项目数量，可传参，为length属性的值</span><br><span class=\"line\">var colors=new Array();</span><br><span class=\"line\">可省略new操作符</span><br><span class=\"line\">var colors= Array();</span><br></pre></td></tr></table></figure>\n<p>2、使用数组字面量表示法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var colors=[&quot;red&quot;,&quot;yellow&quot;];</span><br><span class=\"line\">var names=[];//空数组</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中86</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Date类型\"><a href=\"#Date类型\" class=\"headerlink\" title=\"Date类型\"></a>Date类型</h3><h4 id=\"用法-7\"><a href=\"#用法-7\" class=\"headerlink\" title=\"用法\"></a>用法</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不传参，即获得当前日期和时间</span><br><span class=\"line\">var now=new Date();</span><br><span class=\"line\">传入表示某日期的毫秒数，返回该日期和时间</span><br><span class=\"line\">其中有相应的方法可获取某日期的毫秒数Date.parse()和Date.UTC()</span><br><span class=\"line\">var someDate=new Date(Date.parse(&quot;July 14,2017&quot;));</span><br><span class=\"line\">等价于var someDate=new Date(&quot;July 14,2017&quot;);</span><br><span class=\"line\">var someDate=new Date(Date.UTC(2017,6,14));</span><br><span class=\"line\">等价于var someDate=new Date(2017,6,14);//UTC时间</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关属性与方法详见书中98</p>\n</blockquote>\n<ul>\n<li><h3 id=\"RegExp类型\"><a href=\"#RegExp类型\" class=\"headerlink\" title=\"RegExp类型\"></a>RegExp类型</h3><h4 id=\"用法-8\"><a href=\"#用法-8\" class=\"headerlink\" title=\"用法\"></a>用法</h4>1、使用RegExp构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern=new RegExp(&quot;pattern&quot;,&quot;gim&quot;);</span><br></pre></td></tr></table></figure>\n<p>2、使用字面量表达式（常用）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern =/pattern/gim;</span><br><span class=\"line\">g:全局模式</span><br><span class=\"line\">i:不区分大小写</span><br><span class=\"line\">m:多行模式</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关元字符、实例属性、实例方法、静态属性详见书中103</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Function类型\"><a href=\"#Function类型\" class=\"headerlink\" title=\"Function类型\"></a>Function类型</h3><h4 id=\"用法-9\"><a href=\"#用法-9\" class=\"headerlink\" title=\"用法\"></a>用法</h4>1、使用函数声明语法定义（常用）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解析器会率先读取函数声明，并使其在执行任何代码前可用</span><br><span class=\"line\">function sum(num1,num2)&#123;</span><br><span class=\"line\">    return num1+num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、使用函数表达式定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">必须等解析器执行到函数表达式所在的代码行，才会真正被解释执行</span><br><span class=\"line\">var sum=function(num1,num2)&#123;</span><br><span class=\"line\">    return num1+num2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">无需函数名，通过变量即可引用函数</span><br><span class=\"line\">PS：函数末尾有一个分号，同声明其他变量一样</span><br></pre></td></tr></table></figure>\n<p>3、使用Function构造函数（不推荐使用）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ol>\n<li>没有重载：当声明了两个同名函数时，后面的将覆盖前面的函数</li>\n<li>作为值的函数：像传参一样把函数传递，即访问函数的指针，而不是执行函数  </li>\n<li>内部属性：（有点绕有点难懂，我觉得很少用）<br>arguments.callee：指针，指向拥有 arguments对象的函数；arguments.callee.caller：指向（调用了（拥有arguments对象）的函数）的函数</li>\n</ol>\n<blockquote>\n<p>相关属性与方法详见书中110</p>\n</blockquote>\n"},{"title":"vue+axios解决文件上传问题","Date":"2019-02-25T16:00:00.000Z","comments":1,"_content":"\n# 前因\n关于文件上传，可以使用element-ui中的组件，也可以直接使用input，最近做的一个项目中有用到，查了挺多资料研究了一下，最终就实用性来说还是后者bug少。  \n\n现在就这两个介绍一下，如果有错误请提出纠正，或者有更好的可以来分享一下。\n# Element-UI\n## 直接action\n这个方法很简单，文档中有一一详细列出，重点是下一个\n> 可参考[官方文档](http://element-cn.eleme.io/#/zh-CN/component/upload)\n\n## 利用before-upload属性\n\n直接action很方便简单，但是总会有各种难以解决的错误出现  \n如：后台要求请求方式为multipart/form-data时，不能使用data传参数，这时候就要使用formdata对象了。\n\n### 使用\nnew一个formdata对象，然后对这个对象追加key和value\n\n```\n//网上给出的例子\nbeforeUpload (file,id) {\n    let fd = new FormData()\n    fd.append('file', file)\n    fd.append('id',id)\n    axios.post(url, fd, {\n         \n     })\n    return false // false就是不自动上传\n},\n```\n改进后我的例子\n\n```\n<el-dialog\n    title=\"导入报表\"\n    :visible.sync=\"dialogVisible\"\n    width=\"30%\"\n    :before-close=\"handleClose\"\n    :append-to-body='true'>\n    <el-upload\n      class=\"upload-demo\"\n      ref=\"upload\"\n      action=\"/super_admin/factory/device/import\"\n      :limit=\"1\"\n      :on-exceed=\"handleExceed\"\n      :file-list=\"fileList\"\n      :auto-upload=\"false\"\n      :before-upload=\"beforeAvatarUpload\"\n      :on-error=\"error\"\n      :before-remove=\"beforeRemove\">\n      <el-button size=\"small\" type=\"primary\">点击上传</el-button>\n    </el-upload>\n    <span slot=\"footer\" class=\"dialog-footer\">\n      <el-button type=\"primary\" @click.native=\"importTable()\">确 定</el-button>\n    </span>\n  </el-dialog>\n  \n``` \n \n```\ndata() {\n      return {\n          dialogVisible: false,\n         // 所上传的文件\n          fileList: []\n      }\n  },\n  \n```\n\n  \n```\nmethods: {\n      // 限制上传文件为一个\n    handleExceed() {\n      this.$message.warning('当前限制上传 1 个文件');\n    },\n    // 对文件类型进行判断并上传（重点！）\n    beforeAvatarUpload(file) {\n      const isXLSX = file.type === \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n      if (!isXLSX) {\n        this.$message.error(\"上传的文件只能是 xlsx 格式!\");\n        this.fileList = [];\n      }else {\n        let factoryId = this.factoryId;\n        let fd = new FormData();\n        fd.append('file', file);\n        fd.append('factoryId', factoryId);\n        api.importTable((err, res) => {\n          if (err || res.status !== 200) {\n            this.$message.error(\"出错了，刷新一下吧\");\n            return;\n          }\n          if (res.data.code == 403) {\n            this.$message.error(\"该账号没有此操作权限\");\n          } else if (res.data.code == 200) {\n            this.$message({\n              message: '文件上传成功！',\n              type: 'success'\n            });\n          } else {\n            this.$message.error(\"出错了，刷新一下吧\");\n          }\n        },fd);\n        return true\n      }\n    },\n   // 文件上传失败\n    error(err) {\n        this.$message({\n          message: '文件上传失败！',\n          type: 'warning'\n        });\n    },\n    // 移除已上传的文件\n    beforeRemove(file) {\n      return this.$confirm('确定移除 '+file.name+' ？');\n    },\n    // 导入报表至后台\n    importTable() {\n      this.$refs.upload.submit();\n      this.dialogVisible = false;\n    },\n  }\n```\n\n\n\n\n```\n// 引用instance\nimport instance from './instance.js'\n\nfunction importTable(fn,data) {\n\treturn instance({\n    method: \"post\",\n    url: '/super_admin/factory/device/import',\n    data: data,\n    headers: {\n      \"Content-Type\": \"multipart/form-data\"\n    }\n  })\n}\n\nexport{\n    importTable\n}\n\n```\n### 注意\n1. 这种方法也有弊端，action作为必填参数，无论是填任意数或者填写重复地址，控制台总会报404。\n2. FormData对象是不可以通过console.log在控制台直接打印出来的，但可以通过FormData.get()获取值。\n\n\n## input上传\n\n这个是重点，就实用来说，掌握一种方法就可以了，这个是目前最成功的（结合后台）。\n\n### 使用\n\n```\n<el-button\n \tsize=\"mini\" \n \ttype=\"primary\"\n \ticon=\"el-icon-upload2\"\n \ttitle=\"导入数据\"\n \t@click.native=\"handleUpload(scope.$index, scope.row)\"\n \tslot=\"reference\"\n \tcircle></el-button>\n<!-- 导入文件表单 -->\n<form id=\"uploadform\" style=\"display:none;\">\n    <input name=\"importFile\" type=\"file\" accept=\".xlsx\" ref=\"importFile\" v-on:change=\"confirmUpload()\"></input>\n    <input name=\"factoryId\" :value='this.upload.CurrentfactoryId'></input>\n</form>\n\n\n```\n\n\n```\ndata() {\n    return {\n        // 上传文件所需的参数\n       upload: {\n      \t CurrentfactoryId: \"\"\n       },\n    }\n}\n\n```\n\n\n```\nmethods: {\n    // 打开上传文件的弹出框\n    handleUpload(index, row) {\n      this.upload.CurrentfactoryId = row.factoryId;\n      this.$refs.importFile.click();\n    },\n    // 确认导入列表\n    confirmUpload() {\n    \tthis.$confirm('此操作将上传 '+this.$refs.importFile.files[0].name+' , 是否继续?', '提示', {\n          confirmButtonText: '确定',\n          cancelButtonText: '取消',\n          type: 'warning'\n        }).then(() => {\n          this.$message.info('该过程耗时较长，请耐心等待');\n          this.importTable();\n        }).catch(() => {\n          this.$message({\n            type: 'info',\n            message: '已取消上传'\n          });  \n          this.$refs.importFile.value = null;        \n        });\n    },\n    // 导入报表至后台\n    importTable() {\n      let fd = new FormData(document.getElementById(\"uploadform\"));\n      // fd.append(\"file\", this.upload.importFile);\n      // fd.append(\"factoryId\", this.upload.CurrentfactoryId);\n      // console.log(fd.get('importFile'));\n      api.importTable((err, res) => {\n          if (err) {\n            if (err.response.status === 403 && err.response.data.code==-2) {\n              this.$message.error(\"请登录\");\n              session.clear();\n              this.$router.push({ path: \"/login\" });\n            } else if ( err.response.status === 500) {\n              this.$message.error(\"系统出错，请稍后再试\");\n            } else if (err.response.status == 403) {\n              this.$message.error(\"该账号没有此操作权限\");\n            }\n            return;\n          }\n          if (res.data.code == 200) {\n            this.$message({\n              message: \"文件上传成功！\",\n              type: \"success\"\n            });\n            this.visible = false;\n          } else {\n            this.$message.error(\"出错了，刷新一下吧\");\n          }\n        },fd);\n    },\n}\n\n```\n\n\n```\n// 引用instance\nimport instance from './instance.js'\n\nfunction importTable(fn,data) {\n\tinstance.post('/super_admin/factory/device/import', data)\n    .then(function (res) {\n      fn(false, res);\n    }).catch(function (err) {\n      fn(err);\n    });\n}\n\nexport{\n    importTable\n}\n\n```\n\n### 注意\n1. 如果对于input的样式不满意，可以使用opacity把原来的input透明化来进行美化。\n2. 依然是使用formdata对象，虽然使用vue，但不知道为什么用append无法把文件传到后台，因此通过操作节点来新建，如果有人知道可以分享一下。\n3. headers可以不手动添加，浏览器会判定界限，也可以加上。","source":"_posts/vue/vue+axios解决文件上传问题.md","raw":"---\ntitle: vue+axios解决文件上传问题\nDate: 2019-02-26\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n# 前因\n关于文件上传，可以使用element-ui中的组件，也可以直接使用input，最近做的一个项目中有用到，查了挺多资料研究了一下，最终就实用性来说还是后者bug少。  \n\n现在就这两个介绍一下，如果有错误请提出纠正，或者有更好的可以来分享一下。\n# Element-UI\n## 直接action\n这个方法很简单，文档中有一一详细列出，重点是下一个\n> 可参考[官方文档](http://element-cn.eleme.io/#/zh-CN/component/upload)\n\n## 利用before-upload属性\n\n直接action很方便简单，但是总会有各种难以解决的错误出现  \n如：后台要求请求方式为multipart/form-data时，不能使用data传参数，这时候就要使用formdata对象了。\n\n### 使用\nnew一个formdata对象，然后对这个对象追加key和value\n\n```\n//网上给出的例子\nbeforeUpload (file,id) {\n    let fd = new FormData()\n    fd.append('file', file)\n    fd.append('id',id)\n    axios.post(url, fd, {\n         \n     })\n    return false // false就是不自动上传\n},\n```\n改进后我的例子\n\n```\n<el-dialog\n    title=\"导入报表\"\n    :visible.sync=\"dialogVisible\"\n    width=\"30%\"\n    :before-close=\"handleClose\"\n    :append-to-body='true'>\n    <el-upload\n      class=\"upload-demo\"\n      ref=\"upload\"\n      action=\"/super_admin/factory/device/import\"\n      :limit=\"1\"\n      :on-exceed=\"handleExceed\"\n      :file-list=\"fileList\"\n      :auto-upload=\"false\"\n      :before-upload=\"beforeAvatarUpload\"\n      :on-error=\"error\"\n      :before-remove=\"beforeRemove\">\n      <el-button size=\"small\" type=\"primary\">点击上传</el-button>\n    </el-upload>\n    <span slot=\"footer\" class=\"dialog-footer\">\n      <el-button type=\"primary\" @click.native=\"importTable()\">确 定</el-button>\n    </span>\n  </el-dialog>\n  \n``` \n \n```\ndata() {\n      return {\n          dialogVisible: false,\n         // 所上传的文件\n          fileList: []\n      }\n  },\n  \n```\n\n  \n```\nmethods: {\n      // 限制上传文件为一个\n    handleExceed() {\n      this.$message.warning('当前限制上传 1 个文件');\n    },\n    // 对文件类型进行判断并上传（重点！）\n    beforeAvatarUpload(file) {\n      const isXLSX = file.type === \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n      if (!isXLSX) {\n        this.$message.error(\"上传的文件只能是 xlsx 格式!\");\n        this.fileList = [];\n      }else {\n        let factoryId = this.factoryId;\n        let fd = new FormData();\n        fd.append('file', file);\n        fd.append('factoryId', factoryId);\n        api.importTable((err, res) => {\n          if (err || res.status !== 200) {\n            this.$message.error(\"出错了，刷新一下吧\");\n            return;\n          }\n          if (res.data.code == 403) {\n            this.$message.error(\"该账号没有此操作权限\");\n          } else if (res.data.code == 200) {\n            this.$message({\n              message: '文件上传成功！',\n              type: 'success'\n            });\n          } else {\n            this.$message.error(\"出错了，刷新一下吧\");\n          }\n        },fd);\n        return true\n      }\n    },\n   // 文件上传失败\n    error(err) {\n        this.$message({\n          message: '文件上传失败！',\n          type: 'warning'\n        });\n    },\n    // 移除已上传的文件\n    beforeRemove(file) {\n      return this.$confirm('确定移除 '+file.name+' ？');\n    },\n    // 导入报表至后台\n    importTable() {\n      this.$refs.upload.submit();\n      this.dialogVisible = false;\n    },\n  }\n```\n\n\n\n\n```\n// 引用instance\nimport instance from './instance.js'\n\nfunction importTable(fn,data) {\n\treturn instance({\n    method: \"post\",\n    url: '/super_admin/factory/device/import',\n    data: data,\n    headers: {\n      \"Content-Type\": \"multipart/form-data\"\n    }\n  })\n}\n\nexport{\n    importTable\n}\n\n```\n### 注意\n1. 这种方法也有弊端，action作为必填参数，无论是填任意数或者填写重复地址，控制台总会报404。\n2. FormData对象是不可以通过console.log在控制台直接打印出来的，但可以通过FormData.get()获取值。\n\n\n## input上传\n\n这个是重点，就实用来说，掌握一种方法就可以了，这个是目前最成功的（结合后台）。\n\n### 使用\n\n```\n<el-button\n \tsize=\"mini\" \n \ttype=\"primary\"\n \ticon=\"el-icon-upload2\"\n \ttitle=\"导入数据\"\n \t@click.native=\"handleUpload(scope.$index, scope.row)\"\n \tslot=\"reference\"\n \tcircle></el-button>\n<!-- 导入文件表单 -->\n<form id=\"uploadform\" style=\"display:none;\">\n    <input name=\"importFile\" type=\"file\" accept=\".xlsx\" ref=\"importFile\" v-on:change=\"confirmUpload()\"></input>\n    <input name=\"factoryId\" :value='this.upload.CurrentfactoryId'></input>\n</form>\n\n\n```\n\n\n```\ndata() {\n    return {\n        // 上传文件所需的参数\n       upload: {\n      \t CurrentfactoryId: \"\"\n       },\n    }\n}\n\n```\n\n\n```\nmethods: {\n    // 打开上传文件的弹出框\n    handleUpload(index, row) {\n      this.upload.CurrentfactoryId = row.factoryId;\n      this.$refs.importFile.click();\n    },\n    // 确认导入列表\n    confirmUpload() {\n    \tthis.$confirm('此操作将上传 '+this.$refs.importFile.files[0].name+' , 是否继续?', '提示', {\n          confirmButtonText: '确定',\n          cancelButtonText: '取消',\n          type: 'warning'\n        }).then(() => {\n          this.$message.info('该过程耗时较长，请耐心等待');\n          this.importTable();\n        }).catch(() => {\n          this.$message({\n            type: 'info',\n            message: '已取消上传'\n          });  \n          this.$refs.importFile.value = null;        \n        });\n    },\n    // 导入报表至后台\n    importTable() {\n      let fd = new FormData(document.getElementById(\"uploadform\"));\n      // fd.append(\"file\", this.upload.importFile);\n      // fd.append(\"factoryId\", this.upload.CurrentfactoryId);\n      // console.log(fd.get('importFile'));\n      api.importTable((err, res) => {\n          if (err) {\n            if (err.response.status === 403 && err.response.data.code==-2) {\n              this.$message.error(\"请登录\");\n              session.clear();\n              this.$router.push({ path: \"/login\" });\n            } else if ( err.response.status === 500) {\n              this.$message.error(\"系统出错，请稍后再试\");\n            } else if (err.response.status == 403) {\n              this.$message.error(\"该账号没有此操作权限\");\n            }\n            return;\n          }\n          if (res.data.code == 200) {\n            this.$message({\n              message: \"文件上传成功！\",\n              type: \"success\"\n            });\n            this.visible = false;\n          } else {\n            this.$message.error(\"出错了，刷新一下吧\");\n          }\n        },fd);\n    },\n}\n\n```\n\n\n```\n// 引用instance\nimport instance from './instance.js'\n\nfunction importTable(fn,data) {\n\tinstance.post('/super_admin/factory/device/import', data)\n    .then(function (res) {\n      fn(false, res);\n    }).catch(function (err) {\n      fn(err);\n    });\n}\n\nexport{\n    importTable\n}\n\n```\n\n### 注意\n1. 如果对于input的样式不满意，可以使用opacity把原来的input透明化来进行美化。\n2. 依然是使用formdata对象，虽然使用vue，但不知道为什么用append无法把文件传到后台，因此通过操作节点来新建，如果有人知道可以分享一下。\n3. headers可以不手动添加，浏览器会判定界限，也可以加上。","slug":"vue/vue+axios解决文件上传问题","published":1,"date":"2019-02-26T08:38:22.911Z","updated":"2019-02-26T08:56:58.156Z","layout":"post","photos":[],"link":"","_id":"cka6kin2r0033qgu9tzwsmzvz","content":"<h1 id=\"前因\"><a href=\"#前因\" class=\"headerlink\" title=\"前因\"></a>前因</h1><p>关于文件上传，可以使用element-ui中的组件，也可以直接使用input，最近做的一个项目中有用到，查了挺多资料研究了一下，最终就实用性来说还是后者bug少。  </p>\n<p>现在就这两个介绍一下，如果有错误请提出纠正，或者有更好的可以来分享一下。</p>\n<h1 id=\"Element-UI\"><a href=\"#Element-UI\" class=\"headerlink\" title=\"Element-UI\"></a>Element-UI</h1><h2 id=\"直接action\"><a href=\"#直接action\" class=\"headerlink\" title=\"直接action\"></a>直接action</h2><p>这个方法很简单，文档中有一一详细列出，重点是下一个</p>\n<blockquote>\n<p>可参考<a href=\"http://element-cn.eleme.io/#/zh-CN/component/upload\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n</blockquote>\n<h2 id=\"利用before-upload属性\"><a href=\"#利用before-upload属性\" class=\"headerlink\" title=\"利用before-upload属性\"></a>利用before-upload属性</h2><p>直接action很方便简单，但是总会有各种难以解决的错误出现<br>如：后台要求请求方式为multipart/form-data时，不能使用data传参数，这时候就要使用formdata对象了。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>new一个formdata对象，然后对这个对象追加key和value</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//网上给出的例子</span><br><span class=\"line\">beforeUpload (file,id) &#123;</span><br><span class=\"line\">    let fd = new FormData()</span><br><span class=\"line\">    fd.append(&apos;file&apos;, file)</span><br><span class=\"line\">    fd.append(&apos;id&apos;,id)</span><br><span class=\"line\">    axios.post(url, fd, &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">    return false // false就是不自动上传</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>改进后我的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-dialog</span><br><span class=\"line\">    title=&quot;导入报表&quot;</span><br><span class=\"line\">    :visible.sync=&quot;dialogVisible&quot;</span><br><span class=\"line\">    width=&quot;30%&quot;</span><br><span class=\"line\">    :before-close=&quot;handleClose&quot;</span><br><span class=\"line\">    :append-to-body=&apos;true&apos;&gt;</span><br><span class=\"line\">    &lt;el-upload</span><br><span class=\"line\">      class=&quot;upload-demo&quot;</span><br><span class=\"line\">      ref=&quot;upload&quot;</span><br><span class=\"line\">      action=&quot;/super_admin/factory/device/import&quot;</span><br><span class=\"line\">      :limit=&quot;1&quot;</span><br><span class=\"line\">      :on-exceed=&quot;handleExceed&quot;</span><br><span class=\"line\">      :file-list=&quot;fileList&quot;</span><br><span class=\"line\">      :auto-upload=&quot;false&quot;</span><br><span class=\"line\">      :before-upload=&quot;beforeAvatarUpload&quot;</span><br><span class=\"line\">      :on-error=&quot;error&quot;</span><br><span class=\"line\">      :before-remove=&quot;beforeRemove&quot;&gt;</span><br><span class=\"line\">      &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;</span><br><span class=\"line\">    &lt;/el-upload&gt;</span><br><span class=\"line\">    &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class=\"line\">      &lt;el-button type=&quot;primary&quot; @click.native=&quot;importTable()&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">  &lt;/el-dialog&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>data() {<br>      return {<br>          dialogVisible: false,<br>         // 所上传的文件<br>          fileList: []<br>      }<br>  },</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>methods: {<br>      // 限制上传文件为一个<br>    handleExceed() {<br>      this.$message.warning(‘当前限制上传 1 个文件’);<br>    },<br>    // 对文件类型进行判断并上传（重点！）<br>    beforeAvatarUpload(file) {<br>      const isXLSX = file.type === “application/vnd.openxmlformats-officedocument.spreadsheetml.sheet”;<br>      if (!isXLSX) {<br>        this.$message.error(“上传的文件只能是 xlsx 格式!”);<br>        this.fileList = [];<br>      }else {<br>        let factoryId = this.factoryId;<br>        let fd = new FormData();<br>        fd.append(‘file’, file);<br>        fd.append(‘factoryId’, factoryId);<br>        api.importTable((err, res) =&gt; {<br>          if (err || res.status !== 200) {<br>            this.$message.error(“出错了，刷新一下吧”);<br>            return;<br>          }<br>          if (res.data.code == 403) {<br>            this.$message.error(“该账号没有此操作权限”);<br>          } else if (res.data.code == 200) {<br>            this.$message({<br>              message: ‘文件上传成功！’,<br>              type: ‘success’<br>            });<br>          } else {<br>            this.$message.error(“出错了，刷新一下吧”);<br>          }<br>        },fd);<br>        return true<br>      }<br>    },<br>   // 文件上传失败<br>    error(err) {<br>        this.$message({<br>          message: ‘文件上传失败！’,<br>          type: ‘warning’<br>        });<br>    },<br>    // 移除已上传的文件<br>    beforeRemove(file) {<br>      return this.$confirm(‘确定移除 ‘+file.name+’ ？’);<br>    },<br>    // 导入报表至后台<br>    importTable() {<br>      this.$refs.upload.submit();<br>      this.dialogVisible = false;<br>    },<br>  }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>// 引用instance<br>import instance from ‘./instance.js’</p>\n<p>function importTable(fn,data) {<br>    return instance({<br>    method: “post”,<br>    url: ‘/super_admin/factory/device/import’,<br>    data: data,<br>    headers: {<br>      “Content-Type”: “multipart/form-data”<br>    }<br>  })<br>}</p>\n<p>export{<br>    importTable<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 注意</span><br><span class=\"line\">1. 这种方法也有弊端，action作为必填参数，无论是填任意数或者填写重复地址，控制台总会报404。</span><br><span class=\"line\">2. FormData对象是不可以通过console.log在控制台直接打印出来的，但可以通过FormData.get()获取值。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## input上传</span><br><span class=\"line\"></span><br><span class=\"line\">这个是重点，就实用来说，掌握一种方法就可以了，这个是目前最成功的（结合后台）。</span><br><span class=\"line\"></span><br><span class=\"line\">### 使用</span><br></pre></td></tr></table></figure>\n<p><el-button size=\"mini\" type=\"primary\" icon=\"el-icon-upload2\" title=\"导入数据\" @click.native=\"handleUpload(scope.$index, scope.row)\" slot=\"reference\" circle=\"\"></el-button><br><!-- 导入文件表单 --></p>\n<form id=\"uploadform\" style=\"display:none;\"><br>    <input name=\"importFile\" type=\"file\" accept=\".xlsx\" ref=\"importFile\" v-on:change=\"confirmUpload()\"><br>    <input name=\"factoryId\" :value=\"this.upload.CurrentfactoryId\"><br></form>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>data() {<br>    return {<br>        // 上传文件所需的参数<br>       upload: {<br>           CurrentfactoryId: “”<br>       },<br>    }<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>methods: {<br>    // 打开上传文件的弹出框<br>    handleUpload(index, row) {<br>      this.upload.CurrentfactoryId = row.factoryId;<br>      this.$refs.importFile.click();<br>    },<br>    // 确认导入列表<br>    confirmUpload() {<br>        this.$confirm(‘此操作将上传 ‘+this.$refs.importFile.files[0].name+’ , 是否继续?’, ‘提示’, {<br>          confirmButtonText: ‘确定’,<br>          cancelButtonText: ‘取消’,<br>          type: ‘warning’<br>        }).then(() =&gt; {<br>          this.$message.info(‘该过程耗时较长，请耐心等待’);<br>          this.importTable();<br>        }).catch(() =&gt; {<br>          this.$message({<br>            type: ‘info’,<br>            message: ‘已取消上传’<br>          });<br>          this.$refs.importFile.value = null;<br>        });<br>    },<br>    // 导入报表至后台<br>    importTable() {<br>      let fd = new FormData(document.getElementById(“uploadform”));<br>      // fd.append(“file”, this.upload.importFile);<br>      // fd.append(“factoryId”, this.upload.CurrentfactoryId);<br>      // console.log(fd.get(‘importFile’));<br>      api.importTable((err, res) =&gt; {<br>          if (err) {<br>            if (err.response.status === 403 &amp;&amp; err.response.data.code==-2) {<br>              this.$message.error(“请登录”);<br>              session.clear();<br>              this.$router.push({ path: “/login” });<br>            } else if ( err.response.status === 500) {<br>              this.$message.error(“系统出错，请稍后再试”);<br>            } else if (err.response.status == 403) {<br>              this.$message.error(“该账号没有此操作权限”);<br>            }<br>            return;<br>          }<br>          if (res.data.code == 200) {<br>            this.$message({<br>              message: “文件上传成功！”,<br>              type: “success”<br>            });<br>            this.visible = false;<br>          } else {<br>            this.$message.error(“出错了，刷新一下吧”);<br>          }<br>        },fd);<br>    },<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 引用instance<br>import instance from ‘./instance.js’</p>\n<p>function importTable(fn,data) {<br>    instance.post(‘/super_admin/factory/device/import’, data)<br>    .then(function (res) {<br>      fn(false, res);<br>    }).catch(function (err) {<br>      fn(err);<br>    });<br>}</p>\n<p>export{<br>    importTable<br>}</p>\n<p><code>`</code></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>如果对于input的样式不满意，可以使用opacity把原来的input透明化来进行美化。</li>\n<li>依然是使用formdata对象，虽然使用vue，但不知道为什么用append无法把文件传到后台，因此通过操作节点来新建，如果有人知道可以分享一下。</li>\n<li>headers可以不手动添加，浏览器会判定界限，也可以加上。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前因\"><a href=\"#前因\" class=\"headerlink\" title=\"前因\"></a>前因</h1><p>关于文件上传，可以使用element-ui中的组件，也可以直接使用input，最近做的一个项目中有用到，查了挺多资料研究了一下，最终就实用性来说还是后者bug少。  </p>\n<p>现在就这两个介绍一下，如果有错误请提出纠正，或者有更好的可以来分享一下。</p>\n<h1 id=\"Element-UI\"><a href=\"#Element-UI\" class=\"headerlink\" title=\"Element-UI\"></a>Element-UI</h1><h2 id=\"直接action\"><a href=\"#直接action\" class=\"headerlink\" title=\"直接action\"></a>直接action</h2><p>这个方法很简单，文档中有一一详细列出，重点是下一个</p>\n<blockquote>\n<p>可参考<a href=\"http://element-cn.eleme.io/#/zh-CN/component/upload\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n</blockquote>\n<h2 id=\"利用before-upload属性\"><a href=\"#利用before-upload属性\" class=\"headerlink\" title=\"利用before-upload属性\"></a>利用before-upload属性</h2><p>直接action很方便简单，但是总会有各种难以解决的错误出现<br>如：后台要求请求方式为multipart/form-data时，不能使用data传参数，这时候就要使用formdata对象了。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>new一个formdata对象，然后对这个对象追加key和value</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//网上给出的例子</span><br><span class=\"line\">beforeUpload (file,id) &#123;</span><br><span class=\"line\">    let fd = new FormData()</span><br><span class=\"line\">    fd.append(&apos;file&apos;, file)</span><br><span class=\"line\">    fd.append(&apos;id&apos;,id)</span><br><span class=\"line\">    axios.post(url, fd, &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">    return false // false就是不自动上传</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>改进后我的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-dialog</span><br><span class=\"line\">    title=&quot;导入报表&quot;</span><br><span class=\"line\">    :visible.sync=&quot;dialogVisible&quot;</span><br><span class=\"line\">    width=&quot;30%&quot;</span><br><span class=\"line\">    :before-close=&quot;handleClose&quot;</span><br><span class=\"line\">    :append-to-body=&apos;true&apos;&gt;</span><br><span class=\"line\">    &lt;el-upload</span><br><span class=\"line\">      class=&quot;upload-demo&quot;</span><br><span class=\"line\">      ref=&quot;upload&quot;</span><br><span class=\"line\">      action=&quot;/super_admin/factory/device/import&quot;</span><br><span class=\"line\">      :limit=&quot;1&quot;</span><br><span class=\"line\">      :on-exceed=&quot;handleExceed&quot;</span><br><span class=\"line\">      :file-list=&quot;fileList&quot;</span><br><span class=\"line\">      :auto-upload=&quot;false&quot;</span><br><span class=\"line\">      :before-upload=&quot;beforeAvatarUpload&quot;</span><br><span class=\"line\">      :on-error=&quot;error&quot;</span><br><span class=\"line\">      :before-remove=&quot;beforeRemove&quot;&gt;</span><br><span class=\"line\">      &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;</span><br><span class=\"line\">    &lt;/el-upload&gt;</span><br><span class=\"line\">    &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class=\"line\">      &lt;el-button type=&quot;primary&quot; @click.native=&quot;importTable()&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">  &lt;/el-dialog&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>data() {<br>      return {<br>          dialogVisible: false,<br>         // 所上传的文件<br>          fileList: []<br>      }<br>  },</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>methods: {<br>      // 限制上传文件为一个<br>    handleExceed() {<br>      this.$message.warning(‘当前限制上传 1 个文件’);<br>    },<br>    // 对文件类型进行判断并上传（重点！）<br>    beforeAvatarUpload(file) {<br>      const isXLSX = file.type === “application/vnd.openxmlformats-officedocument.spreadsheetml.sheet”;<br>      if (!isXLSX) {<br>        this.$message.error(“上传的文件只能是 xlsx 格式!”);<br>        this.fileList = [];<br>      }else {<br>        let factoryId = this.factoryId;<br>        let fd = new FormData();<br>        fd.append(‘file’, file);<br>        fd.append(‘factoryId’, factoryId);<br>        api.importTable((err, res) =&gt; {<br>          if (err || res.status !== 200) {<br>            this.$message.error(“出错了，刷新一下吧”);<br>            return;<br>          }<br>          if (res.data.code == 403) {<br>            this.$message.error(“该账号没有此操作权限”);<br>          } else if (res.data.code == 200) {<br>            this.$message({<br>              message: ‘文件上传成功！’,<br>              type: ‘success’<br>            });<br>          } else {<br>            this.$message.error(“出错了，刷新一下吧”);<br>          }<br>        },fd);<br>        return true<br>      }<br>    },<br>   // 文件上传失败<br>    error(err) {<br>        this.$message({<br>          message: ‘文件上传失败！’,<br>          type: ‘warning’<br>        });<br>    },<br>    // 移除已上传的文件<br>    beforeRemove(file) {<br>      return this.$confirm(‘确定移除 ‘+file.name+’ ？’);<br>    },<br>    // 导入报表至后台<br>    importTable() {<br>      this.$refs.upload.submit();<br>      this.dialogVisible = false;<br>    },<br>  }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>// 引用instance<br>import instance from ‘./instance.js’</p>\n<p>function importTable(fn,data) {<br>    return instance({<br>    method: “post”,<br>    url: ‘/super_admin/factory/device/import’,<br>    data: data,<br>    headers: {<br>      “Content-Type”: “multipart/form-data”<br>    }<br>  })<br>}</p>\n<p>export{<br>    importTable<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 注意</span><br><span class=\"line\">1. 这种方法也有弊端，action作为必填参数，无论是填任意数或者填写重复地址，控制台总会报404。</span><br><span class=\"line\">2. FormData对象是不可以通过console.log在控制台直接打印出来的，但可以通过FormData.get()获取值。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## input上传</span><br><span class=\"line\"></span><br><span class=\"line\">这个是重点，就实用来说，掌握一种方法就可以了，这个是目前最成功的（结合后台）。</span><br><span class=\"line\"></span><br><span class=\"line\">### 使用</span><br></pre></td></tr></table></figure>\n<p><el-button size=\"mini\" type=\"primary\" icon=\"el-icon-upload2\" title=\"导入数据\" @click.native=\"handleUpload(scope.$index, scope.row)\" slot=\"reference\" circle=\"\"></el-button><br><!-- 导入文件表单 --></p>\n<form id=\"uploadform\" style=\"display:none;\"><br>    <input name=\"importFile\" type=\"file\" accept=\".xlsx\" ref=\"importFile\" v-on:change=\"confirmUpload()\"><br>    <input name=\"factoryId\" :value=\"this.upload.CurrentfactoryId\"><br></form>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>data() {<br>    return {<br>        // 上传文件所需的参数<br>       upload: {<br>           CurrentfactoryId: “”<br>       },<br>    }<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>methods: {<br>    // 打开上传文件的弹出框<br>    handleUpload(index, row) {<br>      this.upload.CurrentfactoryId = row.factoryId;<br>      this.$refs.importFile.click();<br>    },<br>    // 确认导入列表<br>    confirmUpload() {<br>        this.$confirm(‘此操作将上传 ‘+this.$refs.importFile.files[0].name+’ , 是否继续?’, ‘提示’, {<br>          confirmButtonText: ‘确定’,<br>          cancelButtonText: ‘取消’,<br>          type: ‘warning’<br>        }).then(() =&gt; {<br>          this.$message.info(‘该过程耗时较长，请耐心等待’);<br>          this.importTable();<br>        }).catch(() =&gt; {<br>          this.$message({<br>            type: ‘info’,<br>            message: ‘已取消上传’<br>          });<br>          this.$refs.importFile.value = null;<br>        });<br>    },<br>    // 导入报表至后台<br>    importTable() {<br>      let fd = new FormData(document.getElementById(“uploadform”));<br>      // fd.append(“file”, this.upload.importFile);<br>      // fd.append(“factoryId”, this.upload.CurrentfactoryId);<br>      // console.log(fd.get(‘importFile’));<br>      api.importTable((err, res) =&gt; {<br>          if (err) {<br>            if (err.response.status === 403 &amp;&amp; err.response.data.code==-2) {<br>              this.$message.error(“请登录”);<br>              session.clear();<br>              this.$router.push({ path: “/login” });<br>            } else if ( err.response.status === 500) {<br>              this.$message.error(“系统出错，请稍后再试”);<br>            } else if (err.response.status == 403) {<br>              this.$message.error(“该账号没有此操作权限”);<br>            }<br>            return;<br>          }<br>          if (res.data.code == 200) {<br>            this.$message({<br>              message: “文件上传成功！”,<br>              type: “success”<br>            });<br>            this.visible = false;<br>          } else {<br>            this.$message.error(“出错了，刷新一下吧”);<br>          }<br>        },fd);<br>    },<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 引用instance<br>import instance from ‘./instance.js’</p>\n<p>function importTable(fn,data) {<br>    instance.post(‘/super_admin/factory/device/import’, data)<br>    .then(function (res) {<br>      fn(false, res);<br>    }).catch(function (err) {<br>      fn(err);<br>    });<br>}</p>\n<p>export{<br>    importTable<br>}</p>\n<p><code>`</code></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>如果对于input的样式不满意，可以使用opacity把原来的input透明化来进行美化。</li>\n<li>依然是使用formdata对象，虽然使用vue，但不知道为什么用append无法把文件传到后台，因此通过操作节点来新建，如果有人知道可以分享一下。</li>\n<li>headers可以不手动添加，浏览器会判定界限，也可以加上。</li>\n</ol>\n"},{"title":"vue：MVVM、MVC、MVP","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### MVC\n\nM代表Model，代表数据模型。\n\nV代表View，代表视图。\n\nC代表Controller，代表控制器，用来处理数据。\n\n#### 工作模式\n用户操作视图View，当数据改变时，传到Controller进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知View，View通过观察者模式收到Model变更的消息后，向Model请求最新的数据，自己同步更新视图。\n#### 优点\n观察者模式可以做到多视图同时更新。\n#### 缺点\n- controller测试困难。\n- view无法组件化，它强依赖特定的Model，不同程序的Model不一样。\n\n\n### MVP\n\nM代表Model，代表数据模型。\n\nV代表View，代表视图。\n\nP代表Presenter，代表呈现。\n\n#### 工作模式\n用户操作视图View，当数据改变时，传到Presenter进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知Presenter，Presenter获取到Model变更的消息后，通过View提供的接口更新界面。\n\n#### 和MVC的不同\nM和V是隔离的。\n#### 优点\n- 便于测试。\n- 可以组件化\n#### 缺点\n由于需要大量的手动同步View和Model，导致维护起来很困难。\n\n### MVVM\n\nvue和angular都为mvvm框架\n\nM代表Model，代表数据模型，可以在Model中定义数据修改和操作的业务逻辑。\n\nV代表View，代表视图，它负责将数据模型转化成UI展现出来。\n\nVM代表ViewModel，负责监听模型数据的改变和控制视图行为、处理用户交互。简单理解就是一个同步View和Model的对象，连接View和Model。\n\nMVVM是以双向数据传输为思想的。ViewModel通过双向数据绑定把View和Model连接起来，View数据的变化会同步到Model中，而Model数据的变化也会立即反映到View上。\n#### 优点\n解决MVP大量的手动同步View和Model的问题，提供双向绑定机制。\n#### 缺点\n- 过于简单的图形界面不适用。\n- 没法断点debug，数据绑定的声明是指令式地写在View的模板当中的。\n\n","source":"_posts/vue/vue：MVVM、MVC、MVP.md","raw":"---\ntitle: vue：MVVM、MVC、MVP\nDate: 2020-03-17\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n### MVC\n\nM代表Model，代表数据模型。\n\nV代表View，代表视图。\n\nC代表Controller，代表控制器，用来处理数据。\n\n#### 工作模式\n用户操作视图View，当数据改变时，传到Controller进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知View，View通过观察者模式收到Model变更的消息后，向Model请求最新的数据，自己同步更新视图。\n#### 优点\n观察者模式可以做到多视图同时更新。\n#### 缺点\n- controller测试困难。\n- view无法组件化，它强依赖特定的Model，不同程序的Model不一样。\n\n\n### MVP\n\nM代表Model，代表数据模型。\n\nV代表View，代表视图。\n\nP代表Presenter，代表呈现。\n\n#### 工作模式\n用户操作视图View，当数据改变时，传到Presenter进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知Presenter，Presenter获取到Model变更的消息后，通过View提供的接口更新界面。\n\n#### 和MVC的不同\nM和V是隔离的。\n#### 优点\n- 便于测试。\n- 可以组件化\n#### 缺点\n由于需要大量的手动同步View和Model，导致维护起来很困难。\n\n### MVVM\n\nvue和angular都为mvvm框架\n\nM代表Model，代表数据模型，可以在Model中定义数据修改和操作的业务逻辑。\n\nV代表View，代表视图，它负责将数据模型转化成UI展现出来。\n\nVM代表ViewModel，负责监听模型数据的改变和控制视图行为、处理用户交互。简单理解就是一个同步View和Model的对象，连接View和Model。\n\nMVVM是以双向数据传输为思想的。ViewModel通过双向数据绑定把View和Model连接起来，View数据的变化会同步到Model中，而Model数据的变化也会立即反映到View上。\n#### 优点\n解决MVP大量的手动同步View和Model的问题，提供双向绑定机制。\n#### 缺点\n- 过于简单的图形界面不适用。\n- 没法断点debug，数据绑定的声明是指令式地写在View的模板当中的。\n\n","slug":"vue/vue：MVVM、MVC、MVP","published":1,"date":"2020-03-17T08:21:06.189Z","updated":"2020-03-17T08:24:04.970Z","layout":"post","photos":[],"link":"","_id":"cka6kin310036qgu96rdir78u","content":"<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>M代表Model，代表数据模型。</p>\n<p>V代表View，代表视图。</p>\n<p>C代表Controller，代表控制器，用来处理数据。</p>\n<h4 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h4><p>用户操作视图View，当数据改变时，传到Controller进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知View，View通过观察者模式收到Model变更的消息后，向Model请求最新的数据，自己同步更新视图。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>观察者模式可以做到多视图同时更新。</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>controller测试困难。</li>\n<li>view无法组件化，它强依赖特定的Model，不同程序的Model不一样。</li>\n</ul>\n<h3 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h3><p>M代表Model，代表数据模型。</p>\n<p>V代表View，代表视图。</p>\n<p>P代表Presenter，代表呈现。</p>\n<h4 id=\"工作模式-1\"><a href=\"#工作模式-1\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h4><p>用户操作视图View，当数据改变时，传到Presenter进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知Presenter，Presenter获取到Model变更的消息后，通过View提供的接口更新界面。</p>\n<h4 id=\"和MVC的不同\"><a href=\"#和MVC的不同\" class=\"headerlink\" title=\"和MVC的不同\"></a>和MVC的不同</h4><p>M和V是隔离的。</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>便于测试。</li>\n<li>可以组件化<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4>由于需要大量的手动同步View和Model，导致维护起来很困难。</li>\n</ul>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>vue和angular都为mvvm框架</p>\n<p>M代表Model，代表数据模型，可以在Model中定义数据修改和操作的业务逻辑。</p>\n<p>V代表View，代表视图，它负责将数据模型转化成UI展现出来。</p>\n<p>VM代表ViewModel，负责监听模型数据的改变和控制视图行为、处理用户交互。简单理解就是一个同步View和Model的对象，连接View和Model。</p>\n<p>MVVM是以双向数据传输为思想的。ViewModel通过双向数据绑定把View和Model连接起来，View数据的变化会同步到Model中，而Model数据的变化也会立即反映到View上。</p>\n<h4 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>解决MVP大量的手动同步View和Model的问题，提供双向绑定机制。</p>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>过于简单的图形界面不适用。</li>\n<li>没法断点debug，数据绑定的声明是指令式地写在View的模板当中的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>M代表Model，代表数据模型。</p>\n<p>V代表View，代表视图。</p>\n<p>C代表Controller，代表控制器，用来处理数据。</p>\n<h4 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h4><p>用户操作视图View，当数据改变时，传到Controller进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知View，View通过观察者模式收到Model变更的消息后，向Model请求最新的数据，自己同步更新视图。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>观察者模式可以做到多视图同时更新。</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>controller测试困难。</li>\n<li>view无法组件化，它强依赖特定的Model，不同程序的Model不一样。</li>\n</ul>\n<h3 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h3><p>M代表Model，代表数据模型。</p>\n<p>V代表View，代表视图。</p>\n<p>P代表Presenter，代表呈现。</p>\n<h4 id=\"工作模式-1\"><a href=\"#工作模式-1\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h4><p>用户操作视图View，当数据改变时，传到Presenter进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知Presenter，Presenter获取到Model变更的消息后，通过View提供的接口更新界面。</p>\n<h4 id=\"和MVC的不同\"><a href=\"#和MVC的不同\" class=\"headerlink\" title=\"和MVC的不同\"></a>和MVC的不同</h4><p>M和V是隔离的。</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>便于测试。</li>\n<li>可以组件化<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4>由于需要大量的手动同步View和Model，导致维护起来很困难。</li>\n</ul>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>vue和angular都为mvvm框架</p>\n<p>M代表Model，代表数据模型，可以在Model中定义数据修改和操作的业务逻辑。</p>\n<p>V代表View，代表视图，它负责将数据模型转化成UI展现出来。</p>\n<p>VM代表ViewModel，负责监听模型数据的改变和控制视图行为、处理用户交互。简单理解就是一个同步View和Model的对象，连接View和Model。</p>\n<p>MVVM是以双向数据传输为思想的。ViewModel通过双向数据绑定把View和Model连接起来，View数据的变化会同步到Model中，而Model数据的变化也会立即反映到View上。</p>\n<h4 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>解决MVP大量的手动同步View和Model的问题，提供双向绑定机制。</p>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>过于简单的图形界面不适用。</li>\n<li>没法断点debug，数据绑定的声明是指令式地写在View的模板当中的。</li>\n</ul>\n"},{"title":"Vue-cli脚手架","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n# vue-cli\n\n## 介绍\n\nVue-cli是Vue的脚手架工具  \n\n脚手架：在工地上，是帮助工人们作业的搭建好的架子；在技术上，是编写好基础代码的工具。\n\n## 安装环境\n\n查看版本（具体安装方法百度很多）\n\n```\n$ node -v\n$ npm -v\n$ cnpm -v\n```\n\n# vue-cli 1.x或2.x\n\n## 全局安装\n\n\n```\n$ npm install -g vue-cli\n$ cnpm install -g vue-cli //国内镜像安装，较快\n```\n若安装失败，则先[清理缓存](https://sivanwong.github.io/2018/05/03/npm%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/)，再重新安装\n\n\n查看版本\n\n```\n$ vue -V\n```\n\n## 生成项目\n\n#### 生成项目文件夹\n```\n$ vue init <template-name> <project-name>\n```\n\n输入命令后，会跳出几个选项让你回答：\n\n- Project name (baoge)：          \n项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。\n- Project description (A Vue.js project)：  \n项目描述，也可直接点击回车，使用默认名字\n- Author ()： 作者，输入你的大名\n\n接下来会让用户选择：\n- Runtime + Compiler: recommended for most users                 \n运行加编译，既然已经说了推荐，就选它了\n- Runtime-only:  about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere                 \n仅运行时，已经有推荐了就选择第一个了\n- Install vue-router? (Y/n)               \n是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。\n- Use ESLint to lint your code? (Y/n)       \n是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。\n- 接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车   \n- Setup unit tests with Karma + Mocha? (Y/n)    \n是否安装单元测试，我选择安装y回车\n- Setup e2e tests with Nightwatch(Y/n)?   \n是否安装e2e测试 ，我选择安装y回车\n\n一般一路回车就好了\n\nOfficial Templates\n- webpack（常用）\n- webpack-simplae\n- browaerify\n- browserify-simple\n- simple\n- 自定义\n\n#### 运行 （在项目文件目录下运行）\n```\n$ cnpm install\n```\n\n```\n$ npm run dev\n```\n\n\n## 项目文件\n\n#### 介绍\n1. build和config文件夹：webpack配置相关\n2. node_modules文件夹：npm install安装的依赖代码库\n3. src文件夹：存放项目源码\n4. static文件夹：存放第三方静态资源\n5. .babelrc文件：babel的配置（大多数浏览器不能直接支持ES6，则需通过babel编译成ES5）\n6. .editorconfig文件：编译器的配置\n7. .eslintignore文件：忽略语法检查的目录文件（忽略对build和config进行ES6语法检查）\n8. .eslintrc.js：eslint的配置文件\n9. .gitignore文件：使git仓库忽略里边的文件或者目录\n10. index.html：编译过程中会自动插入到这个html中\n11. package.json：项目的配置文件\n12. README.md：项目的描述文件\n\n#### 运行\n- 创建组件\n\n 创建一个.vue对象，由三部分组成：template、script、style，其中在script中使用export default导出一个对象（里面为组件的各种选项、属性）\n \n- 使用组件\n## 打包上线\n\n```\n$ npm run build\n```\n\n## 所遇到的坑 \n1. 使用vue安装项目文件后，若提示版本过低，则需把node、npm、cnpm全部升级到最新版本\n2. 命令cnpm install需要在==项目文件目录下==运行，若还运行不了，再找其他原因\n\n# vue-cli 3.0","source":"_posts/vue/Vue-cli脚手架.md","raw":"---\ntitle: Vue-cli脚手架\nDate: 2020-03-17\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n# vue-cli\n\n## 介绍\n\nVue-cli是Vue的脚手架工具  \n\n脚手架：在工地上，是帮助工人们作业的搭建好的架子；在技术上，是编写好基础代码的工具。\n\n## 安装环境\n\n查看版本（具体安装方法百度很多）\n\n```\n$ node -v\n$ npm -v\n$ cnpm -v\n```\n\n# vue-cli 1.x或2.x\n\n## 全局安装\n\n\n```\n$ npm install -g vue-cli\n$ cnpm install -g vue-cli //国内镜像安装，较快\n```\n若安装失败，则先[清理缓存](https://sivanwong.github.io/2018/05/03/npm%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/)，再重新安装\n\n\n查看版本\n\n```\n$ vue -V\n```\n\n## 生成项目\n\n#### 生成项目文件夹\n```\n$ vue init <template-name> <project-name>\n```\n\n输入命令后，会跳出几个选项让你回答：\n\n- Project name (baoge)：          \n项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。\n- Project description (A Vue.js project)：  \n项目描述，也可直接点击回车，使用默认名字\n- Author ()： 作者，输入你的大名\n\n接下来会让用户选择：\n- Runtime + Compiler: recommended for most users                 \n运行加编译，既然已经说了推荐，就选它了\n- Runtime-only:  about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere                 \n仅运行时，已经有推荐了就选择第一个了\n- Install vue-router? (Y/n)               \n是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。\n- Use ESLint to lint your code? (Y/n)       \n是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。\n- 接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车   \n- Setup unit tests with Karma + Mocha? (Y/n)    \n是否安装单元测试，我选择安装y回车\n- Setup e2e tests with Nightwatch(Y/n)?   \n是否安装e2e测试 ，我选择安装y回车\n\n一般一路回车就好了\n\nOfficial Templates\n- webpack（常用）\n- webpack-simplae\n- browaerify\n- browserify-simple\n- simple\n- 自定义\n\n#### 运行 （在项目文件目录下运行）\n```\n$ cnpm install\n```\n\n```\n$ npm run dev\n```\n\n\n## 项目文件\n\n#### 介绍\n1. build和config文件夹：webpack配置相关\n2. node_modules文件夹：npm install安装的依赖代码库\n3. src文件夹：存放项目源码\n4. static文件夹：存放第三方静态资源\n5. .babelrc文件：babel的配置（大多数浏览器不能直接支持ES6，则需通过babel编译成ES5）\n6. .editorconfig文件：编译器的配置\n7. .eslintignore文件：忽略语法检查的目录文件（忽略对build和config进行ES6语法检查）\n8. .eslintrc.js：eslint的配置文件\n9. .gitignore文件：使git仓库忽略里边的文件或者目录\n10. index.html：编译过程中会自动插入到这个html中\n11. package.json：项目的配置文件\n12. README.md：项目的描述文件\n\n#### 运行\n- 创建组件\n\n 创建一个.vue对象，由三部分组成：template、script、style，其中在script中使用export default导出一个对象（里面为组件的各种选项、属性）\n \n- 使用组件\n## 打包上线\n\n```\n$ npm run build\n```\n\n## 所遇到的坑 \n1. 使用vue安装项目文件后，若提示版本过低，则需把node、npm、cnpm全部升级到最新版本\n2. 命令cnpm install需要在==项目文件目录下==运行，若还运行不了，再找其他原因\n\n# vue-cli 3.0","slug":"vue/Vue-cli脚手架","published":1,"date":"2020-03-17T08:20:54.601Z","updated":"2020-03-17T08:23:09.556Z","layout":"post","photos":[],"link":"","_id":"cka6kin31003aqgu9t512cwh9","content":"<h1 id=\"vue-cli\"><a href=\"#vue-cli\" class=\"headerlink\" title=\"vue-cli\"></a>vue-cli</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Vue-cli是Vue的脚手架工具  </p>\n<p>脚手架：在工地上，是帮助工人们作业的搭建好的架子；在技术上，是编写好基础代码的工具。</p>\n<h2 id=\"安装环境\"><a href=\"#安装环境\" class=\"headerlink\" title=\"安装环境\"></a>安装环境</h2><p>查看版本（具体安装方法百度很多）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\">$ cnpm -v</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue-cli-1-x或2-x\"><a href=\"#vue-cli-1-x或2-x\" class=\"headerlink\" title=\"vue-cli 1.x或2.x\"></a>vue-cli 1.x或2.x</h1><h2 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g vue-cli</span><br><span class=\"line\">$ cnpm install -g vue-cli //国内镜像安装，较快</span><br></pre></td></tr></table></figure>\n<p>若安装失败，则先<a href=\"https://sivanwong.github.io/2018/05/03/npm%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/\" target=\"_blank\" rel=\"noopener\">清理缓存</a>，再重新安装</p>\n<p>查看版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vue -V</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成项目\"><a href=\"#生成项目\" class=\"headerlink\" title=\"生成项目\"></a>生成项目</h2><h4 id=\"生成项目文件夹\"><a href=\"#生成项目文件夹\" class=\"headerlink\" title=\"生成项目文件夹\"></a>生成项目文件夹</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vue init &lt;template-name&gt; &lt;project-name&gt;</span><br></pre></td></tr></table></figure>\n<p>输入命令后，会跳出几个选项让你回答：</p>\n<ul>\n<li>Project name (baoge)：<br>项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。</li>\n<li>Project description (A Vue.js project)：<br>项目描述，也可直接点击回车，使用默认名字</li>\n<li>Author ()： 作者，输入你的大名</li>\n</ul>\n<p>接下来会让用户选择：</p>\n<ul>\n<li>Runtime + Compiler: recommended for most users<br>运行加编译，既然已经说了推荐，就选它了</li>\n<li>Runtime-only:  about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere<br>仅运行时，已经有推荐了就选择第一个了</li>\n<li>Install vue-router? (Y/n)<br>是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。</li>\n<li>Use ESLint to lint your code? (Y/n)<br>是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。</li>\n<li>接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车   </li>\n<li>Setup unit tests with Karma + Mocha? (Y/n)<br>是否安装单元测试，我选择安装y回车</li>\n<li>Setup e2e tests with Nightwatch(Y/n)?<br>是否安装e2e测试 ，我选择安装y回车</li>\n</ul>\n<p>一般一路回车就好了</p>\n<p>Official Templates</p>\n<ul>\n<li>webpack（常用）</li>\n<li>webpack-simplae</li>\n<li>browaerify</li>\n<li>browserify-simple</li>\n<li>simple</li>\n<li>自定义</li>\n</ul>\n<h4 id=\"运行-（在项目文件目录下运行）\"><a href=\"#运行-（在项目文件目录下运行）\" class=\"headerlink\" title=\"运行 （在项目文件目录下运行）\"></a>运行 （在项目文件目录下运行）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"项目文件\"><a href=\"#项目文件\" class=\"headerlink\" title=\"项目文件\"></a>项目文件</h2><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li>build和config文件夹：webpack配置相关</li>\n<li>node_modules文件夹：npm install安装的依赖代码库</li>\n<li>src文件夹：存放项目源码</li>\n<li>static文件夹：存放第三方静态资源</li>\n<li>.babelrc文件：babel的配置（大多数浏览器不能直接支持ES6，则需通过babel编译成ES5）</li>\n<li>.editorconfig文件：编译器的配置</li>\n<li>.eslintignore文件：忽略语法检查的目录文件（忽略对build和config进行ES6语法检查）</li>\n<li>.eslintrc.js：eslint的配置文件</li>\n<li>.gitignore文件：使git仓库忽略里边的文件或者目录</li>\n<li>index.html：编译过程中会自动插入到这个html中</li>\n<li>package.json：项目的配置文件</li>\n<li>README.md：项目的描述文件</li>\n</ol>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><ul>\n<li><p>创建组件</p>\n<p>创建一个.vue对象，由三部分组成：template、script、style，其中在script中使用export default导出一个对象（里面为组件的各种选项、属性）</p>\n</li>\n<li><p>使用组件</p>\n<h2 id=\"打包上线\"><a href=\"#打包上线\" class=\"headerlink\" title=\"打包上线\"></a>打包上线</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run build</span><br></pre></td></tr></table></figure>\n<h2 id=\"所遇到的坑\"><a href=\"#所遇到的坑\" class=\"headerlink\" title=\"所遇到的坑\"></a>所遇到的坑</h2><ol>\n<li>使用vue安装项目文件后，若提示版本过低，则需把node、npm、cnpm全部升级到最新版本</li>\n<li>命令cnpm install需要在==项目文件目录下==运行，若还运行不了，再找其他原因</li>\n</ol>\n<h1 id=\"vue-cli-3-0\"><a href=\"#vue-cli-3-0\" class=\"headerlink\" title=\"vue-cli 3.0\"></a>vue-cli 3.0</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue-cli\"><a href=\"#vue-cli\" class=\"headerlink\" title=\"vue-cli\"></a>vue-cli</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Vue-cli是Vue的脚手架工具  </p>\n<p>脚手架：在工地上，是帮助工人们作业的搭建好的架子；在技术上，是编写好基础代码的工具。</p>\n<h2 id=\"安装环境\"><a href=\"#安装环境\" class=\"headerlink\" title=\"安装环境\"></a>安装环境</h2><p>查看版本（具体安装方法百度很多）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\">$ cnpm -v</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue-cli-1-x或2-x\"><a href=\"#vue-cli-1-x或2-x\" class=\"headerlink\" title=\"vue-cli 1.x或2.x\"></a>vue-cli 1.x或2.x</h1><h2 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g vue-cli</span><br><span class=\"line\">$ cnpm install -g vue-cli //国内镜像安装，较快</span><br></pre></td></tr></table></figure>\n<p>若安装失败，则先<a href=\"https://sivanwong.github.io/2018/05/03/npm%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/\" target=\"_blank\" rel=\"noopener\">清理缓存</a>，再重新安装</p>\n<p>查看版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vue -V</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成项目\"><a href=\"#生成项目\" class=\"headerlink\" title=\"生成项目\"></a>生成项目</h2><h4 id=\"生成项目文件夹\"><a href=\"#生成项目文件夹\" class=\"headerlink\" title=\"生成项目文件夹\"></a>生成项目文件夹</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vue init &lt;template-name&gt; &lt;project-name&gt;</span><br></pre></td></tr></table></figure>\n<p>输入命令后，会跳出几个选项让你回答：</p>\n<ul>\n<li>Project name (baoge)：<br>项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。</li>\n<li>Project description (A Vue.js project)：<br>项目描述，也可直接点击回车，使用默认名字</li>\n<li>Author ()： 作者，输入你的大名</li>\n</ul>\n<p>接下来会让用户选择：</p>\n<ul>\n<li>Runtime + Compiler: recommended for most users<br>运行加编译，既然已经说了推荐，就选它了</li>\n<li>Runtime-only:  about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere<br>仅运行时，已经有推荐了就选择第一个了</li>\n<li>Install vue-router? (Y/n)<br>是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。</li>\n<li>Use ESLint to lint your code? (Y/n)<br>是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。</li>\n<li>接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车   </li>\n<li>Setup unit tests with Karma + Mocha? (Y/n)<br>是否安装单元测试，我选择安装y回车</li>\n<li>Setup e2e tests with Nightwatch(Y/n)?<br>是否安装e2e测试 ，我选择安装y回车</li>\n</ul>\n<p>一般一路回车就好了</p>\n<p>Official Templates</p>\n<ul>\n<li>webpack（常用）</li>\n<li>webpack-simplae</li>\n<li>browaerify</li>\n<li>browserify-simple</li>\n<li>simple</li>\n<li>自定义</li>\n</ul>\n<h4 id=\"运行-（在项目文件目录下运行）\"><a href=\"#运行-（在项目文件目录下运行）\" class=\"headerlink\" title=\"运行 （在项目文件目录下运行）\"></a>运行 （在项目文件目录下运行）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"项目文件\"><a href=\"#项目文件\" class=\"headerlink\" title=\"项目文件\"></a>项目文件</h2><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li>build和config文件夹：webpack配置相关</li>\n<li>node_modules文件夹：npm install安装的依赖代码库</li>\n<li>src文件夹：存放项目源码</li>\n<li>static文件夹：存放第三方静态资源</li>\n<li>.babelrc文件：babel的配置（大多数浏览器不能直接支持ES6，则需通过babel编译成ES5）</li>\n<li>.editorconfig文件：编译器的配置</li>\n<li>.eslintignore文件：忽略语法检查的目录文件（忽略对build和config进行ES6语法检查）</li>\n<li>.eslintrc.js：eslint的配置文件</li>\n<li>.gitignore文件：使git仓库忽略里边的文件或者目录</li>\n<li>index.html：编译过程中会自动插入到这个html中</li>\n<li>package.json：项目的配置文件</li>\n<li>README.md：项目的描述文件</li>\n</ol>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><ul>\n<li><p>创建组件</p>\n<p>创建一个.vue对象，由三部分组成：template、script、style，其中在script中使用export default导出一个对象（里面为组件的各种选项、属性）</p>\n</li>\n<li><p>使用组件</p>\n<h2 id=\"打包上线\"><a href=\"#打包上线\" class=\"headerlink\" title=\"打包上线\"></a>打包上线</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run build</span><br></pre></td></tr></table></figure>\n<h2 id=\"所遇到的坑\"><a href=\"#所遇到的坑\" class=\"headerlink\" title=\"所遇到的坑\"></a>所遇到的坑</h2><ol>\n<li>使用vue安装项目文件后，若提示版本过低，则需把node、npm、cnpm全部升级到最新版本</li>\n<li>命令cnpm install需要在==项目文件目录下==运行，若还运行不了，再找其他原因</li>\n</ol>\n<h1 id=\"vue-cli-3-0\"><a href=\"#vue-cli-3-0\" class=\"headerlink\" title=\"vue-cli 3.0\"></a>vue-cli 3.0</h1>"},{"title":"vue：其他","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n### 如何理解vue\nvue是一套用于构建用户界面的渐进式框架，采用MVVM架构。其核心库只关注视图层，采用自底向上增量开发的设计。vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。\n\n优势：\n- 低耦合。视图可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n- 简单的语法及项目创建，提供vue-cli脚手架，能非常容易地构建项目。\n- 更快的渲染速度和更小的体积。\n\n缺点：不支持IE8。\n\n### vuex(可以在vue1.0使用)\nvue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。\n\n场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n\n\n### vue1.0和vue2.0的区别\n#### 生命周期不一样\nvue1.0：init、created、beforeCompile、compiled、ready、beforeDestroy、destroyed\n\nvue2.0：beforeCreate、created、beforeMount、mounted、beforeUpload、uploaded、beforeDestroy、destroyed\n\n#### 绑定一次\n```\nvue1.0：{{*msg}}\nvue2.0：v-once，上述已废除\n```\n#### 绑定html代码\n```\nvue1.0：{{{msg}}}\nvue2.0：v-html，上述已废除\n```\n","source":"_posts/vue/vue：其他.md","raw":"---\ntitle: vue：其他\nDate: 2019-03-26\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n### 如何理解vue\nvue是一套用于构建用户界面的渐进式框架，采用MVVM架构。其核心库只关注视图层，采用自底向上增量开发的设计。vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。\n\n优势：\n- 低耦合。视图可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n- 简单的语法及项目创建，提供vue-cli脚手架，能非常容易地构建项目。\n- 更快的渲染速度和更小的体积。\n\n缺点：不支持IE8。\n\n### vuex(可以在vue1.0使用)\nvue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。\n\n场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n\n\n### vue1.0和vue2.0的区别\n#### 生命周期不一样\nvue1.0：init、created、beforeCompile、compiled、ready、beforeDestroy、destroyed\n\nvue2.0：beforeCreate、created、beforeMount、mounted、beforeUpload、uploaded、beforeDestroy、destroyed\n\n#### 绑定一次\n```\nvue1.0：{{*msg}}\nvue2.0：v-once，上述已废除\n```\n#### 绑定html代码\n```\nvue1.0：{{{msg}}}\nvue2.0：v-html，上述已废除\n```\n","slug":"vue/vue：其他","published":1,"date":"2019-03-26T07:49:17.995Z","updated":"2019-03-26T09:02:27.965Z","layout":"post","photos":[],"link":"","_id":"cka6kin3b003dqgu9gx4pf8ht","content":"<h3 id=\"如何理解vue\"><a href=\"#如何理解vue\" class=\"headerlink\" title=\"如何理解vue\"></a>如何理解vue</h3><p>vue是一套用于构建用户界面的渐进式框架，采用MVVM架构。其核心库只关注视图层，采用自底向上增量开发的设计。vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。</p>\n<p>优势：</p>\n<ul>\n<li>低耦合。视图可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>\n<li>简单的语法及项目创建，提供vue-cli脚手架，能非常容易地构建项目。</li>\n<li>更快的渲染速度和更小的体积。</li>\n</ul>\n<p>缺点：不支持IE8。</p>\n<h3 id=\"vuex-可以在vue1-0使用\"><a href=\"#vuex-可以在vue1-0使用\" class=\"headerlink\" title=\"vuex(可以在vue1.0使用)\"></a>vuex(可以在vue1.0使用)</h3><p>vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。</p>\n<p>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>\n<h3 id=\"vue1-0和vue2-0的区别\"><a href=\"#vue1-0和vue2-0的区别\" class=\"headerlink\" title=\"vue1.0和vue2.0的区别\"></a>vue1.0和vue2.0的区别</h3><h4 id=\"生命周期不一样\"><a href=\"#生命周期不一样\" class=\"headerlink\" title=\"生命周期不一样\"></a>生命周期不一样</h4><p>vue1.0：init、created、beforeCompile、compiled、ready、beforeDestroy、destroyed</p>\n<p>vue2.0：beforeCreate、created、beforeMount、mounted、beforeUpload、uploaded、beforeDestroy、destroyed</p>\n<h4 id=\"绑定一次\"><a href=\"#绑定一次\" class=\"headerlink\" title=\"绑定一次\"></a>绑定一次</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue1.0：&#123;&#123;*msg&#125;&#125;</span><br><span class=\"line\">vue2.0：v-once，上述已废除</span><br></pre></td></tr></table></figure>\n<h4 id=\"绑定html代码\"><a href=\"#绑定html代码\" class=\"headerlink\" title=\"绑定html代码\"></a>绑定html代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue1.0：&#123;&#123;&#123;msg&#125;&#125;&#125;</span><br><span class=\"line\">vue2.0：v-html，上述已废除</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"如何理解vue\"><a href=\"#如何理解vue\" class=\"headerlink\" title=\"如何理解vue\"></a>如何理解vue</h3><p>vue是一套用于构建用户界面的渐进式框架，采用MVVM架构。其核心库只关注视图层，采用自底向上增量开发的设计。vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。</p>\n<p>优势：</p>\n<ul>\n<li>低耦合。视图可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>\n<li>简单的语法及项目创建，提供vue-cli脚手架，能非常容易地构建项目。</li>\n<li>更快的渲染速度和更小的体积。</li>\n</ul>\n<p>缺点：不支持IE8。</p>\n<h3 id=\"vuex-可以在vue1-0使用\"><a href=\"#vuex-可以在vue1-0使用\" class=\"headerlink\" title=\"vuex(可以在vue1.0使用)\"></a>vuex(可以在vue1.0使用)</h3><p>vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。</p>\n<p>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>\n<h3 id=\"vue1-0和vue2-0的区别\"><a href=\"#vue1-0和vue2-0的区别\" class=\"headerlink\" title=\"vue1.0和vue2.0的区别\"></a>vue1.0和vue2.0的区别</h3><h4 id=\"生命周期不一样\"><a href=\"#生命周期不一样\" class=\"headerlink\" title=\"生命周期不一样\"></a>生命周期不一样</h4><p>vue1.0：init、created、beforeCompile、compiled、ready、beforeDestroy、destroyed</p>\n<p>vue2.0：beforeCreate、created、beforeMount、mounted、beforeUpload、uploaded、beforeDestroy、destroyed</p>\n<h4 id=\"绑定一次\"><a href=\"#绑定一次\" class=\"headerlink\" title=\"绑定一次\"></a>绑定一次</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue1.0：&#123;&#123;*msg&#125;&#125;</span><br><span class=\"line\">vue2.0：v-once，上述已废除</span><br></pre></td></tr></table></figure>\n<h4 id=\"绑定html代码\"><a href=\"#绑定html代码\" class=\"headerlink\" title=\"绑定html代码\"></a>绑定html代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue1.0：&#123;&#123;&#123;msg&#125;&#125;&#125;</span><br><span class=\"line\">vue2.0：v-html，上述已废除</span><br></pre></td></tr></table></figure>\n"},{"title":"vue：数据双向绑定原理","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()（相当于observer）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n \n-  observer：遍历data中的属性，使用Object.defineProperty()的get/set方法对其进行数据劫持。\n-  dep：每个属性拥有自己的消息订阅器dep，用于存放所有订阅了该属性的观察者对象。\n-  watcher：观察者（对象），通过dep实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。\n \n 要对数据进行劫持监听，我们需要设置数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并发布通知（给dep）。\n \n 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。\n \n 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数。\n \n 当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。\n \n\n \n###  拓展\n####  Object.defineProperty\n```\n//在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\nObject.defineProperty(obj, prop, descriptor)\n//obj 要在其上定义属性的对象。\n//prop 要定义或修改的属性的名称。\n//descriptor  将被定义或修改的属性描述符。 \n```\nobject.defineproperty()缺点\n- 无法监听数组的变化（把对象属性换成数组就无法监听）\n- 只能劫持对象的属性，不能劫持完整的对象（若对象属性为一个对象，则无法深度遍历劫持）\n\n#### 计算属性\n计算属性computed：一个属性通过其他属性计算而来\n\n#### 侦听器\n就是检测某一属性是否发生变化，一旦发生变化，我们就可以在侦听器里面写一下业务逻辑","source":"_posts/vue/vue：数据双向绑定原理.md","raw":"---\ntitle: vue：数据双向绑定原理\nDate: 2020-03-17\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()（相当于observer）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n \n-  observer：遍历data中的属性，使用Object.defineProperty()的get/set方法对其进行数据劫持。\n-  dep：每个属性拥有自己的消息订阅器dep，用于存放所有订阅了该属性的观察者对象。\n-  watcher：观察者（对象），通过dep实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。\n \n 要对数据进行劫持监听，我们需要设置数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并发布通知（给dep）。\n \n 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。\n \n 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数。\n \n 当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。\n \n\n \n###  拓展\n####  Object.defineProperty\n```\n//在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\nObject.defineProperty(obj, prop, descriptor)\n//obj 要在其上定义属性的对象。\n//prop 要定义或修改的属性的名称。\n//descriptor  将被定义或修改的属性描述符。 \n```\nobject.defineproperty()缺点\n- 无法监听数组的变化（把对象属性换成数组就无法监听）\n- 只能劫持对象的属性，不能劫持完整的对象（若对象属性为一个对象，则无法深度遍历劫持）\n\n#### 计算属性\n计算属性computed：一个属性通过其他属性计算而来\n\n#### 侦听器\n就是检测某一属性是否发生变化，一旦发生变化，我们就可以在侦听器里面写一下业务逻辑","slug":"vue/vue：数据双向绑定原理","published":1,"date":"2020-03-17T08:21:25.512Z","updated":"2020-03-17T08:24:34.280Z","layout":"post","photos":[],"link":"","_id":"cka6kin3b003hqgu96gfhm3x2","content":"<p> vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()（相当于observer）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<ul>\n<li>observer：遍历data中的属性，使用Object.defineProperty()的get/set方法对其进行数据劫持。</li>\n<li>dep：每个属性拥有自己的消息订阅器dep，用于存放所有订阅了该属性的观察者对象。</li>\n<li><p>watcher：观察者（对象），通过dep实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。</p>\n<p>要对数据进行劫持监听，我们需要设置数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并发布通知（给dep）。</p>\n<p>因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。</p>\n<p>接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数。</p>\n<p>当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p>\n</li>\n</ul>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><h4 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</span><br><span class=\"line\">Object.defineProperty(obj, prop, descriptor)</span><br><span class=\"line\">//obj 要在其上定义属性的对象。</span><br><span class=\"line\">//prop 要定义或修改的属性的名称。</span><br><span class=\"line\">//descriptor  将被定义或修改的属性描述符。</span><br></pre></td></tr></table></figure>\n<p>object.defineproperty()缺点</p>\n<ul>\n<li>无法监听数组的变化（把对象属性换成数组就无法监听）</li>\n<li>只能劫持对象的属性，不能劫持完整的对象（若对象属性为一个对象，则无法深度遍历劫持）</li>\n</ul>\n<h4 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h4><p>计算属性computed：一个属性通过其他属性计算而来</p>\n<h4 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h4><p>就是检测某一属性是否发生变化，一旦发生变化，我们就可以在侦听器里面写一下业务逻辑</p>\n","site":{"data":{}},"excerpt":"","more":"<p> vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()（相当于observer）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<ul>\n<li>observer：遍历data中的属性，使用Object.defineProperty()的get/set方法对其进行数据劫持。</li>\n<li>dep：每个属性拥有自己的消息订阅器dep，用于存放所有订阅了该属性的观察者对象。</li>\n<li><p>watcher：观察者（对象），通过dep实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。</p>\n<p>要对数据进行劫持监听，我们需要设置数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并发布通知（给dep）。</p>\n<p>因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。</p>\n<p>接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数。</p>\n<p>当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p>\n</li>\n</ul>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><h4 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</span><br><span class=\"line\">Object.defineProperty(obj, prop, descriptor)</span><br><span class=\"line\">//obj 要在其上定义属性的对象。</span><br><span class=\"line\">//prop 要定义或修改的属性的名称。</span><br><span class=\"line\">//descriptor  将被定义或修改的属性描述符。</span><br></pre></td></tr></table></figure>\n<p>object.defineproperty()缺点</p>\n<ul>\n<li>无法监听数组的变化（把对象属性换成数组就无法监听）</li>\n<li>只能劫持对象的属性，不能劫持完整的对象（若对象属性为一个对象，则无法深度遍历劫持）</li>\n</ul>\n<h4 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h4><p>计算属性computed：一个属性通过其他属性计算而来</p>\n<h4 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h4><p>就是检测某一属性是否发生变化，一旦发生变化，我们就可以在侦听器里面写一下业务逻辑</p>\n"},{"title":"vue：生命周期","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n![image](https://user-gold-cdn.xitu.io/2018/4/14/162c087d49e9be5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n## 8个阶段\n\n### 创建前(beforeCreate)\n在数据观测和初始化事件还未开始时。\n### 创建后(created)\n完成数据观测，属性和方法的运算，初始化事件，el属性还没有显示出来。\n### 载入前(beforeMount)\n在挂载开始之前被调用，相关的render函数首次被调用。vue实例的el和data都初始化了，生成了html，但还没有挂载html到页面上。\n### 载入后(mounted)\nvue实例挂载完成，html页面成功渲染。\n### 更新前(beforeUpdate)\n在数据更新之前调用。\n### 更新后(updated)\n调用时，组件DOM已经更新，可以执行依赖于DOM的操作。\n### 销毁前(beforeDestroy)\n在实例销毁之前调用。实例仍然完全可用。\n### 销毁后(destroy)\n在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。\n\n\n## 相关问题\n\n### 什么是vue生命周期？\n答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。\n\n### vue生命周期的作用是什么？\n答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。\n\n### vue生命周期总共有几个阶段？\n答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后\n\n### 第一次页面加载会触发哪几个钩子？\n答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子\n\n### DOM 渲染、挂载在哪个周期中就已经完成？\n答：DOM 渲染、挂载在 mounted 中就已经完成了。\n\n### vue能不能挂载到body或html标签上？\n提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载vue实例到html或者body标签上。\n\n### 简单描述每个周期具体适合哪些场景？\n答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom\n","source":"_posts/vue/vue：生命周期.md","raw":"---\ntitle: vue：生命周期\nDate: 2020-03-17\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n![image](https://user-gold-cdn.xitu.io/2018/4/14/162c087d49e9be5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n## 8个阶段\n\n### 创建前(beforeCreate)\n在数据观测和初始化事件还未开始时。\n### 创建后(created)\n完成数据观测，属性和方法的运算，初始化事件，el属性还没有显示出来。\n### 载入前(beforeMount)\n在挂载开始之前被调用，相关的render函数首次被调用。vue实例的el和data都初始化了，生成了html，但还没有挂载html到页面上。\n### 载入后(mounted)\nvue实例挂载完成，html页面成功渲染。\n### 更新前(beforeUpdate)\n在数据更新之前调用。\n### 更新后(updated)\n调用时，组件DOM已经更新，可以执行依赖于DOM的操作。\n### 销毁前(beforeDestroy)\n在实例销毁之前调用。实例仍然完全可用。\n### 销毁后(destroy)\n在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。\n\n\n## 相关问题\n\n### 什么是vue生命周期？\n答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。\n\n### vue生命周期的作用是什么？\n答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。\n\n### vue生命周期总共有几个阶段？\n答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后\n\n### 第一次页面加载会触发哪几个钩子？\n答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子\n\n### DOM 渲染、挂载在哪个周期中就已经完成？\n答：DOM 渲染、挂载在 mounted 中就已经完成了。\n\n### vue能不能挂载到body或html标签上？\n提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载vue实例到html或者body标签上。\n\n### 简单描述每个周期具体适合哪些场景？\n答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom\n","slug":"vue/vue：生命周期","published":1,"date":"2020-03-17T08:20:48.232Z","updated":"2020-03-17T08:22:16.966Z","layout":"post","photos":[],"link":"","_id":"cka6kin3l003jqgu9m6efo7lk","content":"<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/14/162c087d49e9be5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h2 id=\"8个阶段\"><a href=\"#8个阶段\" class=\"headerlink\" title=\"8个阶段\"></a>8个阶段</h2><h3 id=\"创建前-beforeCreate\"><a href=\"#创建前-beforeCreate\" class=\"headerlink\" title=\"创建前(beforeCreate)\"></a>创建前(beforeCreate)</h3><p>在数据观测和初始化事件还未开始时。</p>\n<h3 id=\"创建后-created\"><a href=\"#创建后-created\" class=\"headerlink\" title=\"创建后(created)\"></a>创建后(created)</h3><p>完成数据观测，属性和方法的运算，初始化事件，el属性还没有显示出来。</p>\n<h3 id=\"载入前-beforeMount\"><a href=\"#载入前-beforeMount\" class=\"headerlink\" title=\"载入前(beforeMount)\"></a>载入前(beforeMount)</h3><p>在挂载开始之前被调用，相关的render函数首次被调用。vue实例的el和data都初始化了，生成了html，但还没有挂载html到页面上。</p>\n<h3 id=\"载入后-mounted\"><a href=\"#载入后-mounted\" class=\"headerlink\" title=\"载入后(mounted)\"></a>载入后(mounted)</h3><p>vue实例挂载完成，html页面成功渲染。</p>\n<h3 id=\"更新前-beforeUpdate\"><a href=\"#更新前-beforeUpdate\" class=\"headerlink\" title=\"更新前(beforeUpdate)\"></a>更新前(beforeUpdate)</h3><p>在数据更新之前调用。</p>\n<h3 id=\"更新后-updated\"><a href=\"#更新后-updated\" class=\"headerlink\" title=\"更新后(updated)\"></a>更新后(updated)</h3><p>调用时，组件DOM已经更新，可以执行依赖于DOM的操作。</p>\n<h3 id=\"销毁前-beforeDestroy\"><a href=\"#销毁前-beforeDestroy\" class=\"headerlink\" title=\"销毁前(beforeDestroy)\"></a>销毁前(beforeDestroy)</h3><p>在实例销毁之前调用。实例仍然完全可用。</p>\n<h3 id=\"销毁后-destroy\"><a href=\"#销毁后-destroy\" class=\"headerlink\" title=\"销毁后(destroy)\"></a>销毁后(destroy)</h3><p>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>\n<h2 id=\"相关问题\"><a href=\"#相关问题\" class=\"headerlink\" title=\"相关问题\"></a>相关问题</h2><h3 id=\"什么是vue生命周期？\"><a href=\"#什么是vue生命周期？\" class=\"headerlink\" title=\"什么是vue生命周期？\"></a>什么是vue生命周期？</h3><p>答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>\n<h3 id=\"vue生命周期的作用是什么？\"><a href=\"#vue生命周期的作用是什么？\" class=\"headerlink\" title=\"vue生命周期的作用是什么？\"></a>vue生命周期的作用是什么？</h3><p>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>\n<h3 id=\"vue生命周期总共有几个阶段？\"><a href=\"#vue生命周期总共有几个阶段？\" class=\"headerlink\" title=\"vue生命周期总共有几个阶段？\"></a>vue生命周期总共有几个阶段？</h3><p>答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>\n<h3 id=\"第一次页面加载会触发哪几个钩子？\"><a href=\"#第一次页面加载会触发哪几个钩子？\" class=\"headerlink\" title=\"第一次页面加载会触发哪几个钩子？\"></a>第一次页面加载会触发哪几个钩子？</h3><p>答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p>\n<h3 id=\"DOM-渲染、挂载在哪个周期中就已经完成？\"><a href=\"#DOM-渲染、挂载在哪个周期中就已经完成？\" class=\"headerlink\" title=\"DOM 渲染、挂载在哪个周期中就已经完成？\"></a>DOM 渲染、挂载在哪个周期中就已经完成？</h3><p>答：DOM 渲染、挂载在 mounted 中就已经完成了。</p>\n<h3 id=\"vue能不能挂载到body或html标签上？\"><a href=\"#vue能不能挂载到body或html标签上？\" class=\"headerlink\" title=\"vue能不能挂载到body或html标签上？\"></a>vue能不能挂载到body或html标签上？</h3><p>提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载vue实例到html或者body标签上。</p>\n<h3 id=\"简单描述每个周期具体适合哪些场景？\"><a href=\"#简单描述每个周期具体适合哪些场景？\" class=\"headerlink\" title=\"简单描述每个周期具体适合哪些场景？\"></a>简单描述每个周期具体适合哪些场景？</h3><p>答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/14/162c087d49e9be5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h2 id=\"8个阶段\"><a href=\"#8个阶段\" class=\"headerlink\" title=\"8个阶段\"></a>8个阶段</h2><h3 id=\"创建前-beforeCreate\"><a href=\"#创建前-beforeCreate\" class=\"headerlink\" title=\"创建前(beforeCreate)\"></a>创建前(beforeCreate)</h3><p>在数据观测和初始化事件还未开始时。</p>\n<h3 id=\"创建后-created\"><a href=\"#创建后-created\" class=\"headerlink\" title=\"创建后(created)\"></a>创建后(created)</h3><p>完成数据观测，属性和方法的运算，初始化事件，el属性还没有显示出来。</p>\n<h3 id=\"载入前-beforeMount\"><a href=\"#载入前-beforeMount\" class=\"headerlink\" title=\"载入前(beforeMount)\"></a>载入前(beforeMount)</h3><p>在挂载开始之前被调用，相关的render函数首次被调用。vue实例的el和data都初始化了，生成了html，但还没有挂载html到页面上。</p>\n<h3 id=\"载入后-mounted\"><a href=\"#载入后-mounted\" class=\"headerlink\" title=\"载入后(mounted)\"></a>载入后(mounted)</h3><p>vue实例挂载完成，html页面成功渲染。</p>\n<h3 id=\"更新前-beforeUpdate\"><a href=\"#更新前-beforeUpdate\" class=\"headerlink\" title=\"更新前(beforeUpdate)\"></a>更新前(beforeUpdate)</h3><p>在数据更新之前调用。</p>\n<h3 id=\"更新后-updated\"><a href=\"#更新后-updated\" class=\"headerlink\" title=\"更新后(updated)\"></a>更新后(updated)</h3><p>调用时，组件DOM已经更新，可以执行依赖于DOM的操作。</p>\n<h3 id=\"销毁前-beforeDestroy\"><a href=\"#销毁前-beforeDestroy\" class=\"headerlink\" title=\"销毁前(beforeDestroy)\"></a>销毁前(beforeDestroy)</h3><p>在实例销毁之前调用。实例仍然完全可用。</p>\n<h3 id=\"销毁后-destroy\"><a href=\"#销毁后-destroy\" class=\"headerlink\" title=\"销毁后(destroy)\"></a>销毁后(destroy)</h3><p>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>\n<h2 id=\"相关问题\"><a href=\"#相关问题\" class=\"headerlink\" title=\"相关问题\"></a>相关问题</h2><h3 id=\"什么是vue生命周期？\"><a href=\"#什么是vue生命周期？\" class=\"headerlink\" title=\"什么是vue生命周期？\"></a>什么是vue生命周期？</h3><p>答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>\n<h3 id=\"vue生命周期的作用是什么？\"><a href=\"#vue生命周期的作用是什么？\" class=\"headerlink\" title=\"vue生命周期的作用是什么？\"></a>vue生命周期的作用是什么？</h3><p>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>\n<h3 id=\"vue生命周期总共有几个阶段？\"><a href=\"#vue生命周期总共有几个阶段？\" class=\"headerlink\" title=\"vue生命周期总共有几个阶段？\"></a>vue生命周期总共有几个阶段？</h3><p>答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>\n<h3 id=\"第一次页面加载会触发哪几个钩子？\"><a href=\"#第一次页面加载会触发哪几个钩子？\" class=\"headerlink\" title=\"第一次页面加载会触发哪几个钩子？\"></a>第一次页面加载会触发哪几个钩子？</h3><p>答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p>\n<h3 id=\"DOM-渲染、挂载在哪个周期中就已经完成？\"><a href=\"#DOM-渲染、挂载在哪个周期中就已经完成？\" class=\"headerlink\" title=\"DOM 渲染、挂载在哪个周期中就已经完成？\"></a>DOM 渲染、挂载在哪个周期中就已经完成？</h3><p>答：DOM 渲染、挂载在 mounted 中就已经完成了。</p>\n<h3 id=\"vue能不能挂载到body或html标签上？\"><a href=\"#vue能不能挂载到body或html标签上？\" class=\"headerlink\" title=\"vue能不能挂载到body或html标签上？\"></a>vue能不能挂载到body或html标签上？</h3><p>提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载vue实例到html或者body标签上。</p>\n<h3 id=\"简单描述每个周期具体适合哪些场景？\"><a href=\"#简单描述每个周期具体适合哪些场景？\" class=\"headerlink\" title=\"简单描述每个周期具体适合哪些场景？\"></a>简单描述每个周期具体适合哪些场景？</h3><p>答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom</p>\n"},{"title":"vue：组件间的传值","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### 父组件向子组件传值\n1. 父组件把要传递的值绑定在调用的子组件上\n2. 子组件通过props[\"\"]来接收值来使用\n\n### 子组件向父组件传值\n1. 子组件通过$emit('函数名','参数')来抛出事件传递参数\n2. 父组件通过在调用的子组件上绑定函数名来使用参数（@函数名）\n3. vuex\n\n### 兄弟之间传值\n1. vuex \n2. 通过路由带参数进行传值\n```\nthis.$router.push({ path: '/conponentsB', query: { orderId: 123 } }) // 跳转到B\n\nthis.$route.query.orderId // 在B组件拿到的参数\n```\n3. 通过设置本地存储，如Session Storage缓存的形式进行传递\n```\nconst orderData = { 'orderId': 123, 'price': 88 }\nsessionStorage.setItem('缓存名称', JSON.stringify(orderData))\nconst dataB = JSON.parse(sessionStorage.getItem('缓存名称')) // 在其他组件拿到session Storage缓存的值\n```","source":"_posts/vue/vue：组件间的传值.md","raw":"---\ntitle: vue：组件间的传值\nDate: 2020-03-17\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n### 父组件向子组件传值\n1. 父组件把要传递的值绑定在调用的子组件上\n2. 子组件通过props[\"\"]来接收值来使用\n\n### 子组件向父组件传值\n1. 子组件通过$emit('函数名','参数')来抛出事件传递参数\n2. 父组件通过在调用的子组件上绑定函数名来使用参数（@函数名）\n3. vuex\n\n### 兄弟之间传值\n1. vuex \n2. 通过路由带参数进行传值\n```\nthis.$router.push({ path: '/conponentsB', query: { orderId: 123 } }) // 跳转到B\n\nthis.$route.query.orderId // 在B组件拿到的参数\n```\n3. 通过设置本地存储，如Session Storage缓存的形式进行传递\n```\nconst orderData = { 'orderId': 123, 'price': 88 }\nsessionStorage.setItem('缓存名称', JSON.stringify(orderData))\nconst dataB = JSON.parse(sessionStorage.getItem('缓存名称')) // 在其他组件拿到session Storage缓存的值\n```","slug":"vue/vue：组件间的传值","published":1,"date":"2020-03-17T08:21:12.799Z","updated":"2020-03-17T08:24:58.795Z","layout":"post","photos":[],"link":"","_id":"cka6kin3l003nqgu9k51v12u9","content":"<h3 id=\"父组件向子组件传值\"><a href=\"#父组件向子组件传值\" class=\"headerlink\" title=\"父组件向子组件传值\"></a>父组件向子组件传值</h3><ol>\n<li>父组件把要传递的值绑定在调用的子组件上</li>\n<li>子组件通过props[“”]来接收值来使用</li>\n</ol>\n<h3 id=\"子组件向父组件传值\"><a href=\"#子组件向父组件传值\" class=\"headerlink\" title=\"子组件向父组件传值\"></a>子组件向父组件传值</h3><ol>\n<li>子组件通过$emit(‘函数名’,’参数’)来抛出事件传递参数</li>\n<li>父组件通过在调用的子组件上绑定函数名来使用参数（@函数名）</li>\n<li>vuex</li>\n</ol>\n<h3 id=\"兄弟之间传值\"><a href=\"#兄弟之间传值\" class=\"headerlink\" title=\"兄弟之间传值\"></a>兄弟之间传值</h3><ol>\n<li>vuex </li>\n<li><p>通过路由带参数进行传值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.push(&#123; path: &apos;/conponentsB&apos;, query: &#123; orderId: 123 &#125; &#125;) // 跳转到B</span><br><span class=\"line\"></span><br><span class=\"line\">this.$route.query.orderId // 在B组件拿到的参数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过设置本地存储，如Session Storage缓存的形式进行传递</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const orderData = &#123; &apos;orderId&apos;: 123, &apos;price&apos;: 88 &#125;</span><br><span class=\"line\">sessionStorage.setItem(&apos;缓存名称&apos;, JSON.stringify(orderData))</span><br><span class=\"line\">const dataB = JSON.parse(sessionStorage.getItem(&apos;缓存名称&apos;)) // 在其他组件拿到session Storage缓存的值</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"父组件向子组件传值\"><a href=\"#父组件向子组件传值\" class=\"headerlink\" title=\"父组件向子组件传值\"></a>父组件向子组件传值</h3><ol>\n<li>父组件把要传递的值绑定在调用的子组件上</li>\n<li>子组件通过props[“”]来接收值来使用</li>\n</ol>\n<h3 id=\"子组件向父组件传值\"><a href=\"#子组件向父组件传值\" class=\"headerlink\" title=\"子组件向父组件传值\"></a>子组件向父组件传值</h3><ol>\n<li>子组件通过$emit(‘函数名’,’参数’)来抛出事件传递参数</li>\n<li>父组件通过在调用的子组件上绑定函数名来使用参数（@函数名）</li>\n<li>vuex</li>\n</ol>\n<h3 id=\"兄弟之间传值\"><a href=\"#兄弟之间传值\" class=\"headerlink\" title=\"兄弟之间传值\"></a>兄弟之间传值</h3><ol>\n<li>vuex </li>\n<li><p>通过路由带参数进行传值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.push(&#123; path: &apos;/conponentsB&apos;, query: &#123; orderId: 123 &#125; &#125;) // 跳转到B</span><br><span class=\"line\"></span><br><span class=\"line\">this.$route.query.orderId // 在B组件拿到的参数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过设置本地存储，如Session Storage缓存的形式进行传递</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const orderData = &#123; &apos;orderId&apos;: 123, &apos;price&apos;: 88 &#125;</span><br><span class=\"line\">sessionStorage.setItem(&apos;缓存名称&apos;, JSON.stringify(orderData))</span><br><span class=\"line\">const dataB = JSON.parse(sessionStorage.getItem(&apos;缓存名称&apos;)) // 在其他组件拿到session Storage缓存的值</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"移动端适配","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### lib-flexible\n#### 原理\n- 在页面中引入flexible.js后，flexible会在html标签上增加一个data-dpr属性和font-size样式。\n- js首先会获取设备型号和对应的dpr，然后根据不同设备添加不同的data-dpr值，比如说1、2或者3，从源码中我们可以看到。\n\n#### vue中适配\n通过npm下载\n```\nnpm i lib-flexible --save\n```\n在main.js中引入\n\n```\nimport 'lib-flexible/flexible'\n```\n#### 把视觉稿中的px转换成rem\nFlexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。\n\n### px2rem-loader\n在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，将下面代码加进cssLoaders方法中\n\n```\nconst px2remLoader = {\n    loader: 'px2rem-loader',\n    options: {\n      remUint: 75\n    }\n}\n```\n同时，对generateLoaders方法进行修改\n\n```\nconst loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader]\n```\n\n### fastclick\n为了检测是否为双击，从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。\n#### 解决\n引入fastclick第三方库，其实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。","source":"_posts/vue/vue：移动端适配.md","raw":"---\ntitle: 移动端适配\nDate: 2020-03-17\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n### lib-flexible\n#### 原理\n- 在页面中引入flexible.js后，flexible会在html标签上增加一个data-dpr属性和font-size样式。\n- js首先会获取设备型号和对应的dpr，然后根据不同设备添加不同的data-dpr值，比如说1、2或者3，从源码中我们可以看到。\n\n#### vue中适配\n通过npm下载\n```\nnpm i lib-flexible --save\n```\n在main.js中引入\n\n```\nimport 'lib-flexible/flexible'\n```\n#### 把视觉稿中的px转换成rem\nFlexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。\n\n### px2rem-loader\n在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，将下面代码加进cssLoaders方法中\n\n```\nconst px2remLoader = {\n    loader: 'px2rem-loader',\n    options: {\n      remUint: 75\n    }\n}\n```\n同时，对generateLoaders方法进行修改\n\n```\nconst loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader]\n```\n\n### fastclick\n为了检测是否为双击，从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。\n#### 解决\n引入fastclick第三方库，其实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。","slug":"vue/vue：移动端适配","published":1,"date":"2020-03-17T08:21:00.445Z","updated":"2020-03-17T08:23:43.840Z","layout":"post","photos":[],"link":"","_id":"cka6kin3v003pqgu9kovnfter","content":"<h3 id=\"lib-flexible\"><a href=\"#lib-flexible\" class=\"headerlink\" title=\"lib-flexible\"></a>lib-flexible</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>在页面中引入flexible.js后，flexible会在html标签上增加一个data-dpr属性和font-size样式。</li>\n<li>js首先会获取设备型号和对应的dpr，然后根据不同设备添加不同的data-dpr值，比如说1、2或者3，从源码中我们可以看到。</li>\n</ul>\n<h4 id=\"vue中适配\"><a href=\"#vue中适配\" class=\"headerlink\" title=\"vue中适配\"></a>vue中适配</h4><p>通过npm下载<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i lib-flexible --save</span><br></pre></td></tr></table></figure></p>\n<p>在main.js中引入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;lib-flexible/flexible&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"把视觉稿中的px转换成rem\"><a href=\"#把视觉稿中的px转换成rem\" class=\"headerlink\" title=\"把视觉稿中的px转换成rem\"></a>把视觉稿中的px转换成rem</h4><p>Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。</p>\n<h3 id=\"px2rem-loader\"><a href=\"#px2rem-loader\" class=\"headerlink\" title=\"px2rem-loader\"></a>px2rem-loader</h3><p>在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，将下面代码加进cssLoaders方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const px2remLoader = &#123;</span><br><span class=\"line\">    loader: &apos;px2rem-loader&apos;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">      remUint: 75</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时，对generateLoaders方法进行修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader]</span><br></pre></td></tr></table></figure>\n<h3 id=\"fastclick\"><a href=\"#fastclick\" class=\"headerlink\" title=\"fastclick\"></a>fastclick</h3><p>为了检测是否为双击，从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。</p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>引入fastclick第三方库，其实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"lib-flexible\"><a href=\"#lib-flexible\" class=\"headerlink\" title=\"lib-flexible\"></a>lib-flexible</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>在页面中引入flexible.js后，flexible会在html标签上增加一个data-dpr属性和font-size样式。</li>\n<li>js首先会获取设备型号和对应的dpr，然后根据不同设备添加不同的data-dpr值，比如说1、2或者3，从源码中我们可以看到。</li>\n</ul>\n<h4 id=\"vue中适配\"><a href=\"#vue中适配\" class=\"headerlink\" title=\"vue中适配\"></a>vue中适配</h4><p>通过npm下载<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i lib-flexible --save</span><br></pre></td></tr></table></figure></p>\n<p>在main.js中引入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;lib-flexible/flexible&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"把视觉稿中的px转换成rem\"><a href=\"#把视觉稿中的px转换成rem\" class=\"headerlink\" title=\"把视觉稿中的px转换成rem\"></a>把视觉稿中的px转换成rem</h4><p>Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。</p>\n<h3 id=\"px2rem-loader\"><a href=\"#px2rem-loader\" class=\"headerlink\" title=\"px2rem-loader\"></a>px2rem-loader</h3><p>在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，将下面代码加进cssLoaders方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const px2remLoader = &#123;</span><br><span class=\"line\">    loader: &apos;px2rem-loader&apos;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">      remUint: 75</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时，对generateLoaders方法进行修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader]</span><br></pre></td></tr></table></figure>\n<h3 id=\"fastclick\"><a href=\"#fastclick\" class=\"headerlink\" title=\"fastclick\"></a>fastclick</h3><p>为了检测是否为双击，从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。</p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>引入fastclick第三方库，其实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。</p>\n"},{"title":"vue：路由原理","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n## 单页面应用\n随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。\n\n## vue-router\n\n### 实现方式\n“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：\n\n1. hash模式，url带#号，但是访问网页不会404。\n2. history模式。url不带#号。前端的 URL 必须和实际向后端发起请求的 URL 一致，如果后端没有规定好路由，直接复制url会404。\n\n```\n// hash\nhttp://localhost:8080/#/test\n// history\nhttp://localhost:8080/test\n```\n\n### mode\n在vue-router中是通过mode这一参数控制路由的实现模式的，创建VueRouter的实例对象时，mode以构造函数参数的形式传入。\n\n```\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n\n// mode 参数：\n- 默认hash\n- history 注：如果浏览器不支持history新特性,则采用hash方式\n- 如果不在浏览器环境则使用abstract（node环境下）\n```\n\n![image](https://upload-images.jianshu.io/upload_images/4099767-4e2101346868ac4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/442/format/webp)\n\n### history对象\n当选择mode类型之后，程序会根据你选择的mode 类型创建不同的history对象\n- HashHistory\n- HTML5History\n- AbstractHistory\n\n```\n// 源码\n// 根据mode确定history实际的类并实例化\nswitch (mode) {\n  case 'history':\n    this.history = new HTML5History(this, options.base)\n    break\n  case 'hash':\n    this.history = new HashHistory(this, options.base, this.fallback)\n    break\n  case 'abstract':\n    this.history = new AbstractHistory(this, options.base)\n    break\n  default:\n    if (process.env.NODE_ENV !== 'production') {\n      assert(false, `invalid mode: ${mode}`)\n    }\n}\n```\n#### HashHistory\n替换路由的两个方法\n- HashHistory.push()\n- HashHistory.replace()\n\n##### HashHistory.push()\n将新路由添加到浏览器访问历史的栈顶\n\n![image](https://upload-images.jianshu.io/upload_images/4099767-1398ade7d9db935e.png?imageMogr2/auto-orient/strip|imageView2/2/w/599/format/webp)\n\n```\n1 $router.push() //调用方法\n2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶）（window.location.hash= XXX）\n3 History.transitionTo() //监测更新，更新则调用History.updateRoute()\n4 History.updateRoute() //更新路由\n5 {app._route= route} //替换当前app路由\n6 vm.render() //更新视图\n```\n\n##### HashHistory.replace()\nreplace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由\n\n![image](https://upload-images.jianshu.io/upload_images/4099767-13ffd0864295ca69.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp)\n\n\n```\nreplace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.transitionTo(location, route => {\n    replaceHash(route.fullPath)\n    onComplete && onComplete(route)\n  }, onAbort)\n}\n  \nfunction replaceHash (path) {\n  const i = window.location.href.indexOf('#')\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  )\n}\n```\n\n##### 监听地址栏\n在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此VueRouter还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在HashHistory中这一功能通过setupListeners实现\n\n```\nsetupListeners () {\n  window.addEventListener('hashchange', () => {\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), route => {\n      replaceHash(route.fullPath)\n    })\n  })\n}\n```\n该方法设置监听了浏览器事件hashchange，调用的函数为replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法\n\n#### HTML5History\n- History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。\n- 从HTML5开始，History interface有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改\n- 当然了，HTML5History用到了HTML5的新特特性，是需要特定浏览器版本的支持的\n\n##### window.history.pushState()和window.history.replaceState()\n- window.history.pushState(stateObject, title, URL)\n- window.history.replaceState(stateObject, title, URL)\n- stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本\n- title: 所添加记录的标题\n- URL: 所添加记录的URL\n\n##### 监听地址变化\n在HTML5History的构造函数中监听popState（window.onpopstate）\n\n在HTML5History中添加对修改浏览器地址栏URL的监听是直接在构造函数中执行的\n\n```\nconstructor (router: Router, base: ?string) {\n  \n  window.addEventListener('popstate', e => {\n    const current = this.current\n    this.transitionTo(getLocation(this.base), route => {\n      if (expectScroll) {\n        handleScroll(router, route, current, true)\n      }\n    })\n  })\n}\n```\n\n\n#### 两者区别\n- pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL\n- pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中\n- pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串\n- pushState可额外设置title属性供后续使用\n\n##### 一个问题\n用户直接在地址栏中输入并回车，浏览器重启重新加载应用时\n\nhash模式仅改变hash部分的内容，而hash部分是不会包含在HTTP请求中的，故在hash模式下遇到根据URL请求页面的情况不会有问题。\n\n```\nhttp://oursite.com/#/user/id   \n// 如重新请求只会发送http://oursite.com/\n```\n\n而history模式则会将URL修改得就和正常请求后端的URL一样。\n```\nhttp://oursite.com/user/id\n```\n如后端没有配置对应/user/id的路由处理，则会返回404错误。\n\n官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。\n\n\n\n\n\n\n","source":"_posts/vue/vue：路由原理.md","raw":"---\ntitle: vue：路由原理\nDate: 2020-03-17\ntags: [vue]\ncategories: vue\ncomments: true\n---\n\n## 单页面应用\n随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。\n\n## vue-router\n\n### 实现方式\n“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：\n\n1. hash模式，url带#号，但是访问网页不会404。\n2. history模式。url不带#号。前端的 URL 必须和实际向后端发起请求的 URL 一致，如果后端没有规定好路由，直接复制url会404。\n\n```\n// hash\nhttp://localhost:8080/#/test\n// history\nhttp://localhost:8080/test\n```\n\n### mode\n在vue-router中是通过mode这一参数控制路由的实现模式的，创建VueRouter的实例对象时，mode以构造函数参数的形式传入。\n\n```\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n\n// mode 参数：\n- 默认hash\n- history 注：如果浏览器不支持history新特性,则采用hash方式\n- 如果不在浏览器环境则使用abstract（node环境下）\n```\n\n![image](https://upload-images.jianshu.io/upload_images/4099767-4e2101346868ac4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/442/format/webp)\n\n### history对象\n当选择mode类型之后，程序会根据你选择的mode 类型创建不同的history对象\n- HashHistory\n- HTML5History\n- AbstractHistory\n\n```\n// 源码\n// 根据mode确定history实际的类并实例化\nswitch (mode) {\n  case 'history':\n    this.history = new HTML5History(this, options.base)\n    break\n  case 'hash':\n    this.history = new HashHistory(this, options.base, this.fallback)\n    break\n  case 'abstract':\n    this.history = new AbstractHistory(this, options.base)\n    break\n  default:\n    if (process.env.NODE_ENV !== 'production') {\n      assert(false, `invalid mode: ${mode}`)\n    }\n}\n```\n#### HashHistory\n替换路由的两个方法\n- HashHistory.push()\n- HashHistory.replace()\n\n##### HashHistory.push()\n将新路由添加到浏览器访问历史的栈顶\n\n![image](https://upload-images.jianshu.io/upload_images/4099767-1398ade7d9db935e.png?imageMogr2/auto-orient/strip|imageView2/2/w/599/format/webp)\n\n```\n1 $router.push() //调用方法\n2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶）（window.location.hash= XXX）\n3 History.transitionTo() //监测更新，更新则调用History.updateRoute()\n4 History.updateRoute() //更新路由\n5 {app._route= route} //替换当前app路由\n6 vm.render() //更新视图\n```\n\n##### HashHistory.replace()\nreplace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由\n\n![image](https://upload-images.jianshu.io/upload_images/4099767-13ffd0864295ca69.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp)\n\n\n```\nreplace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.transitionTo(location, route => {\n    replaceHash(route.fullPath)\n    onComplete && onComplete(route)\n  }, onAbort)\n}\n  \nfunction replaceHash (path) {\n  const i = window.location.href.indexOf('#')\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  )\n}\n```\n\n##### 监听地址栏\n在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此VueRouter还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在HashHistory中这一功能通过setupListeners实现\n\n```\nsetupListeners () {\n  window.addEventListener('hashchange', () => {\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), route => {\n      replaceHash(route.fullPath)\n    })\n  })\n}\n```\n该方法设置监听了浏览器事件hashchange，调用的函数为replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法\n\n#### HTML5History\n- History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。\n- 从HTML5开始，History interface有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改\n- 当然了，HTML5History用到了HTML5的新特特性，是需要特定浏览器版本的支持的\n\n##### window.history.pushState()和window.history.replaceState()\n- window.history.pushState(stateObject, title, URL)\n- window.history.replaceState(stateObject, title, URL)\n- stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本\n- title: 所添加记录的标题\n- URL: 所添加记录的URL\n\n##### 监听地址变化\n在HTML5History的构造函数中监听popState（window.onpopstate）\n\n在HTML5History中添加对修改浏览器地址栏URL的监听是直接在构造函数中执行的\n\n```\nconstructor (router: Router, base: ?string) {\n  \n  window.addEventListener('popstate', e => {\n    const current = this.current\n    this.transitionTo(getLocation(this.base), route => {\n      if (expectScroll) {\n        handleScroll(router, route, current, true)\n      }\n    })\n  })\n}\n```\n\n\n#### 两者区别\n- pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL\n- pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中\n- pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串\n- pushState可额外设置title属性供后续使用\n\n##### 一个问题\n用户直接在地址栏中输入并回车，浏览器重启重新加载应用时\n\nhash模式仅改变hash部分的内容，而hash部分是不会包含在HTTP请求中的，故在hash模式下遇到根据URL请求页面的情况不会有问题。\n\n```\nhttp://oursite.com/#/user/id   \n// 如重新请求只会发送http://oursite.com/\n```\n\n而history模式则会将URL修改得就和正常请求后端的URL一样。\n```\nhttp://oursite.com/user/id\n```\n如后端没有配置对应/user/id的路由处理，则会返回404错误。\n\n官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。\n\n\n\n\n\n\n","slug":"vue/vue：路由原理","published":1,"date":"2020-03-17T08:21:20.232Z","updated":"2020-03-17T08:25:18.097Z","layout":"post","photos":[],"link":"","_id":"cka6kin3v003tqgu9uwh91egm","content":"<h2 id=\"单页面应用\"><a href=\"#单页面应用\" class=\"headerlink\" title=\"单页面应用\"></a>单页面应用</h2><p>随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。</p>\n<h2 id=\"vue-router\"><a href=\"#vue-router\" class=\"headerlink\" title=\"vue-router\"></a>vue-router</h2><h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><p>“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：</p>\n<ol>\n<li>hash模式，url带#号，但是访问网页不会404。</li>\n<li>history模式。url不带#号。前端的 URL 必须和实际向后端发起请求的 URL 一致，如果后端没有规定好路由，直接复制url会404。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hash</span><br><span class=\"line\">http://localhost:8080/#/test</span><br><span class=\"line\">// history</span><br><span class=\"line\">http://localhost:8080/test</span><br></pre></td></tr></table></figure>\n<h3 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h3><p>在vue-router中是通过mode这一参数控制路由的实现模式的，创建VueRouter的实例对象时，mode以构造函数参数的形式传入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  mode: &apos;history&apos;,</span><br><span class=\"line\">  routes: [...]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// mode 参数：</span><br><span class=\"line\">- 默认hash</span><br><span class=\"line\">- history 注：如果浏览器不支持history新特性,则采用hash方式</span><br><span class=\"line\">- 如果不在浏览器环境则使用abstract（node环境下）</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4099767-4e2101346868ac4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/442/format/webp\" alt=\"image\"></p>\n<h3 id=\"history对象\"><a href=\"#history对象\" class=\"headerlink\" title=\"history对象\"></a>history对象</h3><p>当选择mode类型之后，程序会根据你选择的mode 类型创建不同的history对象</p>\n<ul>\n<li>HashHistory</li>\n<li>HTML5History</li>\n<li>AbstractHistory</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源码</span><br><span class=\"line\">// 根据mode确定history实际的类并实例化</span><br><span class=\"line\">switch (mode) &#123;</span><br><span class=\"line\">  case &apos;history&apos;:</span><br><span class=\"line\">    this.history = new HTML5History(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;hash&apos;:</span><br><span class=\"line\">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;abstract&apos;:</span><br><span class=\"line\">    this.history = new AbstractHistory(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"HashHistory\"><a href=\"#HashHistory\" class=\"headerlink\" title=\"HashHistory\"></a>HashHistory</h4><p>替换路由的两个方法</p>\n<ul>\n<li>HashHistory.push()</li>\n<li>HashHistory.replace()</li>\n</ul>\n<h5 id=\"HashHistory-push\"><a href=\"#HashHistory-push\" class=\"headerlink\" title=\"HashHistory.push()\"></a>HashHistory.push()</h5><p>将新路由添加到浏览器访问历史的栈顶</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4099767-1398ade7d9db935e.png?imageMogr2/auto-orient/strip|imageView2/2/w/599/format/webp\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 $router.push() //调用方法</span><br><span class=\"line\">2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶）（window.location.hash= XXX）</span><br><span class=\"line\">3 History.transitionTo() //监测更新，更新则调用History.updateRoute()</span><br><span class=\"line\">4 History.updateRoute() //更新路由</span><br><span class=\"line\">5 &#123;app._route= route&#125; //替换当前app路由</span><br><span class=\"line\">6 vm.render() //更新视图</span><br></pre></td></tr></table></figure>\n<h5 id=\"HashHistory-replace\"><a href=\"#HashHistory-replace\" class=\"headerlink\" title=\"HashHistory.replace()\"></a>HashHistory.replace()</h5><p>replace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4099767-13ffd0864295ca69.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class=\"line\">  this.transitionTo(location, route =&gt; &#123;</span><br><span class=\"line\">    replaceHash(route.fullPath)</span><br><span class=\"line\">    onComplete &amp;&amp; onComplete(route)</span><br><span class=\"line\">  &#125;, onAbort)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">function replaceHash (path) &#123;</span><br><span class=\"line\">  const i = window.location.href.indexOf(&apos;#&apos;)</span><br><span class=\"line\">  window.location.replace(</span><br><span class=\"line\">    window.location.href.slice(0, i &gt;= 0 ? i : 0) + &apos;#&apos; + path</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"监听地址栏\"><a href=\"#监听地址栏\" class=\"headerlink\" title=\"监听地址栏\"></a>监听地址栏</h5><p>在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此VueRouter还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在HashHistory中这一功能通过setupListeners实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setupListeners () &#123;</span><br><span class=\"line\">  window.addEventListener(&apos;hashchange&apos;, () =&gt; &#123;</span><br><span class=\"line\">    if (!ensureSlash()) &#123;</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.transitionTo(getHash(), route =&gt; &#123;</span><br><span class=\"line\">      replaceHash(route.fullPath)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法设置监听了浏览器事件hashchange，调用的函数为replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法</p>\n<h4 id=\"HTML5History\"><a href=\"#HTML5History\" class=\"headerlink\" title=\"HTML5History\"></a>HTML5History</h4><ul>\n<li>History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</li>\n<li>从HTML5开始，History interface有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改</li>\n<li>当然了，HTML5History用到了HTML5的新特特性，是需要特定浏览器版本的支持的</li>\n</ul>\n<h5 id=\"window-history-pushState-和window-history-replaceState\"><a href=\"#window-history-pushState-和window-history-replaceState\" class=\"headerlink\" title=\"window.history.pushState()和window.history.replaceState()\"></a>window.history.pushState()和window.history.replaceState()</h5><ul>\n<li>window.history.pushState(stateObject, title, URL)</li>\n<li>window.history.replaceState(stateObject, title, URL)</li>\n<li>stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本</li>\n<li>title: 所添加记录的标题</li>\n<li>URL: 所添加记录的URL</li>\n</ul>\n<h5 id=\"监听地址变化\"><a href=\"#监听地址变化\" class=\"headerlink\" title=\"监听地址变化\"></a>监听地址变化</h5><p>在HTML5History的构造函数中监听popState（window.onpopstate）</p>\n<p>在HTML5History中添加对修改浏览器地址栏URL的监听是直接在构造函数中执行的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor (router: Router, base: ?string) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  window.addEventListener(&apos;popstate&apos;, e =&gt; &#123;</span><br><span class=\"line\">    const current = this.current</span><br><span class=\"line\">    this.transitionTo(getLocation(this.base), route =&gt; &#123;</span><br><span class=\"line\">      if (expectScroll) &#123;</span><br><span class=\"line\">        handleScroll(router, route, current, true)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h4><ul>\n<li>pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL</li>\n<li>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中</li>\n<li>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串</li>\n<li>pushState可额外设置title属性供后续使用</li>\n</ul>\n<h5 id=\"一个问题\"><a href=\"#一个问题\" class=\"headerlink\" title=\"一个问题\"></a>一个问题</h5><p>用户直接在地址栏中输入并回车，浏览器重启重新加载应用时</p>\n<p>hash模式仅改变hash部分的内容，而hash部分是不会包含在HTTP请求中的，故在hash模式下遇到根据URL请求页面的情况不会有问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://oursite.com/#/user/id   </span><br><span class=\"line\">// 如重新请求只会发送http://oursite.com/</span><br></pre></td></tr></table></figure>\n<p>而history模式则会将URL修改得就和正常请求后端的URL一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://oursite.com/user/id</span><br></pre></td></tr></table></figure></p>\n<p>如后端没有配置对应/user/id的路由处理，则会返回404错误。</p>\n<p>官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单页面应用\"><a href=\"#单页面应用\" class=\"headerlink\" title=\"单页面应用\"></a>单页面应用</h2><p>随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。</p>\n<h2 id=\"vue-router\"><a href=\"#vue-router\" class=\"headerlink\" title=\"vue-router\"></a>vue-router</h2><h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><p>“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：</p>\n<ol>\n<li>hash模式，url带#号，但是访问网页不会404。</li>\n<li>history模式。url不带#号。前端的 URL 必须和实际向后端发起请求的 URL 一致，如果后端没有规定好路由，直接复制url会404。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hash</span><br><span class=\"line\">http://localhost:8080/#/test</span><br><span class=\"line\">// history</span><br><span class=\"line\">http://localhost:8080/test</span><br></pre></td></tr></table></figure>\n<h3 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h3><p>在vue-router中是通过mode这一参数控制路由的实现模式的，创建VueRouter的实例对象时，mode以构造函数参数的形式传入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  mode: &apos;history&apos;,</span><br><span class=\"line\">  routes: [...]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// mode 参数：</span><br><span class=\"line\">- 默认hash</span><br><span class=\"line\">- history 注：如果浏览器不支持history新特性,则采用hash方式</span><br><span class=\"line\">- 如果不在浏览器环境则使用abstract（node环境下）</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4099767-4e2101346868ac4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/442/format/webp\" alt=\"image\"></p>\n<h3 id=\"history对象\"><a href=\"#history对象\" class=\"headerlink\" title=\"history对象\"></a>history对象</h3><p>当选择mode类型之后，程序会根据你选择的mode 类型创建不同的history对象</p>\n<ul>\n<li>HashHistory</li>\n<li>HTML5History</li>\n<li>AbstractHistory</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源码</span><br><span class=\"line\">// 根据mode确定history实际的类并实例化</span><br><span class=\"line\">switch (mode) &#123;</span><br><span class=\"line\">  case &apos;history&apos;:</span><br><span class=\"line\">    this.history = new HTML5History(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;hash&apos;:</span><br><span class=\"line\">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;abstract&apos;:</span><br><span class=\"line\">    this.history = new AbstractHistory(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"HashHistory\"><a href=\"#HashHistory\" class=\"headerlink\" title=\"HashHistory\"></a>HashHistory</h4><p>替换路由的两个方法</p>\n<ul>\n<li>HashHistory.push()</li>\n<li>HashHistory.replace()</li>\n</ul>\n<h5 id=\"HashHistory-push\"><a href=\"#HashHistory-push\" class=\"headerlink\" title=\"HashHistory.push()\"></a>HashHistory.push()</h5><p>将新路由添加到浏览器访问历史的栈顶</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4099767-1398ade7d9db935e.png?imageMogr2/auto-orient/strip|imageView2/2/w/599/format/webp\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 $router.push() //调用方法</span><br><span class=\"line\">2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶）（window.location.hash= XXX）</span><br><span class=\"line\">3 History.transitionTo() //监测更新，更新则调用History.updateRoute()</span><br><span class=\"line\">4 History.updateRoute() //更新路由</span><br><span class=\"line\">5 &#123;app._route= route&#125; //替换当前app路由</span><br><span class=\"line\">6 vm.render() //更新视图</span><br></pre></td></tr></table></figure>\n<h5 id=\"HashHistory-replace\"><a href=\"#HashHistory-replace\" class=\"headerlink\" title=\"HashHistory.replace()\"></a>HashHistory.replace()</h5><p>replace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4099767-13ffd0864295ca69.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class=\"line\">  this.transitionTo(location, route =&gt; &#123;</span><br><span class=\"line\">    replaceHash(route.fullPath)</span><br><span class=\"line\">    onComplete &amp;&amp; onComplete(route)</span><br><span class=\"line\">  &#125;, onAbort)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">function replaceHash (path) &#123;</span><br><span class=\"line\">  const i = window.location.href.indexOf(&apos;#&apos;)</span><br><span class=\"line\">  window.location.replace(</span><br><span class=\"line\">    window.location.href.slice(0, i &gt;= 0 ? i : 0) + &apos;#&apos; + path</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"监听地址栏\"><a href=\"#监听地址栏\" class=\"headerlink\" title=\"监听地址栏\"></a>监听地址栏</h5><p>在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此VueRouter还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在HashHistory中这一功能通过setupListeners实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setupListeners () &#123;</span><br><span class=\"line\">  window.addEventListener(&apos;hashchange&apos;, () =&gt; &#123;</span><br><span class=\"line\">    if (!ensureSlash()) &#123;</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.transitionTo(getHash(), route =&gt; &#123;</span><br><span class=\"line\">      replaceHash(route.fullPath)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法设置监听了浏览器事件hashchange，调用的函数为replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法</p>\n<h4 id=\"HTML5History\"><a href=\"#HTML5History\" class=\"headerlink\" title=\"HTML5History\"></a>HTML5History</h4><ul>\n<li>History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</li>\n<li>从HTML5开始，History interface有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改</li>\n<li>当然了，HTML5History用到了HTML5的新特特性，是需要特定浏览器版本的支持的</li>\n</ul>\n<h5 id=\"window-history-pushState-和window-history-replaceState\"><a href=\"#window-history-pushState-和window-history-replaceState\" class=\"headerlink\" title=\"window.history.pushState()和window.history.replaceState()\"></a>window.history.pushState()和window.history.replaceState()</h5><ul>\n<li>window.history.pushState(stateObject, title, URL)</li>\n<li>window.history.replaceState(stateObject, title, URL)</li>\n<li>stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本</li>\n<li>title: 所添加记录的标题</li>\n<li>URL: 所添加记录的URL</li>\n</ul>\n<h5 id=\"监听地址变化\"><a href=\"#监听地址变化\" class=\"headerlink\" title=\"监听地址变化\"></a>监听地址变化</h5><p>在HTML5History的构造函数中监听popState（window.onpopstate）</p>\n<p>在HTML5History中添加对修改浏览器地址栏URL的监听是直接在构造函数中执行的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor (router: Router, base: ?string) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  window.addEventListener(&apos;popstate&apos;, e =&gt; &#123;</span><br><span class=\"line\">    const current = this.current</span><br><span class=\"line\">    this.transitionTo(getLocation(this.base), route =&gt; &#123;</span><br><span class=\"line\">      if (expectScroll) &#123;</span><br><span class=\"line\">        handleScroll(router, route, current, true)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h4><ul>\n<li>pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL</li>\n<li>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中</li>\n<li>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串</li>\n<li>pushState可额外设置title属性供后续使用</li>\n</ul>\n<h5 id=\"一个问题\"><a href=\"#一个问题\" class=\"headerlink\" title=\"一个问题\"></a>一个问题</h5><p>用户直接在地址栏中输入并回车，浏览器重启重新加载应用时</p>\n<p>hash模式仅改变hash部分的内容，而hash部分是不会包含在HTTP请求中的，故在hash模式下遇到根据URL请求页面的情况不会有问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://oursite.com/#/user/id   </span><br><span class=\"line\">// 如重新请求只会发送http://oursite.com/</span><br></pre></td></tr></table></figure>\n<p>而history模式则会将URL修改得就和正常请求后端的URL一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://oursite.com/user/id</span><br></pre></td></tr></table></figure></p>\n<p>如后端没有配置对应/user/id的路由处理，则会返回404错误。</p>\n<p>官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>\n"},{"title":"BOM和DOM","Date":"2019-04-22T16:00:00.000Z","comments":1,"_content":"\n### BOM和DOM\n- DOM（文档对象模型）是 HTML 和 XML 的应用程序接口。\n- DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。\n- BOM （浏览器对象模型）主要处理浏览器窗口和框架。\n- javacsript是通过访问BOM对象来访问、控制、修改客户端浏览器。\n- 由于BOM的window包含了document，document对象又是DOM的根节点。可以说，BOM包含了DOM。\n- 浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。\n\n### 拓展：遍历dom树\n","source":"_posts/前端/BOM和DOM.md","raw":"---\ntitle: BOM和DOM\nDate: 2019-04-23\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### BOM和DOM\n- DOM（文档对象模型）是 HTML 和 XML 的应用程序接口。\n- DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。\n- BOM （浏览器对象模型）主要处理浏览器窗口和框架。\n- javacsript是通过访问BOM对象来访问、控制、修改客户端浏览器。\n- 由于BOM的window包含了document，document对象又是DOM的根节点。可以说，BOM包含了DOM。\n- 浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。\n\n### 拓展：遍历dom树\n","slug":"前端/BOM和DOM","published":1,"date":"2019-04-23T14:22:18.954Z","updated":"2019-04-23T14:23:35.866Z","layout":"post","photos":[],"link":"","_id":"cka6kinb3007lqgu9ocyej3k7","content":"<h3 id=\"BOM和DOM\"><a href=\"#BOM和DOM\" class=\"headerlink\" title=\"BOM和DOM\"></a>BOM和DOM</h3><ul>\n<li>DOM（文档对象模型）是 HTML 和 XML 的应用程序接口。</li>\n<li>DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。</li>\n<li>BOM （浏览器对象模型）主要处理浏览器窗口和框架。</li>\n<li>javacsript是通过访问BOM对象来访问、控制、修改客户端浏览器。</li>\n<li>由于BOM的window包含了document，document对象又是DOM的根节点。可以说，BOM包含了DOM。</li>\n<li>浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。</li>\n</ul>\n<h3 id=\"拓展：遍历dom树\"><a href=\"#拓展：遍历dom树\" class=\"headerlink\" title=\"拓展：遍历dom树\"></a>拓展：遍历dom树</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"BOM和DOM\"><a href=\"#BOM和DOM\" class=\"headerlink\" title=\"BOM和DOM\"></a>BOM和DOM</h3><ul>\n<li>DOM（文档对象模型）是 HTML 和 XML 的应用程序接口。</li>\n<li>DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。</li>\n<li>BOM （浏览器对象模型）主要处理浏览器窗口和框架。</li>\n<li>javacsript是通过访问BOM对象来访问、控制、修改客户端浏览器。</li>\n<li>由于BOM的window包含了document，document对象又是DOM的根节点。可以说，BOM包含了DOM。</li>\n<li>浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。</li>\n</ul>\n<h3 id=\"拓展：遍历dom树\"><a href=\"#拓展：遍历dom树\" class=\"headerlink\" title=\"拓展：遍历dom树\"></a>拓展：遍历dom树</h3>"},{"title":"WebSocket","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 长连接和短连接\n长连接是存在于网络层的一种连接状态，而实现它则需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。\n\n\n#### http\n- http1.0不支持长连接，http1.1支持长连接\n- http1.x是文本协议，http2.0是二进制协议\n\nHTTP作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于'Keep-Alive'请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。\n\n#### 短连接\n所谓短连接，即连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。\n\n#### 长连接\n长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。\n它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。\n\n### 轮询\n- 所谓轮询，即是浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息这样一个机制。\n- 然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。\n- 只要有请求的的地方，都可以实现轮询，譬如各种事件驱动模型。它的长短是在于某次请求的返回周期。\n\n#### 短轮询\n短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。\n\n#### 长轮询\n而长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。\n\n由上可以看到，长短轮询的理想实现都应当基于长连接，否则若是循环周期太短，那么服务器的荷载会相当重；当然，即便是在长连接下，访问人数过多，长短轮询都有可能造成服务器的瞬时访问量庞大，这就需要一些相应的优化实践了。\n\n### websocket\n- WebSocket是HTML5新增的一种在单个 TCP 连接上进行全双工通讯的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。\n- WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。\n- 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n#### 为什么http不能实现\n这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。\n\n用轮询是可以实现的，但这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。\n\n#### websocket实现\nWebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。\n\n实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。\n\n#### 创建websocket连接\n\n首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：\n\n```\nGET ws://localhost:3000/ws/chat HTTP/1.1\nHost: localhost\nUpgrade: websocket\nConnection: Upgrade\nOrigin: http://localhost:3000\nSec-WebSocket-Key: client-random-string\nSec-WebSocket-Version: 13\n```\n该请求和普通的HTTP请求有几点不同：\n\n- GET请求的地址不是类似/path/，而是以ws://开头的地址；\n- 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；\n- Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；\n- Sec-WebSocket-Version指定了WebSocket的协议版本。\n\n一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本。\n\n浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。\n\n#### 安全的websocket\n安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。\n\n#### 浏览器\n很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下：\n\n- Chrome\n- Firefox\n- IE >= 10\n- Sarafi >= 6\n- Android >= 4.4\n- iOS >= 8\n\n#### 服务器\n由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。","source":"_posts/前端/WebSocket.md","raw":"---\ntitle: WebSocket\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 长连接和短连接\n长连接是存在于网络层的一种连接状态，而实现它则需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。\n\n\n#### http\n- http1.0不支持长连接，http1.1支持长连接\n- http1.x是文本协议，http2.0是二进制协议\n\nHTTP作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于'Keep-Alive'请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。\n\n#### 短连接\n所谓短连接，即连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。\n\n#### 长连接\n长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。\n它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。\n\n### 轮询\n- 所谓轮询，即是浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息这样一个机制。\n- 然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。\n- 只要有请求的的地方，都可以实现轮询，譬如各种事件驱动模型。它的长短是在于某次请求的返回周期。\n\n#### 短轮询\n短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。\n\n#### 长轮询\n而长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。\n\n由上可以看到，长短轮询的理想实现都应当基于长连接，否则若是循环周期太短，那么服务器的荷载会相当重；当然，即便是在长连接下，访问人数过多，长短轮询都有可能造成服务器的瞬时访问量庞大，这就需要一些相应的优化实践了。\n\n### websocket\n- WebSocket是HTML5新增的一种在单个 TCP 连接上进行全双工通讯的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。\n- WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。\n- 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n#### 为什么http不能实现\n这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。\n\n用轮询是可以实现的，但这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。\n\n#### websocket实现\nWebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。\n\n实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。\n\n#### 创建websocket连接\n\n首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：\n\n```\nGET ws://localhost:3000/ws/chat HTTP/1.1\nHost: localhost\nUpgrade: websocket\nConnection: Upgrade\nOrigin: http://localhost:3000\nSec-WebSocket-Key: client-random-string\nSec-WebSocket-Version: 13\n```\n该请求和普通的HTTP请求有几点不同：\n\n- GET请求的地址不是类似/path/，而是以ws://开头的地址；\n- 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；\n- Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；\n- Sec-WebSocket-Version指定了WebSocket的协议版本。\n\n一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本。\n\n浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。\n\n#### 安全的websocket\n安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。\n\n#### 浏览器\n很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下：\n\n- Chrome\n- Firefox\n- IE >= 10\n- Sarafi >= 6\n- Android >= 4.4\n- iOS >= 8\n\n#### 服务器\n由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。","slug":"前端/WebSocket","published":1,"date":"2020-05-14T08:36:31.732Z","updated":"2020-05-14T08:30:08.976Z","layout":"post","photos":[],"link":"","_id":"cka6kinbd007oqgu9mu1klvxb","content":"<h3 id=\"长连接和短连接\"><a href=\"#长连接和短连接\" class=\"headerlink\" title=\"长连接和短连接\"></a>长连接和短连接</h3><p>长连接是存在于网络层的一种连接状态，而实现它则需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。</p>\n<h4 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h4><ul>\n<li>http1.0不支持长连接，http1.1支持长连接</li>\n<li>http1.x是文本协议，http2.0是二进制协议</li>\n</ul>\n<p>HTTP作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于’Keep-Alive’请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。</p>\n<h4 id=\"短连接\"><a href=\"#短连接\" class=\"headerlink\" title=\"短连接\"></a>短连接</h4><p>所谓短连接，即连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。</p>\n<h4 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h4><p>长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。<br>它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。</p>\n<h3 id=\"轮询\"><a href=\"#轮询\" class=\"headerlink\" title=\"轮询\"></a>轮询</h3><ul>\n<li>所谓轮询，即是浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息这样一个机制。</li>\n<li>然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</li>\n<li>只要有请求的的地方，都可以实现轮询，譬如各种事件驱动模型。它的长短是在于某次请求的返回周期。</li>\n</ul>\n<h4 id=\"短轮询\"><a href=\"#短轮询\" class=\"headerlink\" title=\"短轮询\"></a>短轮询</h4><p>短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。</p>\n<h4 id=\"长轮询\"><a href=\"#长轮询\" class=\"headerlink\" title=\"长轮询\"></a>长轮询</h4><p>而长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。</p>\n<p>由上可以看到，长短轮询的理想实现都应当基于长连接，否则若是循环周期太短，那么服务器的荷载会相当重；当然，即便是在长连接下，访问人数过多，长短轮询都有可能造成服务器的瞬时访问量庞大，这就需要一些相应的优化实践了。</p>\n<h3 id=\"websocket\"><a href=\"#websocket\" class=\"headerlink\" title=\"websocket\"></a>websocket</h3><ul>\n<li>WebSocket是HTML5新增的一种在单个 TCP 连接上进行全双工通讯的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</li>\n<li>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</li>\n<li>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</li>\n</ul>\n<h4 id=\"为什么http不能实现\"><a href=\"#为什么http不能实现\" class=\"headerlink\" title=\"为什么http不能实现\"></a>为什么http不能实现</h4><p>这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。</p>\n<p>用轮询是可以实现的，但这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。</p>\n<h4 id=\"websocket实现\"><a href=\"#websocket实现\" class=\"headerlink\" title=\"websocket实现\"></a>websocket实现</h4><p>WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。</p>\n<p>实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。</p>\n<h4 id=\"创建websocket连接\"><a href=\"#创建websocket连接\" class=\"headerlink\" title=\"创建websocket连接\"></a>创建websocket连接</h4><p>首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET ws://localhost:3000/ws/chat HTTP/1.1</span><br><span class=\"line\">Host: localhost</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Origin: http://localhost:3000</span><br><span class=\"line\">Sec-WebSocket-Key: client-random-string</span><br><span class=\"line\">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>\n<p>该请求和普通的HTTP请求有几点不同：</p>\n<ul>\n<li>GET请求的地址不是类似/path/，而是以ws://开头的地址；</li>\n<li>请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；</li>\n<li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li>\n<li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li>\n</ul>\n<p>一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本。</p>\n<p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p>\n<h4 id=\"安全的websocket\"><a href=\"#安全的websocket\" class=\"headerlink\" title=\"安全的websocket\"></a>安全的websocket</h4><p>安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。</p>\n<h4 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h4><p>很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下：</p>\n<ul>\n<li>Chrome</li>\n<li>Firefox</li>\n<li>IE &gt;= 10</li>\n<li>Sarafi &gt;= 6</li>\n<li>Android &gt;= 4.4</li>\n<li>iOS &gt;= 8</li>\n</ul>\n<h4 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h4><p>由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"长连接和短连接\"><a href=\"#长连接和短连接\" class=\"headerlink\" title=\"长连接和短连接\"></a>长连接和短连接</h3><p>长连接是存在于网络层的一种连接状态，而实现它则需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。</p>\n<h4 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h4><ul>\n<li>http1.0不支持长连接，http1.1支持长连接</li>\n<li>http1.x是文本协议，http2.0是二进制协议</li>\n</ul>\n<p>HTTP作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于’Keep-Alive’请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。</p>\n<h4 id=\"短连接\"><a href=\"#短连接\" class=\"headerlink\" title=\"短连接\"></a>短连接</h4><p>所谓短连接，即连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。</p>\n<h4 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h4><p>长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。<br>它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。</p>\n<h3 id=\"轮询\"><a href=\"#轮询\" class=\"headerlink\" title=\"轮询\"></a>轮询</h3><ul>\n<li>所谓轮询，即是浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息这样一个机制。</li>\n<li>然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</li>\n<li>只要有请求的的地方，都可以实现轮询，譬如各种事件驱动模型。它的长短是在于某次请求的返回周期。</li>\n</ul>\n<h4 id=\"短轮询\"><a href=\"#短轮询\" class=\"headerlink\" title=\"短轮询\"></a>短轮询</h4><p>短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。</p>\n<h4 id=\"长轮询\"><a href=\"#长轮询\" class=\"headerlink\" title=\"长轮询\"></a>长轮询</h4><p>而长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。</p>\n<p>由上可以看到，长短轮询的理想实现都应当基于长连接，否则若是循环周期太短，那么服务器的荷载会相当重；当然，即便是在长连接下，访问人数过多，长短轮询都有可能造成服务器的瞬时访问量庞大，这就需要一些相应的优化实践了。</p>\n<h3 id=\"websocket\"><a href=\"#websocket\" class=\"headerlink\" title=\"websocket\"></a>websocket</h3><ul>\n<li>WebSocket是HTML5新增的一种在单个 TCP 连接上进行全双工通讯的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</li>\n<li>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</li>\n<li>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</li>\n</ul>\n<h4 id=\"为什么http不能实现\"><a href=\"#为什么http不能实现\" class=\"headerlink\" title=\"为什么http不能实现\"></a>为什么http不能实现</h4><p>这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。</p>\n<p>用轮询是可以实现的，但这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。</p>\n<h4 id=\"websocket实现\"><a href=\"#websocket实现\" class=\"headerlink\" title=\"websocket实现\"></a>websocket实现</h4><p>WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。</p>\n<p>实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。</p>\n<h4 id=\"创建websocket连接\"><a href=\"#创建websocket连接\" class=\"headerlink\" title=\"创建websocket连接\"></a>创建websocket连接</h4><p>首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET ws://localhost:3000/ws/chat HTTP/1.1</span><br><span class=\"line\">Host: localhost</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Origin: http://localhost:3000</span><br><span class=\"line\">Sec-WebSocket-Key: client-random-string</span><br><span class=\"line\">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>\n<p>该请求和普通的HTTP请求有几点不同：</p>\n<ul>\n<li>GET请求的地址不是类似/path/，而是以ws://开头的地址；</li>\n<li>请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；</li>\n<li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li>\n<li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li>\n</ul>\n<p>一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本。</p>\n<p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p>\n<h4 id=\"安全的websocket\"><a href=\"#安全的websocket\" class=\"headerlink\" title=\"安全的websocket\"></a>安全的websocket</h4><p>安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。</p>\n<h4 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h4><p>很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下：</p>\n<ul>\n<li>Chrome</li>\n<li>Firefox</li>\n<li>IE &gt;= 10</li>\n<li>Sarafi &gt;= 6</li>\n<li>Android &gt;= 4.4</li>\n<li>iOS &gt;= 8</li>\n</ul>\n<h4 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h4><p>由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。</p>\n"},{"title":"canvas","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\nCanvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。\n\n## 属性\n- height\n- width\n\n一个Canvas定义了一个指定尺寸的矩形框\n```\n<canvas id=\"test-canvas\" width=\"300\" height=\"200\"></canvas>\n```\n## 检测浏览器支持\n由于浏览器对HTML5标准支持不一致，所以，通常在canvas内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略canvas内部的HTML，如果浏览器不支持Canvas，它将显示canvas内部的HTML\n\n```\n<canvas id=\"test-stock\" width=\"300\" height=\"200\">\n    <p>Current Price: 25.51</p>\n</canvas>\n\n```\n在使用Canvas前，还需要用canvas.getContext来测试浏览器是否支持Canvas\n\n```\nvar canvas = document.getElementById('test-canvas');\nif (canvas.getContext) {\n    console.log('你的浏览器支持Canvas!');\n} else {\n    console.log('你的浏览器不支持Canvas!');\n}\n```\n## 方法\n\ncanvas绘图以左上角的（0， 0）为基准原点\n```\nlet canvas = document.querySelector('#canvas'); // 得到canvas\n//得到canvas上下文环境\nlet ctx = canvas.getContext('2d')//绘制2d图形\nlet gl = canvas.getContext(\"webgl\");//绘制3d图形\n```\n### 绘制矩形\n\n#### ctx.rect(x,y,width,height);\n- 创建矩形。\n- 但并不会真正将矩形画出，只能调用stroke() 或 fill()后才会真正作用于画布。\n- 先填充再描边。\n- 可通过canvas.width或canvas.height获取画布的宽度和高度\n\n#### ctx.fillRect(x,y,width,height)\n- 执行填充操作，绘制一个已填色的、以(x,y)位置为起点、大小为width x height的矩形。\n- 有填充颜色，默认为black。\n\n####  ctx.fillStyle=\"\"\n为图形设置填充颜色\n\n#### ctx.strokeRect(x,y,width,height);\n- 绘制一个不填色、以(x,y)位置为起点、大小为width x height的矩形。\n- 有边框颜色，默认为black。\n\n#### ctx.strokeStyle=\"\"\n为图形设置边框颜色\n\n#### ctx.clearRect(x,y,width,height);\n- 将(x,y)位置大小为width x height的矩形变为透明。\n- Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 clearRect() 方法。\n- 若canvas设置了背景颜色是不能被清除的，因为那是画布的背景颜色，clearRect清除的是绘制的图形，使绘制的图形变为透明，显现出画布背景色。\n\n### 绘制复杂形状\n\n#### ctx.lineWidth=x;\n设置线宽为x，不需要加px\n\n#### ctx.fill();\n填充图形，可利用fillStyle设置填充颜色\n\n#### ctx.stroke();\n绘制图形，可利用strokeStyle设置边框颜色\n\n#### ctx.beginPath();\n清除原来的痕迹,绘制图形之前要先调用\n\n#### ctx.closePath();\n自动完成闭合\n\n#### ctx.moveTo(x,y);\n从(x,y)点开始绘图\n\n#### ctx.lineTo(x,y);\n绘图终点为(x,y)\n\n#### ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针) \n- 圆心为(x,y),半径为r\n- 弧度 = Math.PI*角度\n- 设置完弧线，要用moveTo()进行绘制\n\n### 绘制文本\n#### ctx.font = \"24px 宋体\"\n设置字体大小、型号\n\n#### ctx.fillText(\"文字内容\",left,top);\n- 绘制实心文字。\n- left为距画布最左边距离，top为距画布最上边距离。\n- 可通过fillStyke设置文字填充颜色\n\n#### ctx.strokeText(\"文字内容\",left,top);\n- 绘制空心文字。\n- left与top同上。\n- 可通过strokeStyle设置文字边框颜色。\n\n#### 设置文字阴影\n这些要在设置文字内容之前设置\n- ctx.shadowOffsetX = x; x轴偏移量，默认位于元素正下方。\n- ctx.shadowOffsetY = y; y轴偏移量，默认位于元素正下方。\n- ctx.shadowBlur = num; 设置模糊系数。默认为0不模糊。\n- ctx.shadowColor = \"\"; 设置阴影颜色，同时要设置shadowBlur，否则看不见\n\n用canvas画出一个(0,0)坐标绿色的100x100矩形框\n，再从(10,10)坐标将50x50的区域变成透明\n\n```\n<canvas id=\"test\" width=\"100px\" height=\"100px\"></canvas>\n\n<script>\nvar canvas = document.getElementById(\"test\");\nvar ctx = canvas.getContext(\"2d\");\nctx.fillStyle = \"green\";\nctx.fillRect(0,0,100,100);\nctx.clearRect(10,10,50,50);\n</script>\n```\n","source":"_posts/前端/canvas.md","raw":"---\ntitle: canvas\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\nCanvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。\n\n## 属性\n- height\n- width\n\n一个Canvas定义了一个指定尺寸的矩形框\n```\n<canvas id=\"test-canvas\" width=\"300\" height=\"200\"></canvas>\n```\n## 检测浏览器支持\n由于浏览器对HTML5标准支持不一致，所以，通常在canvas内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略canvas内部的HTML，如果浏览器不支持Canvas，它将显示canvas内部的HTML\n\n```\n<canvas id=\"test-stock\" width=\"300\" height=\"200\">\n    <p>Current Price: 25.51</p>\n</canvas>\n\n```\n在使用Canvas前，还需要用canvas.getContext来测试浏览器是否支持Canvas\n\n```\nvar canvas = document.getElementById('test-canvas');\nif (canvas.getContext) {\n    console.log('你的浏览器支持Canvas!');\n} else {\n    console.log('你的浏览器不支持Canvas!');\n}\n```\n## 方法\n\ncanvas绘图以左上角的（0， 0）为基准原点\n```\nlet canvas = document.querySelector('#canvas'); // 得到canvas\n//得到canvas上下文环境\nlet ctx = canvas.getContext('2d')//绘制2d图形\nlet gl = canvas.getContext(\"webgl\");//绘制3d图形\n```\n### 绘制矩形\n\n#### ctx.rect(x,y,width,height);\n- 创建矩形。\n- 但并不会真正将矩形画出，只能调用stroke() 或 fill()后才会真正作用于画布。\n- 先填充再描边。\n- 可通过canvas.width或canvas.height获取画布的宽度和高度\n\n#### ctx.fillRect(x,y,width,height)\n- 执行填充操作，绘制一个已填色的、以(x,y)位置为起点、大小为width x height的矩形。\n- 有填充颜色，默认为black。\n\n####  ctx.fillStyle=\"\"\n为图形设置填充颜色\n\n#### ctx.strokeRect(x,y,width,height);\n- 绘制一个不填色、以(x,y)位置为起点、大小为width x height的矩形。\n- 有边框颜色，默认为black。\n\n#### ctx.strokeStyle=\"\"\n为图形设置边框颜色\n\n#### ctx.clearRect(x,y,width,height);\n- 将(x,y)位置大小为width x height的矩形变为透明。\n- Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 clearRect() 方法。\n- 若canvas设置了背景颜色是不能被清除的，因为那是画布的背景颜色，clearRect清除的是绘制的图形，使绘制的图形变为透明，显现出画布背景色。\n\n### 绘制复杂形状\n\n#### ctx.lineWidth=x;\n设置线宽为x，不需要加px\n\n#### ctx.fill();\n填充图形，可利用fillStyle设置填充颜色\n\n#### ctx.stroke();\n绘制图形，可利用strokeStyle设置边框颜色\n\n#### ctx.beginPath();\n清除原来的痕迹,绘制图形之前要先调用\n\n#### ctx.closePath();\n自动完成闭合\n\n#### ctx.moveTo(x,y);\n从(x,y)点开始绘图\n\n#### ctx.lineTo(x,y);\n绘图终点为(x,y)\n\n#### ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针) \n- 圆心为(x,y),半径为r\n- 弧度 = Math.PI*角度\n- 设置完弧线，要用moveTo()进行绘制\n\n### 绘制文本\n#### ctx.font = \"24px 宋体\"\n设置字体大小、型号\n\n#### ctx.fillText(\"文字内容\",left,top);\n- 绘制实心文字。\n- left为距画布最左边距离，top为距画布最上边距离。\n- 可通过fillStyke设置文字填充颜色\n\n#### ctx.strokeText(\"文字内容\",left,top);\n- 绘制空心文字。\n- left与top同上。\n- 可通过strokeStyle设置文字边框颜色。\n\n#### 设置文字阴影\n这些要在设置文字内容之前设置\n- ctx.shadowOffsetX = x; x轴偏移量，默认位于元素正下方。\n- ctx.shadowOffsetY = y; y轴偏移量，默认位于元素正下方。\n- ctx.shadowBlur = num; 设置模糊系数。默认为0不模糊。\n- ctx.shadowColor = \"\"; 设置阴影颜色，同时要设置shadowBlur，否则看不见\n\n用canvas画出一个(0,0)坐标绿色的100x100矩形框\n，再从(10,10)坐标将50x50的区域变成透明\n\n```\n<canvas id=\"test\" width=\"100px\" height=\"100px\"></canvas>\n\n<script>\nvar canvas = document.getElementById(\"test\");\nvar ctx = canvas.getContext(\"2d\");\nctx.fillStyle = \"green\";\nctx.fillRect(0,0,100,100);\nctx.clearRect(10,10,50,50);\n</script>\n```\n","slug":"前端/canvas","published":1,"date":"2020-05-14T08:36:31.822Z","updated":"2020-05-14T08:28:24.167Z","layout":"post","photos":[],"link":"","_id":"cka6kinbn007tqgu90anit00c","content":"<p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li>height</li>\n<li>width</li>\n</ul>\n<p>一个Canvas定义了一个指定尺寸的矩形框<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"检测浏览器支持\"><a href=\"#检测浏览器支持\" class=\"headerlink\" title=\"检测浏览器支持\"></a>检测浏览器支持</h2><p>由于浏览器对HTML5标准支持不一致，所以，通常在canvas内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略canvas内部的HTML，如果浏览器不支持Canvas，它将显示canvas内部的HTML</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;</span><br><span class=\"line\">    &lt;p&gt;Current Price: 25.51&lt;/p&gt;</span><br><span class=\"line\">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>\n<p>在使用Canvas前，还需要用canvas.getContext来测试浏览器是否支持Canvas</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var canvas = document.getElementById(&apos;test-canvas&apos;);</span><br><span class=\"line\">if (canvas.getContext) &#123;</span><br><span class=\"line\">    console.log(&apos;你的浏览器支持Canvas!&apos;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;你的浏览器不支持Canvas!&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>canvas绘图以左上角的（0， 0）为基准原点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let canvas = document.querySelector(&apos;#canvas&apos;); // 得到canvas</span><br><span class=\"line\">//得到canvas上下文环境</span><br><span class=\"line\">let ctx = canvas.getContext(&apos;2d&apos;)//绘制2d图形</span><br><span class=\"line\">let gl = canvas.getContext(&quot;webgl&quot;);//绘制3d图形</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"绘制矩形\"><a href=\"#绘制矩形\" class=\"headerlink\" title=\"绘制矩形\"></a>绘制矩形</h3><h4 id=\"ctx-rect-x-y-width-height\"><a href=\"#ctx-rect-x-y-width-height\" class=\"headerlink\" title=\"ctx.rect(x,y,width,height);\"></a>ctx.rect(x,y,width,height);</h4><ul>\n<li>创建矩形。</li>\n<li>但并不会真正将矩形画出，只能调用stroke() 或 fill()后才会真正作用于画布。</li>\n<li>先填充再描边。</li>\n<li>可通过canvas.width或canvas.height获取画布的宽度和高度</li>\n</ul>\n<h4 id=\"ctx-fillRect-x-y-width-height\"><a href=\"#ctx-fillRect-x-y-width-height\" class=\"headerlink\" title=\"ctx.fillRect(x,y,width,height)\"></a>ctx.fillRect(x,y,width,height)</h4><ul>\n<li>执行填充操作，绘制一个已填色的、以(x,y)位置为起点、大小为width x height的矩形。</li>\n<li>有填充颜色，默认为black。</li>\n</ul>\n<h4 id=\"ctx-fillStyle-””\"><a href=\"#ctx-fillStyle-””\" class=\"headerlink\" title=\"ctx.fillStyle=””\"></a>ctx.fillStyle=””</h4><p>为图形设置填充颜色</p>\n<h4 id=\"ctx-strokeRect-x-y-width-height\"><a href=\"#ctx-strokeRect-x-y-width-height\" class=\"headerlink\" title=\"ctx.strokeRect(x,y,width,height);\"></a>ctx.strokeRect(x,y,width,height);</h4><ul>\n<li>绘制一个不填色、以(x,y)位置为起点、大小为width x height的矩形。</li>\n<li>有边框颜色，默认为black。</li>\n</ul>\n<h4 id=\"ctx-strokeStyle-””\"><a href=\"#ctx-strokeStyle-””\" class=\"headerlink\" title=\"ctx.strokeStyle=””\"></a>ctx.strokeStyle=””</h4><p>为图形设置边框颜色</p>\n<h4 id=\"ctx-clearRect-x-y-width-height\"><a href=\"#ctx-clearRect-x-y-width-height\" class=\"headerlink\" title=\"ctx.clearRect(x,y,width,height);\"></a>ctx.clearRect(x,y,width,height);</h4><ul>\n<li>将(x,y)位置大小为width x height的矩形变为透明。</li>\n<li>Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 clearRect() 方法。</li>\n<li>若canvas设置了背景颜色是不能被清除的，因为那是画布的背景颜色，clearRect清除的是绘制的图形，使绘制的图形变为透明，显现出画布背景色。</li>\n</ul>\n<h3 id=\"绘制复杂形状\"><a href=\"#绘制复杂形状\" class=\"headerlink\" title=\"绘制复杂形状\"></a>绘制复杂形状</h3><h4 id=\"ctx-lineWidth-x\"><a href=\"#ctx-lineWidth-x\" class=\"headerlink\" title=\"ctx.lineWidth=x;\"></a>ctx.lineWidth=x;</h4><p>设置线宽为x，不需要加px</p>\n<h4 id=\"ctx-fill\"><a href=\"#ctx-fill\" class=\"headerlink\" title=\"ctx.fill();\"></a>ctx.fill();</h4><p>填充图形，可利用fillStyle设置填充颜色</p>\n<h4 id=\"ctx-stroke\"><a href=\"#ctx-stroke\" class=\"headerlink\" title=\"ctx.stroke();\"></a>ctx.stroke();</h4><p>绘制图形，可利用strokeStyle设置边框颜色</p>\n<h4 id=\"ctx-beginPath\"><a href=\"#ctx-beginPath\" class=\"headerlink\" title=\"ctx.beginPath();\"></a>ctx.beginPath();</h4><p>清除原来的痕迹,绘制图形之前要先调用</p>\n<h4 id=\"ctx-closePath\"><a href=\"#ctx-closePath\" class=\"headerlink\" title=\"ctx.closePath();\"></a>ctx.closePath();</h4><p>自动完成闭合</p>\n<h4 id=\"ctx-moveTo-x-y\"><a href=\"#ctx-moveTo-x-y\" class=\"headerlink\" title=\"ctx.moveTo(x,y);\"></a>ctx.moveTo(x,y);</h4><p>从(x,y)点开始绘图</p>\n<h4 id=\"ctx-lineTo-x-y\"><a href=\"#ctx-lineTo-x-y\" class=\"headerlink\" title=\"ctx.lineTo(x,y);\"></a>ctx.lineTo(x,y);</h4><p>绘图终点为(x,y)</p>\n<h4 id=\"ctx-arc-x-y-r-起始弧度，-终点弧度，是否逆时针\"><a href=\"#ctx-arc-x-y-r-起始弧度，-终点弧度，是否逆时针\" class=\"headerlink\" title=\"ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针)\"></a>ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针)</h4><ul>\n<li>圆心为(x,y),半径为r</li>\n<li>弧度 = Math.PI*角度</li>\n<li>设置完弧线，要用moveTo()进行绘制</li>\n</ul>\n<h3 id=\"绘制文本\"><a href=\"#绘制文本\" class=\"headerlink\" title=\"绘制文本\"></a>绘制文本</h3><h4 id=\"ctx-font-“24px-宋体”\"><a href=\"#ctx-font-“24px-宋体”\" class=\"headerlink\" title=\"ctx.font = “24px 宋体”\"></a>ctx.font = “24px 宋体”</h4><p>设置字体大小、型号</p>\n<h4 id=\"ctx-fillText-“文字内容”-left-top\"><a href=\"#ctx-fillText-“文字内容”-left-top\" class=\"headerlink\" title=\"ctx.fillText(“文字内容”,left,top);\"></a>ctx.fillText(“文字内容”,left,top);</h4><ul>\n<li>绘制实心文字。</li>\n<li>left为距画布最左边距离，top为距画布最上边距离。</li>\n<li>可通过fillStyke设置文字填充颜色</li>\n</ul>\n<h4 id=\"ctx-strokeText-“文字内容”-left-top\"><a href=\"#ctx-strokeText-“文字内容”-left-top\" class=\"headerlink\" title=\"ctx.strokeText(“文字内容”,left,top);\"></a>ctx.strokeText(“文字内容”,left,top);</h4><ul>\n<li>绘制空心文字。</li>\n<li>left与top同上。</li>\n<li>可通过strokeStyle设置文字边框颜色。</li>\n</ul>\n<h4 id=\"设置文字阴影\"><a href=\"#设置文字阴影\" class=\"headerlink\" title=\"设置文字阴影\"></a>设置文字阴影</h4><p>这些要在设置文字内容之前设置</p>\n<ul>\n<li>ctx.shadowOffsetX = x; x轴偏移量，默认位于元素正下方。</li>\n<li>ctx.shadowOffsetY = y; y轴偏移量，默认位于元素正下方。</li>\n<li>ctx.shadowBlur = num; 设置模糊系数。默认为0不模糊。</li>\n<li>ctx.shadowColor = “”; 设置阴影颜色，同时要设置shadowBlur，否则看不见</li>\n</ul>\n<p>用canvas画出一个(0,0)坐标绿色的100x100矩形框<br>，再从(10,10)坐标将50x50的区域变成透明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;canvas id=&quot;test&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var canvas = document.getElementById(&quot;test&quot;);</span><br><span class=\"line\">var ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class=\"line\">ctx.fillStyle = &quot;green&quot;;</span><br><span class=\"line\">ctx.fillRect(0,0,100,100);</span><br><span class=\"line\">ctx.clearRect(10,10,50,50);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li>height</li>\n<li>width</li>\n</ul>\n<p>一个Canvas定义了一个指定尺寸的矩形框<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"检测浏览器支持\"><a href=\"#检测浏览器支持\" class=\"headerlink\" title=\"检测浏览器支持\"></a>检测浏览器支持</h2><p>由于浏览器对HTML5标准支持不一致，所以，通常在canvas内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略canvas内部的HTML，如果浏览器不支持Canvas，它将显示canvas内部的HTML</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;</span><br><span class=\"line\">    &lt;p&gt;Current Price: 25.51&lt;/p&gt;</span><br><span class=\"line\">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>\n<p>在使用Canvas前，还需要用canvas.getContext来测试浏览器是否支持Canvas</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var canvas = document.getElementById(&apos;test-canvas&apos;);</span><br><span class=\"line\">if (canvas.getContext) &#123;</span><br><span class=\"line\">    console.log(&apos;你的浏览器支持Canvas!&apos;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;你的浏览器不支持Canvas!&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>canvas绘图以左上角的（0， 0）为基准原点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let canvas = document.querySelector(&apos;#canvas&apos;); // 得到canvas</span><br><span class=\"line\">//得到canvas上下文环境</span><br><span class=\"line\">let ctx = canvas.getContext(&apos;2d&apos;)//绘制2d图形</span><br><span class=\"line\">let gl = canvas.getContext(&quot;webgl&quot;);//绘制3d图形</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"绘制矩形\"><a href=\"#绘制矩形\" class=\"headerlink\" title=\"绘制矩形\"></a>绘制矩形</h3><h4 id=\"ctx-rect-x-y-width-height\"><a href=\"#ctx-rect-x-y-width-height\" class=\"headerlink\" title=\"ctx.rect(x,y,width,height);\"></a>ctx.rect(x,y,width,height);</h4><ul>\n<li>创建矩形。</li>\n<li>但并不会真正将矩形画出，只能调用stroke() 或 fill()后才会真正作用于画布。</li>\n<li>先填充再描边。</li>\n<li>可通过canvas.width或canvas.height获取画布的宽度和高度</li>\n</ul>\n<h4 id=\"ctx-fillRect-x-y-width-height\"><a href=\"#ctx-fillRect-x-y-width-height\" class=\"headerlink\" title=\"ctx.fillRect(x,y,width,height)\"></a>ctx.fillRect(x,y,width,height)</h4><ul>\n<li>执行填充操作，绘制一个已填色的、以(x,y)位置为起点、大小为width x height的矩形。</li>\n<li>有填充颜色，默认为black。</li>\n</ul>\n<h4 id=\"ctx-fillStyle-””\"><a href=\"#ctx-fillStyle-””\" class=\"headerlink\" title=\"ctx.fillStyle=””\"></a>ctx.fillStyle=””</h4><p>为图形设置填充颜色</p>\n<h4 id=\"ctx-strokeRect-x-y-width-height\"><a href=\"#ctx-strokeRect-x-y-width-height\" class=\"headerlink\" title=\"ctx.strokeRect(x,y,width,height);\"></a>ctx.strokeRect(x,y,width,height);</h4><ul>\n<li>绘制一个不填色、以(x,y)位置为起点、大小为width x height的矩形。</li>\n<li>有边框颜色，默认为black。</li>\n</ul>\n<h4 id=\"ctx-strokeStyle-””\"><a href=\"#ctx-strokeStyle-””\" class=\"headerlink\" title=\"ctx.strokeStyle=””\"></a>ctx.strokeStyle=””</h4><p>为图形设置边框颜色</p>\n<h4 id=\"ctx-clearRect-x-y-width-height\"><a href=\"#ctx-clearRect-x-y-width-height\" class=\"headerlink\" title=\"ctx.clearRect(x,y,width,height);\"></a>ctx.clearRect(x,y,width,height);</h4><ul>\n<li>将(x,y)位置大小为width x height的矩形变为透明。</li>\n<li>Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 clearRect() 方法。</li>\n<li>若canvas设置了背景颜色是不能被清除的，因为那是画布的背景颜色，clearRect清除的是绘制的图形，使绘制的图形变为透明，显现出画布背景色。</li>\n</ul>\n<h3 id=\"绘制复杂形状\"><a href=\"#绘制复杂形状\" class=\"headerlink\" title=\"绘制复杂形状\"></a>绘制复杂形状</h3><h4 id=\"ctx-lineWidth-x\"><a href=\"#ctx-lineWidth-x\" class=\"headerlink\" title=\"ctx.lineWidth=x;\"></a>ctx.lineWidth=x;</h4><p>设置线宽为x，不需要加px</p>\n<h4 id=\"ctx-fill\"><a href=\"#ctx-fill\" class=\"headerlink\" title=\"ctx.fill();\"></a>ctx.fill();</h4><p>填充图形，可利用fillStyle设置填充颜色</p>\n<h4 id=\"ctx-stroke\"><a href=\"#ctx-stroke\" class=\"headerlink\" title=\"ctx.stroke();\"></a>ctx.stroke();</h4><p>绘制图形，可利用strokeStyle设置边框颜色</p>\n<h4 id=\"ctx-beginPath\"><a href=\"#ctx-beginPath\" class=\"headerlink\" title=\"ctx.beginPath();\"></a>ctx.beginPath();</h4><p>清除原来的痕迹,绘制图形之前要先调用</p>\n<h4 id=\"ctx-closePath\"><a href=\"#ctx-closePath\" class=\"headerlink\" title=\"ctx.closePath();\"></a>ctx.closePath();</h4><p>自动完成闭合</p>\n<h4 id=\"ctx-moveTo-x-y\"><a href=\"#ctx-moveTo-x-y\" class=\"headerlink\" title=\"ctx.moveTo(x,y);\"></a>ctx.moveTo(x,y);</h4><p>从(x,y)点开始绘图</p>\n<h4 id=\"ctx-lineTo-x-y\"><a href=\"#ctx-lineTo-x-y\" class=\"headerlink\" title=\"ctx.lineTo(x,y);\"></a>ctx.lineTo(x,y);</h4><p>绘图终点为(x,y)</p>\n<h4 id=\"ctx-arc-x-y-r-起始弧度，-终点弧度，是否逆时针\"><a href=\"#ctx-arc-x-y-r-起始弧度，-终点弧度，是否逆时针\" class=\"headerlink\" title=\"ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针)\"></a>ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针)</h4><ul>\n<li>圆心为(x,y),半径为r</li>\n<li>弧度 = Math.PI*角度</li>\n<li>设置完弧线，要用moveTo()进行绘制</li>\n</ul>\n<h3 id=\"绘制文本\"><a href=\"#绘制文本\" class=\"headerlink\" title=\"绘制文本\"></a>绘制文本</h3><h4 id=\"ctx-font-“24px-宋体”\"><a href=\"#ctx-font-“24px-宋体”\" class=\"headerlink\" title=\"ctx.font = “24px 宋体”\"></a>ctx.font = “24px 宋体”</h4><p>设置字体大小、型号</p>\n<h4 id=\"ctx-fillText-“文字内容”-left-top\"><a href=\"#ctx-fillText-“文字内容”-left-top\" class=\"headerlink\" title=\"ctx.fillText(“文字内容”,left,top);\"></a>ctx.fillText(“文字内容”,left,top);</h4><ul>\n<li>绘制实心文字。</li>\n<li>left为距画布最左边距离，top为距画布最上边距离。</li>\n<li>可通过fillStyke设置文字填充颜色</li>\n</ul>\n<h4 id=\"ctx-strokeText-“文字内容”-left-top\"><a href=\"#ctx-strokeText-“文字内容”-left-top\" class=\"headerlink\" title=\"ctx.strokeText(“文字内容”,left,top);\"></a>ctx.strokeText(“文字内容”,left,top);</h4><ul>\n<li>绘制空心文字。</li>\n<li>left与top同上。</li>\n<li>可通过strokeStyle设置文字边框颜色。</li>\n</ul>\n<h4 id=\"设置文字阴影\"><a href=\"#设置文字阴影\" class=\"headerlink\" title=\"设置文字阴影\"></a>设置文字阴影</h4><p>这些要在设置文字内容之前设置</p>\n<ul>\n<li>ctx.shadowOffsetX = x; x轴偏移量，默认位于元素正下方。</li>\n<li>ctx.shadowOffsetY = y; y轴偏移量，默认位于元素正下方。</li>\n<li>ctx.shadowBlur = num; 设置模糊系数。默认为0不模糊。</li>\n<li>ctx.shadowColor = “”; 设置阴影颜色，同时要设置shadowBlur，否则看不见</li>\n</ul>\n<p>用canvas画出一个(0,0)坐标绿色的100x100矩形框<br>，再从(10,10)坐标将50x50的区域变成透明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;canvas id=&quot;test&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var canvas = document.getElementById(&quot;test&quot;);</span><br><span class=\"line\">var ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class=\"line\">ctx.fillStyle = &quot;green&quot;;</span><br><span class=\"line\">ctx.fillRect(0,0,100,100);</span><br><span class=\"line\">ctx.clearRect(10,10,50,50);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"h5和css3的新特性","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n## HTML5\n### 绘画标签canvas\n### 用于媒介回放的video、audio\n### 本地离线存储localStorage\n长期存储数据，浏览器关闭后数据不丢失 \n### sessionStorage\n数据在浏览器关闭后自动删除； \n### 语义化更好的内容元素\n比如article、footer、header、nav、section； \n### 表单控件\ncalendar、data、time、email、url、search； \n### webworker、websocket、Geolocation； 移除的元素： \n- 纯表现的元素：basefont、big、center、font、s、strike、tt\n- 对可用性产生负面影响的元素：frame、frameset、noframes\n\n## CSS3\n### RGBA和透明度\n### word-wrap（对长的不可分割单词换行）\n```\nword-wrap: normal|break-word;\n```\n### 文字阴影\n```\ntext-shadow：5px 5px 5px #FF0000;\n//水平阴影，垂直阴影，模糊距离，阴影颜色\n```\n### @font-face规则\n定义自己的字体\n### 圆角（边框半径）\nborder-radius 属性用于创建圆角\n### 边框图片\nborder-image\n### box-sizing\n### 盒阴影\n```\nbox-shadow:10px 10px 5px #88888\n```\n### 媒体查询\n定义两套css，当浏览器的尺寸变化时会采用不同的属性","source":"_posts/前端/h5和css3的新特性.md","raw":"---\ntitle: h5和css3的新特性\nDate: 2019-03-26\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n## HTML5\n### 绘画标签canvas\n### 用于媒介回放的video、audio\n### 本地离线存储localStorage\n长期存储数据，浏览器关闭后数据不丢失 \n### sessionStorage\n数据在浏览器关闭后自动删除； \n### 语义化更好的内容元素\n比如article、footer、header、nav、section； \n### 表单控件\ncalendar、data、time、email、url、search； \n### webworker、websocket、Geolocation； 移除的元素： \n- 纯表现的元素：basefont、big、center、font、s、strike、tt\n- 对可用性产生负面影响的元素：frame、frameset、noframes\n\n## CSS3\n### RGBA和透明度\n### word-wrap（对长的不可分割单词换行）\n```\nword-wrap: normal|break-word;\n```\n### 文字阴影\n```\ntext-shadow：5px 5px 5px #FF0000;\n//水平阴影，垂直阴影，模糊距离，阴影颜色\n```\n### @font-face规则\n定义自己的字体\n### 圆角（边框半径）\nborder-radius 属性用于创建圆角\n### 边框图片\nborder-image\n### box-sizing\n### 盒阴影\n```\nbox-shadow:10px 10px 5px #88888\n```\n### 媒体查询\n定义两套css，当浏览器的尺寸变化时会采用不同的属性","slug":"前端/h5和css3的新特性","published":1,"date":"2019-03-26T03:46:16.459Z","updated":"2019-03-26T03:44:59.306Z","layout":"post","photos":[],"link":"","_id":"cka6kinbn007wqgu9j5fvok95","content":"<h2 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h2><h3 id=\"绘画标签canvas\"><a href=\"#绘画标签canvas\" class=\"headerlink\" title=\"绘画标签canvas\"></a>绘画标签canvas</h3><h3 id=\"用于媒介回放的video、audio\"><a href=\"#用于媒介回放的video、audio\" class=\"headerlink\" title=\"用于媒介回放的video、audio\"></a>用于媒介回放的video、audio</h3><h3 id=\"本地离线存储localStorage\"><a href=\"#本地离线存储localStorage\" class=\"headerlink\" title=\"本地离线存储localStorage\"></a>本地离线存储localStorage</h3><p>长期存储数据，浏览器关闭后数据不丢失 </p>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>数据在浏览器关闭后自动删除； </p>\n<h3 id=\"语义化更好的内容元素\"><a href=\"#语义化更好的内容元素\" class=\"headerlink\" title=\"语义化更好的内容元素\"></a>语义化更好的内容元素</h3><p>比如article、footer、header、nav、section； </p>\n<h3 id=\"表单控件\"><a href=\"#表单控件\" class=\"headerlink\" title=\"表单控件\"></a>表单控件</h3><p>calendar、data、time、email、url、search； </p>\n<h3 id=\"webworker、websocket、Geolocation；-移除的元素：\"><a href=\"#webworker、websocket、Geolocation；-移除的元素：\" class=\"headerlink\" title=\"webworker、websocket、Geolocation； 移除的元素：\"></a>webworker、websocket、Geolocation； 移除的元素：</h3><ul>\n<li>纯表现的元素：basefont、big、center、font、s、strike、tt</li>\n<li>对可用性产生负面影响的元素：frame、frameset、noframes</li>\n</ul>\n<h2 id=\"CSS3\"><a href=\"#CSS3\" class=\"headerlink\" title=\"CSS3\"></a>CSS3</h2><h3 id=\"RGBA和透明度\"><a href=\"#RGBA和透明度\" class=\"headerlink\" title=\"RGBA和透明度\"></a>RGBA和透明度</h3><h3 id=\"word-wrap（对长的不可分割单词换行）\"><a href=\"#word-wrap（对长的不可分割单词换行）\" class=\"headerlink\" title=\"word-wrap（对长的不可分割单词换行）\"></a>word-wrap（对长的不可分割单词换行）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word-wrap: normal|break-word;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文字阴影\"><a href=\"#文字阴影\" class=\"headerlink\" title=\"文字阴影\"></a>文字阴影</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text-shadow：5px 5px 5px #FF0000;</span><br><span class=\"line\">//水平阴影，垂直阴影，模糊距离，阴影颜色</span><br></pre></td></tr></table></figure>\n<h3 id=\"font-face规则\"><a href=\"#font-face规则\" class=\"headerlink\" title=\"@font-face规则\"></a>@font-face规则</h3><p>定义自己的字体</p>\n<h3 id=\"圆角（边框半径）\"><a href=\"#圆角（边框半径）\" class=\"headerlink\" title=\"圆角（边框半径）\"></a>圆角（边框半径）</h3><p>border-radius 属性用于创建圆角</p>\n<h3 id=\"边框图片\"><a href=\"#边框图片\" class=\"headerlink\" title=\"边框图片\"></a>边框图片</h3><p>border-image</p>\n<h3 id=\"box-sizing\"><a href=\"#box-sizing\" class=\"headerlink\" title=\"box-sizing\"></a>box-sizing</h3><h3 id=\"盒阴影\"><a href=\"#盒阴影\" class=\"headerlink\" title=\"盒阴影\"></a>盒阴影</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">box-shadow:10px 10px 5px #88888</span><br></pre></td></tr></table></figure>\n<h3 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h3><p>定义两套css，当浏览器的尺寸变化时会采用不同的属性</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h2><h3 id=\"绘画标签canvas\"><a href=\"#绘画标签canvas\" class=\"headerlink\" title=\"绘画标签canvas\"></a>绘画标签canvas</h3><h3 id=\"用于媒介回放的video、audio\"><a href=\"#用于媒介回放的video、audio\" class=\"headerlink\" title=\"用于媒介回放的video、audio\"></a>用于媒介回放的video、audio</h3><h3 id=\"本地离线存储localStorage\"><a href=\"#本地离线存储localStorage\" class=\"headerlink\" title=\"本地离线存储localStorage\"></a>本地离线存储localStorage</h3><p>长期存储数据，浏览器关闭后数据不丢失 </p>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>数据在浏览器关闭后自动删除； </p>\n<h3 id=\"语义化更好的内容元素\"><a href=\"#语义化更好的内容元素\" class=\"headerlink\" title=\"语义化更好的内容元素\"></a>语义化更好的内容元素</h3><p>比如article、footer、header、nav、section； </p>\n<h3 id=\"表单控件\"><a href=\"#表单控件\" class=\"headerlink\" title=\"表单控件\"></a>表单控件</h3><p>calendar、data、time、email、url、search； </p>\n<h3 id=\"webworker、websocket、Geolocation；-移除的元素：\"><a href=\"#webworker、websocket、Geolocation；-移除的元素：\" class=\"headerlink\" title=\"webworker、websocket、Geolocation； 移除的元素：\"></a>webworker、websocket、Geolocation； 移除的元素：</h3><ul>\n<li>纯表现的元素：basefont、big、center、font、s、strike、tt</li>\n<li>对可用性产生负面影响的元素：frame、frameset、noframes</li>\n</ul>\n<h2 id=\"CSS3\"><a href=\"#CSS3\" class=\"headerlink\" title=\"CSS3\"></a>CSS3</h2><h3 id=\"RGBA和透明度\"><a href=\"#RGBA和透明度\" class=\"headerlink\" title=\"RGBA和透明度\"></a>RGBA和透明度</h3><h3 id=\"word-wrap（对长的不可分割单词换行）\"><a href=\"#word-wrap（对长的不可分割单词换行）\" class=\"headerlink\" title=\"word-wrap（对长的不可分割单词换行）\"></a>word-wrap（对长的不可分割单词换行）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word-wrap: normal|break-word;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文字阴影\"><a href=\"#文字阴影\" class=\"headerlink\" title=\"文字阴影\"></a>文字阴影</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text-shadow：5px 5px 5px #FF0000;</span><br><span class=\"line\">//水平阴影，垂直阴影，模糊距离，阴影颜色</span><br></pre></td></tr></table></figure>\n<h3 id=\"font-face规则\"><a href=\"#font-face规则\" class=\"headerlink\" title=\"@font-face规则\"></a>@font-face规则</h3><p>定义自己的字体</p>\n<h3 id=\"圆角（边框半径）\"><a href=\"#圆角（边框半径）\" class=\"headerlink\" title=\"圆角（边框半径）\"></a>圆角（边框半径）</h3><p>border-radius 属性用于创建圆角</p>\n<h3 id=\"边框图片\"><a href=\"#边框图片\" class=\"headerlink\" title=\"边框图片\"></a>边框图片</h3><p>border-image</p>\n<h3 id=\"box-sizing\"><a href=\"#box-sizing\" class=\"headerlink\" title=\"box-sizing\"></a>box-sizing</h3><h3 id=\"盒阴影\"><a href=\"#盒阴影\" class=\"headerlink\" title=\"盒阴影\"></a>盒阴影</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">box-shadow:10px 10px 5px #88888</span><br></pre></td></tr></table></figure>\n<h3 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h3><p>定义两套css，当浏览器的尺寸变化时会采用不同的属性</p>\n"},{"title":"web页面性能优化","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n## 请求和响应\n### 减少http请求。\n一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。    \n资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。\n\n### 使用CDN加速（缓存）。\nCDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。其本质上是一个缓存，而且将数据（js、css、image等静态资源）缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。\n\n使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓存。\n\n当用户发起访问时，他的访问请求被只能dns定位到最近的缓存服务器，当服务器中没有缓存时，就会去请求最近的服务器中的资源。\n\n### 利用浏览器缓存\n通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,将网络资源存储到本地，下次请求资源时，如果命中可直接在本地获取，不需要重新向服务器请求资源\n\n### 避免重定向。\n当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。\n\n重定向和404将浪费加载请求。\n\n## HTML\n\n### 合理使用内联。\n脚本和样式，应按需选择内联或者外链。对于访问少、样式和脚本复用少的页面，可以考虑使用内联样式从而减少 HTTP 请求。\n\n但如果页面访问频繁，样式脚本在多个页面经常复用，使用外链则是最优选择。\n\n这样浏览器可以缓存它们，下次加载时可以直接从缓存加载。\n\n### 减少dom\n过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）。\n\n### 优化dom操作\n- 使用事件委托来减少事件处理器的数量\n- 减少重绘和回流\n\n如果需要在 DOM操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 一个一个地操作样式。\n\n###  删除HTML的默认属性。\n\n## js\n### 优化js。\n- 将所有script标签放置在页面的底部,紧靠 body 关闭标签</body>的上方。因为页面解析生成dom树时遇到script标签会停下去加载执行js。此法可以保证页面在脚本运行之前完成解析。\n- 将脚本成组打包。页面的<script>标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。\n\n由于浏览器渲染机制的设置，gui渲染线程和js引擎互斥，因此js的执行会阻塞dom的解析和渲染以及其他资源的加载。\n\n## css\n### 将样式表放在头部。\n\ncss在head中通过link引入下载会阻塞页面的渲染，页面的渲染会等待css解析完生成cssom树，再结合dom树生成渲染树进行渲染。所以最好的做法是把css放在页面的最上面，让浏览器尽快下载css，减少首屏加载时间，避免白屏。\n\n为了浏览器的渲染，能让页面显示的时候视觉上更好。避免某些情况，如：假设你放在页面最底部，则不会阻塞，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果\n\n由于gui渲染机制和js引擎互斥，因此css加载会阻塞js的加载，但是cssom和dom是并行的，css加载并不阻塞dom的解析，也不阻塞其他资源的加载，但两者需要互相配合生成渲染树，因此会阻塞dom的渲染。\n\n### 优化css，避免css表达式。\n会导致效率低下。\n\n## 资源\n\n### 延迟加载图片。\n不直接给src路径，而是在页面加载完成后用js操作src，减少了页面加载图片的时间。\n\n### 懒加载\n在进入可视区域之后在进行请求资源\n\n### 预加载\n在静态资源使用前先加载，在使用时可直接在缓存中获取","source":"_posts/前端/web页面性能优化.md","raw":"---\ntitle: web页面性能优化\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n## 请求和响应\n### 减少http请求。\n一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。    \n资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。\n\n### 使用CDN加速（缓存）。\nCDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。其本质上是一个缓存，而且将数据（js、css、image等静态资源）缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。\n\n使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓存。\n\n当用户发起访问时，他的访问请求被只能dns定位到最近的缓存服务器，当服务器中没有缓存时，就会去请求最近的服务器中的资源。\n\n### 利用浏览器缓存\n通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,将网络资源存储到本地，下次请求资源时，如果命中可直接在本地获取，不需要重新向服务器请求资源\n\n### 避免重定向。\n当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。\n\n重定向和404将浪费加载请求。\n\n## HTML\n\n### 合理使用内联。\n脚本和样式，应按需选择内联或者外链。对于访问少、样式和脚本复用少的页面，可以考虑使用内联样式从而减少 HTTP 请求。\n\n但如果页面访问频繁，样式脚本在多个页面经常复用，使用外链则是最优选择。\n\n这样浏览器可以缓存它们，下次加载时可以直接从缓存加载。\n\n### 减少dom\n过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）。\n\n### 优化dom操作\n- 使用事件委托来减少事件处理器的数量\n- 减少重绘和回流\n\n如果需要在 DOM操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 一个一个地操作样式。\n\n###  删除HTML的默认属性。\n\n## js\n### 优化js。\n- 将所有script标签放置在页面的底部,紧靠 body 关闭标签</body>的上方。因为页面解析生成dom树时遇到script标签会停下去加载执行js。此法可以保证页面在脚本运行之前完成解析。\n- 将脚本成组打包。页面的<script>标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。\n\n由于浏览器渲染机制的设置，gui渲染线程和js引擎互斥，因此js的执行会阻塞dom的解析和渲染以及其他资源的加载。\n\n## css\n### 将样式表放在头部。\n\ncss在head中通过link引入下载会阻塞页面的渲染，页面的渲染会等待css解析完生成cssom树，再结合dom树生成渲染树进行渲染。所以最好的做法是把css放在页面的最上面，让浏览器尽快下载css，减少首屏加载时间，避免白屏。\n\n为了浏览器的渲染，能让页面显示的时候视觉上更好。避免某些情况，如：假设你放在页面最底部，则不会阻塞，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果\n\n由于gui渲染机制和js引擎互斥，因此css加载会阻塞js的加载，但是cssom和dom是并行的，css加载并不阻塞dom的解析，也不阻塞其他资源的加载，但两者需要互相配合生成渲染树，因此会阻塞dom的渲染。\n\n### 优化css，避免css表达式。\n会导致效率低下。\n\n## 资源\n\n### 延迟加载图片。\n不直接给src路径，而是在页面加载完成后用js操作src，减少了页面加载图片的时间。\n\n### 懒加载\n在进入可视区域之后在进行请求资源\n\n### 预加载\n在静态资源使用前先加载，在使用时可直接在缓存中获取","slug":"前端/web页面性能优化","published":1,"date":"2020-05-14T08:36:31.879Z","updated":"2020-05-14T08:29:37.088Z","layout":"post","photos":[],"link":"","_id":"cka6kinbx0081qgu94ymcmb5g","content":"<h2 id=\"请求和响应\"><a href=\"#请求和响应\" class=\"headerlink\" title=\"请求和响应\"></a>请求和响应</h2><h3 id=\"减少http请求。\"><a href=\"#减少http请求。\" class=\"headerlink\" title=\"减少http请求。\"></a>减少http请求。</h3><p>一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。<br>资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。</p>\n<h3 id=\"使用CDN加速（缓存）。\"><a href=\"#使用CDN加速（缓存）。\" class=\"headerlink\" title=\"使用CDN加速（缓存）。\"></a>使用CDN加速（缓存）。</h3><p>CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。其本质上是一个缓存，而且将数据（js、css、image等静态资源）缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。</p>\n<p>使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓存。</p>\n<p>当用户发起访问时，他的访问请求被只能dns定位到最近的缓存服务器，当服务器中没有缓存时，就会去请求最近的服务器中的资源。</p>\n<h3 id=\"利用浏览器缓存\"><a href=\"#利用浏览器缓存\" class=\"headerlink\" title=\"利用浏览器缓存\"></a>利用浏览器缓存</h3><p>通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,将网络资源存储到本地，下次请求资源时，如果命中可直接在本地获取，不需要重新向服务器请求资源</p>\n<h3 id=\"避免重定向。\"><a href=\"#避免重定向。\" class=\"headerlink\" title=\"避免重定向。\"></a>避免重定向。</h3><p>当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。</p>\n<p>重定向和404将浪费加载请求。</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><h3 id=\"合理使用内联。\"><a href=\"#合理使用内联。\" class=\"headerlink\" title=\"合理使用内联。\"></a>合理使用内联。</h3><p>脚本和样式，应按需选择内联或者外链。对于访问少、样式和脚本复用少的页面，可以考虑使用内联样式从而减少 HTTP 请求。</p>\n<p>但如果页面访问频繁，样式脚本在多个页面经常复用，使用外链则是最优选择。</p>\n<p>这样浏览器可以缓存它们，下次加载时可以直接从缓存加载。</p>\n<h3 id=\"减少dom\"><a href=\"#减少dom\" class=\"headerlink\" title=\"减少dom\"></a>减少dom</h3><p>过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）。</p>\n<h3 id=\"优化dom操作\"><a href=\"#优化dom操作\" class=\"headerlink\" title=\"优化dom操作\"></a>优化dom操作</h3><ul>\n<li>使用事件委托来减少事件处理器的数量</li>\n<li>减少重绘和回流</li>\n</ul>\n<p>如果需要在 DOM操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 一个一个地操作样式。</p>\n<h3 id=\"删除HTML的默认属性。\"><a href=\"#删除HTML的默认属性。\" class=\"headerlink\" title=\"删除HTML的默认属性。\"></a>删除HTML的默认属性。</h3><h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><h3 id=\"优化js。\"><a href=\"#优化js。\" class=\"headerlink\" title=\"优化js。\"></a>优化js。</h3><ul>\n<li>将所有script标签放置在页面的底部,紧靠 body 关闭标签的上方。因为页面解析生成dom树时遇到script标签会停下去加载执行js。此法可以保证页面在脚本运行之前完成解析。</li>\n<li>将脚本成组打包。页面的<script>标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。</li>\n</ul>\n<p>由于浏览器渲染机制的设置，gui渲染线程和js引擎互斥，因此js的执行会阻塞dom的解析和渲染以及其他资源的加载。</p>\n<h2 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h2><h3 id=\"将样式表放在头部。\"><a href=\"#将样式表放在头部。\" class=\"headerlink\" title=\"将样式表放在头部。\"></a>将样式表放在头部。</h3><p>css在head中通过link引入下载会阻塞页面的渲染，页面的渲染会等待css解析完生成cssom树，再结合dom树生成渲染树进行渲染。所以最好的做法是把css放在页面的最上面，让浏览器尽快下载css，减少首屏加载时间，避免白屏。</p>\n<p>为了浏览器的渲染，能让页面显示的时候视觉上更好。避免某些情况，如：假设你放在页面最底部，则不会阻塞，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果</p>\n<p>由于gui渲染机制和js引擎互斥，因此css加载会阻塞js的加载，但是cssom和dom是并行的，css加载并不阻塞dom的解析，也不阻塞其他资源的加载，但两者需要互相配合生成渲染树，因此会阻塞dom的渲染。</p>\n<h3 id=\"优化css，避免css表达式。\"><a href=\"#优化css，避免css表达式。\" class=\"headerlink\" title=\"优化css，避免css表达式。\"></a>优化css，避免css表达式。</h3><p>会导致效率低下。</p>\n<h2 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h2><h3 id=\"延迟加载图片。\"><a href=\"#延迟加载图片。\" class=\"headerlink\" title=\"延迟加载图片。\"></a>延迟加载图片。</h3><p>不直接给src路径，而是在页面加载完成后用js操作src，减少了页面加载图片的时间。</p>\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><p>在进入可视区域之后在进行请求资源</p>\n<h3 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h3><p>在静态资源使用前先加载，在使用时可直接在缓存中获取</p>\n</script></li></ul>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"请求和响应\"><a href=\"#请求和响应\" class=\"headerlink\" title=\"请求和响应\"></a>请求和响应</h2><h3 id=\"减少http请求。\"><a href=\"#减少http请求。\" class=\"headerlink\" title=\"减少http请求。\"></a>减少http请求。</h3><p>一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。<br>资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。</p>\n<h3 id=\"使用CDN加速（缓存）。\"><a href=\"#使用CDN加速（缓存）。\" class=\"headerlink\" title=\"使用CDN加速（缓存）。\"></a>使用CDN加速（缓存）。</h3><p>CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。其本质上是一个缓存，而且将数据（js、css、image等静态资源）缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。</p>\n<p>使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓存。</p>\n<p>当用户发起访问时，他的访问请求被只能dns定位到最近的缓存服务器，当服务器中没有缓存时，就会去请求最近的服务器中的资源。</p>\n<h3 id=\"利用浏览器缓存\"><a href=\"#利用浏览器缓存\" class=\"headerlink\" title=\"利用浏览器缓存\"></a>利用浏览器缓存</h3><p>通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,将网络资源存储到本地，下次请求资源时，如果命中可直接在本地获取，不需要重新向服务器请求资源</p>\n<h3 id=\"避免重定向。\"><a href=\"#避免重定向。\" class=\"headerlink\" title=\"避免重定向。\"></a>避免重定向。</h3><p>当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。</p>\n<p>重定向和404将浪费加载请求。</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><h3 id=\"合理使用内联。\"><a href=\"#合理使用内联。\" class=\"headerlink\" title=\"合理使用内联。\"></a>合理使用内联。</h3><p>脚本和样式，应按需选择内联或者外链。对于访问少、样式和脚本复用少的页面，可以考虑使用内联样式从而减少 HTTP 请求。</p>\n<p>但如果页面访问频繁，样式脚本在多个页面经常复用，使用外链则是最优选择。</p>\n<p>这样浏览器可以缓存它们，下次加载时可以直接从缓存加载。</p>\n<h3 id=\"减少dom\"><a href=\"#减少dom\" class=\"headerlink\" title=\"减少dom\"></a>减少dom</h3><p>过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）。</p>\n<h3 id=\"优化dom操作\"><a href=\"#优化dom操作\" class=\"headerlink\" title=\"优化dom操作\"></a>优化dom操作</h3><ul>\n<li>使用事件委托来减少事件处理器的数量</li>\n<li>减少重绘和回流</li>\n</ul>\n<p>如果需要在 DOM操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 一个一个地操作样式。</p>\n<h3 id=\"删除HTML的默认属性。\"><a href=\"#删除HTML的默认属性。\" class=\"headerlink\" title=\"删除HTML的默认属性。\"></a>删除HTML的默认属性。</h3><h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><h3 id=\"优化js。\"><a href=\"#优化js。\" class=\"headerlink\" title=\"优化js。\"></a>优化js。</h3><ul>\n<li>将所有script标签放置在页面的底部,紧靠 body 关闭标签的上方。因为页面解析生成dom树时遇到script标签会停下去加载执行js。此法可以保证页面在脚本运行之前完成解析。</li>\n<li>将脚本成组打包。页面的<script>标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。</li>\n</ul>\n<p>由于浏览器渲染机制的设置，gui渲染线程和js引擎互斥，因此js的执行会阻塞dom的解析和渲染以及其他资源的加载。</p>\n<h2 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h2><h3 id=\"将样式表放在头部。\"><a href=\"#将样式表放在头部。\" class=\"headerlink\" title=\"将样式表放在头部。\"></a>将样式表放在头部。</h3><p>css在head中通过link引入下载会阻塞页面的渲染，页面的渲染会等待css解析完生成cssom树，再结合dom树生成渲染树进行渲染。所以最好的做法是把css放在页面的最上面，让浏览器尽快下载css，减少首屏加载时间，避免白屏。</p>\n<p>为了浏览器的渲染，能让页面显示的时候视觉上更好。避免某些情况，如：假设你放在页面最底部，则不会阻塞，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果</p>\n<p>由于gui渲染机制和js引擎互斥，因此css加载会阻塞js的加载，但是cssom和dom是并行的，css加载并不阻塞dom的解析，也不阻塞其他资源的加载，但两者需要互相配合生成渲染树，因此会阻塞dom的渲染。</p>\n<h3 id=\"优化css，避免css表达式。\"><a href=\"#优化css，避免css表达式。\" class=\"headerlink\" title=\"优化css，避免css表达式。\"></a>优化css，避免css表达式。</h3><p>会导致效率低下。</p>\n<h2 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h2><h3 id=\"延迟加载图片。\"><a href=\"#延迟加载图片。\" class=\"headerlink\" title=\"延迟加载图片。\"></a>延迟加载图片。</h3><p>不直接给src路径，而是在页面加载完成后用js操作src，减少了页面加载图片的时间。</p>\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><p>在进入可视区域之后在进行请求资源</p>\n<h3 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h3><p>在静态资源使用前先加载，在使用时可直接在缓存中获取</p>\n</script></li></ul>"},{"title":"一些调试小技巧","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 一些常用的快捷键\n\n快捷键 | 功能\n---|---\nctrl + o | 搜索文件\nctrl + shift + F | 在所有文件中搜索特定的文字\nctrl + shift + o | 在某个文件中搜索特定的文字\nctrl + G | 跳转到某一行\nctrl + L | 清除控制台的信息\nctrl + [ / ctrl + ] | 标签切换\nctrl + shift + c | 审查元素\nshift + Enter / sources -> snippets | 在控制台编写多行代码\n选中，H | 显示/隐藏元素\n\n### 一些常用的功能\n- 通过js代码来设置断点：debugger，或者直接在sources中打断点，查看堆栈，了解函数调用情况\n- elements的event listeners中可以查看元素事件监听器\n- 选中元素，右击Break on.. -> Attributes Modifications，元素改变时启动断点\n- 开发者工具打开的情况下右击chrome的刷新按钮，可清除缓存并硬重载\n","source":"_posts/前端/一些调试小技巧.md","raw":"---\ntitle: 一些调试小技巧\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 一些常用的快捷键\n\n快捷键 | 功能\n---|---\nctrl + o | 搜索文件\nctrl + shift + F | 在所有文件中搜索特定的文字\nctrl + shift + o | 在某个文件中搜索特定的文字\nctrl + G | 跳转到某一行\nctrl + L | 清除控制台的信息\nctrl + [ / ctrl + ] | 标签切换\nctrl + shift + c | 审查元素\nshift + Enter / sources -> snippets | 在控制台编写多行代码\n选中，H | 显示/隐藏元素\n\n### 一些常用的功能\n- 通过js代码来设置断点：debugger，或者直接在sources中打断点，查看堆栈，了解函数调用情况\n- elements的event listeners中可以查看元素事件监听器\n- 选中元素，右击Break on.. -> Attributes Modifications，元素改变时启动断点\n- 开发者工具打开的情况下右击chrome的刷新按钮，可清除缓存并硬重载\n","slug":"前端/一些调试小技巧","published":1,"date":"2020-05-14T08:36:31.866Z","updated":"2020-05-14T08:29:17.784Z","layout":"post","photos":[],"link":"","_id":"cka6kinc70084qgu9x3zw1mlq","content":"<h3 id=\"一些常用的快捷键\"><a href=\"#一些常用的快捷键\" class=\"headerlink\" title=\"一些常用的快捷键\"></a>一些常用的快捷键</h3><table>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ctrl + o</td>\n<td>搜索文件</td>\n</tr>\n<tr>\n<td>ctrl + shift + F</td>\n<td>在所有文件中搜索特定的文字</td>\n</tr>\n<tr>\n<td>ctrl + shift + o</td>\n<td>在某个文件中搜索特定的文字</td>\n</tr>\n<tr>\n<td>ctrl + G</td>\n<td>跳转到某一行</td>\n</tr>\n<tr>\n<td>ctrl + L</td>\n<td>清除控制台的信息</td>\n</tr>\n<tr>\n<td>ctrl + [ / ctrl + ]</td>\n<td>标签切换</td>\n</tr>\n<tr>\n<td>ctrl + shift + c</td>\n<td>审查元素</td>\n</tr>\n<tr>\n<td>shift + Enter / sources -&gt; snippets</td>\n<td>在控制台编写多行代码</td>\n</tr>\n<tr>\n<td>选中，H</td>\n<td>显示/隐藏元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"一些常用的功能\"><a href=\"#一些常用的功能\" class=\"headerlink\" title=\"一些常用的功能\"></a>一些常用的功能</h3><ul>\n<li>通过js代码来设置断点：debugger，或者直接在sources中打断点，查看堆栈，了解函数调用情况</li>\n<li>elements的event listeners中可以查看元素事件监听器</li>\n<li>选中元素，右击Break on.. -&gt; Attributes Modifications，元素改变时启动断点</li>\n<li>开发者工具打开的情况下右击chrome的刷新按钮，可清除缓存并硬重载</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一些常用的快捷键\"><a href=\"#一些常用的快捷键\" class=\"headerlink\" title=\"一些常用的快捷键\"></a>一些常用的快捷键</h3><table>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ctrl + o</td>\n<td>搜索文件</td>\n</tr>\n<tr>\n<td>ctrl + shift + F</td>\n<td>在所有文件中搜索特定的文字</td>\n</tr>\n<tr>\n<td>ctrl + shift + o</td>\n<td>在某个文件中搜索特定的文字</td>\n</tr>\n<tr>\n<td>ctrl + G</td>\n<td>跳转到某一行</td>\n</tr>\n<tr>\n<td>ctrl + L</td>\n<td>清除控制台的信息</td>\n</tr>\n<tr>\n<td>ctrl + [ / ctrl + ]</td>\n<td>标签切换</td>\n</tr>\n<tr>\n<td>ctrl + shift + c</td>\n<td>审查元素</td>\n</tr>\n<tr>\n<td>shift + Enter / sources -&gt; snippets</td>\n<td>在控制台编写多行代码</td>\n</tr>\n<tr>\n<td>选中，H</td>\n<td>显示/隐藏元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"一些常用的功能\"><a href=\"#一些常用的功能\" class=\"headerlink\" title=\"一些常用的功能\"></a>一些常用的功能</h3><ul>\n<li>通过js代码来设置断点：debugger，或者直接在sources中打断点，查看堆栈，了解函数调用情况</li>\n<li>elements的event listeners中可以查看元素事件监听器</li>\n<li>选中元素，右击Break on.. -&gt; Attributes Modifications，元素改变时启动断点</li>\n<li>开发者工具打开的情况下右击chrome的刷新按钮，可清除缓存并硬重载</li>\n</ul>\n"},{"title":"前端SEO（搜索引擎优化）和语义化","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 合理的title、description、keywords\n1. title值强调重点，要靠前，不同页面title不要相同。\n2. description对页面内容高度概括，长度合适，不同页面有所不同。\n3. keywords列举重点关键词即可，不要过分堆砌关键词。 \n\n###  语义化\n语义化的标签，旨在让标签有自己的含义，就是用合理、正确的标签来展示内容，比如h1~h6定义标题。\n#### 优点\n- 易于用户阅读，css样式丢失的时候能让页面呈现清晰的结构。\n- 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。\n- 方便其他设备解析，如盲人阅读器根据语义渲染网页\n- 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。\n\n#### 常见语义化标签\n\n```\n<title>：页面主体内容。\n<hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。\n<ul>：无序列表。\n<li>：有序列表。\n<small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。\n<strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。\n<em>：将其中的文本表示为强调的内容，表现为斜体。\n<mark>：使用黄色突出显示部分文本。\n<figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。\n<figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。\n<cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。\n<blockquoto>：定义块引用，块引用拥有它们自己的空间。\n<q>：短的引述（跨浏览器问题，尽量避免使用）。\n<time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。\n<abbr>：简称或缩写。\n<dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。\n<address>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。\n<del>：移除的内容。\n<ins>：添加的内容。\n<code>：标记代码。\n<meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）\n<progress>：定义运行中的进度（进程）。\n```\n\n#### h5新增语义化标签\n\n```\n<header>  定义文档或者文档的部分区域的页眉\n<nav>  描述一个含有多个超链接的区域\n<main>  定义文档的主要内容，该内容在文档中应当是独一无二的\n<article> 表示文档、页面、应用或网站中的独立结构\n<aside> 表示一个和其余页面内容几乎无关的部分\n<footer> 定义最近一个章节内容或者根节点元素的页脚\n<section> 表示文档中的一个区域（或节），比如，内容中的一个专题组。\n```\n\n### 重要内容的html代码放最前\n搜索引擎抓取html的顺序是从上到下，保证重要内容一定会被抓取\n\n### 重要内容不要用js输出\n爬虫不会执行js获取内容\n\n### 提高网站速度\n网站速度也是搜索引擎排序的一个重要指标","source":"_posts/前端/前端SEO（搜索引擎优化）和语义化.md","raw":"---\ntitle: 前端SEO（搜索引擎优化）和语义化\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 合理的title、description、keywords\n1. title值强调重点，要靠前，不同页面title不要相同。\n2. description对页面内容高度概括，长度合适，不同页面有所不同。\n3. keywords列举重点关键词即可，不要过分堆砌关键词。 \n\n###  语义化\n语义化的标签，旨在让标签有自己的含义，就是用合理、正确的标签来展示内容，比如h1~h6定义标题。\n#### 优点\n- 易于用户阅读，css样式丢失的时候能让页面呈现清晰的结构。\n- 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。\n- 方便其他设备解析，如盲人阅读器根据语义渲染网页\n- 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。\n\n#### 常见语义化标签\n\n```\n<title>：页面主体内容。\n<hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。\n<ul>：无序列表。\n<li>：有序列表。\n<small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。\n<strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。\n<em>：将其中的文本表示为强调的内容，表现为斜体。\n<mark>：使用黄色突出显示部分文本。\n<figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。\n<figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。\n<cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。\n<blockquoto>：定义块引用，块引用拥有它们自己的空间。\n<q>：短的引述（跨浏览器问题，尽量避免使用）。\n<time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。\n<abbr>：简称或缩写。\n<dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。\n<address>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。\n<del>：移除的内容。\n<ins>：添加的内容。\n<code>：标记代码。\n<meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）\n<progress>：定义运行中的进度（进程）。\n```\n\n#### h5新增语义化标签\n\n```\n<header>  定义文档或者文档的部分区域的页眉\n<nav>  描述一个含有多个超链接的区域\n<main>  定义文档的主要内容，该内容在文档中应当是独一无二的\n<article> 表示文档、页面、应用或网站中的独立结构\n<aside> 表示一个和其余页面内容几乎无关的部分\n<footer> 定义最近一个章节内容或者根节点元素的页脚\n<section> 表示文档中的一个区域（或节），比如，内容中的一个专题组。\n```\n\n### 重要内容的html代码放最前\n搜索引擎抓取html的顺序是从上到下，保证重要内容一定会被抓取\n\n### 重要内容不要用js输出\n爬虫不会执行js获取内容\n\n### 提高网站速度\n网站速度也是搜索引擎排序的一个重要指标","slug":"前端/前端SEO（搜索引擎优化）和语义化","published":1,"date":"2020-05-14T08:36:31.772Z","updated":"2020-05-14T08:31:50.499Z","layout":"post","photos":[],"link":"","_id":"cka6kinch0088qgu9al82lcll","content":"<h3 id=\"合理的title、description、keywords\"><a href=\"#合理的title、description、keywords\" class=\"headerlink\" title=\"合理的title、description、keywords\"></a>合理的title、description、keywords</h3><ol>\n<li>title值强调重点，要靠前，不同页面title不要相同。</li>\n<li>description对页面内容高度概括，长度合适，不同页面有所不同。</li>\n<li>keywords列举重点关键词即可，不要过分堆砌关键词。 </li>\n</ol>\n<h3 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h3><p>语义化的标签，旨在让标签有自己的含义，就是用合理、正确的标签来展示内容，比如h1~h6定义标题。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>易于用户阅读，css样式丢失的时候能让页面呈现清晰的结构。</li>\n<li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li>\n<li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li>\n<li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。</li>\n</ul>\n<h4 id=\"常见语义化标签\"><a href=\"#常见语义化标签\" class=\"headerlink\" title=\"常见语义化标签\"></a>常见语义化标签</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;title&gt;：页面主体内容。</span><br><span class=\"line\">&lt;hn&gt;：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。</span><br><span class=\"line\">&lt;ul&gt;：无序列表。</span><br><span class=\"line\">&lt;li&gt;：有序列表。</span><br><span class=\"line\">&lt;small&gt;：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。</span><br><span class=\"line\">&lt;strong&gt;：和 em 标签一样，用于强调文本，但它强调的程度更强一些。</span><br><span class=\"line\">&lt;em&gt;：将其中的文本表示为强调的内容，表现为斜体。</span><br><span class=\"line\">&lt;mark&gt;：使用黄色突出显示部分文本。</span><br><span class=\"line\">&lt;figure&gt;：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。</span><br><span class=\"line\">&lt;figcaption&gt;：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。</span><br><span class=\"line\">&lt;cite&gt;：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</span><br><span class=\"line\">&lt;blockquoto&gt;：定义块引用，块引用拥有它们自己的空间。</span><br><span class=\"line\">&lt;q&gt;：短的引述（跨浏览器问题，尽量避免使用）。</span><br><span class=\"line\">&lt;time&gt;：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。</span><br><span class=\"line\">&lt;abbr&gt;：简称或缩写。</span><br><span class=\"line\">&lt;dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。</span><br><span class=\"line\">&lt;address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。</span><br><span class=\"line\">&lt;del&gt;：移除的内容。</span><br><span class=\"line\">&lt;ins&gt;：添加的内容。</span><br><span class=\"line\">&lt;code&gt;：标记代码。</span><br><span class=\"line\">&lt;meter&gt;：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）</span><br><span class=\"line\">&lt;progress&gt;：定义运行中的进度（进程）。</span><br></pre></td></tr></table></figure>\n<h4 id=\"h5新增语义化标签\"><a href=\"#h5新增语义化标签\" class=\"headerlink\" title=\"h5新增语义化标签\"></a>h5新增语义化标签</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header&gt;  定义文档或者文档的部分区域的页眉</span><br><span class=\"line\">&lt;nav&gt;  描述一个含有多个超链接的区域</span><br><span class=\"line\">&lt;main&gt;  定义文档的主要内容，该内容在文档中应当是独一无二的</span><br><span class=\"line\">&lt;article&gt; 表示文档、页面、应用或网站中的独立结构</span><br><span class=\"line\">&lt;aside&gt; 表示一个和其余页面内容几乎无关的部分</span><br><span class=\"line\">&lt;footer&gt; 定义最近一个章节内容或者根节点元素的页脚</span><br><span class=\"line\">&lt;section&gt; 表示文档中的一个区域（或节），比如，内容中的一个专题组。</span><br></pre></td></tr></table></figure>\n<h3 id=\"重要内容的html代码放最前\"><a href=\"#重要内容的html代码放最前\" class=\"headerlink\" title=\"重要内容的html代码放最前\"></a>重要内容的html代码放最前</h3><p>搜索引擎抓取html的顺序是从上到下，保证重要内容一定会被抓取</p>\n<h3 id=\"重要内容不要用js输出\"><a href=\"#重要内容不要用js输出\" class=\"headerlink\" title=\"重要内容不要用js输出\"></a>重要内容不要用js输出</h3><p>爬虫不会执行js获取内容</p>\n<h3 id=\"提高网站速度\"><a href=\"#提高网站速度\" class=\"headerlink\" title=\"提高网站速度\"></a>提高网站速度</h3><p>网站速度也是搜索引擎排序的一个重要指标</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"合理的title、description、keywords\"><a href=\"#合理的title、description、keywords\" class=\"headerlink\" title=\"合理的title、description、keywords\"></a>合理的title、description、keywords</h3><ol>\n<li>title值强调重点，要靠前，不同页面title不要相同。</li>\n<li>description对页面内容高度概括，长度合适，不同页面有所不同。</li>\n<li>keywords列举重点关键词即可，不要过分堆砌关键词。 </li>\n</ol>\n<h3 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h3><p>语义化的标签，旨在让标签有自己的含义，就是用合理、正确的标签来展示内容，比如h1~h6定义标题。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>易于用户阅读，css样式丢失的时候能让页面呈现清晰的结构。</li>\n<li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li>\n<li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li>\n<li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。</li>\n</ul>\n<h4 id=\"常见语义化标签\"><a href=\"#常见语义化标签\" class=\"headerlink\" title=\"常见语义化标签\"></a>常见语义化标签</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;title&gt;：页面主体内容。</span><br><span class=\"line\">&lt;hn&gt;：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。</span><br><span class=\"line\">&lt;ul&gt;：无序列表。</span><br><span class=\"line\">&lt;li&gt;：有序列表。</span><br><span class=\"line\">&lt;small&gt;：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。</span><br><span class=\"line\">&lt;strong&gt;：和 em 标签一样，用于强调文本，但它强调的程度更强一些。</span><br><span class=\"line\">&lt;em&gt;：将其中的文本表示为强调的内容，表现为斜体。</span><br><span class=\"line\">&lt;mark&gt;：使用黄色突出显示部分文本。</span><br><span class=\"line\">&lt;figure&gt;：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。</span><br><span class=\"line\">&lt;figcaption&gt;：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。</span><br><span class=\"line\">&lt;cite&gt;：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</span><br><span class=\"line\">&lt;blockquoto&gt;：定义块引用，块引用拥有它们自己的空间。</span><br><span class=\"line\">&lt;q&gt;：短的引述（跨浏览器问题，尽量避免使用）。</span><br><span class=\"line\">&lt;time&gt;：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。</span><br><span class=\"line\">&lt;abbr&gt;：简称或缩写。</span><br><span class=\"line\">&lt;dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。</span><br><span class=\"line\">&lt;address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。</span><br><span class=\"line\">&lt;del&gt;：移除的内容。</span><br><span class=\"line\">&lt;ins&gt;：添加的内容。</span><br><span class=\"line\">&lt;code&gt;：标记代码。</span><br><span class=\"line\">&lt;meter&gt;：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）</span><br><span class=\"line\">&lt;progress&gt;：定义运行中的进度（进程）。</span><br></pre></td></tr></table></figure>\n<h4 id=\"h5新增语义化标签\"><a href=\"#h5新增语义化标签\" class=\"headerlink\" title=\"h5新增语义化标签\"></a>h5新增语义化标签</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header&gt;  定义文档或者文档的部分区域的页眉</span><br><span class=\"line\">&lt;nav&gt;  描述一个含有多个超链接的区域</span><br><span class=\"line\">&lt;main&gt;  定义文档的主要内容，该内容在文档中应当是独一无二的</span><br><span class=\"line\">&lt;article&gt; 表示文档、页面、应用或网站中的独立结构</span><br><span class=\"line\">&lt;aside&gt; 表示一个和其余页面内容几乎无关的部分</span><br><span class=\"line\">&lt;footer&gt; 定义最近一个章节内容或者根节点元素的页脚</span><br><span class=\"line\">&lt;section&gt; 表示文档中的一个区域（或节），比如，内容中的一个专题组。</span><br></pre></td></tr></table></figure>\n<h3 id=\"重要内容的html代码放最前\"><a href=\"#重要内容的html代码放最前\" class=\"headerlink\" title=\"重要内容的html代码放最前\"></a>重要内容的html代码放最前</h3><p>搜索引擎抓取html的顺序是从上到下，保证重要内容一定会被抓取</p>\n<h3 id=\"重要内容不要用js输出\"><a href=\"#重要内容不要用js输出\" class=\"headerlink\" title=\"重要内容不要用js输出\"></a>重要内容不要用js输出</h3><p>爬虫不会执行js获取内容</p>\n<h3 id=\"提高网站速度\"><a href=\"#提高网站速度\" class=\"headerlink\" title=\"提高网站速度\"></a>提高网站速度</h3><p>网站速度也是搜索引擎排序的一个重要指标</p>\n"},{"title":"回流（Reflow）和重绘（Repaint）","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 浏览器渲染\n解析HTML，生成DOM树，解析CSS，生成CSSOM树。将DOM树和CSSOM树结合，生成渲染树（Render Tree）。\n\n### 回流\n当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。\n\n每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。\n\n### 重绘\n当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。\n\n\n\n> 回流必定触发重绘，而重绘不一定触发回流。","source":"_posts/前端/回流（Reflow）和重绘（Repaint）.md","raw":"---\ntitle: 回流（Reflow）和重绘（Repaint）\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 浏览器渲染\n解析HTML，生成DOM树，解析CSS，生成CSSOM树。将DOM树和CSSOM树结合，生成渲染树（Render Tree）。\n\n### 回流\n当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。\n\n每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。\n\n### 重绘\n当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。\n\n\n\n> 回流必定触发重绘，而重绘不一定触发回流。","slug":"前端/回流（Reflow）和重绘（Repaint）","published":1,"date":"2020-05-14T08:36:31.742Z","updated":"2020-05-14T08:30:33.561Z","layout":"post","photos":[],"link":"","_id":"cka6kinch008bqgu95s187h9b","content":"<h3 id=\"浏览器渲染\"><a href=\"#浏览器渲染\" class=\"headerlink\" title=\"浏览器渲染\"></a>浏览器渲染</h3><p>解析HTML，生成DOM树，解析CSS，生成CSSOM树。将DOM树和CSSOM树结合，生成渲染树（Render Tree）。</p>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><p>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。</p>\n<p>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。</p>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p>\n<blockquote>\n<p>回流必定触发重绘，而重绘不一定触发回流。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"浏览器渲染\"><a href=\"#浏览器渲染\" class=\"headerlink\" title=\"浏览器渲染\"></a>浏览器渲染</h3><p>解析HTML，生成DOM树，解析CSS，生成CSSOM树。将DOM树和CSSOM树结合，生成渲染树（Render Tree）。</p>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><p>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。</p>\n<p>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。</p>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p>\n<blockquote>\n<p>回流必定触发重绘，而重绘不一定触发回流。</p>\n</blockquote>\n"},{"title":"本地存储方式","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n### cookie、localStorage、sessionStorage\n相同：在本地（浏览器端）存储数据。\n\n不同\n- localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。\n- sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。\n- localStorage是永久存储，除非手动删除。\n- sessionStorage当会话结束（当前页面关闭的时候，自动销毁）\n- cookie的数据会在每一次发送http请求的时候，同时发送给服务器，而localStorage、sessionStorage不会。\n- 每个cookie存放的内容大小有限制，一般为4kb。","source":"_posts/前端/本地存储方式.md","raw":"---\ntitle: 本地存储方式\nDate: 2019-03-26\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### cookie、localStorage、sessionStorage\n相同：在本地（浏览器端）存储数据。\n\n不同\n- localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。\n- sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。\n- localStorage是永久存储，除非手动删除。\n- sessionStorage当会话结束（当前页面关闭的时候，自动销毁）\n- cookie的数据会在每一次发送http请求的时候，同时发送给服务器，而localStorage、sessionStorage不会。\n- 每个cookie存放的内容大小有限制，一般为4kb。","slug":"前端/本地存储方式","published":1,"date":"2019-03-26T03:46:16.449Z","updated":"2019-03-26T03:45:27.355Z","layout":"post","photos":[],"link":"","_id":"cka6kincr008fqgu9zmxg9gpq","content":"<h3 id=\"cookie、localStorage、sessionStorage\"><a href=\"#cookie、localStorage、sessionStorage\" class=\"headerlink\" title=\"cookie、localStorage、sessionStorage\"></a>cookie、localStorage、sessionStorage</h3><p>相同：在本地（浏览器端）存储数据。</p>\n<p>不同</p>\n<ul>\n<li>localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。</li>\n<li>sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。</li>\n<li>localStorage是永久存储，除非手动删除。</li>\n<li>sessionStorage当会话结束（当前页面关闭的时候，自动销毁）</li>\n<li>cookie的数据会在每一次发送http请求的时候，同时发送给服务器，而localStorage、sessionStorage不会。</li>\n<li>每个cookie存放的内容大小有限制，一般为4kb。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"cookie、localStorage、sessionStorage\"><a href=\"#cookie、localStorage、sessionStorage\" class=\"headerlink\" title=\"cookie、localStorage、sessionStorage\"></a>cookie、localStorage、sessionStorage</h3><p>相同：在本地（浏览器端）存储数据。</p>\n<p>不同</p>\n<ul>\n<li>localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。</li>\n<li>sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。</li>\n<li>localStorage是永久存储，除非手动删除。</li>\n<li>sessionStorage当会话结束（当前页面关闭的时候，自动销毁）</li>\n<li>cookie的数据会在每一次发送http请求的时候，同时发送给服务器，而localStorage、sessionStorage不会。</li>\n<li>每个cookie存放的内容大小有限制，一般为4kb。</li>\n</ul>\n"},{"title":"浏览器兼容问题","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### css\n不同浏览器的标签默认的margin和padding不同\n\n```\n//解决\n*{\n    padding:0;\n    margin:0;\n}\n```\n对于一些新特性，低版本浏览器不兼容，可以用渐进增强或优雅降级。\n\n### js\n#### 阻止冒泡\n\n```\nfunction canclebubble(event){ \n    var event = event||window.event; //兼容火狐\n    if(event.stopPropagation){   \n        event.stopPropagation(); //标准浏览器\n    }else{ \n        event.cancaleBubble==true; //老ie \n    } \n}  \n```\n#### 取消默认事件\n\n```\nfunction stopevent(event){ \n    var event = event||window.event; //兼容火狐\n    if(event.preventDefault){\n        event.preventDefault(); //标准浏览器 \n    }else{\n        event.returnValue==false; //老ie \n    } \n} \n\n```\n注意\n1. event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等；\n2. event对象只在事件发生的过程中才有效。\n3. firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。\n4. 在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。","source":"_posts/前端/浏览器兼容问题.md","raw":"---\ntitle: 浏览器兼容问题\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### css\n不同浏览器的标签默认的margin和padding不同\n\n```\n//解决\n*{\n    padding:0;\n    margin:0;\n}\n```\n对于一些新特性，低版本浏览器不兼容，可以用渐进增强或优雅降级。\n\n### js\n#### 阻止冒泡\n\n```\nfunction canclebubble(event){ \n    var event = event||window.event; //兼容火狐\n    if(event.stopPropagation){   \n        event.stopPropagation(); //标准浏览器\n    }else{ \n        event.cancaleBubble==true; //老ie \n    } \n}  \n```\n#### 取消默认事件\n\n```\nfunction stopevent(event){ \n    var event = event||window.event; //兼容火狐\n    if(event.preventDefault){\n        event.preventDefault(); //标准浏览器 \n    }else{\n        event.returnValue==false; //老ie \n    } \n} \n\n```\n注意\n1. event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等；\n2. event对象只在事件发生的过程中才有效。\n3. firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。\n4. 在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。","slug":"前端/浏览器兼容问题","published":1,"date":"2020-05-14T08:36:31.843Z","updated":"2020-05-14T08:28:43.167Z","layout":"post","photos":[],"link":"","_id":"cka6kincr008hqgu9g54116d7","content":"<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><p>不同浏览器的标签默认的margin和padding不同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//解决</span><br><span class=\"line\">*&#123;</span><br><span class=\"line\">    padding:0;</span><br><span class=\"line\">    margin:0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于一些新特性，低版本浏览器不兼容，可以用渐进增强或优雅降级。</p>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><h4 id=\"阻止冒泡\"><a href=\"#阻止冒泡\" class=\"headerlink\" title=\"阻止冒泡\"></a>阻止冒泡</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function canclebubble(event)&#123; </span><br><span class=\"line\">    var event = event||window.event; //兼容火狐</span><br><span class=\"line\">    if(event.stopPropagation)&#123;   </span><br><span class=\"line\">        event.stopPropagation(); //标准浏览器</span><br><span class=\"line\">    &#125;else&#123; </span><br><span class=\"line\">        event.cancaleBubble==true; //老ie </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"取消默认事件\"><a href=\"#取消默认事件\" class=\"headerlink\" title=\"取消默认事件\"></a>取消默认事件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function stopevent(event)&#123; </span><br><span class=\"line\">    var event = event||window.event; //兼容火狐</span><br><span class=\"line\">    if(event.preventDefault)&#123;</span><br><span class=\"line\">        event.preventDefault(); //标准浏览器 </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.returnValue==false; //老ie </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意</p>\n<ol>\n<li>event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等；</li>\n<li>event对象只在事件发生的过程中才有效。</li>\n<li>firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。</li>\n<li>在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><p>不同浏览器的标签默认的margin和padding不同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//解决</span><br><span class=\"line\">*&#123;</span><br><span class=\"line\">    padding:0;</span><br><span class=\"line\">    margin:0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于一些新特性，低版本浏览器不兼容，可以用渐进增强或优雅降级。</p>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><h4 id=\"阻止冒泡\"><a href=\"#阻止冒泡\" class=\"headerlink\" title=\"阻止冒泡\"></a>阻止冒泡</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function canclebubble(event)&#123; </span><br><span class=\"line\">    var event = event||window.event; //兼容火狐</span><br><span class=\"line\">    if(event.stopPropagation)&#123;   </span><br><span class=\"line\">        event.stopPropagation(); //标准浏览器</span><br><span class=\"line\">    &#125;else&#123; </span><br><span class=\"line\">        event.cancaleBubble==true; //老ie </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"取消默认事件\"><a href=\"#取消默认事件\" class=\"headerlink\" title=\"取消默认事件\"></a>取消默认事件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function stopevent(event)&#123; </span><br><span class=\"line\">    var event = event||window.event; //兼容火狐</span><br><span class=\"line\">    if(event.preventDefault)&#123;</span><br><span class=\"line\">        event.preventDefault(); //标准浏览器 </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.returnValue==false; //老ie </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意</p>\n<ol>\n<li>event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等；</li>\n<li>event对象只在事件发生的过程中才有效。</li>\n<li>firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。</li>\n<li>在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。</li>\n</ol>\n"},{"title":"浏览器本地缓存","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 定义\n缓存是性能优化中简单高效的一种优化方式。\n\n和本地存储不一样，浏览器缓存是浏览器请求网站留下的资源副本。\n### 好处\n1. 减少带宽消耗\n2. 提升性能\n3. 缓解服务器压力\n\n### 缓存位置\n1. Service Worker\n2. Memory Cache\n3. Disk Cache\n4. Push Cache\n\n### 缓存策略\n浏览器第一次向服务器发起请求拿到请求结果后，根据请求资源时返回的响应头来确定该不该缓存。\n#### 浏览器常见字段\n- Expires：告知客户端资源缓存失效的绝对时间。\n- Cache-Control：告知客户端或服务器如何处理缓存\n   1. max-age=xxx：表示缓存内容将在缓存时间的xxx秒后失效\n   2. no-cache：表示可以缓存，但每次用都要去向服务器验证缓存是否可用。\n   3. no-store：表示所有内容都不会缓存。\n   4. private：客户端可以缓存。\n   5. public：客户端和代理服务器都可以缓存。默认值。\n- Last-Modified：资源最后一次修改时间。\n- Etag：文件的特殊标识。用于文件内容对比，判断内容是否修改。\n- Cache-Control优先级高于Expires。\n- Etag优先级高于Last-Modified。\n\n#### 强缓存\n1. 根据本地缓存资源的header中的Expires和Cache-Control来判断是否命中强缓存。\n2. 如果命中强缓存则返回缓存的数据。\n3. 如果没有命中则进入协商缓存。\n\n\n#### 协商缓存\n1. 如果没有命中强缓存，浏览器会将本地缓存资源的header中的Last-Modified和Etag的值分别放入请求头的IF-Modified-Since和IF-None-Match字段中，向服务器发送请求，由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。\n2. 若命中即资源未更新，则服务器返回新的响应header信息且返回的http状态为304，但是并不返回资源内容，它会显示一个Not Modified的字符串，来告知浏览器使用缓存。\n3. 否则返回最新的数据，并将新数据存入缓存。\n\n\n#### 总结\n当浏览器再次访问一个已经访问过的资源时，会\n1. 先判断是否存在缓存，再看是否命中强缓存，如果命中，就直接使用缓存了。\n2. 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。\n3. 如果命中协商缓存，服务器会返回 304。\n4. 告诉浏览器使用本地缓存。\n5. 否则，返回最新的资源。\n\n### 拓展 \n#### ctrl+F5和F5的区别\nF5只是刷新本地缓存，强缓存无效，协商缓存有效；ctrl+F5是强缓存与协商缓存均无效，重新向服务器请求。\n\n#### 禁止浏览器缓存方法\n1. 设置响应头\n\n```\n//把Cache-Control设置为no-cache\n<meta HTTP-EQUIV=\"Cache-Control\" CONTENT=\"no-cache\">\n```\n2. 在访问的url后添加一个参数，可以是随机数或者时间戳。这样url时刻在变化，就要重新发送http请求\n","source":"_posts/前端/浏览器本地缓存.md","raw":"---\ntitle: 浏览器本地缓存\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 定义\n缓存是性能优化中简单高效的一种优化方式。\n\n和本地存储不一样，浏览器缓存是浏览器请求网站留下的资源副本。\n### 好处\n1. 减少带宽消耗\n2. 提升性能\n3. 缓解服务器压力\n\n### 缓存位置\n1. Service Worker\n2. Memory Cache\n3. Disk Cache\n4. Push Cache\n\n### 缓存策略\n浏览器第一次向服务器发起请求拿到请求结果后，根据请求资源时返回的响应头来确定该不该缓存。\n#### 浏览器常见字段\n- Expires：告知客户端资源缓存失效的绝对时间。\n- Cache-Control：告知客户端或服务器如何处理缓存\n   1. max-age=xxx：表示缓存内容将在缓存时间的xxx秒后失效\n   2. no-cache：表示可以缓存，但每次用都要去向服务器验证缓存是否可用。\n   3. no-store：表示所有内容都不会缓存。\n   4. private：客户端可以缓存。\n   5. public：客户端和代理服务器都可以缓存。默认值。\n- Last-Modified：资源最后一次修改时间。\n- Etag：文件的特殊标识。用于文件内容对比，判断内容是否修改。\n- Cache-Control优先级高于Expires。\n- Etag优先级高于Last-Modified。\n\n#### 强缓存\n1. 根据本地缓存资源的header中的Expires和Cache-Control来判断是否命中强缓存。\n2. 如果命中强缓存则返回缓存的数据。\n3. 如果没有命中则进入协商缓存。\n\n\n#### 协商缓存\n1. 如果没有命中强缓存，浏览器会将本地缓存资源的header中的Last-Modified和Etag的值分别放入请求头的IF-Modified-Since和IF-None-Match字段中，向服务器发送请求，由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。\n2. 若命中即资源未更新，则服务器返回新的响应header信息且返回的http状态为304，但是并不返回资源内容，它会显示一个Not Modified的字符串，来告知浏览器使用缓存。\n3. 否则返回最新的数据，并将新数据存入缓存。\n\n\n#### 总结\n当浏览器再次访问一个已经访问过的资源时，会\n1. 先判断是否存在缓存，再看是否命中强缓存，如果命中，就直接使用缓存了。\n2. 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。\n3. 如果命中协商缓存，服务器会返回 304。\n4. 告诉浏览器使用本地缓存。\n5. 否则，返回最新的资源。\n\n### 拓展 \n#### ctrl+F5和F5的区别\nF5只是刷新本地缓存，强缓存无效，协商缓存有效；ctrl+F5是强缓存与协商缓存均无效，重新向服务器请求。\n\n#### 禁止浏览器缓存方法\n1. 设置响应头\n\n```\n//把Cache-Control设置为no-cache\n<meta HTTP-EQUIV=\"Cache-Control\" CONTENT=\"no-cache\">\n```\n2. 在访问的url后添加一个参数，可以是随机数或者时间戳。这样url时刻在变化，就要重新发送http请求\n","slug":"前端/浏览器本地缓存","published":1,"date":"2019-03-27T07:36:11.599Z","updated":"2020-05-14T08:31:08.407Z","layout":"post","photos":[],"link":"","_id":"cka6kindb008lqgu9do7gq2jr","content":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>缓存是性能优化中简单高效的一种优化方式。</p>\n<p>和本地存储不一样，浏览器缓存是浏览器请求网站留下的资源副本。</p>\n<h3 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h3><ol>\n<li>减少带宽消耗</li>\n<li>提升性能</li>\n<li>缓解服务器压力</li>\n</ol>\n<h3 id=\"缓存位置\"><a href=\"#缓存位置\" class=\"headerlink\" title=\"缓存位置\"></a>缓存位置</h3><ol>\n<li>Service Worker</li>\n<li>Memory Cache</li>\n<li>Disk Cache</li>\n<li>Push Cache</li>\n</ol>\n<h3 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h3><p>浏览器第一次向服务器发起请求拿到请求结果后，根据请求资源时返回的响应头来确定该不该缓存。</p>\n<h4 id=\"浏览器常见字段\"><a href=\"#浏览器常见字段\" class=\"headerlink\" title=\"浏览器常见字段\"></a>浏览器常见字段</h4><ul>\n<li>Expires：告知客户端资源缓存失效的绝对时间。</li>\n<li>Cache-Control：告知客户端或服务器如何处理缓存<ol>\n<li>max-age=xxx：表示缓存内容将在缓存时间的xxx秒后失效</li>\n<li>no-cache：表示可以缓存，但每次用都要去向服务器验证缓存是否可用。</li>\n<li>no-store：表示所有内容都不会缓存。</li>\n<li>private：客户端可以缓存。</li>\n<li>public：客户端和代理服务器都可以缓存。默认值。</li>\n</ol>\n</li>\n<li>Last-Modified：资源最后一次修改时间。</li>\n<li>Etag：文件的特殊标识。用于文件内容对比，判断内容是否修改。</li>\n<li>Cache-Control优先级高于Expires。</li>\n<li>Etag优先级高于Last-Modified。</li>\n</ul>\n<h4 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h4><ol>\n<li>根据本地缓存资源的header中的Expires和Cache-Control来判断是否命中强缓存。</li>\n<li>如果命中强缓存则返回缓存的数据。</li>\n<li>如果没有命中则进入协商缓存。</li>\n</ol>\n<h4 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h4><ol>\n<li>如果没有命中强缓存，浏览器会将本地缓存资源的header中的Last-Modified和Etag的值分别放入请求头的IF-Modified-Since和IF-None-Match字段中，向服务器发送请求，由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。</li>\n<li>若命中即资源未更新，则服务器返回新的响应header信息且返回的http状态为304，但是并不返回资源内容，它会显示一个Not Modified的字符串，来告知浏览器使用缓存。</li>\n<li>否则返回最新的数据，并将新数据存入缓存。</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>当浏览器再次访问一个已经访问过的资源时，会</p>\n<ol>\n<li>先判断是否存在缓存，再看是否命中强缓存，如果命中，就直接使用缓存了。</li>\n<li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。</li>\n<li>如果命中协商缓存，服务器会返回 304。</li>\n<li>告诉浏览器使用本地缓存。</li>\n<li>否则，返回最新的资源。</li>\n</ol>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><h4 id=\"ctrl-F5和F5的区别\"><a href=\"#ctrl-F5和F5的区别\" class=\"headerlink\" title=\"ctrl+F5和F5的区别\"></a>ctrl+F5和F5的区别</h4><p>F5只是刷新本地缓存，强缓存无效，协商缓存有效；ctrl+F5是强缓存与协商缓存均无效，重新向服务器请求。</p>\n<h4 id=\"禁止浏览器缓存方法\"><a href=\"#禁止浏览器缓存方法\" class=\"headerlink\" title=\"禁止浏览器缓存方法\"></a>禁止浏览器缓存方法</h4><ol>\n<li>设置响应头</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//把Cache-Control设置为no-cache</span><br><span class=\"line\">&lt;meta HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在访问的url后添加一个参数，可以是随机数或者时间戳。这样url时刻在变化，就要重新发送http请求</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>缓存是性能优化中简单高效的一种优化方式。</p>\n<p>和本地存储不一样，浏览器缓存是浏览器请求网站留下的资源副本。</p>\n<h3 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h3><ol>\n<li>减少带宽消耗</li>\n<li>提升性能</li>\n<li>缓解服务器压力</li>\n</ol>\n<h3 id=\"缓存位置\"><a href=\"#缓存位置\" class=\"headerlink\" title=\"缓存位置\"></a>缓存位置</h3><ol>\n<li>Service Worker</li>\n<li>Memory Cache</li>\n<li>Disk Cache</li>\n<li>Push Cache</li>\n</ol>\n<h3 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h3><p>浏览器第一次向服务器发起请求拿到请求结果后，根据请求资源时返回的响应头来确定该不该缓存。</p>\n<h4 id=\"浏览器常见字段\"><a href=\"#浏览器常见字段\" class=\"headerlink\" title=\"浏览器常见字段\"></a>浏览器常见字段</h4><ul>\n<li>Expires：告知客户端资源缓存失效的绝对时间。</li>\n<li>Cache-Control：告知客户端或服务器如何处理缓存<ol>\n<li>max-age=xxx：表示缓存内容将在缓存时间的xxx秒后失效</li>\n<li>no-cache：表示可以缓存，但每次用都要去向服务器验证缓存是否可用。</li>\n<li>no-store：表示所有内容都不会缓存。</li>\n<li>private：客户端可以缓存。</li>\n<li>public：客户端和代理服务器都可以缓存。默认值。</li>\n</ol>\n</li>\n<li>Last-Modified：资源最后一次修改时间。</li>\n<li>Etag：文件的特殊标识。用于文件内容对比，判断内容是否修改。</li>\n<li>Cache-Control优先级高于Expires。</li>\n<li>Etag优先级高于Last-Modified。</li>\n</ul>\n<h4 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h4><ol>\n<li>根据本地缓存资源的header中的Expires和Cache-Control来判断是否命中强缓存。</li>\n<li>如果命中强缓存则返回缓存的数据。</li>\n<li>如果没有命中则进入协商缓存。</li>\n</ol>\n<h4 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h4><ol>\n<li>如果没有命中强缓存，浏览器会将本地缓存资源的header中的Last-Modified和Etag的值分别放入请求头的IF-Modified-Since和IF-None-Match字段中，向服务器发送请求，由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。</li>\n<li>若命中即资源未更新，则服务器返回新的响应header信息且返回的http状态为304，但是并不返回资源内容，它会显示一个Not Modified的字符串，来告知浏览器使用缓存。</li>\n<li>否则返回最新的数据，并将新数据存入缓存。</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>当浏览器再次访问一个已经访问过的资源时，会</p>\n<ol>\n<li>先判断是否存在缓存，再看是否命中强缓存，如果命中，就直接使用缓存了。</li>\n<li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。</li>\n<li>如果命中协商缓存，服务器会返回 304。</li>\n<li>告诉浏览器使用本地缓存。</li>\n<li>否则，返回最新的资源。</li>\n</ol>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><h4 id=\"ctrl-F5和F5的区别\"><a href=\"#ctrl-F5和F5的区别\" class=\"headerlink\" title=\"ctrl+F5和F5的区别\"></a>ctrl+F5和F5的区别</h4><p>F5只是刷新本地缓存，强缓存无效，协商缓存有效；ctrl+F5是强缓存与协商缓存均无效，重新向服务器请求。</p>\n<h4 id=\"禁止浏览器缓存方法\"><a href=\"#禁止浏览器缓存方法\" class=\"headerlink\" title=\"禁止浏览器缓存方法\"></a>禁止浏览器缓存方法</h4><ol>\n<li>设置响应头</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//把Cache-Control设置为no-cache</span><br><span class=\"line\">&lt;meta HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在访问的url后添加一个参数，可以是随机数或者时间戳。这样url时刻在变化，就要重新发送http请求</li>\n</ol>\n"},{"title":"浏览器渲染机制","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 进程和线程\n- 进程时cpu资源分配的最小单位，是能拥有资源和独立运行的最小的单位。\n- 线程是cpu调度的最小单位，是建立在进程基础上的一次程序运行单位。\n- 对于操作系统来说，一个任务就是一个进程，一个进程至少有一个线程\n\n### 浏览器的多进程架构\n![image](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n#### 主进程\n负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。\n#### 第三方插件进程\n每种类型的插件对应一个进程,仅当使用该插件时才创建。\n#### GPU 进程\n最多只有一个,用于 3D 绘制等\n#### 渲染进程\n称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。\n\n### 渲染进程\n浏览器的渲染进程是多线程的\n![image](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee2d5b4df806?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n#### GUI 渲染线程 \n\n- 负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。\n- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。\n- 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。\n\n#### JS 引擎线程 \n\n- Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）\n- JS 引擎线程负责解析 Javascript 脚本，运行代码。\n- JS 引擎一直等待着任务队列中任务的到来,然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。\n- 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n#### 事件触发线程 \n\n- 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解,JS 引擎自己都忙不过来，需要浏览器另开线程协助）\n- 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中\n- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理\n- 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）\n\n#### 定时触发器线程 \n\n- 传说中的 setInterval 与 setTimeout 所在线程\n- 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确）\n- 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中，等待 JS 引擎空闲后执行）\n- 注意，W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。\n\n#### 异步 http 请求线程 \n\n- 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。\n- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。\n\n### 题目\n#### 1. 为什么 Javascript 要是单线程的 ?\n\n- 如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。\n- 如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源,\n- 假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。\n- 当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。\n\n#### 2. 为什么 JS 阻塞页面加载 ?\n\n- 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。\n- 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。\n\n#### 3. css 加载会造成阻塞吗 ？\n\n- CSS 加载不会阻塞 DOM 的解析，会阻塞 Dom 的渲染\n\nDOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。\n\n然而,由于 渲染树 是依赖于 DOM树 和 CSSOM树 的,\n所以他必须等待到 CSSOM树 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。\n因此,CSS 加载会阻塞 Dom 的渲染。\n- css 会阻塞后面 js 的执行。\n\n由于 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行。\n\n#### 4. DOMContentLoaded 与 load 的区别 ?\n- 当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。\n- 当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。\n- 当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。\n- DOMContentLoaded -> load\n\n\n#### 5. defer 和 async 的区别 ?\n1. <script src=\"script.js\">\n\n没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。\n\n2. <script async src=\"script.js\">\n\n有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n\n3. <script defer src=\"myscript.js\">\n\n有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。\n\n4. 总结     \n\ndefer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析），差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的\n\n关于 defer，它是按照加载顺序执行脚本的；\nasync 则是乱序执行的，反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行\n\n仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的\n\n","source":"_posts/前端/浏览器渲染机制.md","raw":"---\ntitle: 浏览器渲染机制\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 进程和线程\n- 进程时cpu资源分配的最小单位，是能拥有资源和独立运行的最小的单位。\n- 线程是cpu调度的最小单位，是建立在进程基础上的一次程序运行单位。\n- 对于操作系统来说，一个任务就是一个进程，一个进程至少有一个线程\n\n### 浏览器的多进程架构\n![image](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n#### 主进程\n负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。\n#### 第三方插件进程\n每种类型的插件对应一个进程,仅当使用该插件时才创建。\n#### GPU 进程\n最多只有一个,用于 3D 绘制等\n#### 渲染进程\n称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。\n\n### 渲染进程\n浏览器的渲染进程是多线程的\n![image](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee2d5b4df806?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n#### GUI 渲染线程 \n\n- 负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。\n- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。\n- 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。\n\n#### JS 引擎线程 \n\n- Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）\n- JS 引擎线程负责解析 Javascript 脚本，运行代码。\n- JS 引擎一直等待着任务队列中任务的到来,然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。\n- 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n#### 事件触发线程 \n\n- 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解,JS 引擎自己都忙不过来，需要浏览器另开线程协助）\n- 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中\n- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理\n- 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）\n\n#### 定时触发器线程 \n\n- 传说中的 setInterval 与 setTimeout 所在线程\n- 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确）\n- 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中，等待 JS 引擎空闲后执行）\n- 注意，W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。\n\n#### 异步 http 请求线程 \n\n- 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。\n- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。\n\n### 题目\n#### 1. 为什么 Javascript 要是单线程的 ?\n\n- 如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。\n- 如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源,\n- 假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。\n- 当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。\n\n#### 2. 为什么 JS 阻塞页面加载 ?\n\n- 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。\n- 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。\n\n#### 3. css 加载会造成阻塞吗 ？\n\n- CSS 加载不会阻塞 DOM 的解析，会阻塞 Dom 的渲染\n\nDOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。\n\n然而,由于 渲染树 是依赖于 DOM树 和 CSSOM树 的,\n所以他必须等待到 CSSOM树 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。\n因此,CSS 加载会阻塞 Dom 的渲染。\n- css 会阻塞后面 js 的执行。\n\n由于 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行。\n\n#### 4. DOMContentLoaded 与 load 的区别 ?\n- 当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。\n- 当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。\n- 当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。\n- DOMContentLoaded -> load\n\n\n#### 5. defer 和 async 的区别 ?\n1. <script src=\"script.js\">\n\n没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。\n\n2. <script async src=\"script.js\">\n\n有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n\n3. <script defer src=\"myscript.js\">\n\n有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。\n\n4. 总结     \n\ndefer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析），差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的\n\n关于 defer，它是按照加载顺序执行脚本的；\nasync 则是乱序执行的，反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行\n\n仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的\n\n","slug":"前端/浏览器渲染机制","published":1,"date":"2020-05-14T08:36:31.702Z","updated":"2020-05-14T08:29:51.892Z","layout":"post","photos":[],"link":"","_id":"cka6kindb008nqgu9bdgeolrh","content":"<h3 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h3><ul>\n<li>进程时cpu资源分配的最小单位，是能拥有资源和独立运行的最小的单位。</li>\n<li>线程是cpu调度的最小单位，是建立在进程基础上的一次程序运行单位。</li>\n<li>对于操作系统来说，一个任务就是一个进程，一个进程至少有一个线程</li>\n</ul>\n<h3 id=\"浏览器的多进程架构\"><a href=\"#浏览器的多进程架构\" class=\"headerlink\" title=\"浏览器的多进程架构\"></a>浏览器的多进程架构</h3><p><img src=\"https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h4 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程\"></a>主进程</h4><p>负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。</p>\n<h4 id=\"第三方插件进程\"><a href=\"#第三方插件进程\" class=\"headerlink\" title=\"第三方插件进程\"></a>第三方插件进程</h4><p>每种类型的插件对应一个进程,仅当使用该插件时才创建。</p>\n<h4 id=\"GPU-进程\"><a href=\"#GPU-进程\" class=\"headerlink\" title=\"GPU 进程\"></a>GPU 进程</h4><p>最多只有一个,用于 3D 绘制等</p>\n<h4 id=\"渲染进程\"><a href=\"#渲染进程\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h4><p>称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。</p>\n<h3 id=\"渲染进程-1\"><a href=\"#渲染进程-1\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h3><p>浏览器的渲染进程是多线程的<br><img src=\"https://user-gold-cdn.xitu.io/2020/1/7/16f7ee2d5b4df806?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h4 id=\"GUI-渲染线程\"><a href=\"#GUI-渲染线程\" class=\"headerlink\" title=\"GUI 渲染线程\"></a>GUI 渲染线程</h4><ul>\n<li>负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li>\n<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。</li>\n<li>注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li>\n</ul>\n<h4 id=\"JS-引擎线程\"><a href=\"#JS-引擎线程\" class=\"headerlink\" title=\"JS 引擎线程\"></a>JS 引擎线程</h4><ul>\n<li>Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li>\n<li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li>\n<li>JS 引擎一直等待着任务队列中任务的到来,然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。</li>\n<li>注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>\n</ul>\n<h4 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h4><ul>\n<li>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解,JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li>\n<li>当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中</li>\n<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li>\n<li>注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</li>\n</ul>\n<h4 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h4><ul>\n<li>传说中的 setInterval 与 setTimeout 所在线程</li>\n<li>浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确）</li>\n<li>因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中，等待 JS 引擎空闲后执行）</li>\n<li>注意，W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li>\n</ul>\n<h4 id=\"异步-http-请求线程\"><a href=\"#异步-http-请求线程\" class=\"headerlink\" title=\"异步 http 请求线程\"></a>异步 http 请求线程</h4><ul>\n<li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>\n</ul>\n<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><h4 id=\"1-为什么-Javascript-要是单线程的\"><a href=\"#1-为什么-Javascript-要是单线程的\" class=\"headerlink\" title=\"1. 为什么 Javascript 要是单线程的 ?\"></a>1. 为什么 Javascript 要是单线程的 ?</h4><ul>\n<li>如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。</li>\n<li>如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源,</li>\n<li>假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。</li>\n<li>当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。</li>\n</ul>\n<h4 id=\"2-为什么-JS-阻塞页面加载\"><a href=\"#2-为什么-JS-阻塞页面加载\" class=\"headerlink\" title=\"2. 为什么 JS 阻塞页面加载 ?\"></a>2. 为什么 JS 阻塞页面加载 ?</h4><ul>\n<li>由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。</li>\n<li>因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。</li>\n</ul>\n<h4 id=\"3-css-加载会造成阻塞吗-？\"><a href=\"#3-css-加载会造成阻塞吗-？\" class=\"headerlink\" title=\"3. css 加载会造成阻塞吗 ？\"></a>3. css 加载会造成阻塞吗 ？</h4><ul>\n<li>CSS 加载不会阻塞 DOM 的解析，会阻塞 Dom 的渲染</li>\n</ul>\n<p>DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。</p>\n<p>然而,由于 渲染树 是依赖于 DOM树 和 CSSOM树 的,<br>所以他必须等待到 CSSOM树 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。<br>因此,CSS 加载会阻塞 Dom 的渲染。</p>\n<ul>\n<li>css 会阻塞后面 js 的执行。</li>\n</ul>\n<p>由于 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行。</p>\n<h4 id=\"4-DOMContentLoaded-与-load-的区别\"><a href=\"#4-DOMContentLoaded-与-load-的区别\" class=\"headerlink\" title=\"4. DOMContentLoaded 与 load 的区别 ?\"></a>4. DOMContentLoaded 与 load 的区别 ?</h4><ul>\n<li>当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。</li>\n<li>当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。</li>\n<li>当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。</li>\n<li>DOMContentLoaded -&gt; load</li>\n</ul>\n<h4 id=\"5-defer-和-async-的区别\"><a href=\"#5-defer-和-async-的区别\" class=\"headerlink\" title=\"5. defer 和 async 的区别 ?\"></a>5. defer 和 async 的区别 ?</h4><ol>\n<li><script src=\"script.js\">\n\n</li>\n</ol>\n<p>没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。</p>\n<ol start=\"2\">\n<li><script async src=\"script.js\">\n\n</li>\n</ol>\n<p>有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p>\n<ol start=\"3\">\n<li><script defer src=\"myscript.js\">\n\n</li>\n</ol>\n<p>有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。</p>\n<ol start=\"4\">\n<li>总结     </li>\n</ol>\n<p>defer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析），差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的</p>\n<p>关于 defer，它是按照加载顺序执行脚本的；<br>async 则是乱序执行的，反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行</p>\n<p>仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的</p>\n</script></li></ol>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h3><ul>\n<li>进程时cpu资源分配的最小单位，是能拥有资源和独立运行的最小的单位。</li>\n<li>线程是cpu调度的最小单位，是建立在进程基础上的一次程序运行单位。</li>\n<li>对于操作系统来说，一个任务就是一个进程，一个进程至少有一个线程</li>\n</ul>\n<h3 id=\"浏览器的多进程架构\"><a href=\"#浏览器的多进程架构\" class=\"headerlink\" title=\"浏览器的多进程架构\"></a>浏览器的多进程架构</h3><p><img src=\"https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h4 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程\"></a>主进程</h4><p>负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。</p>\n<h4 id=\"第三方插件进程\"><a href=\"#第三方插件进程\" class=\"headerlink\" title=\"第三方插件进程\"></a>第三方插件进程</h4><p>每种类型的插件对应一个进程,仅当使用该插件时才创建。</p>\n<h4 id=\"GPU-进程\"><a href=\"#GPU-进程\" class=\"headerlink\" title=\"GPU 进程\"></a>GPU 进程</h4><p>最多只有一个,用于 3D 绘制等</p>\n<h4 id=\"渲染进程\"><a href=\"#渲染进程\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h4><p>称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。</p>\n<h3 id=\"渲染进程-1\"><a href=\"#渲染进程-1\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h3><p>浏览器的渲染进程是多线程的<br><img src=\"https://user-gold-cdn.xitu.io/2020/1/7/16f7ee2d5b4df806?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h4 id=\"GUI-渲染线程\"><a href=\"#GUI-渲染线程\" class=\"headerlink\" title=\"GUI 渲染线程\"></a>GUI 渲染线程</h4><ul>\n<li>负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li>\n<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。</li>\n<li>注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li>\n</ul>\n<h4 id=\"JS-引擎线程\"><a href=\"#JS-引擎线程\" class=\"headerlink\" title=\"JS 引擎线程\"></a>JS 引擎线程</h4><ul>\n<li>Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li>\n<li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li>\n<li>JS 引擎一直等待着任务队列中任务的到来,然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。</li>\n<li>注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>\n</ul>\n<h4 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h4><ul>\n<li>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解,JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li>\n<li>当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中</li>\n<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li>\n<li>注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</li>\n</ul>\n<h4 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h4><ul>\n<li>传说中的 setInterval 与 setTimeout 所在线程</li>\n<li>浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确）</li>\n<li>因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中，等待 JS 引擎空闲后执行）</li>\n<li>注意，W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li>\n</ul>\n<h4 id=\"异步-http-请求线程\"><a href=\"#异步-http-请求线程\" class=\"headerlink\" title=\"异步 http 请求线程\"></a>异步 http 请求线程</h4><ul>\n<li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>\n</ul>\n<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><h4 id=\"1-为什么-Javascript-要是单线程的\"><a href=\"#1-为什么-Javascript-要是单线程的\" class=\"headerlink\" title=\"1. 为什么 Javascript 要是单线程的 ?\"></a>1. 为什么 Javascript 要是单线程的 ?</h4><ul>\n<li>如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。</li>\n<li>如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源,</li>\n<li>假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。</li>\n<li>当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。</li>\n</ul>\n<h4 id=\"2-为什么-JS-阻塞页面加载\"><a href=\"#2-为什么-JS-阻塞页面加载\" class=\"headerlink\" title=\"2. 为什么 JS 阻塞页面加载 ?\"></a>2. 为什么 JS 阻塞页面加载 ?</h4><ul>\n<li>由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。</li>\n<li>因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。</li>\n</ul>\n<h4 id=\"3-css-加载会造成阻塞吗-？\"><a href=\"#3-css-加载会造成阻塞吗-？\" class=\"headerlink\" title=\"3. css 加载会造成阻塞吗 ？\"></a>3. css 加载会造成阻塞吗 ？</h4><ul>\n<li>CSS 加载不会阻塞 DOM 的解析，会阻塞 Dom 的渲染</li>\n</ul>\n<p>DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。</p>\n<p>然而,由于 渲染树 是依赖于 DOM树 和 CSSOM树 的,<br>所以他必须等待到 CSSOM树 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。<br>因此,CSS 加载会阻塞 Dom 的渲染。</p>\n<ul>\n<li>css 会阻塞后面 js 的执行。</li>\n</ul>\n<p>由于 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行。</p>\n<h4 id=\"4-DOMContentLoaded-与-load-的区别\"><a href=\"#4-DOMContentLoaded-与-load-的区别\" class=\"headerlink\" title=\"4. DOMContentLoaded 与 load 的区别 ?\"></a>4. DOMContentLoaded 与 load 的区别 ?</h4><ul>\n<li>当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。</li>\n<li>当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。</li>\n<li>当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。</li>\n<li>DOMContentLoaded -&gt; load</li>\n</ul>\n<h4 id=\"5-defer-和-async-的区别\"><a href=\"#5-defer-和-async-的区别\" class=\"headerlink\" title=\"5. defer 和 async 的区别 ?\"></a>5. defer 和 async 的区别 ?</h4><ol>\n<li><script src=\"script.js\">\n\n</li>\n</ol>\n<p>没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。</p>\n<ol start=\"2\">\n<li><script async src=\"script.js\">\n\n</li>\n</ol>\n<p>有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p>\n<ol start=\"3\">\n<li><script defer src=\"myscript.js\">\n\n</li>\n</ol>\n<p>有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。</p>\n<ol start=\"4\">\n<li>总结     </li>\n</ol>\n<p>defer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析），差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的</p>\n<p>关于 defer，它是按照加载顺序执行脚本的；<br>async 则是乱序执行的，反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行</p>\n<p>仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的</p>\n</script></li></ol>"},{"title":"渐进增强和优雅降级","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 渐进增强\n针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n```\n.transition{\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;  \n}\n```\n\n### 优雅降级\n一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n```\n.transition{ \n　　     transition: all .5s;\n　　  -o-transition: all .5s;\n  　-moz-transition: all .5s;\n -webkit-transition: all .5s;\n}\n```\n\n### 区别\n- 渐进增强观点认为应该关注于内容本身。\n- 优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。","source":"_posts/前端/渐进增强和优雅降级.md","raw":"---\ntitle: 渐进增强和优雅降级\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 渐进增强\n针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n```\n.transition{\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;  \n}\n```\n\n### 优雅降级\n一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n```\n.transition{ \n　　     transition: all .5s;\n　　  -o-transition: all .5s;\n  　-moz-transition: all .5s;\n -webkit-transition: all .5s;\n}\n```\n\n### 区别\n- 渐进增强观点认为应该关注于内容本身。\n- 优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。","slug":"前端/渐进增强和优雅降级","published":1,"date":"2019-03-27T07:30:44.262Z","updated":"2020-05-14T08:28:04.028Z","layout":"post","photos":[],"link":"","_id":"cka6kindl008rqgu9hxfrv7jm","content":"<h3 id=\"渐进增强\"><a href=\"#渐进增强\" class=\"headerlink\" title=\"渐进增强\"></a>渐进增强</h3><p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transition&#123;</span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">          transition: all .5s;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优雅降级\"><a href=\"#优雅降级\" class=\"headerlink\" title=\"优雅降级\"></a>优雅降级</h3><p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transition&#123; </span><br><span class=\"line\">　　     transition: all .5s;</span><br><span class=\"line\">　　  -o-transition: all .5s;</span><br><span class=\"line\">  　-moz-transition: all .5s;</span><br><span class=\"line\"> -webkit-transition: all .5s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>渐进增强观点认为应该关注于内容本身。</li>\n<li>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"渐进增强\"><a href=\"#渐进增强\" class=\"headerlink\" title=\"渐进增强\"></a>渐进增强</h3><p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transition&#123;</span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">          transition: all .5s;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优雅降级\"><a href=\"#优雅降级\" class=\"headerlink\" title=\"优雅降级\"></a>优雅降级</h3><p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transition&#123; </span><br><span class=\"line\">　　     transition: all .5s;</span><br><span class=\"line\">　　  -o-transition: all .5s;</span><br><span class=\"line\">  　-moz-transition: all .5s;</span><br><span class=\"line\"> -webkit-transition: all .5s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>渐进增强观点认为应该关注于内容本身。</li>\n<li>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。</li>\n</ul>\n"},{"title":"行内元素、块元素、行内块元素","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 行内元素\n- 设置宽高无效。\n- margin水平方向有效，垂直方向无效。\n- padding水平方向有效，垂直方向在显示上有效果即会增大元素的内容范围，但对其他元素无影响。\n- 不会自动进行换行。\n\n```\n常见行内元素\na - 锚点\nb - 粗体(不推荐)\nbig - 大字体\nbr - 换行\nem - 强调\nfont - 字体设定(不推荐)\ni - 斜体\nimg - 图片\ninput - 输入框\nlabel - 表格标签\nselect - 项目选择\nsmall - 小字体文本\nspan - 常用内联容器，定义文本内区块\nstrong - 粗体强调\ntextarea - 多行文本输入框\nu - 下划线\nvar - 定义变量\n```\n\n### 块元素\n- 能够识别宽高。\n- margin和padding的上下左右均对其有效。\n- 可以自动换行。\n- 多个块状元素标签写在一起，默认排列方式为从上至下。\n\n```\n常见块元素\naddress - 地址\nenter - 居中对齐块\ndir - 目录列表\ndiv - 常用块级容器，也是css layout的主要标签\ndl - 定义列表\nform - 交互表单\nh1 - 大标题\nh2 - 副标题\nh3 - 3级标题\nh4 - 4级标题\nh5 - 5级标题\nh6 - 6级标题\nhr - 水平分隔线\nmenu - 菜单列表\nol - 排序表单\np - 段落\ntable - 表格\nul - 非排序列表（无序列表）\n```\n### 可变元素\n可变元素由上下文语境来决定是块元素还是内联元素 \n\n```\nbutton - 按钮\ndel - 删除文本\niframe - inline frame\nins - 插入的文本\nmap - 图片区块（map）\nobject - object对象\nscript - 客户端脚本\n```\n\n\n### 行内块元素\n- 不自动换行\n- 能够识别宽高\n- 默认排列方式为从左到右\n\n### 三者转换\n使用display属性能够将三者任意转换：\n- display:inline;转换为行内元素\n- display:block;转换为块状元素\n- display:inline-block;转换为行内块状元素\n","source":"_posts/前端/行内元素、块元素、行内块元素.md","raw":"---\ntitle: 行内元素、块元素、行内块元素\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 行内元素\n- 设置宽高无效。\n- margin水平方向有效，垂直方向无效。\n- padding水平方向有效，垂直方向在显示上有效果即会增大元素的内容范围，但对其他元素无影响。\n- 不会自动进行换行。\n\n```\n常见行内元素\na - 锚点\nb - 粗体(不推荐)\nbig - 大字体\nbr - 换行\nem - 强调\nfont - 字体设定(不推荐)\ni - 斜体\nimg - 图片\ninput - 输入框\nlabel - 表格标签\nselect - 项目选择\nsmall - 小字体文本\nspan - 常用内联容器，定义文本内区块\nstrong - 粗体强调\ntextarea - 多行文本输入框\nu - 下划线\nvar - 定义变量\n```\n\n### 块元素\n- 能够识别宽高。\n- margin和padding的上下左右均对其有效。\n- 可以自动换行。\n- 多个块状元素标签写在一起，默认排列方式为从上至下。\n\n```\n常见块元素\naddress - 地址\nenter - 居中对齐块\ndir - 目录列表\ndiv - 常用块级容器，也是css layout的主要标签\ndl - 定义列表\nform - 交互表单\nh1 - 大标题\nh2 - 副标题\nh3 - 3级标题\nh4 - 4级标题\nh5 - 5级标题\nh6 - 6级标题\nhr - 水平分隔线\nmenu - 菜单列表\nol - 排序表单\np - 段落\ntable - 表格\nul - 非排序列表（无序列表）\n```\n### 可变元素\n可变元素由上下文语境来决定是块元素还是内联元素 \n\n```\nbutton - 按钮\ndel - 删除文本\niframe - inline frame\nins - 插入的文本\nmap - 图片区块（map）\nobject - object对象\nscript - 客户端脚本\n```\n\n\n### 行内块元素\n- 不自动换行\n- 能够识别宽高\n- 默认排列方式为从左到右\n\n### 三者转换\n使用display属性能够将三者任意转换：\n- display:inline;转换为行内元素\n- display:block;转换为块状元素\n- display:inline-block;转换为行内块状元素\n","slug":"前端/行内元素、块元素、行内块元素","published":1,"date":"2020-05-14T08:36:31.772Z","updated":"2020-05-14T08:31:28.612Z","layout":"post","photos":[],"link":"","_id":"cka6kindl008tqgu9aphe7lst","content":"<h3 id=\"行内元素\"><a href=\"#行内元素\" class=\"headerlink\" title=\"行内元素\"></a>行内元素</h3><ul>\n<li>设置宽高无效。</li>\n<li>margin水平方向有效，垂直方向无效。</li>\n<li>padding水平方向有效，垂直方向在显示上有效果即会增大元素的内容范围，但对其他元素无影响。</li>\n<li>不会自动进行换行。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常见行内元素</span><br><span class=\"line\">a - 锚点</span><br><span class=\"line\">b - 粗体(不推荐)</span><br><span class=\"line\">big - 大字体</span><br><span class=\"line\">br - 换行</span><br><span class=\"line\">em - 强调</span><br><span class=\"line\">font - 字体设定(不推荐)</span><br><span class=\"line\">i - 斜体</span><br><span class=\"line\">img - 图片</span><br><span class=\"line\">input - 输入框</span><br><span class=\"line\">label - 表格标签</span><br><span class=\"line\">select - 项目选择</span><br><span class=\"line\">small - 小字体文本</span><br><span class=\"line\">span - 常用内联容器，定义文本内区块</span><br><span class=\"line\">strong - 粗体强调</span><br><span class=\"line\">textarea - 多行文本输入框</span><br><span class=\"line\">u - 下划线</span><br><span class=\"line\">var - 定义变量</span><br></pre></td></tr></table></figure>\n<h3 id=\"块元素\"><a href=\"#块元素\" class=\"headerlink\" title=\"块元素\"></a>块元素</h3><ul>\n<li>能够识别宽高。</li>\n<li>margin和padding的上下左右均对其有效。</li>\n<li>可以自动换行。</li>\n<li>多个块状元素标签写在一起，默认排列方式为从上至下。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常见块元素</span><br><span class=\"line\">address - 地址</span><br><span class=\"line\">enter - 居中对齐块</span><br><span class=\"line\">dir - 目录列表</span><br><span class=\"line\">div - 常用块级容器，也是css layout的主要标签</span><br><span class=\"line\">dl - 定义列表</span><br><span class=\"line\">form - 交互表单</span><br><span class=\"line\">h1 - 大标题</span><br><span class=\"line\">h2 - 副标题</span><br><span class=\"line\">h3 - 3级标题</span><br><span class=\"line\">h4 - 4级标题</span><br><span class=\"line\">h5 - 5级标题</span><br><span class=\"line\">h6 - 6级标题</span><br><span class=\"line\">hr - 水平分隔线</span><br><span class=\"line\">menu - 菜单列表</span><br><span class=\"line\">ol - 排序表单</span><br><span class=\"line\">p - 段落</span><br><span class=\"line\">table - 表格</span><br><span class=\"line\">ul - 非排序列表（无序列表）</span><br></pre></td></tr></table></figure>\n<h3 id=\"可变元素\"><a href=\"#可变元素\" class=\"headerlink\" title=\"可变元素\"></a>可变元素</h3><p>可变元素由上下文语境来决定是块元素还是内联元素 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button - 按钮</span><br><span class=\"line\">del - 删除文本</span><br><span class=\"line\">iframe - inline frame</span><br><span class=\"line\">ins - 插入的文本</span><br><span class=\"line\">map - 图片区块（map）</span><br><span class=\"line\">object - object对象</span><br><span class=\"line\">script - 客户端脚本</span><br></pre></td></tr></table></figure>\n<h3 id=\"行内块元素\"><a href=\"#行内块元素\" class=\"headerlink\" title=\"行内块元素\"></a>行内块元素</h3><ul>\n<li>不自动换行</li>\n<li>能够识别宽高</li>\n<li>默认排列方式为从左到右</li>\n</ul>\n<h3 id=\"三者转换\"><a href=\"#三者转换\" class=\"headerlink\" title=\"三者转换\"></a>三者转换</h3><p>使用display属性能够将三者任意转换：</p>\n<ul>\n<li>display:inline;转换为行内元素</li>\n<li>display:block;转换为块状元素</li>\n<li>display:inline-block;转换为行内块状元素</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"行内元素\"><a href=\"#行内元素\" class=\"headerlink\" title=\"行内元素\"></a>行内元素</h3><ul>\n<li>设置宽高无效。</li>\n<li>margin水平方向有效，垂直方向无效。</li>\n<li>padding水平方向有效，垂直方向在显示上有效果即会增大元素的内容范围，但对其他元素无影响。</li>\n<li>不会自动进行换行。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常见行内元素</span><br><span class=\"line\">a - 锚点</span><br><span class=\"line\">b - 粗体(不推荐)</span><br><span class=\"line\">big - 大字体</span><br><span class=\"line\">br - 换行</span><br><span class=\"line\">em - 强调</span><br><span class=\"line\">font - 字体设定(不推荐)</span><br><span class=\"line\">i - 斜体</span><br><span class=\"line\">img - 图片</span><br><span class=\"line\">input - 输入框</span><br><span class=\"line\">label - 表格标签</span><br><span class=\"line\">select - 项目选择</span><br><span class=\"line\">small - 小字体文本</span><br><span class=\"line\">span - 常用内联容器，定义文本内区块</span><br><span class=\"line\">strong - 粗体强调</span><br><span class=\"line\">textarea - 多行文本输入框</span><br><span class=\"line\">u - 下划线</span><br><span class=\"line\">var - 定义变量</span><br></pre></td></tr></table></figure>\n<h3 id=\"块元素\"><a href=\"#块元素\" class=\"headerlink\" title=\"块元素\"></a>块元素</h3><ul>\n<li>能够识别宽高。</li>\n<li>margin和padding的上下左右均对其有效。</li>\n<li>可以自动换行。</li>\n<li>多个块状元素标签写在一起，默认排列方式为从上至下。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常见块元素</span><br><span class=\"line\">address - 地址</span><br><span class=\"line\">enter - 居中对齐块</span><br><span class=\"line\">dir - 目录列表</span><br><span class=\"line\">div - 常用块级容器，也是css layout的主要标签</span><br><span class=\"line\">dl - 定义列表</span><br><span class=\"line\">form - 交互表单</span><br><span class=\"line\">h1 - 大标题</span><br><span class=\"line\">h2 - 副标题</span><br><span class=\"line\">h3 - 3级标题</span><br><span class=\"line\">h4 - 4级标题</span><br><span class=\"line\">h5 - 5级标题</span><br><span class=\"line\">h6 - 6级标题</span><br><span class=\"line\">hr - 水平分隔线</span><br><span class=\"line\">menu - 菜单列表</span><br><span class=\"line\">ol - 排序表单</span><br><span class=\"line\">p - 段落</span><br><span class=\"line\">table - 表格</span><br><span class=\"line\">ul - 非排序列表（无序列表）</span><br></pre></td></tr></table></figure>\n<h3 id=\"可变元素\"><a href=\"#可变元素\" class=\"headerlink\" title=\"可变元素\"></a>可变元素</h3><p>可变元素由上下文语境来决定是块元素还是内联元素 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button - 按钮</span><br><span class=\"line\">del - 删除文本</span><br><span class=\"line\">iframe - inline frame</span><br><span class=\"line\">ins - 插入的文本</span><br><span class=\"line\">map - 图片区块（map）</span><br><span class=\"line\">object - object对象</span><br><span class=\"line\">script - 客户端脚本</span><br></pre></td></tr></table></figure>\n<h3 id=\"行内块元素\"><a href=\"#行内块元素\" class=\"headerlink\" title=\"行内块元素\"></a>行内块元素</h3><ul>\n<li>不自动换行</li>\n<li>能够识别宽高</li>\n<li>默认排列方式为从左到右</li>\n</ul>\n<h3 id=\"三者转换\"><a href=\"#三者转换\" class=\"headerlink\" title=\"三者转换\"></a>三者转换</h3><p>使用display属性能够将三者任意转换：</p>\n<ul>\n<li>display:inline;转换为行内元素</li>\n<li>display:block;转换为块状元素</li>\n<li>display:inline-block;转换为行内块状元素</li>\n</ul>\n"},{"title":"虚拟dom","Date":"2019-04-22T16:00:00.000Z","comments":1,"_content":"\n### 是什么\n可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。\n### 为什么\n之前使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，且在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的。在js做dom对比，减少对dom的操作，而不是每一次都要渲染，这样效率会提高。\n","source":"_posts/前端/虚拟dom.md","raw":"---\ntitle: 虚拟dom\nDate: 2019-04-23\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n### 是什么\n可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。\n### 为什么\n之前使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，且在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的。在js做dom对比，减少对dom的操作，而不是每一次都要渲染，这样效率会提高。\n","slug":"前端/虚拟dom","published":1,"date":"2019-04-23T14:14:11.134Z","updated":"2019-04-23T14:16:28.213Z","layout":"post","photos":[],"link":"","_id":"cka6kindv008xqgu91kjzyuaf","content":"<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。</p>\n<h3 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><p>之前使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，且在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的。在js做dom对比，减少对dom的操作，而不是每一次都要渲染，这样效率会提高。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。</p>\n<h3 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><p>之前使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，且在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的。在js做dom对比，减少对dom的操作，而不是每一次都要渲染，这样效率会提高。</p>\n"},{"title":"页面渲染过程（输入一个url）","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n输入一个url到网页呈现\n1. 输入网址\n2. 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址。\n3. 与web服务器建立TCP连接\n4. 浏览器向web服务器发送http请求\n5. web服务器响应请求，并返回指定url数据\n6. 浏览器下载web服务器返回的数据。\n7. 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件\n8. CSS 文件下载完成,解析 CSS 文件生成cssom树，调用JS执行引擎执行JS代码，然后将DOM树和CSSOM树结合生成渲染树。\n9. 根据渲染树来布局，计算每个节点的布局信息，将各个节点绘制到屏幕上来渲染页面，直至显示完成。\n\n若dom树生成过程中遇到script标签，则暂停，执行js直至完成再继续生成。\n\n若执行js时需要操作cssom，还得等css加载执行完生成cssom才能继续执行。\n\n因此，css资源要先于js资源加载，js放于页面底部，尽量少影响dom树的生成\n\n![image](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee2d9a5667b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n### 各种拓展\n#### 页面加载白屏\n原因：\n- 在弱网络下，网络延迟，JS加载延迟，会阻塞页面。\n- 客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html。\n\n如果页面完全一片空白。极有可能是后端出现问题，后端配置无错误输出，并且服务状态500，这个时候页面就是一片空白。\n如果是前端导致的，那么极有可能是单页应用异常，比如到了一个没有设置的新的页面。\n1、打开能看到源码和request、response的浏览器，如chrome，查看源码输出\n2、如果是后端问题，那么后端查看accesslog、程序日志，看看是否有问题\n3、如果是前端问题，那么根据给出的js异常之类的排查\n\n\n统计白屏数量：监听某个主div的变化，在规定时间内该DIV没有变化，那就可以进行白屏统计了。\n\n监控白屏时间：监听某个主div的变化，直至页面渲染。\n\n优化：尽量减少文件夹的嵌套，文件名不要过长。\n\n#### 一个网站很卡找原因\n\n首先用3g网络测试一下：如果卡就是http请求数据可能过大。\n可以合并JS脚本和CSS文件，css精灵图，对HTTP传输进行gzip压缩。\ncss放顶部，javascript放底部。\n\n可能服务端出问题：\n比如用户访问量大，并发量大。\nmysql没有优化好，造成死锁。\n\n可以用CDN加速把数据放在离用户更近的位置。\n","source":"_posts/前端/页面渲染过程（输入一个url）.md","raw":"---\ntitle: 页面渲染过程（输入一个url）\nDate: 2020-05-14\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n输入一个url到网页呈现\n1. 输入网址\n2. 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址。\n3. 与web服务器建立TCP连接\n4. 浏览器向web服务器发送http请求\n5. web服务器响应请求，并返回指定url数据\n6. 浏览器下载web服务器返回的数据。\n7. 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件\n8. CSS 文件下载完成,解析 CSS 文件生成cssom树，调用JS执行引擎执行JS代码，然后将DOM树和CSSOM树结合生成渲染树。\n9. 根据渲染树来布局，计算每个节点的布局信息，将各个节点绘制到屏幕上来渲染页面，直至显示完成。\n\n若dom树生成过程中遇到script标签，则暂停，执行js直至完成再继续生成。\n\n若执行js时需要操作cssom，还得等css加载执行完生成cssom才能继续执行。\n\n因此，css资源要先于js资源加载，js放于页面底部，尽量少影响dom树的生成\n\n![image](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee2d9a5667b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n### 各种拓展\n#### 页面加载白屏\n原因：\n- 在弱网络下，网络延迟，JS加载延迟，会阻塞页面。\n- 客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html。\n\n如果页面完全一片空白。极有可能是后端出现问题，后端配置无错误输出，并且服务状态500，这个时候页面就是一片空白。\n如果是前端导致的，那么极有可能是单页应用异常，比如到了一个没有设置的新的页面。\n1、打开能看到源码和request、response的浏览器，如chrome，查看源码输出\n2、如果是后端问题，那么后端查看accesslog、程序日志，看看是否有问题\n3、如果是前端问题，那么根据给出的js异常之类的排查\n\n\n统计白屏数量：监听某个主div的变化，在规定时间内该DIV没有变化，那就可以进行白屏统计了。\n\n监控白屏时间：监听某个主div的变化，直至页面渲染。\n\n优化：尽量减少文件夹的嵌套，文件名不要过长。\n\n#### 一个网站很卡找原因\n\n首先用3g网络测试一下：如果卡就是http请求数据可能过大。\n可以合并JS脚本和CSS文件，css精灵图，对HTTP传输进行gzip压缩。\ncss放顶部，javascript放底部。\n\n可能服务端出问题：\n比如用户访问量大，并发量大。\nmysql没有优化好，造成死锁。\n\n可以用CDN加速把数据放在离用户更近的位置。\n","slug":"前端/页面渲染过程（输入一个url）","published":1,"date":"2020-05-14T08:36:31.792Z","updated":"2020-05-14T08:32:08.254Z","layout":"post","photos":[],"link":"","_id":"cka6kindv008zqgu96v7g2y34","content":"<p>输入一个url到网页呈现</p>\n<ol>\n<li>输入网址</li>\n<li>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址。</li>\n<li>与web服务器建立TCP连接</li>\n<li>浏览器向web服务器发送http请求</li>\n<li>web服务器响应请求，并返回指定url数据</li>\n<li>浏览器下载web服务器返回的数据。</li>\n<li>解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件</li>\n<li>CSS 文件下载完成,解析 CSS 文件生成cssom树，调用JS执行引擎执行JS代码，然后将DOM树和CSSOM树结合生成渲染树。</li>\n<li>根据渲染树来布局，计算每个节点的布局信息，将各个节点绘制到屏幕上来渲染页面，直至显示完成。</li>\n</ol>\n<p>若dom树生成过程中遇到script标签，则暂停，执行js直至完成再继续生成。</p>\n<p>若执行js时需要操作cssom，还得等css加载执行完生成cssom才能继续执行。</p>\n<p>因此，css资源要先于js资源加载，js放于页面底部，尽量少影响dom树的生成</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/1/7/16f7ee2d9a5667b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"各种拓展\"><a href=\"#各种拓展\" class=\"headerlink\" title=\"各种拓展\"></a>各种拓展</h3><h4 id=\"页面加载白屏\"><a href=\"#页面加载白屏\" class=\"headerlink\" title=\"页面加载白屏\"></a>页面加载白屏</h4><p>原因：</p>\n<ul>\n<li>在弱网络下，网络延迟，JS加载延迟，会阻塞页面。</li>\n<li>客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html。</li>\n</ul>\n<p>如果页面完全一片空白。极有可能是后端出现问题，后端配置无错误输出，并且服务状态500，这个时候页面就是一片空白。<br>如果是前端导致的，那么极有可能是单页应用异常，比如到了一个没有设置的新的页面。<br>1、打开能看到源码和request、response的浏览器，如chrome，查看源码输出<br>2、如果是后端问题，那么后端查看accesslog、程序日志，看看是否有问题<br>3、如果是前端问题，那么根据给出的js异常之类的排查</p>\n<p>统计白屏数量：监听某个主div的变化，在规定时间内该DIV没有变化，那就可以进行白屏统计了。</p>\n<p>监控白屏时间：监听某个主div的变化，直至页面渲染。</p>\n<p>优化：尽量减少文件夹的嵌套，文件名不要过长。</p>\n<h4 id=\"一个网站很卡找原因\"><a href=\"#一个网站很卡找原因\" class=\"headerlink\" title=\"一个网站很卡找原因\"></a>一个网站很卡找原因</h4><p>首先用3g网络测试一下：如果卡就是http请求数据可能过大。<br>可以合并JS脚本和CSS文件，css精灵图，对HTTP传输进行gzip压缩。<br>css放顶部，javascript放底部。</p>\n<p>可能服务端出问题：<br>比如用户访问量大，并发量大。<br>mysql没有优化好，造成死锁。</p>\n<p>可以用CDN加速把数据放在离用户更近的位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>输入一个url到网页呈现</p>\n<ol>\n<li>输入网址</li>\n<li>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址。</li>\n<li>与web服务器建立TCP连接</li>\n<li>浏览器向web服务器发送http请求</li>\n<li>web服务器响应请求，并返回指定url数据</li>\n<li>浏览器下载web服务器返回的数据。</li>\n<li>解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件</li>\n<li>CSS 文件下载完成,解析 CSS 文件生成cssom树，调用JS执行引擎执行JS代码，然后将DOM树和CSSOM树结合生成渲染树。</li>\n<li>根据渲染树来布局，计算每个节点的布局信息，将各个节点绘制到屏幕上来渲染页面，直至显示完成。</li>\n</ol>\n<p>若dom树生成过程中遇到script标签，则暂停，执行js直至完成再继续生成。</p>\n<p>若执行js时需要操作cssom，还得等css加载执行完生成cssom才能继续执行。</p>\n<p>因此，css资源要先于js资源加载，js放于页面底部，尽量少影响dom树的生成</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/1/7/16f7ee2d9a5667b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"各种拓展\"><a href=\"#各种拓展\" class=\"headerlink\" title=\"各种拓展\"></a>各种拓展</h3><h4 id=\"页面加载白屏\"><a href=\"#页面加载白屏\" class=\"headerlink\" title=\"页面加载白屏\"></a>页面加载白屏</h4><p>原因：</p>\n<ul>\n<li>在弱网络下，网络延迟，JS加载延迟，会阻塞页面。</li>\n<li>客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html。</li>\n</ul>\n<p>如果页面完全一片空白。极有可能是后端出现问题，后端配置无错误输出，并且服务状态500，这个时候页面就是一片空白。<br>如果是前端导致的，那么极有可能是单页应用异常，比如到了一个没有设置的新的页面。<br>1、打开能看到源码和request、response的浏览器，如chrome，查看源码输出<br>2、如果是后端问题，那么后端查看accesslog、程序日志，看看是否有问题<br>3、如果是前端问题，那么根据给出的js异常之类的排查</p>\n<p>统计白屏数量：监听某个主div的变化，在规定时间内该DIV没有变化，那就可以进行白屏统计了。</p>\n<p>监控白屏时间：监听某个主div的变化，直至页面渲染。</p>\n<p>优化：尽量减少文件夹的嵌套，文件名不要过长。</p>\n<h4 id=\"一个网站很卡找原因\"><a href=\"#一个网站很卡找原因\" class=\"headerlink\" title=\"一个网站很卡找原因\"></a>一个网站很卡找原因</h4><p>首先用3g网络测试一下：如果卡就是http请求数据可能过大。<br>可以合并JS脚本和CSS文件，css精灵图，对HTTP传输进行gzip压缩。<br>css放顶部，javascript放底部。</p>\n<p>可能服务端出问题：<br>比如用户访问量大，并发量大。<br>mysql没有优化好，造成死锁。</p>\n<p>可以用CDN加速把数据放在离用户更近的位置。</p>\n"},{"title":"LeetCode算法题（一）","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n1. 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。    \n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n```\nvar reverse = function(x) {\n    var arr = x.toString().split('');\n    if(arr[0]=='-'){\n        var temp = arr.slice(1,arr.length);\n        temp.reverse().unshift(\"-\");\n        x = parseInt(temp.join(''));\n    }else{\n        x = parseInt(arr.reverse().join(''));\n    }\n    if(x>=-Math.pow(2,31)&&x<=Math.pow(2,31)){\n        return x; \n    }else{\n        return 0;\n    }\n};\n```\n2. 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 \"\"。\n\n```\nvar longestCommonPrefix = function(strs) {\n    var str=\"\";\n    if(strs.length == 1){\n        str = strs[0];\n    }else if(strs.length >= 2){\n        for(var i=1;i<=Math.min(strs[0].length,strs[1].length);i++){\n            if(strs[0].slice(0,i)==strs[1].slice(0,i)){\n                str = strs[0].slice(0,i);\n                continue;\n            }else{\n                break;\n            }\n        }\n        for(var j=2;j<strs.length;j++){\n            while(str!=\"\"&&strs[j].substr(0,str.length)!=str){\n              str = str.slice(0,str.length-1);\n            }\n        } \n    }\n    return str;\n};\n```\n3. 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n- 左括号必须用相同类型的右括号闭合。\n- 左括号必须以正确的顺序闭合。即先开的后闭合。 \n\n```\n \"([)]\" //false\n \"{[]}\" //true\n \"\" //true\n```\n注意空字符串可被认为是有效字符串。\n\n```\nvar isValid = function(s) {\n    var temp = [];\n    for(var i in s){\n        if(s[i]==\"(\"){\n            temp.push(\")\");\n        }else if(s[i]==\"[\"){\n            temp.push(\"]\");\n        }else if(s[i]==\"{\"){\n            temp.push(\"}\");\n        }else if(s[i]!=temp.pop()){\n            return false;\n        }\n    }\n    return !temp.length;\n    //只开不闭temp.length为true\n    //空字符串temp.length为false\n    //其余有效字符串temp会被移除空\n};\n```\n4. 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n```\nvar searchInsert = function(nums, target) {\n    for(var i=0;i<nums.length;i++){\n        if(nums[i]>=target){\n            return i\n        }\n    }\n    return nums.length;\n};\n```\n5. 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。\n\n如果不存在最后一个单词，请返回 0 。\n\n说明：一个单词是指由字母组成，但不包含任何空格的字符串。\n\n```\nvar lengthOfLastWord = function(s) {\n     var len = s.length;\n      var count = 0;\n      while(len!=0&&s[len-1]==\" \"){\n        len--;\n      }\n      while(s[len-1]!=\" \"&&len>0){\n        count++;\n        len--;\n      }\n      return count;\n};\n```\n","source":"_posts/算法/LeetCode算法题（一）.md","raw":"---\ntitle: LeetCode算法题（一）\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n1. 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。    \n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n```\nvar reverse = function(x) {\n    var arr = x.toString().split('');\n    if(arr[0]=='-'){\n        var temp = arr.slice(1,arr.length);\n        temp.reverse().unshift(\"-\");\n        x = parseInt(temp.join(''));\n    }else{\n        x = parseInt(arr.reverse().join(''));\n    }\n    if(x>=-Math.pow(2,31)&&x<=Math.pow(2,31)){\n        return x; \n    }else{\n        return 0;\n    }\n};\n```\n2. 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 \"\"。\n\n```\nvar longestCommonPrefix = function(strs) {\n    var str=\"\";\n    if(strs.length == 1){\n        str = strs[0];\n    }else if(strs.length >= 2){\n        for(var i=1;i<=Math.min(strs[0].length,strs[1].length);i++){\n            if(strs[0].slice(0,i)==strs[1].slice(0,i)){\n                str = strs[0].slice(0,i);\n                continue;\n            }else{\n                break;\n            }\n        }\n        for(var j=2;j<strs.length;j++){\n            while(str!=\"\"&&strs[j].substr(0,str.length)!=str){\n              str = str.slice(0,str.length-1);\n            }\n        } \n    }\n    return str;\n};\n```\n3. 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n- 左括号必须用相同类型的右括号闭合。\n- 左括号必须以正确的顺序闭合。即先开的后闭合。 \n\n```\n \"([)]\" //false\n \"{[]}\" //true\n \"\" //true\n```\n注意空字符串可被认为是有效字符串。\n\n```\nvar isValid = function(s) {\n    var temp = [];\n    for(var i in s){\n        if(s[i]==\"(\"){\n            temp.push(\")\");\n        }else if(s[i]==\"[\"){\n            temp.push(\"]\");\n        }else if(s[i]==\"{\"){\n            temp.push(\"}\");\n        }else if(s[i]!=temp.pop()){\n            return false;\n        }\n    }\n    return !temp.length;\n    //只开不闭temp.length为true\n    //空字符串temp.length为false\n    //其余有效字符串temp会被移除空\n};\n```\n4. 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n```\nvar searchInsert = function(nums, target) {\n    for(var i=0;i<nums.length;i++){\n        if(nums[i]>=target){\n            return i\n        }\n    }\n    return nums.length;\n};\n```\n5. 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。\n\n如果不存在最后一个单词，请返回 0 。\n\n说明：一个单词是指由字母组成，但不包含任何空格的字符串。\n\n```\nvar lengthOfLastWord = function(s) {\n     var len = s.length;\n      var count = 0;\n      while(len!=0&&s[len-1]==\" \"){\n        len--;\n      }\n      while(s[len-1]!=\" \"&&len>0){\n        count++;\n        len--;\n      }\n      return count;\n};\n```\n","slug":"算法/LeetCode算法题（一）","published":1,"date":"2020-03-17T09:03:33.978Z","updated":"2020-03-17T09:11:49.417Z","layout":"post","photos":[],"link":"","_id":"cka6kine50093qgu9tght9bwi","content":"<ol>\n<li>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reverse = function(x) &#123;</span><br><span class=\"line\">    var arr = x.toString().split(&apos;&apos;);</span><br><span class=\"line\">    if(arr[0]==&apos;-&apos;)&#123;</span><br><span class=\"line\">        var temp = arr.slice(1,arr.length);</span><br><span class=\"line\">        temp.reverse().unshift(&quot;-&quot;);</span><br><span class=\"line\">        x = parseInt(temp.join(&apos;&apos;));</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        x = parseInt(arr.reverse().join(&apos;&apos;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(x&gt;=-Math.pow(2,31)&amp;&amp;x&lt;=Math.pow(2,31))&#123;</span><br><span class=\"line\">        return x; </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var longestCommonPrefix = function(strs) &#123;</span><br><span class=\"line\">    var str=&quot;&quot;;</span><br><span class=\"line\">    if(strs.length == 1)&#123;</span><br><span class=\"line\">        str = strs[0];</span><br><span class=\"line\">    &#125;else if(strs.length &gt;= 2)&#123;</span><br><span class=\"line\">        for(var i=1;i&lt;=Math.min(strs[0].length,strs[1].length);i++)&#123;</span><br><span class=\"line\">            if(strs[0].slice(0,i)==strs[1].slice(0,i))&#123;</span><br><span class=\"line\">                str = strs[0].slice(0,i);</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(var j=2;j&lt;strs.length;j++)&#123;</span><br><span class=\"line\">            while(str!=&quot;&quot;&amp;&amp;strs[j].substr(0,str.length)!=str)&#123;</span><br><span class=\"line\">              str = str.slice(0,str.length-1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</li>\n</ol>\n<p>有效字符串需满足：</p>\n<ul>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。即先开的后闭合。 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;([)]&quot; //false</span><br><span class=\"line\">&quot;&#123;[]&#125;&quot; //true</span><br><span class=\"line\">&quot;&quot; //true</span><br></pre></td></tr></table></figure>\n<p>注意空字符串可被认为是有效字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isValid = function(s) &#123;</span><br><span class=\"line\">    var temp = [];</span><br><span class=\"line\">    for(var i in s)&#123;</span><br><span class=\"line\">        if(s[i]==&quot;(&quot;)&#123;</span><br><span class=\"line\">            temp.push(&quot;)&quot;);</span><br><span class=\"line\">        &#125;else if(s[i]==&quot;[&quot;)&#123;</span><br><span class=\"line\">            temp.push(&quot;]&quot;);</span><br><span class=\"line\">        &#125;else if(s[i]==&quot;&#123;&quot;)&#123;</span><br><span class=\"line\">            temp.push(&quot;&#125;&quot;);</span><br><span class=\"line\">        &#125;else if(s[i]!=temp.pop())&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return !temp.length;</span><br><span class=\"line\">    //只开不闭temp.length为true</span><br><span class=\"line\">    //空字符串temp.length为false</span><br><span class=\"line\">    //其余有效字符串temp会被移除空</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</li>\n</ol>\n<p>你可以假设数组中无重复元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var searchInsert = function(nums, target) &#123;</span><br><span class=\"line\">    for(var i=0;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">        if(nums[i]&gt;=target)&#123;</span><br><span class=\"line\">            return i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return nums.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。</li>\n</ol>\n<p>如果不存在最后一个单词，请返回 0 。</p>\n<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lengthOfLastWord = function(s) &#123;</span><br><span class=\"line\">     var len = s.length;</span><br><span class=\"line\">      var count = 0;</span><br><span class=\"line\">      while(len!=0&amp;&amp;s[len-1]==&quot; &quot;)&#123;</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      while(s[len-1]!=&quot; &quot;&amp;&amp;len&gt;0)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return count;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reverse = function(x) &#123;</span><br><span class=\"line\">    var arr = x.toString().split(&apos;&apos;);</span><br><span class=\"line\">    if(arr[0]==&apos;-&apos;)&#123;</span><br><span class=\"line\">        var temp = arr.slice(1,arr.length);</span><br><span class=\"line\">        temp.reverse().unshift(&quot;-&quot;);</span><br><span class=\"line\">        x = parseInt(temp.join(&apos;&apos;));</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        x = parseInt(arr.reverse().join(&apos;&apos;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(x&gt;=-Math.pow(2,31)&amp;&amp;x&lt;=Math.pow(2,31))&#123;</span><br><span class=\"line\">        return x; </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var longestCommonPrefix = function(strs) &#123;</span><br><span class=\"line\">    var str=&quot;&quot;;</span><br><span class=\"line\">    if(strs.length == 1)&#123;</span><br><span class=\"line\">        str = strs[0];</span><br><span class=\"line\">    &#125;else if(strs.length &gt;= 2)&#123;</span><br><span class=\"line\">        for(var i=1;i&lt;=Math.min(strs[0].length,strs[1].length);i++)&#123;</span><br><span class=\"line\">            if(strs[0].slice(0,i)==strs[1].slice(0,i))&#123;</span><br><span class=\"line\">                str = strs[0].slice(0,i);</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(var j=2;j&lt;strs.length;j++)&#123;</span><br><span class=\"line\">            while(str!=&quot;&quot;&amp;&amp;strs[j].substr(0,str.length)!=str)&#123;</span><br><span class=\"line\">              str = str.slice(0,str.length-1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</li>\n</ol>\n<p>有效字符串需满足：</p>\n<ul>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。即先开的后闭合。 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;([)]&quot; //false</span><br><span class=\"line\">&quot;&#123;[]&#125;&quot; //true</span><br><span class=\"line\">&quot;&quot; //true</span><br></pre></td></tr></table></figure>\n<p>注意空字符串可被认为是有效字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isValid = function(s) &#123;</span><br><span class=\"line\">    var temp = [];</span><br><span class=\"line\">    for(var i in s)&#123;</span><br><span class=\"line\">        if(s[i]==&quot;(&quot;)&#123;</span><br><span class=\"line\">            temp.push(&quot;)&quot;);</span><br><span class=\"line\">        &#125;else if(s[i]==&quot;[&quot;)&#123;</span><br><span class=\"line\">            temp.push(&quot;]&quot;);</span><br><span class=\"line\">        &#125;else if(s[i]==&quot;&#123;&quot;)&#123;</span><br><span class=\"line\">            temp.push(&quot;&#125;&quot;);</span><br><span class=\"line\">        &#125;else if(s[i]!=temp.pop())&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return !temp.length;</span><br><span class=\"line\">    //只开不闭temp.length为true</span><br><span class=\"line\">    //空字符串temp.length为false</span><br><span class=\"line\">    //其余有效字符串temp会被移除空</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</li>\n</ol>\n<p>你可以假设数组中无重复元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var searchInsert = function(nums, target) &#123;</span><br><span class=\"line\">    for(var i=0;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">        if(nums[i]&gt;=target)&#123;</span><br><span class=\"line\">            return i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return nums.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。</li>\n</ol>\n<p>如果不存在最后一个单词，请返回 0 。</p>\n<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lengthOfLastWord = function(s) &#123;</span><br><span class=\"line\">     var len = s.length;</span><br><span class=\"line\">      var count = 0;</span><br><span class=\"line\">      while(len!=0&amp;&amp;s[len-1]==&quot; &quot;)&#123;</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      while(s[len-1]!=&quot; &quot;&amp;&amp;len&gt;0)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return count;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"C：冒泡法和选择法","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n## 冒泡法\n### 算法示例\n用起泡法对10个整数按升序排序。\n### 算法分析\n如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。\n### 算法源代码\n\n```\n  #include <stdio.h>\n　int main()\n　{\n　int a[10],i,j,t;\n　printf(\"Please input 10 numbers: \");\n　/*输入源数据*/\n　for(i=0;i<10;i++)\n　scanf(\"%d\",&a[i]);\n　/*排序*/\n　for(j=0;j<9;j++)          /*外循环控制排序趟数，n个数排n-1趟*/\n　for(i=0;i<9-j;i++)    /*内循环每趟比较的次数，第j趟比较n-j次*/\n　if(a[i]>a[i+1])    /*相邻元素比较，逆序则交换*/\n　{ t=a[i];\n　a[i]=a[i+1];\n　a[i+1]=t;\n　}\n　\n　/*输出排序结果*/\n　printf(\"The sorted numbers: \");\n　for(i=0;i<10;i++)\n　printf(\"%d   \",a[i]);\n　printf(\"\\n\");\n　return 0;\n　\n　}\n```\n\n## 选择法\n### 算法示例要求\n用选择法对10个整数按降序排序。\n### 算法分析\n每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。\n### 算法源代码\n\n```\n#include <stdio.h>\n　int main()\n　{\n　int a[10],i,j,k,t,n=10;\n　printf(\"Please input 10 numbers:\");\n　for(i=0;i<10;i++)\n　scanf(\"%d\",&a[i]);\n　for(i=0;i<n-1;i++)   /*外循环控制趟数，n个数选n-1趟*/\n　{\n　k=i;             /*假设当前趟的第一个数为最值,记在k中 */\n　for(j=i+1;j<n;j++)  /*从下一个数到最后一个数之间找最值*/\n　if(a[k]<a[j])     /*若其后有比最值更大的*/\n　k=j;         /*则将其下标记在k中*/\n　if(k!=i)        /*若k不为最初的i值，说明在其后找到比其更大的数*/\n　{  t=a[k];  a[k]=a[i];  a[i]=t;  } /*则交换最值和当前序列的第一\n　个数*/\n　}\n　printf(\"The sorted numbers: \");\n　for(i=0;i<10;i++)\n　printf(\"%d   \",a[i]);\n　printf(\"\\n\");\n　}\n```\n\n## 区别：（个人见解）\n- 冒泡法要进行对n个数进行n-1趟，第j趟要进行n-j次比较，每次比较相邻的数不符合则要交换，每趟最多需要n-j次数的交换\n- 选择法也要进行n-1趟，每趟是选出最值，而选最值是把下标交换，直到选出最值的下标，把最值和第一位交换，每趟最多仅需1次数的交换\n- 简单地说，冒泡法每次都是数的交换（各个下标对应的数是变化的），而选择法是通过下标交换（这时候各个下标对应的数是不变的）选出最值的下标，最后再进行数的交换","source":"_posts/算法/C：冒泡法和选择法.md","raw":"---\ntitle: C：冒泡法和选择法\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n## 冒泡法\n### 算法示例\n用起泡法对10个整数按升序排序。\n### 算法分析\n如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。\n### 算法源代码\n\n```\n  #include <stdio.h>\n　int main()\n　{\n　int a[10],i,j,t;\n　printf(\"Please input 10 numbers: \");\n　/*输入源数据*/\n　for(i=0;i<10;i++)\n　scanf(\"%d\",&a[i]);\n　/*排序*/\n　for(j=0;j<9;j++)          /*外循环控制排序趟数，n个数排n-1趟*/\n　for(i=0;i<9-j;i++)    /*内循环每趟比较的次数，第j趟比较n-j次*/\n　if(a[i]>a[i+1])    /*相邻元素比较，逆序则交换*/\n　{ t=a[i];\n　a[i]=a[i+1];\n　a[i+1]=t;\n　}\n　\n　/*输出排序结果*/\n　printf(\"The sorted numbers: \");\n　for(i=0;i<10;i++)\n　printf(\"%d   \",a[i]);\n　printf(\"\\n\");\n　return 0;\n　\n　}\n```\n\n## 选择法\n### 算法示例要求\n用选择法对10个整数按降序排序。\n### 算法分析\n每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。\n### 算法源代码\n\n```\n#include <stdio.h>\n　int main()\n　{\n　int a[10],i,j,k,t,n=10;\n　printf(\"Please input 10 numbers:\");\n　for(i=0;i<10;i++)\n　scanf(\"%d\",&a[i]);\n　for(i=0;i<n-1;i++)   /*外循环控制趟数，n个数选n-1趟*/\n　{\n　k=i;             /*假设当前趟的第一个数为最值,记在k中 */\n　for(j=i+1;j<n;j++)  /*从下一个数到最后一个数之间找最值*/\n　if(a[k]<a[j])     /*若其后有比最值更大的*/\n　k=j;         /*则将其下标记在k中*/\n　if(k!=i)        /*若k不为最初的i值，说明在其后找到比其更大的数*/\n　{  t=a[k];  a[k]=a[i];  a[i]=t;  } /*则交换最值和当前序列的第一\n　个数*/\n　}\n　printf(\"The sorted numbers: \");\n　for(i=0;i<10;i++)\n　printf(\"%d   \",a[i]);\n　printf(\"\\n\");\n　}\n```\n\n## 区别：（个人见解）\n- 冒泡法要进行对n个数进行n-1趟，第j趟要进行n-j次比较，每次比较相邻的数不符合则要交换，每趟最多需要n-j次数的交换\n- 选择法也要进行n-1趟，每趟是选出最值，而选最值是把下标交换，直到选出最值的下标，把最值和第一位交换，每趟最多仅需1次数的交换\n- 简单地说，冒泡法每次都是数的交换（各个下标对应的数是变化的），而选择法是通过下标交换（这时候各个下标对应的数是不变的）选出最值的下标，最后再进行数的交换","slug":"算法/C：冒泡法和选择法","published":1,"date":"2020-03-17T09:03:09.377Z","updated":"2020-03-17T09:08:27.266Z","layout":"post","photos":[],"link":"","_id":"cka6kine50095qgu9qp2ayzpu","content":"<h2 id=\"冒泡法\"><a href=\"#冒泡法\" class=\"headerlink\" title=\"冒泡法\"></a>冒泡法</h2><h3 id=\"算法示例\"><a href=\"#算法示例\" class=\"headerlink\" title=\"算法示例\"></a>算法示例</h3><p>用起泡法对10个整数按升序排序。</p>\n<h3 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h3><p>如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。</p>\n<h3 id=\"算法源代码\"><a href=\"#算法源代码\" class=\"headerlink\" title=\"算法源代码\"></a>算法源代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">　int main()</span><br><span class=\"line\">　&#123;</span><br><span class=\"line\">　int a[10],i,j,t;</span><br><span class=\"line\">　printf(&quot;Please input 10 numbers: &quot;);</span><br><span class=\"line\">　/*输入源数据*/</span><br><span class=\"line\">　for(i=0;i&lt;10;i++)</span><br><span class=\"line\">　scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">　/*排序*/</span><br><span class=\"line\">　for(j=0;j&lt;9;j++)          /*外循环控制排序趟数，n个数排n-1趟*/</span><br><span class=\"line\">　for(i=0;i&lt;9-j;i++)    /*内循环每趟比较的次数，第j趟比较n-j次*/</span><br><span class=\"line\">　if(a[i]&gt;a[i+1])    /*相邻元素比较，逆序则交换*/</span><br><span class=\"line\">　&#123; t=a[i];</span><br><span class=\"line\">　a[i]=a[i+1];</span><br><span class=\"line\">　a[i+1]=t;</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　</span><br><span class=\"line\">　/*输出排序结果*/</span><br><span class=\"line\">　printf(&quot;The sorted numbers: &quot;);</span><br><span class=\"line\">　for(i=0;i&lt;10;i++)</span><br><span class=\"line\">　printf(&quot;%d   &quot;,a[i]);</span><br><span class=\"line\">　printf(&quot;\\n&quot;);</span><br><span class=\"line\">　return 0;</span><br><span class=\"line\">　</span><br><span class=\"line\">　&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择法\"><a href=\"#选择法\" class=\"headerlink\" title=\"选择法\"></a>选择法</h2><h3 id=\"算法示例要求\"><a href=\"#算法示例要求\" class=\"headerlink\" title=\"算法示例要求\"></a>算法示例要求</h3><p>用选择法对10个整数按降序排序。</p>\n<h3 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h3><p>每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。</p>\n<h3 id=\"算法源代码-1\"><a href=\"#算法源代码-1\" class=\"headerlink\" title=\"算法源代码\"></a>算法源代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">　int main()</span><br><span class=\"line\">　&#123;</span><br><span class=\"line\">　int a[10],i,j,k,t,n=10;</span><br><span class=\"line\">　printf(&quot;Please input 10 numbers:&quot;);</span><br><span class=\"line\">　for(i=0;i&lt;10;i++)</span><br><span class=\"line\">　scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">　for(i=0;i&lt;n-1;i++)   /*外循环控制趟数，n个数选n-1趟*/</span><br><span class=\"line\">　&#123;</span><br><span class=\"line\">　k=i;             /*假设当前趟的第一个数为最值,记在k中 */</span><br><span class=\"line\">　for(j=i+1;j&lt;n;j++)  /*从下一个数到最后一个数之间找最值*/</span><br><span class=\"line\">　if(a[k]&lt;a[j])     /*若其后有比最值更大的*/</span><br><span class=\"line\">　k=j;         /*则将其下标记在k中*/</span><br><span class=\"line\">　if(k!=i)        /*若k不为最初的i值，说明在其后找到比其更大的数*/</span><br><span class=\"line\">　&#123;  t=a[k];  a[k]=a[i];  a[i]=t;  &#125; /*则交换最值和当前序列的第一</span><br><span class=\"line\">　个数*/</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　printf(&quot;The sorted numbers: &quot;);</span><br><span class=\"line\">　for(i=0;i&lt;10;i++)</span><br><span class=\"line\">　printf(&quot;%d   &quot;,a[i]);</span><br><span class=\"line\">　printf(&quot;\\n&quot;);</span><br><span class=\"line\">　&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"区别：（个人见解）\"><a href=\"#区别：（个人见解）\" class=\"headerlink\" title=\"区别：（个人见解）\"></a>区别：（个人见解）</h2><ul>\n<li>冒泡法要进行对n个数进行n-1趟，第j趟要进行n-j次比较，每次比较相邻的数不符合则要交换，每趟最多需要n-j次数的交换</li>\n<li>选择法也要进行n-1趟，每趟是选出最值，而选最值是把下标交换，直到选出最值的下标，把最值和第一位交换，每趟最多仅需1次数的交换</li>\n<li>简单地说，冒泡法每次都是数的交换（各个下标对应的数是变化的），而选择法是通过下标交换（这时候各个下标对应的数是不变的）选出最值的下标，最后再进行数的交换</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"冒泡法\"><a href=\"#冒泡法\" class=\"headerlink\" title=\"冒泡法\"></a>冒泡法</h2><h3 id=\"算法示例\"><a href=\"#算法示例\" class=\"headerlink\" title=\"算法示例\"></a>算法示例</h3><p>用起泡法对10个整数按升序排序。</p>\n<h3 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h3><p>如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。</p>\n<h3 id=\"算法源代码\"><a href=\"#算法源代码\" class=\"headerlink\" title=\"算法源代码\"></a>算法源代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">　int main()</span><br><span class=\"line\">　&#123;</span><br><span class=\"line\">　int a[10],i,j,t;</span><br><span class=\"line\">　printf(&quot;Please input 10 numbers: &quot;);</span><br><span class=\"line\">　/*输入源数据*/</span><br><span class=\"line\">　for(i=0;i&lt;10;i++)</span><br><span class=\"line\">　scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">　/*排序*/</span><br><span class=\"line\">　for(j=0;j&lt;9;j++)          /*外循环控制排序趟数，n个数排n-1趟*/</span><br><span class=\"line\">　for(i=0;i&lt;9-j;i++)    /*内循环每趟比较的次数，第j趟比较n-j次*/</span><br><span class=\"line\">　if(a[i]&gt;a[i+1])    /*相邻元素比较，逆序则交换*/</span><br><span class=\"line\">　&#123; t=a[i];</span><br><span class=\"line\">　a[i]=a[i+1];</span><br><span class=\"line\">　a[i+1]=t;</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　</span><br><span class=\"line\">　/*输出排序结果*/</span><br><span class=\"line\">　printf(&quot;The sorted numbers: &quot;);</span><br><span class=\"line\">　for(i=0;i&lt;10;i++)</span><br><span class=\"line\">　printf(&quot;%d   &quot;,a[i]);</span><br><span class=\"line\">　printf(&quot;\\n&quot;);</span><br><span class=\"line\">　return 0;</span><br><span class=\"line\">　</span><br><span class=\"line\">　&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择法\"><a href=\"#选择法\" class=\"headerlink\" title=\"选择法\"></a>选择法</h2><h3 id=\"算法示例要求\"><a href=\"#算法示例要求\" class=\"headerlink\" title=\"算法示例要求\"></a>算法示例要求</h3><p>用选择法对10个整数按降序排序。</p>\n<h3 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h3><p>每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。</p>\n<h3 id=\"算法源代码-1\"><a href=\"#算法源代码-1\" class=\"headerlink\" title=\"算法源代码\"></a>算法源代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">　int main()</span><br><span class=\"line\">　&#123;</span><br><span class=\"line\">　int a[10],i,j,k,t,n=10;</span><br><span class=\"line\">　printf(&quot;Please input 10 numbers:&quot;);</span><br><span class=\"line\">　for(i=0;i&lt;10;i++)</span><br><span class=\"line\">　scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">　for(i=0;i&lt;n-1;i++)   /*外循环控制趟数，n个数选n-1趟*/</span><br><span class=\"line\">　&#123;</span><br><span class=\"line\">　k=i;             /*假设当前趟的第一个数为最值,记在k中 */</span><br><span class=\"line\">　for(j=i+1;j&lt;n;j++)  /*从下一个数到最后一个数之间找最值*/</span><br><span class=\"line\">　if(a[k]&lt;a[j])     /*若其后有比最值更大的*/</span><br><span class=\"line\">　k=j;         /*则将其下标记在k中*/</span><br><span class=\"line\">　if(k!=i)        /*若k不为最初的i值，说明在其后找到比其更大的数*/</span><br><span class=\"line\">　&#123;  t=a[k];  a[k]=a[i];  a[i]=t;  &#125; /*则交换最值和当前序列的第一</span><br><span class=\"line\">　个数*/</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　printf(&quot;The sorted numbers: &quot;);</span><br><span class=\"line\">　for(i=0;i&lt;10;i++)</span><br><span class=\"line\">　printf(&quot;%d   &quot;,a[i]);</span><br><span class=\"line\">　printf(&quot;\\n&quot;);</span><br><span class=\"line\">　&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"区别：（个人见解）\"><a href=\"#区别：（个人见解）\" class=\"headerlink\" title=\"区别：（个人见解）\"></a>区别：（个人见解）</h2><ul>\n<li>冒泡法要进行对n个数进行n-1趟，第j趟要进行n-j次比较，每次比较相邻的数不符合则要交换，每趟最多需要n-j次数的交换</li>\n<li>选择法也要进行n-1趟，每趟是选出最值，而选最值是把下标交换，直到选出最值的下标，把最值和第一位交换，每趟最多仅需1次数的交换</li>\n<li>简单地说，冒泡法每次都是数的交换（各个下标对应的数是变化的），而选择法是通过下标交换（这时候各个下标对应的数是不变的）选出最值的下标，最后再进行数的交换</li>\n</ul>\n"},{"title":"LeetCode：有效的括号","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### 题目\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n- 左括号必须用相同类型的右括号闭合。\n- 左括号必须以正确的顺序闭合。\n- 注意空字符串可被认为是有效字符串。\n\n### 测试用例\n\n```\n1. \"()\" // true\n2. \"()[]{}\" // true\n3. \"(]\" // false\n4. \"([)]\" // false\n5. \"{[]}\" // true\n```\n\n### 解法一\n#### 思路\n- 使用字符串的replace方法进行匹配替换，直到全部匹配成功，字符串长度为0，返回true\n- 或直到没有相匹配的项，匹配前的字符串与匹配后的字符串相等，则返回false\n\n#### 算法\n\n```\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    if(s.length === 0) {\n        return true;\n    }\n    while(s.length !== 0) {\n        var temp = s;\n        s = s.replace('()','');\n        s = s.replace('[]','');\n        s = s.replace('{}','');\n        if(s === temp) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n\n### 解法二\n#### 思路\n- 构造哈希表，遍历字符串\n- 对于左括号，把相应的右括号放进栈里\n- 对于右括号，若与栈顶匹配，则把栈顶去除；若是不匹配，则往栈顶添加undefined，为了防止开头就是右括号的情况\n\n#### 算法\n\n```\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    var map = {\n        '(': ')',\n        '[': ']',\n        '{': '}'\n    }\n    var stack = [];\n    for(let i in s) {\n        if(s[i] !== stack[stack.length-1]) {\n            stack.push(map[s[i]])\n        } else {\n            stack.pop();\n        }\n    }\n    return stack.length === 0 ? true : false;\n};\n```\n\n","source":"_posts/算法/LeetCode：有效的括号.md","raw":"---\ntitle: LeetCode：有效的括号\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n### 题目\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n- 左括号必须用相同类型的右括号闭合。\n- 左括号必须以正确的顺序闭合。\n- 注意空字符串可被认为是有效字符串。\n\n### 测试用例\n\n```\n1. \"()\" // true\n2. \"()[]{}\" // true\n3. \"(]\" // false\n4. \"([)]\" // false\n5. \"{[]}\" // true\n```\n\n### 解法一\n#### 思路\n- 使用字符串的replace方法进行匹配替换，直到全部匹配成功，字符串长度为0，返回true\n- 或直到没有相匹配的项，匹配前的字符串与匹配后的字符串相等，则返回false\n\n#### 算法\n\n```\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    if(s.length === 0) {\n        return true;\n    }\n    while(s.length !== 0) {\n        var temp = s;\n        s = s.replace('()','');\n        s = s.replace('[]','');\n        s = s.replace('{}','');\n        if(s === temp) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n\n### 解法二\n#### 思路\n- 构造哈希表，遍历字符串\n- 对于左括号，把相应的右括号放进栈里\n- 对于右括号，若与栈顶匹配，则把栈顶去除；若是不匹配，则往栈顶添加undefined，为了防止开头就是右括号的情况\n\n#### 算法\n\n```\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    var map = {\n        '(': ')',\n        '[': ']',\n        '{': '}'\n    }\n    var stack = [];\n    for(let i in s) {\n        if(s[i] !== stack[stack.length-1]) {\n            stack.push(map[s[i]])\n        } else {\n            stack.pop();\n        }\n    }\n    return stack.length === 0 ? true : false;\n};\n```\n\n","slug":"算法/LeetCode：有效的括号","published":1,"date":"2020-03-17T09:03:52.468Z","updated":"2020-03-17T09:11:16.163Z","layout":"post","photos":[],"link":"","_id":"cka6kinef0099qgu9nun9p5cl","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ul>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n<li>注意空字符串可被认为是有效字符串。</li>\n</ul>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. &quot;()&quot; // true</span><br><span class=\"line\">2. &quot;()[]&#123;&#125;&quot; // true</span><br><span class=\"line\">3. &quot;(]&quot; // false</span><br><span class=\"line\">4. &quot;([)]&quot; // false</span><br><span class=\"line\">5. &quot;&#123;[]&#125;&quot; // true</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>使用字符串的replace方法进行匹配替换，直到全部匹配成功，字符串长度为0，返回true</li>\n<li>或直到没有相匹配的项，匹配前的字符串与匹配后的字符串相等，则返回false</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var isValid = function(s) &#123;</span><br><span class=\"line\">    if(s.length === 0) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(s.length !== 0) &#123;</span><br><span class=\"line\">        var temp = s;</span><br><span class=\"line\">        s = s.replace(&apos;()&apos;,&apos;&apos;);</span><br><span class=\"line\">        s = s.replace(&apos;[]&apos;,&apos;&apos;);</span><br><span class=\"line\">        s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;);</span><br><span class=\"line\">        if(s === temp) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>构造哈希表，遍历字符串</li>\n<li>对于左括号，把相应的右括号放进栈里</li>\n<li>对于右括号，若与栈顶匹配，则把栈顶去除；若是不匹配，则往栈顶添加undefined，为了防止开头就是右括号的情况</li>\n</ul>\n<h4 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var isValid = function(s) &#123;</span><br><span class=\"line\">    var map = &#123;</span><br><span class=\"line\">        &apos;(&apos;: &apos;)&apos;,</span><br><span class=\"line\">        &apos;[&apos;: &apos;]&apos;,</span><br><span class=\"line\">        &apos;&#123;&apos;: &apos;&#125;&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var stack = [];</span><br><span class=\"line\">    for(let i in s) &#123;</span><br><span class=\"line\">        if(s[i] !== stack[stack.length-1]) &#123;</span><br><span class=\"line\">            stack.push(map[s[i]])</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            stack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return stack.length === 0 ? true : false;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ul>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n<li>注意空字符串可被认为是有效字符串。</li>\n</ul>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. &quot;()&quot; // true</span><br><span class=\"line\">2. &quot;()[]&#123;&#125;&quot; // true</span><br><span class=\"line\">3. &quot;(]&quot; // false</span><br><span class=\"line\">4. &quot;([)]&quot; // false</span><br><span class=\"line\">5. &quot;&#123;[]&#125;&quot; // true</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>使用字符串的replace方法进行匹配替换，直到全部匹配成功，字符串长度为0，返回true</li>\n<li>或直到没有相匹配的项，匹配前的字符串与匹配后的字符串相等，则返回false</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var isValid = function(s) &#123;</span><br><span class=\"line\">    if(s.length === 0) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(s.length !== 0) &#123;</span><br><span class=\"line\">        var temp = s;</span><br><span class=\"line\">        s = s.replace(&apos;()&apos;,&apos;&apos;);</span><br><span class=\"line\">        s = s.replace(&apos;[]&apos;,&apos;&apos;);</span><br><span class=\"line\">        s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;);</span><br><span class=\"line\">        if(s === temp) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>构造哈希表，遍历字符串</li>\n<li>对于左括号，把相应的右括号放进栈里</li>\n<li>对于右括号，若与栈顶匹配，则把栈顶去除；若是不匹配，则往栈顶添加undefined，为了防止开头就是右括号的情况</li>\n</ul>\n<h4 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var isValid = function(s) &#123;</span><br><span class=\"line\">    var map = &#123;</span><br><span class=\"line\">        &apos;(&apos;: &apos;)&apos;,</span><br><span class=\"line\">        &apos;[&apos;: &apos;]&apos;,</span><br><span class=\"line\">        &apos;&#123;&apos;: &apos;&#125;&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var stack = [];</span><br><span class=\"line\">    for(let i in s) &#123;</span><br><span class=\"line\">        if(s[i] !== stack[stack.length-1]) &#123;</span><br><span class=\"line\">            stack.push(map[s[i]])</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            stack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return stack.length === 0 ? true : false;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"LeetCode：罗马数字转整数","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### 题目\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n字符 | 数值\n---|---\nI | 1\nV | 5\nX | 10\nL | 50\nC | 100\nD | 500\nM |  1000\n\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\n- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\n- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和  900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n### 测试用例\n\n```\n1. \"III\" // 3\n2. \"IV\" // 4\n3. \"IX\" // 9\n4. \"LVIII\" // 58  解释: L = 50, V= 5, III = 3\n5. \"MCMXCIV\" // 1994  解释:M = 1000, CM = 900, XC = 90, IV = 4\n```\n\n### 解法\n#### 思路\n- 根据题目中的所有情况写出哈希表\n- 先匹配特殊情况，由于是匹配两个字符串，所以应考虑到最后一个字符串没有下一个的情况，所以先判断是否到最后了\n- 若匹配，直接加，并使指针跳过这两个字符串\n- 若不匹配，则直接得出该字符串的值，指针正常指向下一个\n\n#### 算法\n\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    var map = {\n        I: 1,\n        IV: 4,\n        V: 5,\n        IX: 9,\n        X: 10,\n        XL: 40,\n        L: 50,\n        XC: 90,\n        C: 100,\n        CD: 400,\n        D: 500,\n        CM: 900,\n        M: 1000\n    }\n    var res = 0;\n    for(let i=0;i<s.length;i++) {\n        if(i+1 < s.length && map[s.substr(i,2)]) {\n        res += map[s.substr(i,2)];\n        i++;\n        } else {\n        res += map[s.substr(i,1)];\n        }\n    }  \n    return res;\n};\n```\n","source":"_posts/算法/LeetCode：罗马数字转整数.md","raw":"---\ntitle: LeetCode：罗马数字转整数\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n### 题目\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n字符 | 数值\n---|---\nI | 1\nV | 5\nX | 10\nL | 50\nC | 100\nD | 500\nM |  1000\n\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\n- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\n- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和  900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n### 测试用例\n\n```\n1. \"III\" // 3\n2. \"IV\" // 4\n3. \"IX\" // 9\n4. \"LVIII\" // 58  解释: L = 50, V= 5, III = 3\n5. \"MCMXCIV\" // 1994  解释:M = 1000, CM = 900, XC = 90, IV = 4\n```\n\n### 解法\n#### 思路\n- 根据题目中的所有情况写出哈希表\n- 先匹配特殊情况，由于是匹配两个字符串，所以应考虑到最后一个字符串没有下一个的情况，所以先判断是否到最后了\n- 若匹配，直接加，并使指针跳过这两个字符串\n- 若不匹配，则直接得出该字符串的值，指针正常指向下一个\n\n#### 算法\n\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    var map = {\n        I: 1,\n        IV: 4,\n        V: 5,\n        IX: 9,\n        X: 10,\n        XL: 40,\n        L: 50,\n        XC: 90,\n        C: 100,\n        CD: 400,\n        D: 500,\n        CM: 900,\n        M: 1000\n    }\n    var res = 0;\n    for(let i=0;i<s.length;i++) {\n        if(i+1 < s.length && map[s.substr(i,2)]) {\n        res += map[s.substr(i,2)];\n        i++;\n        } else {\n        res += map[s.substr(i,1)];\n        }\n    }  \n    return res;\n};\n```\n","slug":"算法/LeetCode：罗马数字转整数","published":1,"date":"2020-03-17T09:03:45.124Z","updated":"2020-03-17T09:11:26.106Z","layout":"post","photos":[],"link":"","_id":"cka6kinef009bqgu93lvwxt9t","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>数值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>I</td>\n<td>1</td>\n</tr>\n<tr>\n<td>V</td>\n<td>5</td>\n</tr>\n<tr>\n<td>X</td>\n<td>10</td>\n</tr>\n<tr>\n<td>L</td>\n<td>50</td>\n</tr>\n<tr>\n<td>C</td>\n<td>100</td>\n</tr>\n<tr>\n<td>D</td>\n<td>500</td>\n</tr>\n<tr>\n<td>M</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和  900。</li>\n</ul>\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. &quot;III&quot; // 3</span><br><span class=\"line\">2. &quot;IV&quot; // 4</span><br><span class=\"line\">3. &quot;IX&quot; // 9</span><br><span class=\"line\">4. &quot;LVIII&quot; // 58  解释: L = 50, V= 5, III = 3</span><br><span class=\"line\">5. &quot;MCMXCIV&quot; // 1994  解释:M = 1000, CM = 900, XC = 90, IV = 4</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>根据题目中的所有情况写出哈希表</li>\n<li>先匹配特殊情况，由于是匹配两个字符串，所以应考虑到最后一个字符串没有下一个的情况，所以先判断是否到最后了</li>\n<li>若匹配，直接加，并使指针跳过这两个字符串</li>\n<li>若不匹配，则直接得出该字符串的值，指针正常指向下一个</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var romanToInt = function(s) &#123;</span><br><span class=\"line\">    var map = &#123;</span><br><span class=\"line\">        I: 1,</span><br><span class=\"line\">        IV: 4,</span><br><span class=\"line\">        V: 5,</span><br><span class=\"line\">        IX: 9,</span><br><span class=\"line\">        X: 10,</span><br><span class=\"line\">        XL: 40,</span><br><span class=\"line\">        L: 50,</span><br><span class=\"line\">        XC: 90,</span><br><span class=\"line\">        C: 100,</span><br><span class=\"line\">        CD: 400,</span><br><span class=\"line\">        D: 500,</span><br><span class=\"line\">        CM: 900,</span><br><span class=\"line\">        M: 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var res = 0;</span><br><span class=\"line\">    for(let i=0;i&lt;s.length;i++) &#123;</span><br><span class=\"line\">        if(i+1 &lt; s.length &amp;&amp; map[s.substr(i,2)]) &#123;</span><br><span class=\"line\">        res += map[s.substr(i,2)];</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        res += map[s.substr(i,1)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>数值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>I</td>\n<td>1</td>\n</tr>\n<tr>\n<td>V</td>\n<td>5</td>\n</tr>\n<tr>\n<td>X</td>\n<td>10</td>\n</tr>\n<tr>\n<td>L</td>\n<td>50</td>\n</tr>\n<tr>\n<td>C</td>\n<td>100</td>\n</tr>\n<tr>\n<td>D</td>\n<td>500</td>\n</tr>\n<tr>\n<td>M</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和  900。</li>\n</ul>\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. &quot;III&quot; // 3</span><br><span class=\"line\">2. &quot;IV&quot; // 4</span><br><span class=\"line\">3. &quot;IX&quot; // 9</span><br><span class=\"line\">4. &quot;LVIII&quot; // 58  解释: L = 50, V= 5, III = 3</span><br><span class=\"line\">5. &quot;MCMXCIV&quot; // 1994  解释:M = 1000, CM = 900, XC = 90, IV = 4</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>根据题目中的所有情况写出哈希表</li>\n<li>先匹配特殊情况，由于是匹配两个字符串，所以应考虑到最后一个字符串没有下一个的情况，所以先判断是否到最后了</li>\n<li>若匹配，直接加，并使指针跳过这两个字符串</li>\n<li>若不匹配，则直接得出该字符串的值，指针正常指向下一个</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var romanToInt = function(s) &#123;</span><br><span class=\"line\">    var map = &#123;</span><br><span class=\"line\">        I: 1,</span><br><span class=\"line\">        IV: 4,</span><br><span class=\"line\">        V: 5,</span><br><span class=\"line\">        IX: 9,</span><br><span class=\"line\">        X: 10,</span><br><span class=\"line\">        XL: 40,</span><br><span class=\"line\">        L: 50,</span><br><span class=\"line\">        XC: 90,</span><br><span class=\"line\">        C: 100,</span><br><span class=\"line\">        CD: 400,</span><br><span class=\"line\">        D: 500,</span><br><span class=\"line\">        CM: 900,</span><br><span class=\"line\">        M: 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var res = 0;</span><br><span class=\"line\">    for(let i=0;i&lt;s.length;i++) &#123;</span><br><span class=\"line\">        if(i+1 &lt; s.length &amp;&amp; map[s.substr(i,2)]) &#123;</span><br><span class=\"line\">        res += map[s.substr(i,2)];</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        res += map[s.substr(i,1)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"LeetCode：验证回文串","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### 题目\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n### 测试用例\n\n```\n1. \"A man, a plan, a canal: Panama\" // true\n2. \"race a car\" // false\n```\n\n### 解法\n#### 思路\n- 先判空字符串\n- 对非空字符串，先用正则把除字母和数字之外的字符去除，再全部转换为小写字母\n- 把字符串分割为数组，翻转，再拼接为字符串，与原字符串进行对比\n\n#### 算法\n\n```\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isPalindrome = function(s) {\n    if(s === '') {\n        return true;\n    }\n    s = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase();\n    if(s === s.split('').reverse().join('')){\n        return true;\n    }\n    return false;\n};\n```\n","source":"_posts/算法/LeetCode：验证回文串.md","raw":"---\ntitle: LeetCode：验证回文串\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n### 题目\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n### 测试用例\n\n```\n1. \"A man, a plan, a canal: Panama\" // true\n2. \"race a car\" // false\n```\n\n### 解法\n#### 思路\n- 先判空字符串\n- 对非空字符串，先用正则把除字母和数字之外的字符去除，再全部转换为小写字母\n- 把字符串分割为数组，翻转，再拼接为字符串，与原字符串进行对比\n\n#### 算法\n\n```\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isPalindrome = function(s) {\n    if(s === '') {\n        return true;\n    }\n    s = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase();\n    if(s === s.split('').reverse().join('')){\n        return true;\n    }\n    return false;\n};\n```\n","slug":"算法/LeetCode：验证回文串","published":1,"date":"2020-03-17T09:03:57.679Z","updated":"2020-03-17T09:11:05.915Z","layout":"post","photos":[],"link":"","_id":"cka6kines009fqgu9bh9gadmh","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>\n<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. &quot;A man, a plan, a canal: Panama&quot; // true</span><br><span class=\"line\">2. &quot;race a car&quot; // false</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>先判空字符串</li>\n<li>对非空字符串，先用正则把除字母和数字之外的字符去除，再全部转换为小写字母</li>\n<li>把字符串分割为数组，翻转，再拼接为字符串，与原字符串进行对比</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var isPalindrome = function(s) &#123;</span><br><span class=\"line\">    if(s === &apos;&apos;) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = s.replace(/[^0-9a-zA-Z]/g, &apos;&apos;).toLowerCase();</span><br><span class=\"line\">    if(s === s.split(&apos;&apos;).reverse().join(&apos;&apos;))&#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>\n<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. &quot;A man, a plan, a canal: Panama&quot; // true</span><br><span class=\"line\">2. &quot;race a car&quot; // false</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>先判空字符串</li>\n<li>对非空字符串，先用正则把除字母和数字之外的字符去除，再全部转换为小写字母</li>\n<li>把字符串分割为数组，翻转，再拼接为字符串，与原字符串进行对比</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var isPalindrome = function(s) &#123;</span><br><span class=\"line\">    if(s === &apos;&apos;) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = s.replace(/[^0-9a-zA-Z]/g, &apos;&apos;).toLowerCase();</span><br><span class=\"line\">    if(s === s.split(&apos;&apos;).reverse().join(&apos;&apos;))&#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"各种算法（一）","Date":"2019-03-26T16:00:00.000Z","comments":1,"_content":"\n求1+2+3+...+n\n```\nfunction Sum_Solution(n) {\n    var result = n;\n    if(n > 0)\n        result += Sum_Solution(n-1);\n    return result;\n}\nconsole.log(Sum_Solution(3)); //6\n```\n\n统计一个数字在无序数组中出现的次数\n```\nfunction count(arr,num){\n\tarr.sort(function(a,b){\n\t\treturn a-b;\n\t});\n\tvar result;\n\tvar left = arr.indexOf(num);\n\tvar right = arr.lastIndexOf(num,arr.length-1);\n\tif(arr.indexOf(num) == -1){\n\t\tresult = 0;\n\t}else{\n\t\tresult = right-left+1;\n\t}\n\treturn result;\n}\nconsole.log(count([5,5,5,5,5,2,3],5)); //5\n```\n\n找出数组中任意一个重复的数字\n```\nfunction duplicate(numbers, duplication){\n     // write code here\n    //这里要特别注意~找到任意重复的一个值并赋值到duplication[0]\n    //函数返回True/False\n    var temp = [];\n    for(var i in numbers){\n        if(temp.indexOf(numbers[i])==-1){\n            temp.push(numbers[i]);\n        }else{\n            duplication[0] = numbers[i];\n            return true;\n        }\n    }\n    return false;\n}\nconsole.log(duplicate([5,5,5,5,5,2,3],[]));//true\n```\n\n快速排序\n\n```\nfunction quickSort(arr){\n    if(arr.length <= 1){\n        return arr;\n    }\n    var pivotIndex = Math.floor(arr.length/2);\n    var pivot = splice(pivotIndex,1)[0];\n    var left = [];\n    var right = [];\n    for(var i in arr){\n        if(arr[i] < pivot){\n            left.push(arr[i]);\n        }else{\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat([pivot],quickSort(right));\n}\n```\n\n\n\n","source":"_posts/算法/各种算法（一）.md","raw":"---\ntitle: 各种算法（一）\nDate: 2019-03-27\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n求1+2+3+...+n\n```\nfunction Sum_Solution(n) {\n    var result = n;\n    if(n > 0)\n        result += Sum_Solution(n-1);\n    return result;\n}\nconsole.log(Sum_Solution(3)); //6\n```\n\n统计一个数字在无序数组中出现的次数\n```\nfunction count(arr,num){\n\tarr.sort(function(a,b){\n\t\treturn a-b;\n\t});\n\tvar result;\n\tvar left = arr.indexOf(num);\n\tvar right = arr.lastIndexOf(num,arr.length-1);\n\tif(arr.indexOf(num) == -1){\n\t\tresult = 0;\n\t}else{\n\t\tresult = right-left+1;\n\t}\n\treturn result;\n}\nconsole.log(count([5,5,5,5,5,2,3],5)); //5\n```\n\n找出数组中任意一个重复的数字\n```\nfunction duplicate(numbers, duplication){\n     // write code here\n    //这里要特别注意~找到任意重复的一个值并赋值到duplication[0]\n    //函数返回True/False\n    var temp = [];\n    for(var i in numbers){\n        if(temp.indexOf(numbers[i])==-1){\n            temp.push(numbers[i]);\n        }else{\n            duplication[0] = numbers[i];\n            return true;\n        }\n    }\n    return false;\n}\nconsole.log(duplicate([5,5,5,5,5,2,3],[]));//true\n```\n\n快速排序\n\n```\nfunction quickSort(arr){\n    if(arr.length <= 1){\n        return arr;\n    }\n    var pivotIndex = Math.floor(arr.length/2);\n    var pivot = splice(pivotIndex,1)[0];\n    var left = [];\n    var right = [];\n    for(var i in arr){\n        if(arr[i] < pivot){\n            left.push(arr[i]);\n        }else{\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat([pivot],quickSort(right));\n}\n```\n\n\n\n","slug":"算法/各种算法（一）","published":1,"date":"2019-03-27T07:30:55.074Z","updated":"2019-03-27T07:34:54.838Z","layout":"post","photos":[],"link":"","_id":"cka6kinex009hqgu9cp365ewb","content":"<p>求1+2+3+…+n<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Sum_Solution(n) &#123;</span><br><span class=\"line\">    var result = n;</span><br><span class=\"line\">    if(n &gt; 0)</span><br><span class=\"line\">        result += Sum_Solution(n-1);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Sum_Solution(3)); //6</span><br></pre></td></tr></table></figure></p>\n<p>统计一个数字在无序数组中出现的次数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function count(arr,num)&#123;</span><br><span class=\"line\">\tarr.sort(function(a,b)&#123;</span><br><span class=\"line\">\t\treturn a-b;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tvar result;</span><br><span class=\"line\">\tvar left = arr.indexOf(num);</span><br><span class=\"line\">\tvar right = arr.lastIndexOf(num,arr.length-1);</span><br><span class=\"line\">\tif(arr.indexOf(num) == -1)&#123;</span><br><span class=\"line\">\t\tresult = 0;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tresult = right-left+1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(count([5,5,5,5,5,2,3],5)); //5</span><br></pre></td></tr></table></figure></p>\n<p>找出数组中任意一个重复的数字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function duplicate(numbers, duplication)&#123;</span><br><span class=\"line\">     // write code here</span><br><span class=\"line\">    //这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span><br><span class=\"line\">    //函数返回True/False</span><br><span class=\"line\">    var temp = [];</span><br><span class=\"line\">    for(var i in numbers)&#123;</span><br><span class=\"line\">        if(temp.indexOf(numbers[i])==-1)&#123;</span><br><span class=\"line\">            temp.push(numbers[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            duplication[0] = numbers[i];</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(duplicate([5,5,5,5,5,2,3],[]));//true</span><br></pre></td></tr></table></figure></p>\n<p>快速排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length &lt;= 1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class=\"line\">    var pivot = splice(pivotIndex,1)[0];</span><br><span class=\"line\">    var left = [];</span><br><span class=\"line\">    var right = [];</span><br><span class=\"line\">    for(var i in arr)&#123;</span><br><span class=\"line\">        if(arr[i] &lt; pivot)&#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return quickSort(left).concat([pivot],quickSort(right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>求1+2+3+…+n<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Sum_Solution(n) &#123;</span><br><span class=\"line\">    var result = n;</span><br><span class=\"line\">    if(n &gt; 0)</span><br><span class=\"line\">        result += Sum_Solution(n-1);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Sum_Solution(3)); //6</span><br></pre></td></tr></table></figure></p>\n<p>统计一个数字在无序数组中出现的次数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function count(arr,num)&#123;</span><br><span class=\"line\">\tarr.sort(function(a,b)&#123;</span><br><span class=\"line\">\t\treturn a-b;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tvar result;</span><br><span class=\"line\">\tvar left = arr.indexOf(num);</span><br><span class=\"line\">\tvar right = arr.lastIndexOf(num,arr.length-1);</span><br><span class=\"line\">\tif(arr.indexOf(num) == -1)&#123;</span><br><span class=\"line\">\t\tresult = 0;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tresult = right-left+1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(count([5,5,5,5,5,2,3],5)); //5</span><br></pre></td></tr></table></figure></p>\n<p>找出数组中任意一个重复的数字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function duplicate(numbers, duplication)&#123;</span><br><span class=\"line\">     // write code here</span><br><span class=\"line\">    //这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span><br><span class=\"line\">    //函数返回True/False</span><br><span class=\"line\">    var temp = [];</span><br><span class=\"line\">    for(var i in numbers)&#123;</span><br><span class=\"line\">        if(temp.indexOf(numbers[i])==-1)&#123;</span><br><span class=\"line\">            temp.push(numbers[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            duplication[0] = numbers[i];</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(duplicate([5,5,5,5,5,2,3],[]));//true</span><br></pre></td></tr></table></figure></p>\n<p>快速排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length &lt;= 1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class=\"line\">    var pivot = splice(pivotIndex,1)[0];</span><br><span class=\"line\">    var left = [];</span><br><span class=\"line\">    var right = [];</span><br><span class=\"line\">    for(var i in arr)&#123;</span><br><span class=\"line\">        if(arr[i] &lt; pivot)&#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return quickSort(left).concat([pivot],quickSort(right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"各种算法（三）","Date":"2019-03-26T16:00:00.000Z","comments":1,"_content":"\n有一个字符串有很多is，写一个方法只保留一个is？\n\n```\nfunction deleteIs(str){\n  var index = str.search(\"is\");\n  var left = str.slice(0,index+2);\n  var right = str.slice(index+2,str.length);\n  right = right.split(\"is\").join(\"\");\n  return left.concat(right);\n }\n\nconsole.log(deleteIs(\"thisismybook\"));//thismybook\n```\n\n有3个-10-10之间的整数，写一个方法这三个数一共有多少可能相加等于10。\n\n改写数组的push方法，保持原有逻辑，添加一个console.log(arguments)，即push什么打印什么。\n\n```\nArray.prototype.push = function(val){\n    console.log(val);\n}\nvar temp = [1,2,5];\ntemp.push(7);//打印7\n```\n\n传入一个无序数组，要求n数相加，获取特定的sum\n\n```\n function getResult(arr,n,sum){\n    if(n==0&&sum==0){\n        return true;\n    }\n    if(n<0){\n        return false;\n    }\n    if(n>0){\n        for(var i in arr){\n            var temp = arr.slice(i+1,arr.length);\n            return getResult(temp,n-1,sum-arr[i]) || getResult(temp,n,sum);\n        }\n    }\n}\n\nconsole.log(getResult([1,2,3,4],2,7)); //true\n```\n\n用正则表达式去掉两边的空格\n\n```\nfunction remove(str){\n  var reg = /(^\\s+)|(\\s+?)/g;\n  return str.replace(reg,\"\");\n}\n\nconsole.log(remove(\"this is book\"));//\"thisisbook\"\n```\n给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项\n\n```\nfunction getSingleNumber(arr){\n  var temp = [];\n  for(var i in arr){\n    if(temp.indexOf(arr[i]) == -1){\n      temp.push(arr[i]);\n    }else{\n      temp.splice(temp.indexOf(arr[i]),1);\n    }\n  }\n  return temp[0];\n}\n\nconsole.log(getSingleNumber([0,1,0,0])); //1\n```\n请实现一个函数merge，传入一个数组，合并数组中【相邻且重复】的元素\n\n```\nfunction merge(arr){\n  var reg = /(.)\\1*/g;\n  var str = arr.join(\"\");\n  str = str.replace(reg,\"$1\");\n  arr = str.split(\"\");\n  arr = arr.map(function(val){\n    return parseInt(val);\n  })\n  return arr;\n}\n\nconsole.log(merge([3,2,2,4,5,5,6,2,1]));//[3,2,4,5,6,2,1]\n```\n\n","source":"_posts/算法/各种算法（三）.md","raw":"---\ntitle: 各种算法（三）\nDate: 2019-03-27\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n有一个字符串有很多is，写一个方法只保留一个is？\n\n```\nfunction deleteIs(str){\n  var index = str.search(\"is\");\n  var left = str.slice(0,index+2);\n  var right = str.slice(index+2,str.length);\n  right = right.split(\"is\").join(\"\");\n  return left.concat(right);\n }\n\nconsole.log(deleteIs(\"thisismybook\"));//thismybook\n```\n\n有3个-10-10之间的整数，写一个方法这三个数一共有多少可能相加等于10。\n\n改写数组的push方法，保持原有逻辑，添加一个console.log(arguments)，即push什么打印什么。\n\n```\nArray.prototype.push = function(val){\n    console.log(val);\n}\nvar temp = [1,2,5];\ntemp.push(7);//打印7\n```\n\n传入一个无序数组，要求n数相加，获取特定的sum\n\n```\n function getResult(arr,n,sum){\n    if(n==0&&sum==0){\n        return true;\n    }\n    if(n<0){\n        return false;\n    }\n    if(n>0){\n        for(var i in arr){\n            var temp = arr.slice(i+1,arr.length);\n            return getResult(temp,n-1,sum-arr[i]) || getResult(temp,n,sum);\n        }\n    }\n}\n\nconsole.log(getResult([1,2,3,4],2,7)); //true\n```\n\n用正则表达式去掉两边的空格\n\n```\nfunction remove(str){\n  var reg = /(^\\s+)|(\\s+?)/g;\n  return str.replace(reg,\"\");\n}\n\nconsole.log(remove(\"this is book\"));//\"thisisbook\"\n```\n给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项\n\n```\nfunction getSingleNumber(arr){\n  var temp = [];\n  for(var i in arr){\n    if(temp.indexOf(arr[i]) == -1){\n      temp.push(arr[i]);\n    }else{\n      temp.splice(temp.indexOf(arr[i]),1);\n    }\n  }\n  return temp[0];\n}\n\nconsole.log(getSingleNumber([0,1,0,0])); //1\n```\n请实现一个函数merge，传入一个数组，合并数组中【相邻且重复】的元素\n\n```\nfunction merge(arr){\n  var reg = /(.)\\1*/g;\n  var str = arr.join(\"\");\n  str = str.replace(reg,\"$1\");\n  arr = str.split(\"\");\n  arr = arr.map(function(val){\n    return parseInt(val);\n  })\n  return arr;\n}\n\nconsole.log(merge([3,2,2,4,5,5,6,2,1]));//[3,2,4,5,6,2,1]\n```\n\n","slug":"算法/各种算法（三）","published":1,"date":"2019-03-27T07:36:59.067Z","updated":"2019-03-27T07:39:02.515Z","layout":"post","photos":[],"link":"","_id":"cka6kinf4009lqgu9527rzd70","content":"<p>有一个字符串有很多is，写一个方法只保留一个is？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deleteIs(str)&#123;</span><br><span class=\"line\">  var index = str.search(&quot;is&quot;);</span><br><span class=\"line\">  var left = str.slice(0,index+2);</span><br><span class=\"line\">  var right = str.slice(index+2,str.length);</span><br><span class=\"line\">  right = right.split(&quot;is&quot;).join(&quot;&quot;);</span><br><span class=\"line\">  return left.concat(right);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(deleteIs(&quot;thisismybook&quot;));//thismybook</span><br></pre></td></tr></table></figure>\n<p>有3个-10-10之间的整数，写一个方法这三个数一共有多少可能相加等于10。</p>\n<p>改写数组的push方法，保持原有逻辑，添加一个console.log(arguments)，即push什么打印什么。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.push = function(val)&#123;</span><br><span class=\"line\">    console.log(val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var temp = [1,2,5];</span><br><span class=\"line\">temp.push(7);//打印7</span><br></pre></td></tr></table></figure>\n<p>传入一个无序数组，要求n数相加，获取特定的sum</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function getResult(arr,n,sum)&#123;</span><br><span class=\"line\">    if(n==0&amp;&amp;sum==0)&#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(n&lt;0)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(n&gt;0)&#123;</span><br><span class=\"line\">        for(var i in arr)&#123;</span><br><span class=\"line\">            var temp = arr.slice(i+1,arr.length);</span><br><span class=\"line\">            return getResult(temp,n-1,sum-arr[i]) || getResult(temp,n,sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(getResult([1,2,3,4],2,7)); //true</span><br></pre></td></tr></table></figure>\n<p>用正则表达式去掉两边的空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function remove(str)&#123;</span><br><span class=\"line\">  var reg = /(^\\s+)|(\\s+?)/g;</span><br><span class=\"line\">  return str.replace(reg,&quot;&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(remove(&quot;this is book&quot;));//&quot;thisisbook&quot;</span><br></pre></td></tr></table></figure>\n<p>给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getSingleNumber(arr)&#123;</span><br><span class=\"line\">  var temp = [];</span><br><span class=\"line\">  for(var i in arr)&#123;</span><br><span class=\"line\">    if(temp.indexOf(arr[i]) == -1)&#123;</span><br><span class=\"line\">      temp.push(arr[i]);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      temp.splice(temp.indexOf(arr[i]),1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return temp[0];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(getSingleNumber([0,1,0,0])); //1</span><br></pre></td></tr></table></figure>\n<p>请实现一个函数merge，传入一个数组，合并数组中【相邻且重复】的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function merge(arr)&#123;</span><br><span class=\"line\">  var reg = /(.)\\1*/g;</span><br><span class=\"line\">  var str = arr.join(&quot;&quot;);</span><br><span class=\"line\">  str = str.replace(reg,&quot;$1&quot;);</span><br><span class=\"line\">  arr = str.split(&quot;&quot;);</span><br><span class=\"line\">  arr = arr.map(function(val)&#123;</span><br><span class=\"line\">    return parseInt(val);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(merge([3,2,2,4,5,5,6,2,1]));//[3,2,4,5,6,2,1]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>有一个字符串有很多is，写一个方法只保留一个is？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deleteIs(str)&#123;</span><br><span class=\"line\">  var index = str.search(&quot;is&quot;);</span><br><span class=\"line\">  var left = str.slice(0,index+2);</span><br><span class=\"line\">  var right = str.slice(index+2,str.length);</span><br><span class=\"line\">  right = right.split(&quot;is&quot;).join(&quot;&quot;);</span><br><span class=\"line\">  return left.concat(right);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(deleteIs(&quot;thisismybook&quot;));//thismybook</span><br></pre></td></tr></table></figure>\n<p>有3个-10-10之间的整数，写一个方法这三个数一共有多少可能相加等于10。</p>\n<p>改写数组的push方法，保持原有逻辑，添加一个console.log(arguments)，即push什么打印什么。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.push = function(val)&#123;</span><br><span class=\"line\">    console.log(val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var temp = [1,2,5];</span><br><span class=\"line\">temp.push(7);//打印7</span><br></pre></td></tr></table></figure>\n<p>传入一个无序数组，要求n数相加，获取特定的sum</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function getResult(arr,n,sum)&#123;</span><br><span class=\"line\">    if(n==0&amp;&amp;sum==0)&#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(n&lt;0)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(n&gt;0)&#123;</span><br><span class=\"line\">        for(var i in arr)&#123;</span><br><span class=\"line\">            var temp = arr.slice(i+1,arr.length);</span><br><span class=\"line\">            return getResult(temp,n-1,sum-arr[i]) || getResult(temp,n,sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(getResult([1,2,3,4],2,7)); //true</span><br></pre></td></tr></table></figure>\n<p>用正则表达式去掉两边的空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function remove(str)&#123;</span><br><span class=\"line\">  var reg = /(^\\s+)|(\\s+?)/g;</span><br><span class=\"line\">  return str.replace(reg,&quot;&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(remove(&quot;this is book&quot;));//&quot;thisisbook&quot;</span><br></pre></td></tr></table></figure>\n<p>给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getSingleNumber(arr)&#123;</span><br><span class=\"line\">  var temp = [];</span><br><span class=\"line\">  for(var i in arr)&#123;</span><br><span class=\"line\">    if(temp.indexOf(arr[i]) == -1)&#123;</span><br><span class=\"line\">      temp.push(arr[i]);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      temp.splice(temp.indexOf(arr[i]),1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return temp[0];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(getSingleNumber([0,1,0,0])); //1</span><br></pre></td></tr></table></figure>\n<p>请实现一个函数merge，传入一个数组，合并数组中【相邻且重复】的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function merge(arr)&#123;</span><br><span class=\"line\">  var reg = /(.)\\1*/g;</span><br><span class=\"line\">  var str = arr.join(&quot;&quot;);</span><br><span class=\"line\">  str = str.replace(reg,&quot;$1&quot;);</span><br><span class=\"line\">  arr = str.split(&quot;&quot;);</span><br><span class=\"line\">  arr = arr.map(function(val)&#123;</span><br><span class=\"line\">    return parseInt(val);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(merge([3,2,2,4,5,5,6,2,1]));//[3,2,4,5,6,2,1]</span><br></pre></td></tr></table></figure>\n"},{"title":"算法：两数相加为0","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n## 2数相加为0\n### 题目\n给定一个不重复的数字数组，找出该数组中两个数之和等于0的所有情况。\n\n### 测试用例\n\n```\n1. [1,2,3,-1] // [[1,-1]]\n2. [1,2,3,-3,-1] // [[1,1],[3,-3]]\n```\n\n### 解法\n#### 思路\n- 数组长度少于2则直接返回\n- 取数组首元素，与剩余元素比较是否相加为0，若为0取该值，拼接为数组，否则undefined\n- 递归剩余元素，将得到的返回值拼接，对于undefined的值不拼接\n\n#### 算法\n\n```\n/**\n * @param {array} arr\n * @return {array}\n */\nvar addUpToZero = function (arr) {\n    if(arr.length < 2) {\n        return;\n    }\n    var left = arr.splice(0,1)[0];\n    var right, res;\n    for(let i in arr) {\n    if(left + arr[i] === 0) {\n        right = arr.splice(i,1)[0];\n    }\n    }\n    if(right) {\n        res = [left, right];\n    }\n    var next = test(arr);\n    if(res && next){\n        return [res].concat(next);\n    } else if (res) {\n        return [res];\n    } else if (next) {\n        return next;\n    }\n}\n```\n## n数相加为sum\n### 题目\n给定一个无序数组，找出该数组中n个数之和等于0的所有情况。\n\n### 测试用例\n\n```\n1. [1,2,3,-3,-1],2 // [[1,-1],[3,-3]\n2. [1,2,0,-1],3 // [[1,0,-1]]\n```\n\n### 解法\n#### 思路\n\n\n#### 算法\n\n```\n\n```\n","source":"_posts/算法/算法：两数相加为0.md","raw":"---\ntitle: 算法：两数相加为0\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n## 2数相加为0\n### 题目\n给定一个不重复的数字数组，找出该数组中两个数之和等于0的所有情况。\n\n### 测试用例\n\n```\n1. [1,2,3,-1] // [[1,-1]]\n2. [1,2,3,-3,-1] // [[1,1],[3,-3]]\n```\n\n### 解法\n#### 思路\n- 数组长度少于2则直接返回\n- 取数组首元素，与剩余元素比较是否相加为0，若为0取该值，拼接为数组，否则undefined\n- 递归剩余元素，将得到的返回值拼接，对于undefined的值不拼接\n\n#### 算法\n\n```\n/**\n * @param {array} arr\n * @return {array}\n */\nvar addUpToZero = function (arr) {\n    if(arr.length < 2) {\n        return;\n    }\n    var left = arr.splice(0,1)[0];\n    var right, res;\n    for(let i in arr) {\n    if(left + arr[i] === 0) {\n        right = arr.splice(i,1)[0];\n    }\n    }\n    if(right) {\n        res = [left, right];\n    }\n    var next = test(arr);\n    if(res && next){\n        return [res].concat(next);\n    } else if (res) {\n        return [res];\n    } else if (next) {\n        return next;\n    }\n}\n```\n## n数相加为sum\n### 题目\n给定一个无序数组，找出该数组中n个数之和等于0的所有情况。\n\n### 测试用例\n\n```\n1. [1,2,3,-3,-1],2 // [[1,-1],[3,-3]\n2. [1,2,0,-1],3 // [[1,0,-1]]\n```\n\n### 解法\n#### 思路\n\n\n#### 算法\n\n```\n\n```\n","slug":"算法/算法：两数相加为0","published":1,"date":"2020-03-17T09:04:01.982Z","updated":"2020-03-17T09:10:04.134Z","layout":"post","photos":[],"link":"","_id":"cka6kinfa009nqgu99ou97fqf","content":"<h2 id=\"2数相加为0\"><a href=\"#2数相加为0\" class=\"headerlink\" title=\"2数相加为0\"></a>2数相加为0</h2><h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个不重复的数字数组，找出该数组中两个数之和等于0的所有情况。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. [1,2,3,-1] // [[1,-1]]</span><br><span class=\"line\">2. [1,2,3,-3,-1] // [[1,1],[3,-3]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>数组长度少于2则直接返回</li>\n<li>取数组首元素，与剩余元素比较是否相加为0，若为0取该值，拼接为数组，否则undefined</li>\n<li>递归剩余元素，将得到的返回值拼接，对于undefined的值不拼接</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;array&#125; arr</span><br><span class=\"line\"> * @return &#123;array&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var addUpToZero = function (arr) &#123;</span><br><span class=\"line\">    if(arr.length &lt; 2) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var left = arr.splice(0,1)[0];</span><br><span class=\"line\">    var right, res;</span><br><span class=\"line\">    for(let i in arr) &#123;</span><br><span class=\"line\">    if(left + arr[i] === 0) &#123;</span><br><span class=\"line\">        right = arr.splice(i,1)[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(right) &#123;</span><br><span class=\"line\">        res = [left, right];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var next = test(arr);</span><br><span class=\"line\">    if(res &amp;&amp; next)&#123;</span><br><span class=\"line\">        return [res].concat(next);</span><br><span class=\"line\">    &#125; else if (res) &#123;</span><br><span class=\"line\">        return [res];</span><br><span class=\"line\">    &#125; else if (next) &#123;</span><br><span class=\"line\">        return next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"n数相加为sum\"><a href=\"#n数相加为sum\" class=\"headerlink\" title=\"n数相加为sum\"></a>n数相加为sum</h2><h3 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个无序数组，找出该数组中n个数之和等于0的所有情况。</p>\n<h3 id=\"测试用例-1\"><a href=\"#测试用例-1\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. [1,2,3,-3,-1],2 // [[1,-1],[3,-3]</span><br><span class=\"line\">2. [1,2,0,-1],3 // [[1,0,-1]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法-1\"><a href=\"#解法-1\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><h4 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2数相加为0\"><a href=\"#2数相加为0\" class=\"headerlink\" title=\"2数相加为0\"></a>2数相加为0</h2><h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个不重复的数字数组，找出该数组中两个数之和等于0的所有情况。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. [1,2,3,-1] // [[1,-1]]</span><br><span class=\"line\">2. [1,2,3,-3,-1] // [[1,1],[3,-3]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>数组长度少于2则直接返回</li>\n<li>取数组首元素，与剩余元素比较是否相加为0，若为0取该值，拼接为数组，否则undefined</li>\n<li>递归剩余元素，将得到的返回值拼接，对于undefined的值不拼接</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;array&#125; arr</span><br><span class=\"line\"> * @return &#123;array&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var addUpToZero = function (arr) &#123;</span><br><span class=\"line\">    if(arr.length &lt; 2) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var left = arr.splice(0,1)[0];</span><br><span class=\"line\">    var right, res;</span><br><span class=\"line\">    for(let i in arr) &#123;</span><br><span class=\"line\">    if(left + arr[i] === 0) &#123;</span><br><span class=\"line\">        right = arr.splice(i,1)[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(right) &#123;</span><br><span class=\"line\">        res = [left, right];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var next = test(arr);</span><br><span class=\"line\">    if(res &amp;&amp; next)&#123;</span><br><span class=\"line\">        return [res].concat(next);</span><br><span class=\"line\">    &#125; else if (res) &#123;</span><br><span class=\"line\">        return [res];</span><br><span class=\"line\">    &#125; else if (next) &#123;</span><br><span class=\"line\">        return next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"n数相加为sum\"><a href=\"#n数相加为sum\" class=\"headerlink\" title=\"n数相加为sum\"></a>n数相加为sum</h2><h3 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个无序数组，找出该数组中n个数之和等于0的所有情况。</p>\n<h3 id=\"测试用例-1\"><a href=\"#测试用例-1\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. [1,2,3,-3,-1],2 // [[1,-1],[3,-3]</span><br><span class=\"line\">2. [1,2,0,-1],3 // [[1,0,-1]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法-1\"><a href=\"#解法-1\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><h4 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"算法：二分查找","Date":"2019-04-22T16:00:00.000Z","comments":1,"_content":"\n二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。\n1. 首先，从有序数组的中间的元素开始搜索， 如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。\n2. 如果目标元素大于或者小于中间元素， 则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。\n3. 如果某一步数组为空，则表示找不到目标元素。 \n\n```\nfunction search(arr,key){\n    var low = 0;\n    var high = arr.length-1;\n    while(low <= high){\n        var mid = parseInt((low+high)/2);\n        if(key == arr[mid]){\n            return mid;\n        }else if(key < arr[mid]){\n            high = mid-1;\n        }else if(key > arr[mid]){\n            low = mid+1;\n        }else{\n            return -1;\n        }\n    }\n}\n\nconsole.log(search([0,1,2,3,5,6,7],5));//4\nconsole.log(search([0,1,2,3,5,6,7],4));//undefined\n```\n","source":"_posts/算法/算法：二分查找.md","raw":"---\ntitle: 算法：二分查找\nDate: 2019-04-23\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。\n1. 首先，从有序数组的中间的元素开始搜索， 如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。\n2. 如果目标元素大于或者小于中间元素， 则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。\n3. 如果某一步数组为空，则表示找不到目标元素。 \n\n```\nfunction search(arr,key){\n    var low = 0;\n    var high = arr.length-1;\n    while(low <= high){\n        var mid = parseInt((low+high)/2);\n        if(key == arr[mid]){\n            return mid;\n        }else if(key < arr[mid]){\n            high = mid-1;\n        }else if(key > arr[mid]){\n            low = mid+1;\n        }else{\n            return -1;\n        }\n    }\n}\n\nconsole.log(search([0,1,2,3,5,6,7],5));//4\nconsole.log(search([0,1,2,3,5,6,7],4));//undefined\n```\n","slug":"算法/算法：二分查找","published":1,"date":"2019-04-23T14:19:01.129Z","updated":"2019-04-23T14:21:38.334Z","layout":"post","photos":[],"link":"","_id":"cka6kinfh009rqgu9b6j7delb","content":"<p>二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。</p>\n<ol>\n<li>首先，从有序数组的中间的元素开始搜索， 如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。</li>\n<li>如果目标元素大于或者小于中间元素， 则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。</li>\n<li>如果某一步数组为空，则表示找不到目标元素。 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function search(arr,key)&#123;</span><br><span class=\"line\">    var low = 0;</span><br><span class=\"line\">    var high = arr.length-1;</span><br><span class=\"line\">    while(low &lt;= high)&#123;</span><br><span class=\"line\">        var mid = parseInt((low+high)/2);</span><br><span class=\"line\">        if(key == arr[mid])&#123;</span><br><span class=\"line\">            return mid;</span><br><span class=\"line\">        &#125;else if(key &lt; arr[mid])&#123;</span><br><span class=\"line\">            high = mid-1;</span><br><span class=\"line\">        &#125;else if(key &gt; arr[mid])&#123;</span><br><span class=\"line\">            low = mid+1;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(search([0,1,2,3,5,6,7],5));//4</span><br><span class=\"line\">console.log(search([0,1,2,3,5,6,7],4));//undefined</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。</p>\n<ol>\n<li>首先，从有序数组的中间的元素开始搜索， 如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。</li>\n<li>如果目标元素大于或者小于中间元素， 则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。</li>\n<li>如果某一步数组为空，则表示找不到目标元素。 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function search(arr,key)&#123;</span><br><span class=\"line\">    var low = 0;</span><br><span class=\"line\">    var high = arr.length-1;</span><br><span class=\"line\">    while(low &lt;= high)&#123;</span><br><span class=\"line\">        var mid = parseInt((low+high)/2);</span><br><span class=\"line\">        if(key == arr[mid])&#123;</span><br><span class=\"line\">            return mid;</span><br><span class=\"line\">        &#125;else if(key &lt; arr[mid])&#123;</span><br><span class=\"line\">            high = mid-1;</span><br><span class=\"line\">        &#125;else if(key &gt; arr[mid])&#123;</span><br><span class=\"line\">            low = mid+1;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(search([0,1,2,3,5,6,7],5));//4</span><br><span class=\"line\">console.log(search([0,1,2,3,5,6,7],4));//undefined</span><br></pre></td></tr></table></figure>\n"},{"title":"算法：二进制转十进制","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### 解法一\n按权相加\n```\nfunction toDecimal(str){\n  var res = 0;\n  for(var i=str.length-1;i>=0;i--){\n    res = str[i]==='1' ? Math.pow(2,str.length-1-i) + res : res;\n  }\n  return res;\n}\n```\n\n```\nfunction toDecimal(str){\n  var res = 0;\n  var temp = 1;\n  for(var i=str.length-1;i>=0;i--){\n      res = str[i]==='1' ? res + temp : res;\n      temp *= 2;\n  }\n  return res;\n}\n```\n### 解法二\nparseInt 的第二个参数表示要解析的数字的基数\n```\nfunction toDecimal(str){\n  return parseInt(str,2);\n}\n```\n","source":"_posts/算法/算法：二进制转十进制.md","raw":"---\ntitle: 算法：二进制转十进制\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n### 解法一\n按权相加\n```\nfunction toDecimal(str){\n  var res = 0;\n  for(var i=str.length-1;i>=0;i--){\n    res = str[i]==='1' ? Math.pow(2,str.length-1-i) + res : res;\n  }\n  return res;\n}\n```\n\n```\nfunction toDecimal(str){\n  var res = 0;\n  var temp = 1;\n  for(var i=str.length-1;i>=0;i--){\n      res = str[i]==='1' ? res + temp : res;\n      temp *= 2;\n  }\n  return res;\n}\n```\n### 解法二\nparseInt 的第二个参数表示要解析的数字的基数\n```\nfunction toDecimal(str){\n  return parseInt(str,2);\n}\n```\n","slug":"算法/算法：二进制转十进制","published":1,"date":"2020-03-17T09:04:12.669Z","updated":"2020-03-17T09:12:21.563Z","layout":"post","photos":[],"link":"","_id":"cka6kinfo009tqgu9ytdqn7v3","content":"<h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><p>按权相加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toDecimal(str)&#123;</span><br><span class=\"line\">  var res = 0;</span><br><span class=\"line\">  for(var i=str.length-1;i&gt;=0;i--)&#123;</span><br><span class=\"line\">    res = str[i]===&apos;1&apos; ? Math.pow(2,str.length-1-i) + res : res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toDecimal(str)&#123;</span><br><span class=\"line\">  var res = 0;</span><br><span class=\"line\">  var temp = 1;</span><br><span class=\"line\">  for(var i=str.length-1;i&gt;=0;i--)&#123;</span><br><span class=\"line\">      res = str[i]===&apos;1&apos; ? res + temp : res;</span><br><span class=\"line\">      temp *= 2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><p>parseInt 的第二个参数表示要解析的数字的基数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toDecimal(str)&#123;</span><br><span class=\"line\">  return parseInt(str,2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><p>按权相加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toDecimal(str)&#123;</span><br><span class=\"line\">  var res = 0;</span><br><span class=\"line\">  for(var i=str.length-1;i&gt;=0;i--)&#123;</span><br><span class=\"line\">    res = str[i]===&apos;1&apos; ? Math.pow(2,str.length-1-i) + res : res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toDecimal(str)&#123;</span><br><span class=\"line\">  var res = 0;</span><br><span class=\"line\">  var temp = 1;</span><br><span class=\"line\">  for(var i=str.length-1;i&gt;=0;i--)&#123;</span><br><span class=\"line\">      res = str[i]===&apos;1&apos; ? res + temp : res;</span><br><span class=\"line\">      temp *= 2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><p>parseInt 的第二个参数表示要解析的数字的基数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toDecimal(str)&#123;</span><br><span class=\"line\">  return parseInt(str,2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法：多层数组转化为一层","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### 题目\n给定一个数组，将多层数组转化为一层。\n\n注意，数组元素不一定是数字，有可能为对象或字符串。\n\n### 测试用例\n\n```\n1. ['1',[2,3],-1] // ['1',2,3,-1]\n2. ['1',[2,3],{a:-1}] // ['1',2,3,{a:-1}]\n```\n\n### 解法\n#### 思路\n- 遍历数组，取出元素放入新数组，若元素为数组则递归取出\n\n#### 算法\n\n```\n/**\n * @param {array} arr\n * @param {array} res\n * @return {array}\n */\nvar flatten = function (arr, res) {\n   for(let i in arr) {\n    if(arr[i] instanceof Array) {\n      test(arr[i],res)\n    } else {\n      res.push(arr[i]);\n    }\n  }\n  return res;\n}\n```","source":"_posts/算法/算法：多层数组转化为一层.md","raw":"---\ntitle: 算法：多层数组转化为一层\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n### 题目\n给定一个数组，将多层数组转化为一层。\n\n注意，数组元素不一定是数字，有可能为对象或字符串。\n\n### 测试用例\n\n```\n1. ['1',[2,3],-1] // ['1',2,3,-1]\n2. ['1',[2,3],{a:-1}] // ['1',2,3,{a:-1}]\n```\n\n### 解法\n#### 思路\n- 遍历数组，取出元素放入新数组，若元素为数组则递归取出\n\n#### 算法\n\n```\n/**\n * @param {array} arr\n * @param {array} res\n * @return {array}\n */\nvar flatten = function (arr, res) {\n   for(let i in arr) {\n    if(arr[i] instanceof Array) {\n      test(arr[i],res)\n    } else {\n      res.push(arr[i]);\n    }\n  }\n  return res;\n}\n```","slug":"算法/算法：多层数组转化为一层","published":1,"date":"2020-03-17T09:04:07.700Z","updated":"2020-03-17T09:09:41.764Z","layout":"post","photos":[],"link":"","_id":"cka6kinfv009xqgu917ykgk69","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个数组，将多层数组转化为一层。</p>\n<p>注意，数组元素不一定是数字，有可能为对象或字符串。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. [&apos;1&apos;,[2,3],-1] // [&apos;1&apos;,2,3,-1]</span><br><span class=\"line\">2. [&apos;1&apos;,[2,3],&#123;a:-1&#125;] // [&apos;1&apos;,2,3,&#123;a:-1&#125;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>遍历数组，取出元素放入新数组，若元素为数组则递归取出</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;array&#125; arr</span><br><span class=\"line\"> * @param &#123;array&#125; res</span><br><span class=\"line\"> * @return &#123;array&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var flatten = function (arr, res) &#123;</span><br><span class=\"line\">   for(let i in arr) &#123;</span><br><span class=\"line\">    if(arr[i] instanceof Array) &#123;</span><br><span class=\"line\">      test(arr[i],res)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      res.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个数组，将多层数组转化为一层。</p>\n<p>注意，数组元素不一定是数字，有可能为对象或字符串。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. [&apos;1&apos;,[2,3],-1] // [&apos;1&apos;,2,3,-1]</span><br><span class=\"line\">2. [&apos;1&apos;,[2,3],&#123;a:-1&#125;] // [&apos;1&apos;,2,3,&#123;a:-1&#125;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>遍历数组，取出元素放入新数组，若元素为数组则递归取出</li>\n</ul>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;array&#125; arr</span><br><span class=\"line\"> * @param &#123;array&#125; res</span><br><span class=\"line\"> * @return &#123;array&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var flatten = function (arr, res) &#123;</span><br><span class=\"line\">   for(let i in arr) &#123;</span><br><span class=\"line\">    if(arr[i] instanceof Array) &#123;</span><br><span class=\"line\">      test(arr[i],res)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      res.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"算法：如何找出单链表中的倒数第k个元素","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n1. 首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。\n\n\n2. 优化：设置两个指针p1和p2，p1在p2前，两者相差k-1个节点，当p1指向null时，p2刚好指向目标元素。\n","source":"_posts/算法/算法：如何找出单链表中的倒数第k个元素.md","raw":"---\ntitle: 算法：如何找出单链表中的倒数第k个元素\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n1. 首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。\n\n\n2. 优化：设置两个指针p1和p2，p1在p2前，两者相差k-1个节点，当p1指向null时，p2刚好指向目标元素。\n","slug":"算法/算法：如何找出单链表中的倒数第k个元素","published":1,"date":"2020-03-17T09:03:40.379Z","updated":"2020-03-17T09:11:38.924Z","layout":"post","photos":[],"link":"","_id":"cka6king1009zqgu9juxmw86r","content":"<ol>\n<li>首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。</li>\n</ol>\n<ol start=\"2\">\n<li>优化：设置两个指针p1和p2，p1在p2前，两者相差k-1个节点，当p1指向null时，p2刚好指向目标元素。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。</li>\n</ol>\n<ol start=\"2\">\n<li>优化：设置两个指针p1和p2，p1在p2前，两者相差k-1个节点，当p1指向null时，p2刚好指向目标元素。</li>\n</ol>\n"},{"title":"算法：快速排序","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n排序分为交换排序、选择排序、插入排序、归并排序、基数排序   \n快速排序和冒泡排序数据交换排序\n\n首先，定义一个quickSort函数，它的参数是一个数组。\n\n```\nfunction quickSort(arr){\n    \n}\n```\n\n然后，检查数组的元素个数，如果小于等于1，就返回。\n\n```\nfunction quickSort(arr){\n    if(arr.length<=1){\n        return arr;\n    }\n}\n```\n\n接着，选择\"基准\"（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。\n\n```\nfunction quickSort(arr){\n    if(arr.length<=1){\n        return arr;\n    }\n    var pivotIndex = Math.floor(arr.length/2);\n    var pivot = arr.splice(pivotIndex,1)[0];\n    var left = [];\n    var right = [];\n}\n```\n\n然后，开始遍历数组，小于\"基准\"的元素放入左边的子集，大于等于基准的元素放入右边的子集。\n\n```\nfunction quickSort(arr){\n    if(arr.length<=1){\n        return arr;\n    }\n    var pivotIndex = Math.floor(arr.length/2);\n    var pivot = arr.splice(pivotIndex,1)[0];\n    var left = [];\n    var right = [];\n    for(var i in arr){\n        if(arr[i] < pivot){\n            left.push(arr[i]);\n        }else{\n            right.push(arr[i]);\n        }\n    }\n}\n```\n\n最后，使用递归不断重复这个过程，就可以得到排序后的数组。\n```\nfunction quickSort(arr){\n    if(arr.length<=1){\n        return arr;\n    }\n    var pivotIndex = Math.floor(arr.length/2);\n    var pivot = arr.splice(pivotIndex,1)[0];\n    var left = [];\n    var right = [];\n    for(var i in arr){\n        if(arr[i] < pivot){\n            left.push(arr[i]);\n        }else{\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat([pivot],quickSort(right));\n}\n```\n\n> 优化：选一个好的基准：随机选取三个数，排序取中\n\n> 时间复杂度：nlogn","source":"_posts/算法/算法：快速排序.md","raw":"---\ntitle: 算法：快速排序\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n排序分为交换排序、选择排序、插入排序、归并排序、基数排序   \n快速排序和冒泡排序数据交换排序\n\n首先，定义一个quickSort函数，它的参数是一个数组。\n\n```\nfunction quickSort(arr){\n    \n}\n```\n\n然后，检查数组的元素个数，如果小于等于1，就返回。\n\n```\nfunction quickSort(arr){\n    if(arr.length<=1){\n        return arr;\n    }\n}\n```\n\n接着，选择\"基准\"（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。\n\n```\nfunction quickSort(arr){\n    if(arr.length<=1){\n        return arr;\n    }\n    var pivotIndex = Math.floor(arr.length/2);\n    var pivot = arr.splice(pivotIndex,1)[0];\n    var left = [];\n    var right = [];\n}\n```\n\n然后，开始遍历数组，小于\"基准\"的元素放入左边的子集，大于等于基准的元素放入右边的子集。\n\n```\nfunction quickSort(arr){\n    if(arr.length<=1){\n        return arr;\n    }\n    var pivotIndex = Math.floor(arr.length/2);\n    var pivot = arr.splice(pivotIndex,1)[0];\n    var left = [];\n    var right = [];\n    for(var i in arr){\n        if(arr[i] < pivot){\n            left.push(arr[i]);\n        }else{\n            right.push(arr[i]);\n        }\n    }\n}\n```\n\n最后，使用递归不断重复这个过程，就可以得到排序后的数组。\n```\nfunction quickSort(arr){\n    if(arr.length<=1){\n        return arr;\n    }\n    var pivotIndex = Math.floor(arr.length/2);\n    var pivot = arr.splice(pivotIndex,1)[0];\n    var left = [];\n    var right = [];\n    for(var i in arr){\n        if(arr[i] < pivot){\n            left.push(arr[i]);\n        }else{\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat([pivot],quickSort(right));\n}\n```\n\n> 优化：选一个好的基准：随机选取三个数，排序取中\n\n> 时间复杂度：nlogn","slug":"算法/算法：快速排序","published":1,"date":"2020-03-17T09:03:21.984Z","updated":"2020-03-17T09:08:49.113Z","layout":"post","photos":[],"link":"","_id":"cka6kingc00a3qgu91skbs184","content":"<p>排序分为交换排序、选择排序、插入排序、归并排序、基数排序<br>快速排序和冒泡排序数据交换排序</p>\n<p>首先，定义一个quickSort函数，它的参数是一个数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，检查数组的元素个数，如果小于等于1，就返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length&lt;=1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length&lt;=1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class=\"line\">    var pivot = arr.splice(pivotIndex,1)[0];</span><br><span class=\"line\">    var left = [];</span><br><span class=\"line\">    var right = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于等于基准的元素放入右边的子集。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length&lt;=1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class=\"line\">    var pivot = arr.splice(pivotIndex,1)[0];</span><br><span class=\"line\">    var left = [];</span><br><span class=\"line\">    var right = [];</span><br><span class=\"line\">    for(var i in arr)&#123;</span><br><span class=\"line\">        if(arr[i] &lt; pivot)&#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，使用递归不断重复这个过程，就可以得到排序后的数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length&lt;=1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class=\"line\">    var pivot = arr.splice(pivotIndex,1)[0];</span><br><span class=\"line\">    var left = [];</span><br><span class=\"line\">    var right = [];</span><br><span class=\"line\">    for(var i in arr)&#123;</span><br><span class=\"line\">        if(arr[i] &lt; pivot)&#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return quickSort(left).concat([pivot],quickSort(right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>优化：选一个好的基准：随机选取三个数，排序取中</p>\n</blockquote>\n<blockquote>\n<p>时间复杂度：nlogn</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>排序分为交换排序、选择排序、插入排序、归并排序、基数排序<br>快速排序和冒泡排序数据交换排序</p>\n<p>首先，定义一个quickSort函数，它的参数是一个数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，检查数组的元素个数，如果小于等于1，就返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length&lt;=1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length&lt;=1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class=\"line\">    var pivot = arr.splice(pivotIndex,1)[0];</span><br><span class=\"line\">    var left = [];</span><br><span class=\"line\">    var right = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于等于基准的元素放入右边的子集。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length&lt;=1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class=\"line\">    var pivot = arr.splice(pivotIndex,1)[0];</span><br><span class=\"line\">    var left = [];</span><br><span class=\"line\">    var right = [];</span><br><span class=\"line\">    for(var i in arr)&#123;</span><br><span class=\"line\">        if(arr[i] &lt; pivot)&#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，使用递归不断重复这个过程，就可以得到排序后的数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr)&#123;</span><br><span class=\"line\">    if(arr.length&lt;=1)&#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class=\"line\">    var pivot = arr.splice(pivotIndex,1)[0];</span><br><span class=\"line\">    var left = [];</span><br><span class=\"line\">    var right = [];</span><br><span class=\"line\">    for(var i in arr)&#123;</span><br><span class=\"line\">        if(arr[i] &lt; pivot)&#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return quickSort(left).concat([pivot],quickSort(right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>优化：选一个好的基准：随机选取三个数，排序取中</p>\n</blockquote>\n<blockquote>\n<p>时间复杂度：nlogn</p>\n</blockquote>\n"},{"title":"算法：把十六进制的ip地址转换为十进制的","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n```\nfunction change(ip){\n  var temp = [];\n\tfor(var i=0;i<ip.length;i+=2){\n      temp.push(ip.substr(i,2))\n    }\n  return temp.map(function(value){\n    return parseInt(value,16);\n  }).join(\".\");\n}\nconsole.log(change(\"C0A80000\")); //\"192.168.0.0\"\n```\n拓展\n\n```\n在ip地址中，8位二进制取一个.\n且二进制的4位对应十六进制的1位\n因此\n8位二进制对应一个十进制整数\n2位十六进制对应一个十进制整数\n```\n","source":"_posts/算法/算法：把十六进制的ip地址转换为十进制的.md","raw":"---\ntitle: 算法：把十六进制的ip地址转换为十进制的\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n```\nfunction change(ip){\n  var temp = [];\n\tfor(var i=0;i<ip.length;i+=2){\n      temp.push(ip.substr(i,2))\n    }\n  return temp.map(function(value){\n    return parseInt(value,16);\n  }).join(\".\");\n}\nconsole.log(change(\"C0A80000\")); //\"192.168.0.0\"\n```\n拓展\n\n```\n在ip地址中，8位二进制取一个.\n且二进制的4位对应十六进制的1位\n因此\n8位二进制对应一个十进制整数\n2位十六进制对应一个十进制整数\n```\n","slug":"算法/算法：把十六进制的ip地址转换为十进制的","published":1,"date":"2020-03-17T09:03:28.211Z","updated":"2020-03-17T09:09:14.117Z","layout":"post","photos":[],"link":"","_id":"cka6kingj00a5qgu9r9uub0bl","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function change(ip)&#123;</span><br><span class=\"line\">  var temp = [];</span><br><span class=\"line\">\tfor(var i=0;i&lt;ip.length;i+=2)&#123;</span><br><span class=\"line\">      temp.push(ip.substr(i,2))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  return temp.map(function(value)&#123;</span><br><span class=\"line\">    return parseInt(value,16);</span><br><span class=\"line\">  &#125;).join(&quot;.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(change(&quot;C0A80000&quot;)); //&quot;192.168.0.0&quot;</span><br></pre></td></tr></table></figure>\n<p>拓展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在ip地址中，8位二进制取一个.</span><br><span class=\"line\">且二进制的4位对应十六进制的1位</span><br><span class=\"line\">因此</span><br><span class=\"line\">8位二进制对应一个十进制整数</span><br><span class=\"line\">2位十六进制对应一个十进制整数</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function change(ip)&#123;</span><br><span class=\"line\">  var temp = [];</span><br><span class=\"line\">\tfor(var i=0;i&lt;ip.length;i+=2)&#123;</span><br><span class=\"line\">      temp.push(ip.substr(i,2))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  return temp.map(function(value)&#123;</span><br><span class=\"line\">    return parseInt(value,16);</span><br><span class=\"line\">  &#125;).join(&quot;.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(change(&quot;C0A80000&quot;)); //&quot;192.168.0.0&quot;</span><br></pre></td></tr></table></figure>\n<p>拓展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在ip地址中，8位二进制取一个.</span><br><span class=\"line\">且二进制的4位对应十六进制的1位</span><br><span class=\"line\">因此</span><br><span class=\"line\">8位二进制对应一个十进制整数</span><br><span class=\"line\">2位十六进制对应一个十进制整数</span><br></pre></td></tr></table></figure>\n"},{"title":"算法：青蛙跳台阶和斐波那契数列","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n### 简单\n一次跳一层或两层，求跳上一个n级的台阶总共有多少种跳法。     \n因为n级台阶，第一步有n种跳法：跳1级、跳2级    \n跳1级，剩下n-1级，则剩下跳法是f(n-1)    \n跳2级，剩下n-2级，则剩下跳法是f(n-2)   \n\nf(0)=0    \nf(1)=1    \nf(2)=2   \nf(n)=f(n-1)+f(n-2)\n\n```\nfunction jump(n){\n    if(n==0){\n        return 0;\n    }else if(n==1){\n        return 1;\n    }else if(n==2){\n        return 2;\n    }else{\n        return jump(n-1)+jump(n-2);\n    }\n}\n```\n### 复杂\n一次可以跳上1级台阶，也可以跳上2级……也可以跳上n级。求跳上一个n级的台阶总共有多少种跳法。     \n因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级     \n跳1级，剩下n-1级，则剩下跳法是f(n-1)    \n跳2级，剩下n-2级，则剩下跳法是f(n-2)    \n所以f(n)=f(n-1)+f(n-2)+...+f(1)    \n因为f(n-1)=f(n-2)+f(n-3)+...+f(1)    \n所以f(n)=2*f(n-1) \n\n```\nfunction jumpII(number)\n{\n    if(number == 0){\n        return 0;\n    }else if(number == 1){\n        return 1;\n    }\n    return 2*jumpII(number-1)\n}\n```\n\n\n### 斐波那契数列\n斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……\n#### 性能优化之缓存\n- 缓存: 存储数据的容器(cache)\n- 在js中, 可以使用数组或者是对象进行存储数据,用键存储值,这样就可以实现既能存值也能取值\n\n#### 用缓存的基本思路\n1. 创建一个空对象，作为缓存的容器。\n2. 首先去缓存容器中查看缓存中是否有对应的数据，如果有，直接取出来使用。\n3. 如果没有，就先计算结果，然后把结果存储到缓存容器中，方便下次复用。\n```\nvar cache = { };\nvar count = 0;\nfunction fib(n){\n    count++;\n    if(n === 1 || n === 2){\n        return 1;\n    }\n    if(cache[n]){\n        return cache[n];\n    }else{\n        var ret = fib(n - 1) + fib(n - 2);\n        cache[n] = ret;\n        return ret;\n    }\n}\n\nconsole.log(fib(10));\nconsole.log(\"fib函数调用的次数 \" + count);\n```\n#### 总结\n- 缓存: 存数据(该案例中,用键存月份,值存的对数)\n- 在js中,缓存中如何表示, 对象 || 数组\n\n","source":"_posts/算法/算法：青蛙跳台阶和斐波那契数列.md","raw":"---\ntitle: 算法：青蛙跳台阶和斐波那契数列\nDate: 2020-03-17\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n### 简单\n一次跳一层或两层，求跳上一个n级的台阶总共有多少种跳法。     \n因为n级台阶，第一步有n种跳法：跳1级、跳2级    \n跳1级，剩下n-1级，则剩下跳法是f(n-1)    \n跳2级，剩下n-2级，则剩下跳法是f(n-2)   \n\nf(0)=0    \nf(1)=1    \nf(2)=2   \nf(n)=f(n-1)+f(n-2)\n\n```\nfunction jump(n){\n    if(n==0){\n        return 0;\n    }else if(n==1){\n        return 1;\n    }else if(n==2){\n        return 2;\n    }else{\n        return jump(n-1)+jump(n-2);\n    }\n}\n```\n### 复杂\n一次可以跳上1级台阶，也可以跳上2级……也可以跳上n级。求跳上一个n级的台阶总共有多少种跳法。     \n因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级     \n跳1级，剩下n-1级，则剩下跳法是f(n-1)    \n跳2级，剩下n-2级，则剩下跳法是f(n-2)    \n所以f(n)=f(n-1)+f(n-2)+...+f(1)    \n因为f(n-1)=f(n-2)+f(n-3)+...+f(1)    \n所以f(n)=2*f(n-1) \n\n```\nfunction jumpII(number)\n{\n    if(number == 0){\n        return 0;\n    }else if(number == 1){\n        return 1;\n    }\n    return 2*jumpII(number-1)\n}\n```\n\n\n### 斐波那契数列\n斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……\n#### 性能优化之缓存\n- 缓存: 存储数据的容器(cache)\n- 在js中, 可以使用数组或者是对象进行存储数据,用键存储值,这样就可以实现既能存值也能取值\n\n#### 用缓存的基本思路\n1. 创建一个空对象，作为缓存的容器。\n2. 首先去缓存容器中查看缓存中是否有对应的数据，如果有，直接取出来使用。\n3. 如果没有，就先计算结果，然后把结果存储到缓存容器中，方便下次复用。\n```\nvar cache = { };\nvar count = 0;\nfunction fib(n){\n    count++;\n    if(n === 1 || n === 2){\n        return 1;\n    }\n    if(cache[n]){\n        return cache[n];\n    }else{\n        var ret = fib(n - 1) + fib(n - 2);\n        cache[n] = ret;\n        return ret;\n    }\n}\n\nconsole.log(fib(10));\nconsole.log(\"fib函数调用的次数 \" + count);\n```\n#### 总结\n- 缓存: 存数据(该案例中,用键存月份,值存的对数)\n- 在js中,缓存中如何表示, 对象 || 数组\n\n","slug":"算法/算法：青蛙跳台阶和斐波那契数列","published":1,"date":"2020-03-17T09:07:29.276Z","updated":"2020-03-17T09:12:19.809Z","layout":"post","photos":[],"link":"","_id":"cka6kingq00a9qgu9kn50g6nw","content":"<h3 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a>简单</h3><p>一次跳一层或两层，求跳上一个n级的台阶总共有多少种跳法。<br>因为n级台阶，第一步有n种跳法：跳1级、跳2级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)   </p>\n<p>f(0)=0<br>f(1)=1<br>f(2)=2<br>f(n)=f(n-1)+f(n-2)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jump(n)&#123;</span><br><span class=\"line\">    if(n==0)&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;else if(n==1)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;else if(n==2)&#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return jump(n-1)+jump(n-2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂\"><a href=\"#复杂\" class=\"headerlink\" title=\"复杂\"></a>复杂</h3><p>一次可以跳上1级台阶，也可以跳上2级……也可以跳上n级。求跳上一个n级的台阶总共有多少种跳法。<br>因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)+…+f(1)<br>因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>所以f(n)=2*f(n-1) </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jumpII(number)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(number == 0)&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;else if(number == 1)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 2*jumpII(number-1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h3><p>斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p>\n<h4 id=\"性能优化之缓存\"><a href=\"#性能优化之缓存\" class=\"headerlink\" title=\"性能优化之缓存\"></a>性能优化之缓存</h4><ul>\n<li>缓存: 存储数据的容器(cache)</li>\n<li>在js中, 可以使用数组或者是对象进行存储数据,用键存储值,这样就可以实现既能存值也能取值</li>\n</ul>\n<h4 id=\"用缓存的基本思路\"><a href=\"#用缓存的基本思路\" class=\"headerlink\" title=\"用缓存的基本思路\"></a>用缓存的基本思路</h4><ol>\n<li>创建一个空对象，作为缓存的容器。</li>\n<li>首先去缓存容器中查看缓存中是否有对应的数据，如果有，直接取出来使用。</li>\n<li>如果没有，就先计算结果，然后把结果存储到缓存容器中，方便下次复用。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cache = &#123; &#125;;</span><br><span class=\"line\">var count = 0;</span><br><span class=\"line\">function fib(n)&#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    if(n === 1 || n === 2)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(cache[n])&#123;</span><br><span class=\"line\">        return cache[n];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        var ret = fib(n - 1) + fib(n - 2);</span><br><span class=\"line\">        cache[n] = ret;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(fib(10));</span><br><span class=\"line\">console.log(&quot;fib函数调用的次数 &quot; + count);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>缓存: 存数据(该案例中,用键存月份,值存的对数)</li>\n<li>在js中,缓存中如何表示, 对象 || 数组</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a>简单</h3><p>一次跳一层或两层，求跳上一个n级的台阶总共有多少种跳法。<br>因为n级台阶，第一步有n种跳法：跳1级、跳2级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)   </p>\n<p>f(0)=0<br>f(1)=1<br>f(2)=2<br>f(n)=f(n-1)+f(n-2)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jump(n)&#123;</span><br><span class=\"line\">    if(n==0)&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;else if(n==1)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;else if(n==2)&#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return jump(n-1)+jump(n-2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂\"><a href=\"#复杂\" class=\"headerlink\" title=\"复杂\"></a>复杂</h3><p>一次可以跳上1级台阶，也可以跳上2级……也可以跳上n级。求跳上一个n级的台阶总共有多少种跳法。<br>因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)+…+f(1)<br>因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>所以f(n)=2*f(n-1) </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jumpII(number)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(number == 0)&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;else if(number == 1)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 2*jumpII(number-1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h3><p>斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p>\n<h4 id=\"性能优化之缓存\"><a href=\"#性能优化之缓存\" class=\"headerlink\" title=\"性能优化之缓存\"></a>性能优化之缓存</h4><ul>\n<li>缓存: 存储数据的容器(cache)</li>\n<li>在js中, 可以使用数组或者是对象进行存储数据,用键存储值,这样就可以实现既能存值也能取值</li>\n</ul>\n<h4 id=\"用缓存的基本思路\"><a href=\"#用缓存的基本思路\" class=\"headerlink\" title=\"用缓存的基本思路\"></a>用缓存的基本思路</h4><ol>\n<li>创建一个空对象，作为缓存的容器。</li>\n<li>首先去缓存容器中查看缓存中是否有对应的数据，如果有，直接取出来使用。</li>\n<li>如果没有，就先计算结果，然后把结果存储到缓存容器中，方便下次复用。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cache = &#123; &#125;;</span><br><span class=\"line\">var count = 0;</span><br><span class=\"line\">function fib(n)&#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    if(n === 1 || n === 2)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(cache[n])&#123;</span><br><span class=\"line\">        return cache[n];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        var ret = fib(n - 1) + fib(n - 2);</span><br><span class=\"line\">        cache[n] = ret;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(fib(10));</span><br><span class=\"line\">console.log(&quot;fib函数调用的次数 &quot; + count);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>缓存: 存数据(该案例中,用键存月份,值存的对数)</li>\n<li>在js中,缓存中如何表示, 对象 || 数组</li>\n</ul>\n"},{"_content":"迭代+递归\n\n1. 在DNS解析器缓存中查找某主机的ip地址\n2. 向其本地域名服务器进行递归查找。\n3. 本地域名服务器查不到，就向根域名服务器进行迭代查询。\n4. 根域名服务器告诉本地域名服务器，下一步该向顶级域名服务器查找。\n5. 本地域名服务器向顶级域名服务器查找。\n6. 顶级域名服务器告诉本地域名服务器，下一步该向权限域名服务器查找。\n7. 权限域名服务器返回目标主机的ip地址。\n8. 本地域名服务器就把ip地址告诉目标主机。\n\n","source":"_posts/计网/计网：DNS查询过程.md","raw":"迭代+递归\n\n1. 在DNS解析器缓存中查找某主机的ip地址\n2. 向其本地域名服务器进行递归查找。\n3. 本地域名服务器查不到，就向根域名服务器进行迭代查询。\n4. 根域名服务器告诉本地域名服务器，下一步该向顶级域名服务器查找。\n5. 本地域名服务器向顶级域名服务器查找。\n6. 顶级域名服务器告诉本地域名服务器，下一步该向权限域名服务器查找。\n7. 权限域名服务器返回目标主机的ip地址。\n8. 本地域名服务器就把ip地址告诉目标主机。\n\n","slug":"计网/计网：DNS查询过程","published":1,"date":"2020-05-14T08:38:46.027Z","updated":"2020-02-14T06:45:06.002Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cka6kingy00abqgu90ecv7yfg","content":"<p>迭代+递归</p>\n<ol>\n<li>在DNS解析器缓存中查找某主机的ip地址</li>\n<li>向其本地域名服务器进行递归查找。</li>\n<li>本地域名服务器查不到，就向根域名服务器进行迭代查询。</li>\n<li>根域名服务器告诉本地域名服务器，下一步该向顶级域名服务器查找。</li>\n<li>本地域名服务器向顶级域名服务器查找。</li>\n<li>顶级域名服务器告诉本地域名服务器，下一步该向权限域名服务器查找。</li>\n<li>权限域名服务器返回目标主机的ip地址。</li>\n<li>本地域名服务器就把ip地址告诉目标主机。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>迭代+递归</p>\n<ol>\n<li>在DNS解析器缓存中查找某主机的ip地址</li>\n<li>向其本地域名服务器进行递归查找。</li>\n<li>本地域名服务器查不到，就向根域名服务器进行迭代查询。</li>\n<li>根域名服务器告诉本地域名服务器，下一步该向顶级域名服务器查找。</li>\n<li>本地域名服务器向顶级域名服务器查找。</li>\n<li>顶级域名服务器告诉本地域名服务器，下一步该向权限域名服务器查找。</li>\n<li>权限域名服务器返回目标主机的ip地址。</li>\n<li>本地域名服务器就把ip地址告诉目标主机。</li>\n</ol>\n"},{"title":"计网：TCP","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### TCP和UDP\n- 都是运输层协议\n- tcp有连接，可靠：数据包校验、对失序数据包重排序、丢弃重复数据、应答机制、超时重传、流量控制。\n- udp无连接，快。只是传输数据，不管服务器是否收到。\n\n### TCP拥塞控制\n防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。\n- 慢开始\n\n把初始拥塞窗口cwnd设置为1或2个发送方的最大报文段（SMSS），由小到大逐渐增大发送窗口。每经过一个传输轮次，cwnd加倍。\n\n把拥塞窗口允许发送的报文段都连续发送出去，收到对已发送的最后一个字节的确认，为一个传输轮次，时间为一个往返时间。\n\n- 拥塞避免\n\n让拥塞窗口缓慢增大，没经过一个往返时间RTT就加1\n\n- 快重传\n\n让发送方尽早知道发生了个别报文段丢失\n\n- 快恢复\n\n发送方知道丢失报文段，则不启动慢开始，用快恢复，调整门限值cwnd/2.\n\n#### TCP建立连接——三次握手\n1. 客户端发送连接请求报文，将SYN位置设为1\n2. 服务器端收到报文后回复ACK+SYN报文。\n3. 客户端接收到报文后也向服务器端发送ACK报文，这个报文发送完毕后，完成了三次握手。\n> 通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。\n\n#### TCP释放连接——四次挥手（断开连接）\n1. 客户端向服务器传送断开的请求包。客户端进入FIN_WAIT_1状态。\n2. 服务器端确定收到断开的请求，回复ACK报文。客户端进入FIN_WAIT_2状态。\n3. 服务器端向客户端FIN报文，请求关闭连接。服务器端进入LAST_ACK状态。\n4. 客户端收到FIN报文后，回复ACK报文。客户端进入TIME_WAIT状态。服务器端收到ACK报文就会关闭连接（不然一直处于LAST_ACK状态），客户端没有收到服务器端的回复，证明服务器端已关闭连接，客户端也可以关闭连接了。\n","source":"_posts/计网/计网：TCP.md","raw":"---\ntitle: 计网：TCP\nDate: 2020-05-14\ntags: [计网]\ncategories: 计网\ncomments: true\n---\n\n\n### TCP和UDP\n- 都是运输层协议\n- tcp有连接，可靠：数据包校验、对失序数据包重排序、丢弃重复数据、应答机制、超时重传、流量控制。\n- udp无连接，快。只是传输数据，不管服务器是否收到。\n\n### TCP拥塞控制\n防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。\n- 慢开始\n\n把初始拥塞窗口cwnd设置为1或2个发送方的最大报文段（SMSS），由小到大逐渐增大发送窗口。每经过一个传输轮次，cwnd加倍。\n\n把拥塞窗口允许发送的报文段都连续发送出去，收到对已发送的最后一个字节的确认，为一个传输轮次，时间为一个往返时间。\n\n- 拥塞避免\n\n让拥塞窗口缓慢增大，没经过一个往返时间RTT就加1\n\n- 快重传\n\n让发送方尽早知道发生了个别报文段丢失\n\n- 快恢复\n\n发送方知道丢失报文段，则不启动慢开始，用快恢复，调整门限值cwnd/2.\n\n#### TCP建立连接——三次握手\n1. 客户端发送连接请求报文，将SYN位置设为1\n2. 服务器端收到报文后回复ACK+SYN报文。\n3. 客户端接收到报文后也向服务器端发送ACK报文，这个报文发送完毕后，完成了三次握手。\n> 通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。\n\n#### TCP释放连接——四次挥手（断开连接）\n1. 客户端向服务器传送断开的请求包。客户端进入FIN_WAIT_1状态。\n2. 服务器端确定收到断开的请求，回复ACK报文。客户端进入FIN_WAIT_2状态。\n3. 服务器端向客户端FIN报文，请求关闭连接。服务器端进入LAST_ACK状态。\n4. 客户端收到FIN报文后，回复ACK报文。客户端进入TIME_WAIT状态。服务器端收到ACK报文就会关闭连接（不然一直处于LAST_ACK状态），客户端没有收到服务器端的回复，证明服务器端已关闭连接，客户端也可以关闭连接了。\n","slug":"计网/计网：TCP","published":1,"date":"2020-05-14T08:38:52.369Z","updated":"2020-05-14T08:40:31.503Z","layout":"post","photos":[],"link":"","_id":"cka6kinh700afqgu9q9yxnf6s","content":"<h3 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h3><ul>\n<li>都是运输层协议</li>\n<li>tcp有连接，可靠：数据包校验、对失序数据包重排序、丢弃重复数据、应答机制、超时重传、流量控制。</li>\n<li>udp无连接，快。只是传输数据，不管服务器是否收到。</li>\n</ul>\n<h3 id=\"TCP拥塞控制\"><a href=\"#TCP拥塞控制\" class=\"headerlink\" title=\"TCP拥塞控制\"></a>TCP拥塞控制</h3><p>防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>\n<ul>\n<li>慢开始</li>\n</ul>\n<p>把初始拥塞窗口cwnd设置为1或2个发送方的最大报文段（SMSS），由小到大逐渐增大发送窗口。每经过一个传输轮次，cwnd加倍。</p>\n<p>把拥塞窗口允许发送的报文段都连续发送出去，收到对已发送的最后一个字节的确认，为一个传输轮次，时间为一个往返时间。</p>\n<ul>\n<li>拥塞避免</li>\n</ul>\n<p>让拥塞窗口缓慢增大，没经过一个往返时间RTT就加1</p>\n<ul>\n<li>快重传</li>\n</ul>\n<p>让发送方尽早知道发生了个别报文段丢失</p>\n<ul>\n<li>快恢复</li>\n</ul>\n<p>发送方知道丢失报文段，则不启动慢开始，用快恢复，调整门限值cwnd/2.</p>\n<h4 id=\"TCP建立连接——三次握手\"><a href=\"#TCP建立连接——三次握手\" class=\"headerlink\" title=\"TCP建立连接——三次握手\"></a>TCP建立连接——三次握手</h4><ol>\n<li>客户端发送连接请求报文，将SYN位置设为1</li>\n<li>服务器端收到报文后回复ACK+SYN报文。</li>\n<li>客户端接收到报文后也向服务器端发送ACK报文，这个报文发送完毕后，完成了三次握手。<blockquote>\n<p>通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"TCP释放连接——四次挥手（断开连接）\"><a href=\"#TCP释放连接——四次挥手（断开连接）\" class=\"headerlink\" title=\"TCP释放连接——四次挥手（断开连接）\"></a>TCP释放连接——四次挥手（断开连接）</h4><ol>\n<li>客户端向服务器传送断开的请求包。客户端进入FIN_WAIT_1状态。</li>\n<li>服务器端确定收到断开的请求，回复ACK报文。客户端进入FIN_WAIT_2状态。</li>\n<li>服务器端向客户端FIN报文，请求关闭连接。服务器端进入LAST_ACK状态。</li>\n<li>客户端收到FIN报文后，回复ACK报文。客户端进入TIME_WAIT状态。服务器端收到ACK报文就会关闭连接（不然一直处于LAST_ACK状态），客户端没有收到服务器端的回复，证明服务器端已关闭连接，客户端也可以关闭连接了。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h3><ul>\n<li>都是运输层协议</li>\n<li>tcp有连接，可靠：数据包校验、对失序数据包重排序、丢弃重复数据、应答机制、超时重传、流量控制。</li>\n<li>udp无连接，快。只是传输数据，不管服务器是否收到。</li>\n</ul>\n<h3 id=\"TCP拥塞控制\"><a href=\"#TCP拥塞控制\" class=\"headerlink\" title=\"TCP拥塞控制\"></a>TCP拥塞控制</h3><p>防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>\n<ul>\n<li>慢开始</li>\n</ul>\n<p>把初始拥塞窗口cwnd设置为1或2个发送方的最大报文段（SMSS），由小到大逐渐增大发送窗口。每经过一个传输轮次，cwnd加倍。</p>\n<p>把拥塞窗口允许发送的报文段都连续发送出去，收到对已发送的最后一个字节的确认，为一个传输轮次，时间为一个往返时间。</p>\n<ul>\n<li>拥塞避免</li>\n</ul>\n<p>让拥塞窗口缓慢增大，没经过一个往返时间RTT就加1</p>\n<ul>\n<li>快重传</li>\n</ul>\n<p>让发送方尽早知道发生了个别报文段丢失</p>\n<ul>\n<li>快恢复</li>\n</ul>\n<p>发送方知道丢失报文段，则不启动慢开始，用快恢复，调整门限值cwnd/2.</p>\n<h4 id=\"TCP建立连接——三次握手\"><a href=\"#TCP建立连接——三次握手\" class=\"headerlink\" title=\"TCP建立连接——三次握手\"></a>TCP建立连接——三次握手</h4><ol>\n<li>客户端发送连接请求报文，将SYN位置设为1</li>\n<li>服务器端收到报文后回复ACK+SYN报文。</li>\n<li>客户端接收到报文后也向服务器端发送ACK报文，这个报文发送完毕后，完成了三次握手。<blockquote>\n<p>通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"TCP释放连接——四次挥手（断开连接）\"><a href=\"#TCP释放连接——四次挥手（断开连接）\" class=\"headerlink\" title=\"TCP释放连接——四次挥手（断开连接）\"></a>TCP释放连接——四次挥手（断开连接）</h4><ol>\n<li>客户端向服务器传送断开的请求包。客户端进入FIN_WAIT_1状态。</li>\n<li>服务器端确定收到断开的请求，回复ACK报文。客户端进入FIN_WAIT_2状态。</li>\n<li>服务器端向客户端FIN报文，请求关闭连接。服务器端进入LAST_ACK状态。</li>\n<li>客户端收到FIN报文后，回复ACK报文。客户端进入TIME_WAIT状态。服务器端收到ACK报文就会关闭连接（不然一直处于LAST_ACK状态），客户端没有收到服务器端的回复，证明服务器端已关闭连接，客户端也可以关闭连接了。</li>\n</ol>\n"},{"title":"计网：cdn","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 是什么\n内容分发网络。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\n### cdn缓存\n\n用户浏览器和服务器端之间加入cdn\n\n用户在浏览网站的时候，向服务器请求到资源后，cdn会在本地保存网站中的图片或者js、css等其他文件的副本，通过http响应头中的cache-control字段设置数据缓存时间，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。\n\n再次浏览网站时，客户端浏览器会先向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求,来拉取最新的数据。","source":"_posts/计网/计网：cdn.md","raw":"---\ntitle: 计网：cdn\nDate: 2020-05-14\ntags: [计网]\ncategories: 计网\ncomments: true\n---\n\n\n### 是什么\n内容分发网络。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\n### cdn缓存\n\n用户浏览器和服务器端之间加入cdn\n\n用户在浏览网站的时候，向服务器请求到资源后，cdn会在本地保存网站中的图片或者js、css等其他文件的副本，通过http响应头中的cache-control字段设置数据缓存时间，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。\n\n再次浏览网站时，客户端浏览器会先向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求,来拉取最新的数据。","slug":"计网/计网：cdn","published":1,"date":"2020-05-14T08:38:40.757Z","updated":"2020-05-14T08:40:22.240Z","layout":"post","photos":[],"link":"","_id":"cka6kinhe00ahqgu92nwxhpsq","content":"<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>内容分发网络。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>\n<h3 id=\"cdn缓存\"><a href=\"#cdn缓存\" class=\"headerlink\" title=\"cdn缓存\"></a>cdn缓存</h3><p>用户浏览器和服务器端之间加入cdn</p>\n<p>用户在浏览网站的时候，向服务器请求到资源后，cdn会在本地保存网站中的图片或者js、css等其他文件的副本，通过http响应头中的cache-control字段设置数据缓存时间，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。</p>\n<p>再次浏览网站时，客户端浏览器会先向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求,来拉取最新的数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>内容分发网络。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>\n<h3 id=\"cdn缓存\"><a href=\"#cdn缓存\" class=\"headerlink\" title=\"cdn缓存\"></a>cdn缓存</h3><p>用户浏览器和服务器端之间加入cdn</p>\n<p>用户在浏览网站的时候，向服务器请求到资源后，cdn会在本地保存网站中的图片或者js、css等其他文件的副本，通过http响应头中的cache-control字段设置数据缓存时间，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。</p>\n<p>再次浏览网站时，客户端浏览器会先向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求,来拉取最新的数据。</p>\n"},{"title":"计网：http和https","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 关于https\n用处：\n- 建立一个信息安全通道，来保证数据传输的安全。\n- 确认网站的真实性，防止钓鱼网站。\n\nhttps就是在http下加入了ssl层，从而保护了交换数据隐私和完整性，提供了对网站服务器身份认证的功能，简单来说就是安全版的http。\n\n### http和https的区别\n- 同属于应用层的协议\n- http协议是运行在tcp之上的，所有传输的内容都是未加密的，也就是明文的。https协议是运行在SSL\\TLS之上的，而SSL\\TLS协议运行在tcp之上，在http和tcp之间，所有传输的内容都经过加密的，比http更安全。（加密采用对称加密，而密钥的传输利用非对称加密）\n- http默认使用端口80。https默认使用端口443。\n\n### https的工作原理\n1. 使用HTTPS的url访问服务器，客户端向服务器端请求建立SSL连接。（可以说TLS为SSL的新版本）\n2. 服务器收到客户端请求后，会将网站的证书信息（证书包含公钥）传送一份给客户端。\n3. 客户端浏览器和服务器端协商信息加密的等级。\n4. 客户端浏览器根据协商好的安全等级，建立会话密钥，然后利用网站的公钥加密会话密钥，并传送给服务器。\n5. 服务器利用私钥解密会话密钥，并利用会话密钥加密与客户端之间的通信。\n\n非对称密码解密速度比较慢，但比较安全；对称密码解密速度比较快。所以用对称密码加密数据，非对称密码加密对称密钥。\n\n非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。","source":"_posts/计网/计网：http和https.md","raw":"---\ntitle: 计网：http和https\nDate: 2020-05-14\ntags: [计网]\ncategories: 计网\ncomments: true\n---\n\n\n### 关于https\n用处：\n- 建立一个信息安全通道，来保证数据传输的安全。\n- 确认网站的真实性，防止钓鱼网站。\n\nhttps就是在http下加入了ssl层，从而保护了交换数据隐私和完整性，提供了对网站服务器身份认证的功能，简单来说就是安全版的http。\n\n### http和https的区别\n- 同属于应用层的协议\n- http协议是运行在tcp之上的，所有传输的内容都是未加密的，也就是明文的。https协议是运行在SSL\\TLS之上的，而SSL\\TLS协议运行在tcp之上，在http和tcp之间，所有传输的内容都经过加密的，比http更安全。（加密采用对称加密，而密钥的传输利用非对称加密）\n- http默认使用端口80。https默认使用端口443。\n\n### https的工作原理\n1. 使用HTTPS的url访问服务器，客户端向服务器端请求建立SSL连接。（可以说TLS为SSL的新版本）\n2. 服务器收到客户端请求后，会将网站的证书信息（证书包含公钥）传送一份给客户端。\n3. 客户端浏览器和服务器端协商信息加密的等级。\n4. 客户端浏览器根据协商好的安全等级，建立会话密钥，然后利用网站的公钥加密会话密钥，并传送给服务器。\n5. 服务器利用私钥解密会话密钥，并利用会话密钥加密与客户端之间的通信。\n\n非对称密码解密速度比较慢，但比较安全；对称密码解密速度比较快。所以用对称密码加密数据，非对称密码加密对称密钥。\n\n非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。","slug":"计网/计网：http和https","published":1,"date":"2020-05-14T08:38:35.674Z","updated":"2020-05-14T08:40:13.311Z","layout":"post","photos":[],"link":"","_id":"cka6kinhk00alqgu9unavh6g1","content":"<h3 id=\"关于https\"><a href=\"#关于https\" class=\"headerlink\" title=\"关于https\"></a>关于https</h3><p>用处：</p>\n<ul>\n<li>建立一个信息安全通道，来保证数据传输的安全。</li>\n<li>确认网站的真实性，防止钓鱼网站。</li>\n</ul>\n<p>https就是在http下加入了ssl层，从而保护了交换数据隐私和完整性，提供了对网站服务器身份认证的功能，简单来说就是安全版的http。</p>\n<h3 id=\"http和https的区别\"><a href=\"#http和https的区别\" class=\"headerlink\" title=\"http和https的区别\"></a>http和https的区别</h3><ul>\n<li>同属于应用层的协议</li>\n<li>http协议是运行在tcp之上的，所有传输的内容都是未加密的，也就是明文的。https协议是运行在SSL\\TLS之上的，而SSL\\TLS协议运行在tcp之上，在http和tcp之间，所有传输的内容都经过加密的，比http更安全。（加密采用对称加密，而密钥的传输利用非对称加密）</li>\n<li>http默认使用端口80。https默认使用端口443。</li>\n</ul>\n<h3 id=\"https的工作原理\"><a href=\"#https的工作原理\" class=\"headerlink\" title=\"https的工作原理\"></a>https的工作原理</h3><ol>\n<li>使用HTTPS的url访问服务器，客户端向服务器端请求建立SSL连接。（可以说TLS为SSL的新版本）</li>\n<li>服务器收到客户端请求后，会将网站的证书信息（证书包含公钥）传送一份给客户端。</li>\n<li>客户端浏览器和服务器端协商信息加密的等级。</li>\n<li>客户端浏览器根据协商好的安全等级，建立会话密钥，然后利用网站的公钥加密会话密钥，并传送给服务器。</li>\n<li>服务器利用私钥解密会话密钥，并利用会话密钥加密与客户端之间的通信。</li>\n</ol>\n<p>非对称密码解密速度比较慢，但比较安全；对称密码解密速度比较快。所以用对称密码加密数据，非对称密码加密对称密钥。</p>\n<p>非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关于https\"><a href=\"#关于https\" class=\"headerlink\" title=\"关于https\"></a>关于https</h3><p>用处：</p>\n<ul>\n<li>建立一个信息安全通道，来保证数据传输的安全。</li>\n<li>确认网站的真实性，防止钓鱼网站。</li>\n</ul>\n<p>https就是在http下加入了ssl层，从而保护了交换数据隐私和完整性，提供了对网站服务器身份认证的功能，简单来说就是安全版的http。</p>\n<h3 id=\"http和https的区别\"><a href=\"#http和https的区别\" class=\"headerlink\" title=\"http和https的区别\"></a>http和https的区别</h3><ul>\n<li>同属于应用层的协议</li>\n<li>http协议是运行在tcp之上的，所有传输的内容都是未加密的，也就是明文的。https协议是运行在SSL\\TLS之上的，而SSL\\TLS协议运行在tcp之上，在http和tcp之间，所有传输的内容都经过加密的，比http更安全。（加密采用对称加密，而密钥的传输利用非对称加密）</li>\n<li>http默认使用端口80。https默认使用端口443。</li>\n</ul>\n<h3 id=\"https的工作原理\"><a href=\"#https的工作原理\" class=\"headerlink\" title=\"https的工作原理\"></a>https的工作原理</h3><ol>\n<li>使用HTTPS的url访问服务器，客户端向服务器端请求建立SSL连接。（可以说TLS为SSL的新版本）</li>\n<li>服务器收到客户端请求后，会将网站的证书信息（证书包含公钥）传送一份给客户端。</li>\n<li>客户端浏览器和服务器端协商信息加密的等级。</li>\n<li>客户端浏览器根据协商好的安全等级，建立会话密钥，然后利用网站的公钥加密会话密钥，并传送给服务器。</li>\n<li>服务器利用私钥解密会话密钥，并利用会话密钥加密与客户端之间的通信。</li>\n</ol>\n<p>非对称密码解密速度比较慢，但比较安全；对称密码解密速度比较快。所以用对称密码加密数据，非对称密码加密对称密钥。</p>\n<p>非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。</p>\n"},{"title":"计网：http报文结构","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### http报文的产生\nHTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。\n\n### 什么是HTTP报文呢？\nHTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。\n\n### 报文结构\n- HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。\n- 报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。\n- 报文首部包括请求行和请求头部。\n- 报文主体主要包含应被发送的数据。\n- 通常，不一定有报文主体。\n\n### http请求报文\n一个HTTP请求报文由请求行、请求头部、空行和请求数据4个部分构成。\n\n![image](https://img-blog.csdn.net/20180828215741663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdtaW5fMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。\n```\n// 该部分位于数据首行，基本格式为：\nGET /index.html HTTP/1.1\n```\n该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。\n\n### http响应报文\nHTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。\n\n![image](https://img-blog.csdn.net/20180828215835558?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdtaW5fMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。格式为：\n```\nHTTP/1.1 200 OK\n```\n状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。\n\n### 报文首部\n#### 结构\n- 由首部字段名和字段值构成的，中间用冒号“:”分割。\n- 首部字段格式： 首部字段名:字段值。\n\n#### 类型\n- 通用首部字段：请求报文和响应报文两方都会使用的首部。\n- 请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。\n- 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。\n- 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。\n\n\n","source":"_posts/计网/计网：http报文结构.md","raw":"---\ntitle: 计网：http报文结构\nDate: 2020-05-14\ntags: [计网]\ncategories: 计网\ncomments: true\n---\n\n### http报文的产生\nHTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。\n\n### 什么是HTTP报文呢？\nHTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。\n\n### 报文结构\n- HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。\n- 报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。\n- 报文首部包括请求行和请求头部。\n- 报文主体主要包含应被发送的数据。\n- 通常，不一定有报文主体。\n\n### http请求报文\n一个HTTP请求报文由请求行、请求头部、空行和请求数据4个部分构成。\n\n![image](https://img-blog.csdn.net/20180828215741663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdtaW5fMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。\n```\n// 该部分位于数据首行，基本格式为：\nGET /index.html HTTP/1.1\n```\n该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。\n\n### http响应报文\nHTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。\n\n![image](https://img-blog.csdn.net/20180828215835558?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdtaW5fMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。格式为：\n```\nHTTP/1.1 200 OK\n```\n状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。\n\n### 报文首部\n#### 结构\n- 由首部字段名和字段值构成的，中间用冒号“:”分割。\n- 首部字段格式： 首部字段名:字段值。\n\n#### 类型\n- 通用首部字段：请求报文和响应报文两方都会使用的首部。\n- 请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。\n- 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。\n- 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。\n\n\n","slug":"计网/计网：http报文结构","published":1,"date":"2020-05-14T08:38:30.742Z","updated":"2020-05-14T08:40:03.650Z","layout":"post","photos":[],"link":"","_id":"cka6kinhp00anqgu9p1dkzbph","content":"<h3 id=\"http报文的产生\"><a href=\"#http报文的产生\" class=\"headerlink\" title=\"http报文的产生\"></a>http报文的产生</h3><p>HTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。</p>\n<h3 id=\"什么是HTTP报文呢？\"><a href=\"#什么是HTTP报文呢？\" class=\"headerlink\" title=\"什么是HTTP报文呢？\"></a>什么是HTTP报文呢？</h3><p>HTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。</p>\n<h3 id=\"报文结构\"><a href=\"#报文结构\" class=\"headerlink\" title=\"报文结构\"></a>报文结构</h3><ul>\n<li>HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。</li>\n<li>报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。</li>\n<li>报文首部包括请求行和请求头部。</li>\n<li>报文主体主要包含应被发送的数据。</li>\n<li>通常，不一定有报文主体。</li>\n</ul>\n<h3 id=\"http请求报文\"><a href=\"#http请求报文\" class=\"headerlink\" title=\"http请求报文\"></a>http请求报文</h3><p>一个HTTP请求报文由请求行、请求头部、空行和请求数据4个部分构成。</p>\n<p><img src=\"https://img-blog.csdn.net/20180828215741663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdtaW5fMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 该部分位于数据首行，基本格式为：</span><br><span class=\"line\">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure></p>\n<p>该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。</p>\n<h3 id=\"http响应报文\"><a href=\"#http响应报文\" class=\"headerlink\" title=\"http响应报文\"></a>http响应报文</h3><p>HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。</p>\n<p><img src=\"https://img-blog.csdn.net/20180828215835558?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdtaW5fMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。格式为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure></p>\n<p>状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。</p>\n<h3 id=\"报文首部\"><a href=\"#报文首部\" class=\"headerlink\" title=\"报文首部\"></a>报文首部</h3><h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><ul>\n<li>由首部字段名和字段值构成的，中间用冒号“:”分割。</li>\n<li>首部字段格式： 首部字段名:字段值。</li>\n</ul>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><ul>\n<li>通用首部字段：请求报文和响应报文两方都会使用的首部。</li>\n<li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>\n<li>响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>\n<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"http报文的产生\"><a href=\"#http报文的产生\" class=\"headerlink\" title=\"http报文的产生\"></a>http报文的产生</h3><p>HTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。</p>\n<h3 id=\"什么是HTTP报文呢？\"><a href=\"#什么是HTTP报文呢？\" class=\"headerlink\" title=\"什么是HTTP报文呢？\"></a>什么是HTTP报文呢？</h3><p>HTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。</p>\n<h3 id=\"报文结构\"><a href=\"#报文结构\" class=\"headerlink\" title=\"报文结构\"></a>报文结构</h3><ul>\n<li>HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。</li>\n<li>报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。</li>\n<li>报文首部包括请求行和请求头部。</li>\n<li>报文主体主要包含应被发送的数据。</li>\n<li>通常，不一定有报文主体。</li>\n</ul>\n<h3 id=\"http请求报文\"><a href=\"#http请求报文\" class=\"headerlink\" title=\"http请求报文\"></a>http请求报文</h3><p>一个HTTP请求报文由请求行、请求头部、空行和请求数据4个部分构成。</p>\n<p><img src=\"https://img-blog.csdn.net/20180828215741663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdtaW5fMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 该部分位于数据首行，基本格式为：</span><br><span class=\"line\">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure></p>\n<p>该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。</p>\n<h3 id=\"http响应报文\"><a href=\"#http响应报文\" class=\"headerlink\" title=\"http响应报文\"></a>http响应报文</h3><p>HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。</p>\n<p><img src=\"https://img-blog.csdn.net/20180828215835558?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdtaW5fMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。格式为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure></p>\n<p>状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。</p>\n<h3 id=\"报文首部\"><a href=\"#报文首部\" class=\"headerlink\" title=\"报文首部\"></a>报文首部</h3><h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><ul>\n<li>由首部字段名和字段值构成的，中间用冒号“:”分割。</li>\n<li>首部字段格式： 首部字段名:字段值。</li>\n</ul>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><ul>\n<li>通用首部字段：请求报文和响应报文两方都会使用的首部。</li>\n<li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>\n<li>响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>\n<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。</li>\n</ul>\n"},{"title":"计网：http的header字段","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\nhttp头 = 通用头 + 请求头 + 响应头\n### 通用头(General)\n通用头域包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息。\n\n![image](https://img-blog.csdn.net/20170919180331072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDQyOTQyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nheader | 含义\n---|---\nRequest URL  | 请求的URL\nRequest Method  | 请求的方法 \nStatus Code  | HTTP 状态码\nRemote Address  | 远程IP地址 \nReferrer Policy  | 记录了是从哪个链接跳来的\n\n### 响应头(Response Headers)\n\nheader  | 含义 | 示例\n---|---|---\nAccept-Ranges | 表明服务器是否支持指定范围请求及哪种类型的分段请求 | Accept-Ranges: bytes\nAge |  \t从原始服务器到代理缓存形成的估算时间（以秒计，非负） | Age: 12\nAllow |\t对某网络资源的有效的请求行为，不允许则返回405 | Allow: GET, HEAD\nCache-Control |\t告诉所有的缓存机制是否可以缓存及哪种类型 |\tCache-Control: no-cache\nContent-Encoding |\tweb服务器支持的返回内容压缩编码类型。 |\tContent-Encoding: gzip\nContent-Language  |\t响应体的语言 |\tContent-Language: en,zh\nContent-Length | 响应体的长度 |\tContent-Length: 348\nContent-Location |\t请求资源可替代的备用的另一地址 |\tContent-Location: /index.htm\nContent-MD5  |\t返回资源的MD5校验值 |\tContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\nContent-Range |\t在整个返回体中本部分的字节位置 | \tContent-Range: bytes 21010-47021/47022\nContent-Type  |\t返回内容的MIME类型 |\tContent-Type: text/html; charset=utf-8\nDate |\t原始服务器消息发出的时间 |\tDate: Tue, 15 Nov 2010 08:12:31 GMT\nETag |\t请求变量的实体标签的当前值 |\tETag: “737060cd8c284d8af7ad3082f209582d”\nExpires |\t响应过期的日期和时间 |\tExpires: Thu, 01 Dec 2010 16:00:00 GMT\nLast-Modified |\t请求资源的最后修改时间 |\tLast-Modified: Tue, 15 Nov 2010 12:45:26 GMT\nLocation |\t用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 |\tLocation: http://www.zcmhi.com/archives/94.html\nPragma |\t包括实现特定的指令，它可应用到响应链上的任何接收方 |\tPragma: no-cache\nProxy-Authenticate |\t它指出认证方案和可应用到代理的该URL上的参数 |\tProxy-Authenticate: Basic\nrefresh |\t应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） \t|Refresh: 5; url=http://www.zcmhi.com/archives/94.html\nRetry-After |\t如果实体暂时不可取，通知客户端在指定时间之后再次尝试 |\tRetry-After: 120\nServer |\tweb服务器软件名称 |\tServer: Apache/1.3.27 (Unix) (Red-Hat/Linux)\nSet-Cookie \t| 设置Http Cookie |\tSet-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1\nTrailer  |\t指出头域在分块传输编码的尾部存在 |\tTrailer: Max-Forwards\nTransfer-Encoding |\t文件传输编码 |\tTransfer-Encoding:chunked\nVary |\t告诉下游代理是使用缓存响应还是从原始服务器请求 |\tVary: *\nVia |\t告知代理客户端响应是通过哪里发送的 |\tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning |\t警告实体可能存在的问题 |\tWarning: 199 Miscellaneous warning\nWWW-Authenticate |\t表明客户端请求实体应该使用的授权方案 |\tWWW-Authenticate: Basic\n\n### 请求头(Request Headers)\n\nheader  | 含义 | 示例\n---|---|---\nAccept |\t指定客户端能够接收的内容类型 |\tAccept: text/plain, text/html\nAccept-Charset |\t浏览器可以接受的字符编码集。 |\tAccept-Charset: iso-8859-5\nAccept-Encoding |\t指定浏览器可以支持的web服务器返回内容压缩编码类型。 |\tAccept-Encoding: compress, gzip\nAccept-Language |\t浏览器可接受的语言 |\tAccept-Language: en,zh\nAccept-Ranges |\t可以请求网页实体的一个或者多个子范围字段 |\tAccept-Ranges: bytes\nAuthorization |\tHTTP授权的授权证书 |\tAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nCache-Control |\t指定请求和响应遵循的缓存机制 |\tCache-Control: no-cache\nConnection |\t表示是否需要持久连接。（HTTP 1.1默认进行持久连接） |\tConnection: close\nCookie |\tHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 |\tCookie: $Version=1; Skin=new;\nContent-Length |\t请求的内容长度 |\tContent-Length: 348\nContent-Type |\t请求的与实体对应的MIME信息 |\tContent-Type: application/x-www-form-urlencoded\nDate |\t请求发送的日期和时间 |\tDate: Tue, 15 Nov 2010 08:12:31 GMT\nExpect |\t请求的特定的服务器行为 |\tExpect: 100-continue\nFrom |\t发出请求的用户的Email |\tFrom: user@email.com\nHost |\t指定请求的服务器的域名和端口号 |\tHost: www.zcmhi.com\nIf-Match |\t只有请求内容与实体相匹配才有效 |\tIf-Match: “737060cd8c284d8af7ad3082f209582d”\nIf-Modified-Since |\t如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 |\tIf-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT\nIf-None-Match |\t如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 |\tIf-None-Match: “737060cd8c284d8af7ad3082f209582d”\nIf-Range |\t如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag |\tIf-Range: “737060cd8c284d8af7ad3082f209582d”\nIf-Unmodified-Since |\t只在实体在指定时间之后未被修改才请求成功 |\tIf-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT\nMax-Forwards |\t限制信息通过代理和网关传送的时间 |\tMax-Forwards: 10\nPragma |\t用来包含实现特定的指令 | \tPragma: no-cache\nProxy-Authorization |\t连接到代理的授权证书 |\tProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nRange |\t只请求实体的一部分，指定范围 |\tRange: bytes=500-999\nReferer |\t先前网页的地址，当前请求网页紧随其后,即来路 |\tReferer: http://www.zcmhi.com/archives/71.html\nTE |\t客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 |\tTE: trailers,deflate;q=0.5\nUpgrade |\t向服务器指定某种传输协议以便服务器进行转换（如果支持） |\tUpgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\nUser-Agent |\tUser-Agent的内容包含发出请求的用户信息 |\tUser-Agent: Mozilla/5.0 (Linux; X11)\nVia |\t通知中间网关或代理服务器地址，通信协议| \tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning |\t关于消息实体的警告信息 |\tWarn: 199 Miscellaneous warning","source":"_posts/计网/计网：http的header字段.md","raw":"---\ntitle: 计网：http的header字段\nDate: 2020-05-14\ntags: [计网]\ncategories: 计网\ncomments: true\n---\n\n\nhttp头 = 通用头 + 请求头 + 响应头\n### 通用头(General)\n通用头域包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息。\n\n![image](https://img-blog.csdn.net/20170919180331072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDQyOTQyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nheader | 含义\n---|---\nRequest URL  | 请求的URL\nRequest Method  | 请求的方法 \nStatus Code  | HTTP 状态码\nRemote Address  | 远程IP地址 \nReferrer Policy  | 记录了是从哪个链接跳来的\n\n### 响应头(Response Headers)\n\nheader  | 含义 | 示例\n---|---|---\nAccept-Ranges | 表明服务器是否支持指定范围请求及哪种类型的分段请求 | Accept-Ranges: bytes\nAge |  \t从原始服务器到代理缓存形成的估算时间（以秒计，非负） | Age: 12\nAllow |\t对某网络资源的有效的请求行为，不允许则返回405 | Allow: GET, HEAD\nCache-Control |\t告诉所有的缓存机制是否可以缓存及哪种类型 |\tCache-Control: no-cache\nContent-Encoding |\tweb服务器支持的返回内容压缩编码类型。 |\tContent-Encoding: gzip\nContent-Language  |\t响应体的语言 |\tContent-Language: en,zh\nContent-Length | 响应体的长度 |\tContent-Length: 348\nContent-Location |\t请求资源可替代的备用的另一地址 |\tContent-Location: /index.htm\nContent-MD5  |\t返回资源的MD5校验值 |\tContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\nContent-Range |\t在整个返回体中本部分的字节位置 | \tContent-Range: bytes 21010-47021/47022\nContent-Type  |\t返回内容的MIME类型 |\tContent-Type: text/html; charset=utf-8\nDate |\t原始服务器消息发出的时间 |\tDate: Tue, 15 Nov 2010 08:12:31 GMT\nETag |\t请求变量的实体标签的当前值 |\tETag: “737060cd8c284d8af7ad3082f209582d”\nExpires |\t响应过期的日期和时间 |\tExpires: Thu, 01 Dec 2010 16:00:00 GMT\nLast-Modified |\t请求资源的最后修改时间 |\tLast-Modified: Tue, 15 Nov 2010 12:45:26 GMT\nLocation |\t用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 |\tLocation: http://www.zcmhi.com/archives/94.html\nPragma |\t包括实现特定的指令，它可应用到响应链上的任何接收方 |\tPragma: no-cache\nProxy-Authenticate |\t它指出认证方案和可应用到代理的该URL上的参数 |\tProxy-Authenticate: Basic\nrefresh |\t应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） \t|Refresh: 5; url=http://www.zcmhi.com/archives/94.html\nRetry-After |\t如果实体暂时不可取，通知客户端在指定时间之后再次尝试 |\tRetry-After: 120\nServer |\tweb服务器软件名称 |\tServer: Apache/1.3.27 (Unix) (Red-Hat/Linux)\nSet-Cookie \t| 设置Http Cookie |\tSet-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1\nTrailer  |\t指出头域在分块传输编码的尾部存在 |\tTrailer: Max-Forwards\nTransfer-Encoding |\t文件传输编码 |\tTransfer-Encoding:chunked\nVary |\t告诉下游代理是使用缓存响应还是从原始服务器请求 |\tVary: *\nVia |\t告知代理客户端响应是通过哪里发送的 |\tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning |\t警告实体可能存在的问题 |\tWarning: 199 Miscellaneous warning\nWWW-Authenticate |\t表明客户端请求实体应该使用的授权方案 |\tWWW-Authenticate: Basic\n\n### 请求头(Request Headers)\n\nheader  | 含义 | 示例\n---|---|---\nAccept |\t指定客户端能够接收的内容类型 |\tAccept: text/plain, text/html\nAccept-Charset |\t浏览器可以接受的字符编码集。 |\tAccept-Charset: iso-8859-5\nAccept-Encoding |\t指定浏览器可以支持的web服务器返回内容压缩编码类型。 |\tAccept-Encoding: compress, gzip\nAccept-Language |\t浏览器可接受的语言 |\tAccept-Language: en,zh\nAccept-Ranges |\t可以请求网页实体的一个或者多个子范围字段 |\tAccept-Ranges: bytes\nAuthorization |\tHTTP授权的授权证书 |\tAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nCache-Control |\t指定请求和响应遵循的缓存机制 |\tCache-Control: no-cache\nConnection |\t表示是否需要持久连接。（HTTP 1.1默认进行持久连接） |\tConnection: close\nCookie |\tHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 |\tCookie: $Version=1; Skin=new;\nContent-Length |\t请求的内容长度 |\tContent-Length: 348\nContent-Type |\t请求的与实体对应的MIME信息 |\tContent-Type: application/x-www-form-urlencoded\nDate |\t请求发送的日期和时间 |\tDate: Tue, 15 Nov 2010 08:12:31 GMT\nExpect |\t请求的特定的服务器行为 |\tExpect: 100-continue\nFrom |\t发出请求的用户的Email |\tFrom: user@email.com\nHost |\t指定请求的服务器的域名和端口号 |\tHost: www.zcmhi.com\nIf-Match |\t只有请求内容与实体相匹配才有效 |\tIf-Match: “737060cd8c284d8af7ad3082f209582d”\nIf-Modified-Since |\t如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 |\tIf-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT\nIf-None-Match |\t如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 |\tIf-None-Match: “737060cd8c284d8af7ad3082f209582d”\nIf-Range |\t如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag |\tIf-Range: “737060cd8c284d8af7ad3082f209582d”\nIf-Unmodified-Since |\t只在实体在指定时间之后未被修改才请求成功 |\tIf-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT\nMax-Forwards |\t限制信息通过代理和网关传送的时间 |\tMax-Forwards: 10\nPragma |\t用来包含实现特定的指令 | \tPragma: no-cache\nProxy-Authorization |\t连接到代理的授权证书 |\tProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nRange |\t只请求实体的一部分，指定范围 |\tRange: bytes=500-999\nReferer |\t先前网页的地址，当前请求网页紧随其后,即来路 |\tReferer: http://www.zcmhi.com/archives/71.html\nTE |\t客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 |\tTE: trailers,deflate;q=0.5\nUpgrade |\t向服务器指定某种传输协议以便服务器进行转换（如果支持） |\tUpgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\nUser-Agent |\tUser-Agent的内容包含发出请求的用户信息 |\tUser-Agent: Mozilla/5.0 (Linux; X11)\nVia |\t通知中间网关或代理服务器地址，通信协议| \tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning |\t关于消息实体的警告信息 |\tWarn: 199 Miscellaneous warning","slug":"计网/计网：http的header字段","published":1,"date":"2020-05-14T08:38:57.533Z","updated":"2020-05-14T08:40:43.078Z","layout":"post","photos":[],"link":"","_id":"cka6kinhu00arqgu9qpsc5fgg","content":"<p>http头 = 通用头 + 请求头 + 响应头</p>\n<h3 id=\"通用头-General\"><a href=\"#通用头-General\" class=\"headerlink\" title=\"通用头(General)\"></a>通用头(General)</h3><p>通用头域包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息。</p>\n<p><img src=\"https://img-blog.csdn.net/20170919180331072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDQyOTQyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"image\"></p>\n<table>\n<thead>\n<tr>\n<th>header</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Request URL</td>\n<td>请求的URL</td>\n</tr>\n<tr>\n<td>Request Method</td>\n<td>请求的方法 </td>\n</tr>\n<tr>\n<td>Status Code</td>\n<td>HTTP 状态码</td>\n</tr>\n<tr>\n<td>Remote Address</td>\n<td>远程IP地址 </td>\n</tr>\n<tr>\n<td>Referrer Policy</td>\n<td>记录了是从哪个链接跳来的</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"响应头-Response-Headers\"><a href=\"#响应头-Response-Headers\" class=\"headerlink\" title=\"响应头(Response Headers)\"></a>响应头(Response Headers)</h3><table>\n<thead>\n<tr>\n<th>header</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept-Ranges</td>\n<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>\n<td>Accept-Ranges: bytes</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>\n<td>Age: 12</td>\n</tr>\n<tr>\n<td>Allow</td>\n<td>对某网络资源的有效的请求行为，不允许则返回405</td>\n<td>Allow: GET, HEAD</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>\n<td>Cache-Control: no-cache</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>web服务器支持的返回内容压缩编码类型。</td>\n<td>Content-Encoding: gzip</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>响应体的语言</td>\n<td>Content-Language: en,zh</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>响应体的长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>请求资源可替代的备用的另一地址</td>\n<td>Content-Location: /index.htm</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>返回资源的MD5校验值</td>\n<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个返回体中本部分的字节位置</td>\n<td>Content-Range: bytes 21010-47021/47022</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>返回内容的MIME类型</td>\n<td>Content-Type: text/html; charset=utf-8</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>原始服务器消息发出的时间</td>\n<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>请求变量的实体标签的当前值</td>\n<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>响应过期的日期和时间</td>\n<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>请求资源的最后修改时间</td>\n<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>\n<td>Location: <a href=\"http://www.zcmhi.com/archives/94.html\" target=\"_blank\" rel=\"noopener\">http://www.zcmhi.com/archives/94.html</a></td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>\n<td>Pragma: no-cache</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>它指出认证方案和可应用到代理的该URL上的参数</td>\n<td>Proxy-Authenticate: Basic</td>\n</tr>\n<tr>\n<td>refresh</td>\n<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>\n<td>Refresh: 5; url=<a href=\"http://www.zcmhi.com/archives/94.html\" target=\"_blank\" rel=\"noopener\">http://www.zcmhi.com/archives/94.html</a></td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>\n<td>Retry-After: 120</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>web服务器软件名称</td>\n<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置Http Cookie</td>\n<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>指出头域在分块传输编码的尾部存在</td>\n<td>Trailer: Max-Forwards</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>文件传输编码</td>\n<td>Transfer-Encoding:chunked</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>\n<td>Vary: *</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>告知代理客户端响应是通过哪里发送的</td>\n<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>警告实体可能存在的问题</td>\n<td>Warning: 199 Miscellaneous warning</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>表明客户端请求实体应该使用的授权方案</td>\n<td>WWW-Authenticate: Basic</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求头-Request-Headers\"><a href=\"#请求头-Request-Headers\" class=\"headerlink\" title=\"请求头(Request Headers)\"></a>请求头(Request Headers)</h3><table>\n<thead>\n<tr>\n<th>header</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>指定客户端能够接收的内容类型</td>\n<td>Accept: text/plain, text/html</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>浏览器可以接受的字符编码集。</td>\n<td>Accept-Charset: iso-8859-5</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>\n<td>Accept-Encoding: compress, gzip</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>浏览器可接受的语言</td>\n<td>Accept-Language: en,zh</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>可以请求网页实体的一个或者多个子范围字段</td>\n<td>Accept-Ranges: bytes</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>HTTP授权的授权证书</td>\n<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>指定请求和响应遵循的缓存机制</td>\n<td>Cache-Control: no-cache</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>\n<td>Connection: close</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>请求的内容长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>请求的与实体对应的MIME信息</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>请求发送的日期和时间</td>\n<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>请求的特定的服务器行为</td>\n<td>Expect: 100-continue</td>\n</tr>\n<tr>\n<td>From</td>\n<td>发出请求的用户的Email</td>\n<td>From: <a href=\"mailto:user@email.com\" target=\"_blank\" rel=\"noopener\">user@email.com</a></td>\n</tr>\n<tr>\n<td>Host</td>\n<td>指定请求的服务器的域名和端口号</td>\n<td>Host: <a href=\"http://www.zcmhi.com\" target=\"_blank\" rel=\"noopener\">www.zcmhi.com</a></td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>只有请求内容与实体相匹配才有效</td>\n<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>\n<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>\n<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>\n<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>只在实体在指定时间之后未被修改才请求成功</td>\n<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>限制信息通过代理和网关传送的时间</td>\n<td>Max-Forwards: 10</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>用来包含实现特定的指令</td>\n<td>Pragma: no-cache</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>连接到代理的授权证书</td>\n<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>只请求实体的一部分，指定范围</td>\n<td>Range: bytes=500-999</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>先前网页的地址，当前请求网页紧随其后,即来路</td>\n<td>Referer: <a href=\"http://www.zcmhi.com/archives/71.html\" target=\"_blank\" rel=\"noopener\">http://www.zcmhi.com/archives/71.html</a></td>\n</tr>\n<tr>\n<td>TE</td>\n<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>\n<td>TE: trailers,deflate;q=0.5</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>\n<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>User-Agent的内容包含发出请求的用户信息</td>\n<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>通知中间网关或代理服务器地址，通信协议</td>\n<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>关于消息实体的警告信息</td>\n<td>Warn: 199 Miscellaneous warning</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<p>http头 = 通用头 + 请求头 + 响应头</p>\n<h3 id=\"通用头-General\"><a href=\"#通用头-General\" class=\"headerlink\" title=\"通用头(General)\"></a>通用头(General)</h3><p>通用头域包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息。</p>\n<p><img src=\"https://img-blog.csdn.net/20170919180331072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDQyOTQyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"image\"></p>\n<table>\n<thead>\n<tr>\n<th>header</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Request URL</td>\n<td>请求的URL</td>\n</tr>\n<tr>\n<td>Request Method</td>\n<td>请求的方法 </td>\n</tr>\n<tr>\n<td>Status Code</td>\n<td>HTTP 状态码</td>\n</tr>\n<tr>\n<td>Remote Address</td>\n<td>远程IP地址 </td>\n</tr>\n<tr>\n<td>Referrer Policy</td>\n<td>记录了是从哪个链接跳来的</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"响应头-Response-Headers\"><a href=\"#响应头-Response-Headers\" class=\"headerlink\" title=\"响应头(Response Headers)\"></a>响应头(Response Headers)</h3><table>\n<thead>\n<tr>\n<th>header</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept-Ranges</td>\n<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>\n<td>Accept-Ranges: bytes</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>\n<td>Age: 12</td>\n</tr>\n<tr>\n<td>Allow</td>\n<td>对某网络资源的有效的请求行为，不允许则返回405</td>\n<td>Allow: GET, HEAD</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>\n<td>Cache-Control: no-cache</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>web服务器支持的返回内容压缩编码类型。</td>\n<td>Content-Encoding: gzip</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>响应体的语言</td>\n<td>Content-Language: en,zh</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>响应体的长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>请求资源可替代的备用的另一地址</td>\n<td>Content-Location: /index.htm</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>返回资源的MD5校验值</td>\n<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个返回体中本部分的字节位置</td>\n<td>Content-Range: bytes 21010-47021/47022</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>返回内容的MIME类型</td>\n<td>Content-Type: text/html; charset=utf-8</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>原始服务器消息发出的时间</td>\n<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>请求变量的实体标签的当前值</td>\n<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>响应过期的日期和时间</td>\n<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>请求资源的最后修改时间</td>\n<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>\n<td>Location: <a href=\"http://www.zcmhi.com/archives/94.html\" target=\"_blank\" rel=\"noopener\">http://www.zcmhi.com/archives/94.html</a></td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>\n<td>Pragma: no-cache</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>它指出认证方案和可应用到代理的该URL上的参数</td>\n<td>Proxy-Authenticate: Basic</td>\n</tr>\n<tr>\n<td>refresh</td>\n<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>\n<td>Refresh: 5; url=<a href=\"http://www.zcmhi.com/archives/94.html\" target=\"_blank\" rel=\"noopener\">http://www.zcmhi.com/archives/94.html</a></td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>\n<td>Retry-After: 120</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>web服务器软件名称</td>\n<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置Http Cookie</td>\n<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>指出头域在分块传输编码的尾部存在</td>\n<td>Trailer: Max-Forwards</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>文件传输编码</td>\n<td>Transfer-Encoding:chunked</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>\n<td>Vary: *</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>告知代理客户端响应是通过哪里发送的</td>\n<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>警告实体可能存在的问题</td>\n<td>Warning: 199 Miscellaneous warning</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>表明客户端请求实体应该使用的授权方案</td>\n<td>WWW-Authenticate: Basic</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求头-Request-Headers\"><a href=\"#请求头-Request-Headers\" class=\"headerlink\" title=\"请求头(Request Headers)\"></a>请求头(Request Headers)</h3><table>\n<thead>\n<tr>\n<th>header</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>指定客户端能够接收的内容类型</td>\n<td>Accept: text/plain, text/html</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>浏览器可以接受的字符编码集。</td>\n<td>Accept-Charset: iso-8859-5</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>\n<td>Accept-Encoding: compress, gzip</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>浏览器可接受的语言</td>\n<td>Accept-Language: en,zh</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>可以请求网页实体的一个或者多个子范围字段</td>\n<td>Accept-Ranges: bytes</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>HTTP授权的授权证书</td>\n<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>指定请求和响应遵循的缓存机制</td>\n<td>Cache-Control: no-cache</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>\n<td>Connection: close</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>请求的内容长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>请求的与实体对应的MIME信息</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>请求发送的日期和时间</td>\n<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>请求的特定的服务器行为</td>\n<td>Expect: 100-continue</td>\n</tr>\n<tr>\n<td>From</td>\n<td>发出请求的用户的Email</td>\n<td>From: <a href=\"mailto:user@email.com\" target=\"_blank\" rel=\"noopener\">user@email.com</a></td>\n</tr>\n<tr>\n<td>Host</td>\n<td>指定请求的服务器的域名和端口号</td>\n<td>Host: <a href=\"http://www.zcmhi.com\" target=\"_blank\" rel=\"noopener\">www.zcmhi.com</a></td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>只有请求内容与实体相匹配才有效</td>\n<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>\n<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>\n<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>\n<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>只在实体在指定时间之后未被修改才请求成功</td>\n<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>限制信息通过代理和网关传送的时间</td>\n<td>Max-Forwards: 10</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>用来包含实现特定的指令</td>\n<td>Pragma: no-cache</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>连接到代理的授权证书</td>\n<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>只请求实体的一部分，指定范围</td>\n<td>Range: bytes=500-999</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>先前网页的地址，当前请求网页紧随其后,即来路</td>\n<td>Referer: <a href=\"http://www.zcmhi.com/archives/71.html\" target=\"_blank\" rel=\"noopener\">http://www.zcmhi.com/archives/71.html</a></td>\n</tr>\n<tr>\n<td>TE</td>\n<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>\n<td>TE: trailers,deflate;q=0.5</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>\n<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>User-Agent的内容包含发出请求的用户信息</td>\n<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>通知中间网关或代理服务器地址，通信协议</td>\n<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>关于消息实体的警告信息</td>\n<td>Warn: 199 Miscellaneous warning</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"计网：计算机网络体系结构","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### TCP/IP体系结构\n#### 五层协议\n- 应用层（http，ftp）\n- 运输层（TCP，UDP）\n- 网络层（IP）\n- 数据链路层\n- 物理层\n\n#### 四层协议\n- 应用层（http，ftp）\n- 运输层（TCP，UDP）\n- 网际层IP\n- 网络接口层\n\n### OSI模型\n- 应用层（HTTP）\n- 表示层\n- 会话层（SSL\\TLS）\n- 运输层（TCP，UDP）\n- 网络层（IP）\n- 数据链路层\n- 物理层\n","source":"_posts/计网/计网：计算机网络体系结构.md","raw":"---\ntitle: 计网：计算机网络体系结构\nDate: 2020-05-14\ntags: [计网]\ncategories: 计网\ncomments: true\n---\n\n\n### TCP/IP体系结构\n#### 五层协议\n- 应用层（http，ftp）\n- 运输层（TCP，UDP）\n- 网络层（IP）\n- 数据链路层\n- 物理层\n\n#### 四层协议\n- 应用层（http，ftp）\n- 运输层（TCP，UDP）\n- 网际层IP\n- 网络接口层\n\n### OSI模型\n- 应用层（HTTP）\n- 表示层\n- 会话层（SSL\\TLS）\n- 运输层（TCP，UDP）\n- 网络层（IP）\n- 数据链路层\n- 物理层\n","slug":"计网/计网：计算机网络体系结构","published":1,"date":"2020-05-14T08:39:03.009Z","updated":"2020-05-14T08:40:53.881Z","layout":"post","photos":[],"link":"","_id":"cka6kinhy00atqgu9c5m67xz8","content":"<h3 id=\"TCP-IP体系结构\"><a href=\"#TCP-IP体系结构\" class=\"headerlink\" title=\"TCP/IP体系结构\"></a>TCP/IP体系结构</h3><h4 id=\"五层协议\"><a href=\"#五层协议\" class=\"headerlink\" title=\"五层协议\"></a>五层协议</h4><ul>\n<li>应用层（http，ftp）</li>\n<li>运输层（TCP，UDP）</li>\n<li>网络层（IP）</li>\n<li>数据链路层</li>\n<li>物理层</li>\n</ul>\n<h4 id=\"四层协议\"><a href=\"#四层协议\" class=\"headerlink\" title=\"四层协议\"></a>四层协议</h4><ul>\n<li>应用层（http，ftp）</li>\n<li>运输层（TCP，UDP）</li>\n<li>网际层IP</li>\n<li>网络接口层</li>\n</ul>\n<h3 id=\"OSI模型\"><a href=\"#OSI模型\" class=\"headerlink\" title=\"OSI模型\"></a>OSI模型</h3><ul>\n<li>应用层（HTTP）</li>\n<li>表示层</li>\n<li>会话层（SSL\\TLS）</li>\n<li>运输层（TCP，UDP）</li>\n<li>网络层（IP）</li>\n<li>数据链路层</li>\n<li>物理层</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"TCP-IP体系结构\"><a href=\"#TCP-IP体系结构\" class=\"headerlink\" title=\"TCP/IP体系结构\"></a>TCP/IP体系结构</h3><h4 id=\"五层协议\"><a href=\"#五层协议\" class=\"headerlink\" title=\"五层协议\"></a>五层协议</h4><ul>\n<li>应用层（http，ftp）</li>\n<li>运输层（TCP，UDP）</li>\n<li>网络层（IP）</li>\n<li>数据链路层</li>\n<li>物理层</li>\n</ul>\n<h4 id=\"四层协议\"><a href=\"#四层协议\" class=\"headerlink\" title=\"四层协议\"></a>四层协议</h4><ul>\n<li>应用层（http，ftp）</li>\n<li>运输层（TCP，UDP）</li>\n<li>网际层IP</li>\n<li>网络接口层</li>\n</ul>\n<h3 id=\"OSI模型\"><a href=\"#OSI模型\" class=\"headerlink\" title=\"OSI模型\"></a>OSI模型</h3><ul>\n<li>应用层（HTTP）</li>\n<li>表示层</li>\n<li>会话层（SSL\\TLS）</li>\n<li>运输层（TCP，UDP）</li>\n<li>网络层（IP）</li>\n<li>数据链路层</li>\n<li>物理层</li>\n</ul>\n"},{"title":"各种算法（二）","Date":"2019-03-26T16:00:00.000Z","comments":1,"_content":"\n求“123456789876543212345678987654321...”中的第n位\n```\nfunction index(n){\n  if(n%16<10){\n    return n%16;\n  }else{\n    return 9-(n%16-9);\n  }\n}\n\nconsole.log(index(26));//8\n```\n实现  \nadd(1);//1    \nadd(1)(2); //3  \nadd(1)(2)(3); //6\n\n```\nvar add = function(a) {\n    var sum = a;\n    var s = function(b) {\n        sum += b;\n        //s，继续累加后面的执行参数。\n        return s;\n    };\n    //当要打印一个对象时，会自动调用 valueOf()或 toString方法\n    s.toString = function() {\n        return sum;\n    };\n    //获取第一个参数赋值给sum后，s。\n    return s;\n};\n\nadd(1)(2)(3);//6\n//第一次调用add(),初始化了s，并将a保存在s的作用链中。\n//然后返回s保证了第二次调用的是s函数。\n//第二次之后的调用也是调用s，而在s中将传入的参数与保存在作用链中a相加并付给sum。\n```\n给定一个数组，返回所有的数字。如[1,'3',false,null,100]=>[1,3,100]\n\n```\nfunction search(arr){\n  var temp = [];\n  for(var i in arr){\n    if(typeof arr[i] == \"string\" || typeof arr[i] == \"number\"){\n      temp.push(arr[i]);\n    }\n  }\n  temp = temp.map(function(val){\n     if（typeof parseInt（val） == \"number\"）\n         return parseInt(val);\n  })\n  return temp;\n}\n\nconsole.log(search([1,'3',false,null,100])); //[1,3,100]\n```\n\n\n","source":"_posts/算法/各种算法（二）.md","raw":"---\ntitle: 各种算法（二）\nDate: 2019-03-27\ntags: [算法]\ncategories: 算法\ncomments: true\n---\n\n求“123456789876543212345678987654321...”中的第n位\n```\nfunction index(n){\n  if(n%16<10){\n    return n%16;\n  }else{\n    return 9-(n%16-9);\n  }\n}\n\nconsole.log(index(26));//8\n```\n实现  \nadd(1);//1    \nadd(1)(2); //3  \nadd(1)(2)(3); //6\n\n```\nvar add = function(a) {\n    var sum = a;\n    var s = function(b) {\n        sum += b;\n        //s，继续累加后面的执行参数。\n        return s;\n    };\n    //当要打印一个对象时，会自动调用 valueOf()或 toString方法\n    s.toString = function() {\n        return sum;\n    };\n    //获取第一个参数赋值给sum后，s。\n    return s;\n};\n\nadd(1)(2)(3);//6\n//第一次调用add(),初始化了s，并将a保存在s的作用链中。\n//然后返回s保证了第二次调用的是s函数。\n//第二次之后的调用也是调用s，而在s中将传入的参数与保存在作用链中a相加并付给sum。\n```\n给定一个数组，返回所有的数字。如[1,'3',false,null,100]=>[1,3,100]\n\n```\nfunction search(arr){\n  var temp = [];\n  for(var i in arr){\n    if(typeof arr[i] == \"string\" || typeof arr[i] == \"number\"){\n      temp.push(arr[i]);\n    }\n  }\n  temp = temp.map(function(val){\n     if（typeof parseInt（val） == \"number\"）\n         return parseInt(val);\n  })\n  return temp;\n}\n\nconsole.log(search([1,'3',false,null,100])); //[1,3,100]\n```\n\n\n","slug":"算法/各种算法（二）","published":1,"date":"2019-03-27T07:36:35.988Z","updated":"2019-03-27T07:38:39.075Z","layout":"post","photos":[],"link":"","_id":"cka6kini300axqgu9o8oanl30","content":"<p>求“123456789876543212345678987654321…”中的第n位<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function index(n)&#123;</span><br><span class=\"line\">  if(n%16&lt;10)&#123;</span><br><span class=\"line\">    return n%16;</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    return 9-(n%16-9);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(index(26));//8</span><br></pre></td></tr></table></figure></p>\n<p>实现<br>add(1);//1<br>add(1)(2); //3<br>add(1)(2)(3); //6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add = function(a) &#123;</span><br><span class=\"line\">    var sum = a;</span><br><span class=\"line\">    var s = function(b) &#123;</span><br><span class=\"line\">        sum += b;</span><br><span class=\"line\">        //s，继续累加后面的执行参数。</span><br><span class=\"line\">        return s;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //当要打印一个对象时，会自动调用 valueOf()或 toString方法</span><br><span class=\"line\">    s.toString = function() &#123;</span><br><span class=\"line\">        return sum;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //获取第一个参数赋值给sum后，s。</span><br><span class=\"line\">    return s;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">add(1)(2)(3);//6</span><br><span class=\"line\">//第一次调用add(),初始化了s，并将a保存在s的作用链中。</span><br><span class=\"line\">//然后返回s保证了第二次调用的是s函数。</span><br><span class=\"line\">//第二次之后的调用也是调用s，而在s中将传入的参数与保存在作用链中a相加并付给sum。</span><br></pre></td></tr></table></figure>\n<p>给定一个数组，返回所有的数字。如[1,’3’,false,null,100]=&gt;[1,3,100]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function search(arr)&#123;</span><br><span class=\"line\">  var temp = [];</span><br><span class=\"line\">  for(var i in arr)&#123;</span><br><span class=\"line\">    if(typeof arr[i] == &quot;string&quot; || typeof arr[i] == &quot;number&quot;)&#123;</span><br><span class=\"line\">      temp.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  temp = temp.map(function(val)&#123;</span><br><span class=\"line\">     if（typeof parseInt（val） == &quot;number&quot;）</span><br><span class=\"line\">         return parseInt(val);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(search([1,&apos;3&apos;,false,null,100])); //[1,3,100]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>求“123456789876543212345678987654321…”中的第n位<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function index(n)&#123;</span><br><span class=\"line\">  if(n%16&lt;10)&#123;</span><br><span class=\"line\">    return n%16;</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    return 9-(n%16-9);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(index(26));//8</span><br></pre></td></tr></table></figure></p>\n<p>实现<br>add(1);//1<br>add(1)(2); //3<br>add(1)(2)(3); //6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add = function(a) &#123;</span><br><span class=\"line\">    var sum = a;</span><br><span class=\"line\">    var s = function(b) &#123;</span><br><span class=\"line\">        sum += b;</span><br><span class=\"line\">        //s，继续累加后面的执行参数。</span><br><span class=\"line\">        return s;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //当要打印一个对象时，会自动调用 valueOf()或 toString方法</span><br><span class=\"line\">    s.toString = function() &#123;</span><br><span class=\"line\">        return sum;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //获取第一个参数赋值给sum后，s。</span><br><span class=\"line\">    return s;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">add(1)(2)(3);//6</span><br><span class=\"line\">//第一次调用add(),初始化了s，并将a保存在s的作用链中。</span><br><span class=\"line\">//然后返回s保证了第二次调用的是s函数。</span><br><span class=\"line\">//第二次之后的调用也是调用s，而在s中将传入的参数与保存在作用链中a相加并付给sum。</span><br></pre></td></tr></table></figure>\n<p>给定一个数组，返回所有的数字。如[1,’3’,false,null,100]=&gt;[1,3,100]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function search(arr)&#123;</span><br><span class=\"line\">  var temp = [];</span><br><span class=\"line\">  for(var i in arr)&#123;</span><br><span class=\"line\">    if(typeof arr[i] == &quot;string&quot; || typeof arr[i] == &quot;number&quot;)&#123;</span><br><span class=\"line\">      temp.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  temp = temp.map(function(val)&#123;</span><br><span class=\"line\">     if（typeof parseInt（val） == &quot;number&quot;）</span><br><span class=\"line\">         return parseInt(val);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(search([1,&apos;3&apos;,false,null,100])); //[1,3,100]</span><br></pre></td></tr></table></figure>\n"},{"title":"面向对象的程序设计","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\n# 理解对象\n### 面向对象和面向过程\n- 面向过程是分析出解决问题所需要的步骤，然后用函数把步骤一步一步实现，使用时一个一个依次调用就可以了。\n- 面向对象是把构成问题事务分解为各个对象，建立对象的目的是为了描述某个事物在整个解决问题的步骤中的行为。\n### 概念（我讲得通俗一点）\n- #### 类：js中没有类的概念，取了一个新的名字---原型对象\n- #### 原型对象：把猫（人、狗...）的特性提取出来，形成猫类（人类、狗类...），这个即为原型对象，代表着一类事物\n- #### 对象（实例）：猫类（人类、狗类...）中的A猫（A人、A狗...），即为对象实例，代表一个具体事物\n\n### 对象的属性类型\n一般为基本数据类型，也可以是另外的对象\n- #### 数据属性\n- #### 访问器属性\n> ##### 其特性详见书中139，感觉不会常用\n\n### 小结\n1. 在js中一切都是对象     \n2. 原型对象其实也是对象                 \n3. 判断一个对象实例具体是什么类型用instanceof运算符  \n（引用类型中有详讲）\n4. 面向对象三大要素：封装、继承、多态。\n\n---\n# 创建对象\n\n### 工厂模式（最古老）\n\n```\n这是一个能够根据接受的参数来构建一个包含所有必要信息的对象的函数\nfunction Person(name,age){\n    var o=new Object();   //创建对象实例，但无法得知对象的类型\n    o.name=name;                 //添加属性\n    o.age=age;\n    o.sayName=function(){       //添加方法\n        alert(this.name);\n    };\n    return o;                  //返回对象引用       \n}\nvar person1=Person(\"greg\",27);//调用函数创建对象实例\n\n```\n\n### 构造函数模式\n\n```\nfunction Person(name,age){\n    this.name=name;              //实例属性\n    this.age=age;\n    this.sayName=function(){  //实例方法（不同实例地址不一样）\n        alert(this.name);\n    };\n}\nvar person1=new Person(\"greg\",27);\n\n```\n\n### 原型模式\n\n```\nfunction Person(){  }\nPerson.prototype={\n    constructor:Person, //强制指向Person\n    name:\"greg\",        //原型属性\n    friend:[\"blue\",\"yellow\"],\n    sayName:function(){  //原型方法（共享，地址一样）\n        alert(this.name);\n    }\n};\nvar person1=new Person();\nvar person2=new Person();\nperson1.name=\"Lee\";   //重写person1的名字\nalert(person1.name);  //Lee\nalert(person2.name);  //Greg\nperson1.friend.push(\"black\");\nalert(person1.friend); //blue，yellow,black\nalert(person2.friend);//blue，yellow,black\n\n```\n\n小结：  \n1. 属性的查找是先从实例中找，实例中没有该属性，便从原型中找 \n2. 数组friend添加了一个项，是先从person1中找数组修改，由于没找到，所以顺着原型链找到原型中的数组并修改了\n3. 实例对象的__proto__指向，其构造函数的原型。构造函数的prototype获得构造函数的原型。构造函数原型的constructor指向对应的构造函数\n\n### 组合使用构造函数模式和原型模式（最佳）\n构造函数模式定义实例属性    \n原型模式定义方法和原型属性\n\n```\nfunction Person(name,age){\n    this.name=name;         //实例属性\n    this.age=age;\n}\nPerson.prototype={\n    constructor:Person,    //原型属性（共享）\n    sayName:function(){    //原型方法（共享）\n        alert(this.name);\n    }\n};\nvar person1=new Person(\"Greg\",27);\nperson1.sayName();      //\"Greg\"\n\n```\n\n### 动态原型模式\n\n```\nfunction Person(name,age){\n    this.name=name;\n    this.age=age;\n    //仅在第一次调用时初始化\n    if(typeof this.sayName!=\"function\"){\n        person.prototype.sayName=function(){\n            alert(this.name);  //将原型方法封装在构造函数中\n        };\n    }\n}\nvar person1=new Person(\"Greg\",27);\nperson1.sayName();      //\"Greg\"\n\n```\n\n### 寄生构造函数模式（工厂模式+构造函数模式）\n\n```\nfunction Person(name,age){\n    var o=new Object();\n    o.name=name;\n    o.age=age;\n    o.sayName=function(){\n        alert(this.name);\n    };\n    return o;\n}\nvar person1=new Person(\"Greg\",27);\nperson1.sayName();\n不能确定对象关系，不推荐使用\n\n```\n\n### 稳妥构造函数模式\n\n```\nfunction Person(name,age){\n    var o=new Object();\n    //可以在这里定义*私有*属性和方法\n    o.sayName=function(){\n    alert(name);\n    };\n    return o;\n}\nvar person1=Person(\"Greg\",27);\nperson1.sayName();\n不引用this，不使用new操作符\n但除了sayName()方法没有别的方法访问原始数据，安全性很高\n\n```\n\n# 继承\n### 原型链继承\n\n```\nfunction Super(){\n    this.val=1;\n    this.arr=[1];\n}\nSuper.prototype.getSuper=function(){\n    return true;                   //原型方法\n};\nfunction Sub(){  }\n//继承Super，把Super的对象实例赋给Sub的原型\nSub.prototype=new Super(); \nvar sub1=new Sub();\nvar sub2=new Sub();\nvar super1=new Super();\nsub1.val=2;\nalert(sub1.val);//2\nalert(sub2.val);//1\nsub1.arr.push(2);\nalert(sub1.arr);//1,2\nalert(sub2.arr);//1,2\nSub.prototype.getSuper=function(){  //重写方法\n    return false;    \n};\nalert(sub1.getSuper());//false  //调用重写后的方法\nalert(super1.getSuper());//true  //调用原来的方法\n\n```\n小结：     \n1. 重写方法或添加新方法需写在继承后        \n2. 属性查找是先从对象实例中找，没有就顺着原型链继续向上查找\n3. 创建子类实例时，无法向父类构造函数传参\n4. 父类方法和属性得到复用，子类实例没有自己的属性\n\n### 借用构造函数继承\n\n```\nfunction Super(val){\n    this.val=val;\n    this.arr=[1];\n    this.getSuper=function(){  };//方法在构造函数中，无法复用\n}\nfunction Sub(val){\n    Super.call(this,val); //继承Super，类似于对象冒充\n}\nvar sub1=new Sub(1);\nvar sub2=new Sub(2);\nalert(sub1.val);        //1\nalert(sub2.val);       //2\nalert(sub1.getSuper==sub2.getSuper);//false\n每个子类实例都有新的方法地址，内存要爆炸了！！！\n\n```\n小结：  \n子类的每个实例都有自己的属性、方法，不会相互影响，但是占用内存。\n\n### 组合继承（最常用）\n原型链：对原型属性和方法的继承     \n借用构造函数：对实例属性的继承\n\n```\nfunction Super(val){\n    this.val=val;\n    this.arr=[1];\n}\nSuper.prototype.getSuper=function(){\n    return true;                   //原型方法\n};\nfunction Sub(val){\n    Super.call(this,val);     //继承Super\n}\nSub.prototype=new Super();     //继承Super\nvar sub1=new Sub(1);\nvar sub2=new Sub(2);\nalert(sub1.val);        //1\nalert(sub2.val);       //2\nalert(sub1.getSuper==sub2.getSuper);//true\n\n```\n小结：\n1. 复用了方法，子类又有各自的属性。\n2. 因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例的属性覆盖掉，也存在内存浪费。\n\n### 原型式继承（类似于对象复制）\n创建新对象-->返回该对象-->增强（添加属性/方法）\n\n```\n// 生孩子函数 beget：龙beget龙，凤beget凤\n//创建新的obj的对象实例\nfunction beget(obj){   \n    var F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\n// 生孩子\nvar sub = beget(new Super());   // 核心\n// 添加属性\nsub.attr1 = 1;\nsub.attr2 = 2;\nalert(sub.val);     // 1\nalert(sub.arr);     // 1\nalert(sub.attr1);   // 1\n不像继承？\n\n```\n### 寄生式继承\n创建新对象-->增强-->返回该对象\n\n```\n// 生孩子函数 beget：龙beget龙，凤beget凤。\nfunction beget(obj){   \n    var F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\nfunction getSubObject(obj){\n    // 创建新对象\n    var clone = beget(obj); // 核心\n    // 添加属性\n    clone.attr1 = 1;\n    clone.attr2 = 2;\n \n    return clone;\n}\n \nvar sub = getSubObject(new Super());\nalert(sub.val);     // 1\nalert(sub.arr);     // 1\nalert(sub.attr1);   // 1\n给原型式继承穿个马甲？\n\n```\n### 寄生组合式继承（最佳，但组合继承最常用）\n有缺陷的寄生式继承+不完美的组合继承\n\n```\n// 生孩子函数 beget：龙beget龙，凤beget凤\n//创建新的obj的对象实例\nfunction beget(obj){   \n    var F = function(){};\n    F.prototype = obj;  \n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\n//  在此处声明函数\nSuper.prototype.getSuper = function(){};\nfunction Sub(){\n    Super.call(this);   // 继承\n}\n//继承，把实例赋给Sub的原型\nvar proto = beget(Super.prototype); \nproto.constructor = Sub;           \nSub.prototype = proto;             \n \nvar sub = new Sub();\nalert(sub.val);  //1\nalert(sub.arr);  //1\n\n```\n大总结：加油！棒棒哒！熬过这一章其余就轻松啦啦啦！已经写得尽可能详细了，多多复习！\n\n# ES6\n## 创建对象\n\n```\nclass father {\n    constructor(name,age){\n        this.name = name;\n        this.age = age;\n    }  //方法与方法之间不需要逗号分隔\n    run(){\n        console.log(\"ok\");\n    }\n}\nvar ming = new father(\"ming\",20);\nming.run(); //ok\nconsole.log(ming.name); //ming\n```\n## 继承\n\n```\nclass son extends father {\n    constructor(name,age,sex){\n        super(); //super方法要放在最前面\n        this.sex = sex; //添加新属性\n    }\n    run(){ //重写run方法\n   \t  \tconsole.log(\"true\");\n   \t}\n   \tget(){\n   \t    //添加新方法\n   \t}\n}\nvar hong = new son(\"hong\",2,\"女\");\nhong.run(); //true\nconsole.log(hong.sex);  //女\n```\n> 单词不要拼错：constructor\n\n\n\n","source":"_posts/js高级程序设计/面向对象的程序设计.md","raw":"---\ntitle: 面向对象的程序设计\nDate: 2020-03-17\ntags: [红宝书]\ncategories: 红宝书\ncomments: true\n---\n\n# 理解对象\n### 面向对象和面向过程\n- 面向过程是分析出解决问题所需要的步骤，然后用函数把步骤一步一步实现，使用时一个一个依次调用就可以了。\n- 面向对象是把构成问题事务分解为各个对象，建立对象的目的是为了描述某个事物在整个解决问题的步骤中的行为。\n### 概念（我讲得通俗一点）\n- #### 类：js中没有类的概念，取了一个新的名字---原型对象\n- #### 原型对象：把猫（人、狗...）的特性提取出来，形成猫类（人类、狗类...），这个即为原型对象，代表着一类事物\n- #### 对象（实例）：猫类（人类、狗类...）中的A猫（A人、A狗...），即为对象实例，代表一个具体事物\n\n### 对象的属性类型\n一般为基本数据类型，也可以是另外的对象\n- #### 数据属性\n- #### 访问器属性\n> ##### 其特性详见书中139，感觉不会常用\n\n### 小结\n1. 在js中一切都是对象     \n2. 原型对象其实也是对象                 \n3. 判断一个对象实例具体是什么类型用instanceof运算符  \n（引用类型中有详讲）\n4. 面向对象三大要素：封装、继承、多态。\n\n---\n# 创建对象\n\n### 工厂模式（最古老）\n\n```\n这是一个能够根据接受的参数来构建一个包含所有必要信息的对象的函数\nfunction Person(name,age){\n    var o=new Object();   //创建对象实例，但无法得知对象的类型\n    o.name=name;                 //添加属性\n    o.age=age;\n    o.sayName=function(){       //添加方法\n        alert(this.name);\n    };\n    return o;                  //返回对象引用       \n}\nvar person1=Person(\"greg\",27);//调用函数创建对象实例\n\n```\n\n### 构造函数模式\n\n```\nfunction Person(name,age){\n    this.name=name;              //实例属性\n    this.age=age;\n    this.sayName=function(){  //实例方法（不同实例地址不一样）\n        alert(this.name);\n    };\n}\nvar person1=new Person(\"greg\",27);\n\n```\n\n### 原型模式\n\n```\nfunction Person(){  }\nPerson.prototype={\n    constructor:Person, //强制指向Person\n    name:\"greg\",        //原型属性\n    friend:[\"blue\",\"yellow\"],\n    sayName:function(){  //原型方法（共享，地址一样）\n        alert(this.name);\n    }\n};\nvar person1=new Person();\nvar person2=new Person();\nperson1.name=\"Lee\";   //重写person1的名字\nalert(person1.name);  //Lee\nalert(person2.name);  //Greg\nperson1.friend.push(\"black\");\nalert(person1.friend); //blue，yellow,black\nalert(person2.friend);//blue，yellow,black\n\n```\n\n小结：  \n1. 属性的查找是先从实例中找，实例中没有该属性，便从原型中找 \n2. 数组friend添加了一个项，是先从person1中找数组修改，由于没找到，所以顺着原型链找到原型中的数组并修改了\n3. 实例对象的__proto__指向，其构造函数的原型。构造函数的prototype获得构造函数的原型。构造函数原型的constructor指向对应的构造函数\n\n### 组合使用构造函数模式和原型模式（最佳）\n构造函数模式定义实例属性    \n原型模式定义方法和原型属性\n\n```\nfunction Person(name,age){\n    this.name=name;         //实例属性\n    this.age=age;\n}\nPerson.prototype={\n    constructor:Person,    //原型属性（共享）\n    sayName:function(){    //原型方法（共享）\n        alert(this.name);\n    }\n};\nvar person1=new Person(\"Greg\",27);\nperson1.sayName();      //\"Greg\"\n\n```\n\n### 动态原型模式\n\n```\nfunction Person(name,age){\n    this.name=name;\n    this.age=age;\n    //仅在第一次调用时初始化\n    if(typeof this.sayName!=\"function\"){\n        person.prototype.sayName=function(){\n            alert(this.name);  //将原型方法封装在构造函数中\n        };\n    }\n}\nvar person1=new Person(\"Greg\",27);\nperson1.sayName();      //\"Greg\"\n\n```\n\n### 寄生构造函数模式（工厂模式+构造函数模式）\n\n```\nfunction Person(name,age){\n    var o=new Object();\n    o.name=name;\n    o.age=age;\n    o.sayName=function(){\n        alert(this.name);\n    };\n    return o;\n}\nvar person1=new Person(\"Greg\",27);\nperson1.sayName();\n不能确定对象关系，不推荐使用\n\n```\n\n### 稳妥构造函数模式\n\n```\nfunction Person(name,age){\n    var o=new Object();\n    //可以在这里定义*私有*属性和方法\n    o.sayName=function(){\n    alert(name);\n    };\n    return o;\n}\nvar person1=Person(\"Greg\",27);\nperson1.sayName();\n不引用this，不使用new操作符\n但除了sayName()方法没有别的方法访问原始数据，安全性很高\n\n```\n\n# 继承\n### 原型链继承\n\n```\nfunction Super(){\n    this.val=1;\n    this.arr=[1];\n}\nSuper.prototype.getSuper=function(){\n    return true;                   //原型方法\n};\nfunction Sub(){  }\n//继承Super，把Super的对象实例赋给Sub的原型\nSub.prototype=new Super(); \nvar sub1=new Sub();\nvar sub2=new Sub();\nvar super1=new Super();\nsub1.val=2;\nalert(sub1.val);//2\nalert(sub2.val);//1\nsub1.arr.push(2);\nalert(sub1.arr);//1,2\nalert(sub2.arr);//1,2\nSub.prototype.getSuper=function(){  //重写方法\n    return false;    \n};\nalert(sub1.getSuper());//false  //调用重写后的方法\nalert(super1.getSuper());//true  //调用原来的方法\n\n```\n小结：     \n1. 重写方法或添加新方法需写在继承后        \n2. 属性查找是先从对象实例中找，没有就顺着原型链继续向上查找\n3. 创建子类实例时，无法向父类构造函数传参\n4. 父类方法和属性得到复用，子类实例没有自己的属性\n\n### 借用构造函数继承\n\n```\nfunction Super(val){\n    this.val=val;\n    this.arr=[1];\n    this.getSuper=function(){  };//方法在构造函数中，无法复用\n}\nfunction Sub(val){\n    Super.call(this,val); //继承Super，类似于对象冒充\n}\nvar sub1=new Sub(1);\nvar sub2=new Sub(2);\nalert(sub1.val);        //1\nalert(sub2.val);       //2\nalert(sub1.getSuper==sub2.getSuper);//false\n每个子类实例都有新的方法地址，内存要爆炸了！！！\n\n```\n小结：  \n子类的每个实例都有自己的属性、方法，不会相互影响，但是占用内存。\n\n### 组合继承（最常用）\n原型链：对原型属性和方法的继承     \n借用构造函数：对实例属性的继承\n\n```\nfunction Super(val){\n    this.val=val;\n    this.arr=[1];\n}\nSuper.prototype.getSuper=function(){\n    return true;                   //原型方法\n};\nfunction Sub(val){\n    Super.call(this,val);     //继承Super\n}\nSub.prototype=new Super();     //继承Super\nvar sub1=new Sub(1);\nvar sub2=new Sub(2);\nalert(sub1.val);        //1\nalert(sub2.val);       //2\nalert(sub1.getSuper==sub2.getSuper);//true\n\n```\n小结：\n1. 复用了方法，子类又有各自的属性。\n2. 因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例的属性覆盖掉，也存在内存浪费。\n\n### 原型式继承（类似于对象复制）\n创建新对象-->返回该对象-->增强（添加属性/方法）\n\n```\n// 生孩子函数 beget：龙beget龙，凤beget凤\n//创建新的obj的对象实例\nfunction beget(obj){   \n    var F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\n// 生孩子\nvar sub = beget(new Super());   // 核心\n// 添加属性\nsub.attr1 = 1;\nsub.attr2 = 2;\nalert(sub.val);     // 1\nalert(sub.arr);     // 1\nalert(sub.attr1);   // 1\n不像继承？\n\n```\n### 寄生式继承\n创建新对象-->增强-->返回该对象\n\n```\n// 生孩子函数 beget：龙beget龙，凤beget凤。\nfunction beget(obj){   \n    var F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\nfunction getSubObject(obj){\n    // 创建新对象\n    var clone = beget(obj); // 核心\n    // 添加属性\n    clone.attr1 = 1;\n    clone.attr2 = 2;\n \n    return clone;\n}\n \nvar sub = getSubObject(new Super());\nalert(sub.val);     // 1\nalert(sub.arr);     // 1\nalert(sub.attr1);   // 1\n给原型式继承穿个马甲？\n\n```\n### 寄生组合式继承（最佳，但组合继承最常用）\n有缺陷的寄生式继承+不完美的组合继承\n\n```\n// 生孩子函数 beget：龙beget龙，凤beget凤\n//创建新的obj的对象实例\nfunction beget(obj){   \n    var F = function(){};\n    F.prototype = obj;  \n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\n//  在此处声明函数\nSuper.prototype.getSuper = function(){};\nfunction Sub(){\n    Super.call(this);   // 继承\n}\n//继承，把实例赋给Sub的原型\nvar proto = beget(Super.prototype); \nproto.constructor = Sub;           \nSub.prototype = proto;             \n \nvar sub = new Sub();\nalert(sub.val);  //1\nalert(sub.arr);  //1\n\n```\n大总结：加油！棒棒哒！熬过这一章其余就轻松啦啦啦！已经写得尽可能详细了，多多复习！\n\n# ES6\n## 创建对象\n\n```\nclass father {\n    constructor(name,age){\n        this.name = name;\n        this.age = age;\n    }  //方法与方法之间不需要逗号分隔\n    run(){\n        console.log(\"ok\");\n    }\n}\nvar ming = new father(\"ming\",20);\nming.run(); //ok\nconsole.log(ming.name); //ming\n```\n## 继承\n\n```\nclass son extends father {\n    constructor(name,age,sex){\n        super(); //super方法要放在最前面\n        this.sex = sex; //添加新属性\n    }\n    run(){ //重写run方法\n   \t  \tconsole.log(\"true\");\n   \t}\n   \tget(){\n   \t    //添加新方法\n   \t}\n}\nvar hong = new son(\"hong\",2,\"女\");\nhong.run(); //true\nconsole.log(hong.sex);  //女\n```\n> 单词不要拼错：constructor\n\n\n\n","slug":"js高级程序设计/面向对象的程序设计","published":1,"date":"2020-03-17T08:28:03.056Z","updated":"2020-03-17T08:28:40.285Z","layout":"post","photos":[],"link":"","_id":"cka6kint700gdqgu9i5q4jh2j","content":"<h1 id=\"理解对象\"><a href=\"#理解对象\" class=\"headerlink\" title=\"理解对象\"></a>理解对象</h1><h3 id=\"面向对象和面向过程\"><a href=\"#面向对象和面向过程\" class=\"headerlink\" title=\"面向对象和面向过程\"></a>面向对象和面向过程</h3><ul>\n<li>面向过程是分析出解决问题所需要的步骤，然后用函数把步骤一步一步实现，使用时一个一个依次调用就可以了。</li>\n<li>面向对象是把构成问题事务分解为各个对象，建立对象的目的是为了描述某个事物在整个解决问题的步骤中的行为。<h3 id=\"概念（我讲得通俗一点）\"><a href=\"#概念（我讲得通俗一点）\" class=\"headerlink\" title=\"概念（我讲得通俗一点）\"></a>概念（我讲得通俗一点）</h3></li>\n<li><h4 id=\"类：js中没有类的概念，取了一个新的名字—原型对象\"><a href=\"#类：js中没有类的概念，取了一个新的名字—原型对象\" class=\"headerlink\" title=\"类：js中没有类的概念，取了一个新的名字—原型对象\"></a>类：js中没有类的概念，取了一个新的名字—原型对象</h4></li>\n<li><h4 id=\"原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物\"><a href=\"#原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物\" class=\"headerlink\" title=\"原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物\"></a>原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物</h4></li>\n<li><h4 id=\"对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物\"><a href=\"#对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物\" class=\"headerlink\" title=\"对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物\"></a>对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物</h4></li>\n</ul>\n<h3 id=\"对象的属性类型\"><a href=\"#对象的属性类型\" class=\"headerlink\" title=\"对象的属性类型\"></a>对象的属性类型</h3><p>一般为基本数据类型，也可以是另外的对象</p>\n<ul>\n<li><h4 id=\"数据属性\"><a href=\"#数据属性\" class=\"headerlink\" title=\"数据属性\"></a>数据属性</h4></li>\n<li><h4 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h4><blockquote>\n<h5 id=\"其特性详见书中139，感觉不会常用\"><a href=\"#其特性详见书中139，感觉不会常用\" class=\"headerlink\" title=\"其特性详见书中139，感觉不会常用\"></a>其特性详见书中139，感觉不会常用</h5></blockquote>\n</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li>在js中一切都是对象     </li>\n<li>原型对象其实也是对象                 </li>\n<li>判断一个对象实例具体是什么类型用instanceof运算符<br>（引用类型中有详讲）</li>\n<li>面向对象三大要素：封装、继承、多态。</li>\n</ol>\n<hr>\n<h1 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h1><h3 id=\"工厂模式（最古老）\"><a href=\"#工厂模式（最古老）\" class=\"headerlink\" title=\"工厂模式（最古老）\"></a>工厂模式（最古老）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个能够根据接受的参数来构建一个包含所有必要信息的对象的函数</span><br><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    var o=new Object();   //创建对象实例，但无法得知对象的类型</span><br><span class=\"line\">    o.name=name;                 //添加属性</span><br><span class=\"line\">    o.age=age;</span><br><span class=\"line\">    o.sayName=function()&#123;       //添加方法</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return o;                  //返回对象引用       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=Person(&quot;greg&quot;,27);//调用函数创建对象实例</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    this.name=name;              //实例属性</span><br><span class=\"line\">    this.age=age;</span><br><span class=\"line\">    this.sayName=function()&#123;  //实例方法（不同实例地址不一样）</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=new Person(&quot;greg&quot;,27);</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;  &#125;</span><br><span class=\"line\">Person.prototype=&#123;</span><br><span class=\"line\">    constructor:Person, //强制指向Person</span><br><span class=\"line\">    name:&quot;greg&quot;,        //原型属性</span><br><span class=\"line\">    friend:[&quot;blue&quot;,&quot;yellow&quot;],</span><br><span class=\"line\">    sayName:function()&#123;  //原型方法（共享，地址一样）</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var person1=new Person();</span><br><span class=\"line\">var person2=new Person();</span><br><span class=\"line\">person1.name=&quot;Lee&quot;;   //重写person1的名字</span><br><span class=\"line\">alert(person1.name);  //Lee</span><br><span class=\"line\">alert(person2.name);  //Greg</span><br><span class=\"line\">person1.friend.push(&quot;black&quot;);</span><br><span class=\"line\">alert(person1.friend); //blue，yellow,black</span><br><span class=\"line\">alert(person2.friend);//blue，yellow,black</span><br></pre></td></tr></table></figure>\n<p>小结：  </p>\n<ol>\n<li>属性的查找是先从实例中找，实例中没有该属性，便从原型中找 </li>\n<li>数组friend添加了一个项，是先从person1中找数组修改，由于没找到，所以顺着原型链找到原型中的数组并修改了</li>\n<li>实例对象的<strong>proto</strong>指向，其构造函数的原型。构造函数的prototype获得构造函数的原型。构造函数原型的constructor指向对应的构造函数</li>\n</ol>\n<h3 id=\"组合使用构造函数模式和原型模式（最佳）\"><a href=\"#组合使用构造函数模式和原型模式（最佳）\" class=\"headerlink\" title=\"组合使用构造函数模式和原型模式（最佳）\"></a>组合使用构造函数模式和原型模式（最佳）</h3><p>构造函数模式定义实例属性<br>原型模式定义方法和原型属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    this.name=name;         //实例属性</span><br><span class=\"line\">    this.age=age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype=&#123;</span><br><span class=\"line\">    constructor:Person,    //原型属性（共享）</span><br><span class=\"line\">    sayName:function()&#123;    //原型方法（共享）</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var person1=new Person(&quot;Greg&quot;,27);</span><br><span class=\"line\">person1.sayName();      //&quot;Greg&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    this.name=name;</span><br><span class=\"line\">    this.age=age;</span><br><span class=\"line\">    //仅在第一次调用时初始化</span><br><span class=\"line\">    if(typeof this.sayName!=&quot;function&quot;)&#123;</span><br><span class=\"line\">        person.prototype.sayName=function()&#123;</span><br><span class=\"line\">            alert(this.name);  //将原型方法封装在构造函数中</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=new Person(&quot;Greg&quot;,27);</span><br><span class=\"line\">person1.sayName();      //&quot;Greg&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生构造函数模式（工厂模式-构造函数模式）\"><a href=\"#寄生构造函数模式（工厂模式-构造函数模式）\" class=\"headerlink\" title=\"寄生构造函数模式（工厂模式+构造函数模式）\"></a>寄生构造函数模式（工厂模式+构造函数模式）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    var o=new Object();</span><br><span class=\"line\">    o.name=name;</span><br><span class=\"line\">    o.age=age;</span><br><span class=\"line\">    o.sayName=function()&#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=new Person(&quot;Greg&quot;,27);</span><br><span class=\"line\">person1.sayName();</span><br><span class=\"line\">不能确定对象关系，不推荐使用</span><br></pre></td></tr></table></figure>\n<h3 id=\"稳妥构造函数模式\"><a href=\"#稳妥构造函数模式\" class=\"headerlink\" title=\"稳妥构造函数模式\"></a>稳妥构造函数模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    var o=new Object();</span><br><span class=\"line\">    //可以在这里定义*私有*属性和方法</span><br><span class=\"line\">    o.sayName=function()&#123;</span><br><span class=\"line\">    alert(name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=Person(&quot;Greg&quot;,27);</span><br><span class=\"line\">person1.sayName();</span><br><span class=\"line\">不引用this，不使用new操作符</span><br><span class=\"line\">但除了sayName()方法没有别的方法访问原始数据，安全性很高</span><br></pre></td></tr></table></figure>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val=1;</span><br><span class=\"line\">    this.arr=[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.getSuper=function()&#123;</span><br><span class=\"line\">    return true;                   //原型方法</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Sub()&#123;  &#125;</span><br><span class=\"line\">//继承Super，把Super的对象实例赋给Sub的原型</span><br><span class=\"line\">Sub.prototype=new Super(); </span><br><span class=\"line\">var sub1=new Sub();</span><br><span class=\"line\">var sub2=new Sub();</span><br><span class=\"line\">var super1=new Super();</span><br><span class=\"line\">sub1.val=2;</span><br><span class=\"line\">alert(sub1.val);//2</span><br><span class=\"line\">alert(sub2.val);//1</span><br><span class=\"line\">sub1.arr.push(2);</span><br><span class=\"line\">alert(sub1.arr);//1,2</span><br><span class=\"line\">alert(sub2.arr);//1,2</span><br><span class=\"line\">Sub.prototype.getSuper=function()&#123;  //重写方法</span><br><span class=\"line\">    return false;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(sub1.getSuper());//false  //调用重写后的方法</span><br><span class=\"line\">alert(super1.getSuper());//true  //调用原来的方法</span><br></pre></td></tr></table></figure>\n<p>小结：     </p>\n<ol>\n<li>重写方法或添加新方法需写在继承后        </li>\n<li>属性查找是先从对象实例中找，没有就顺着原型链继续向上查找</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n<li>父类方法和属性得到复用，子类实例没有自己的属性</li>\n</ol>\n<h3 id=\"借用构造函数继承\"><a href=\"#借用构造函数继承\" class=\"headerlink\" title=\"借用构造函数继承\"></a>借用构造函数继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super(val)&#123;</span><br><span class=\"line\">    this.val=val;</span><br><span class=\"line\">    this.arr=[1];</span><br><span class=\"line\">    this.getSuper=function()&#123;  &#125;;//方法在构造函数中，无法复用</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub(val)&#123;</span><br><span class=\"line\">    Super.call(this,val); //继承Super，类似于对象冒充</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sub1=new Sub(1);</span><br><span class=\"line\">var sub2=new Sub(2);</span><br><span class=\"line\">alert(sub1.val);        //1</span><br><span class=\"line\">alert(sub2.val);       //2</span><br><span class=\"line\">alert(sub1.getSuper==sub2.getSuper);//false</span><br><span class=\"line\">每个子类实例都有新的方法地址，内存要爆炸了！！！</span><br></pre></td></tr></table></figure>\n<p>小结：<br>子类的每个实例都有自己的属性、方法，不会相互影响，但是占用内存。</p>\n<h3 id=\"组合继承（最常用）\"><a href=\"#组合继承（最常用）\" class=\"headerlink\" title=\"组合继承（最常用）\"></a>组合继承（最常用）</h3><p>原型链：对原型属性和方法的继承<br>借用构造函数：对实例属性的继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super(val)&#123;</span><br><span class=\"line\">    this.val=val;</span><br><span class=\"line\">    this.arr=[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.getSuper=function()&#123;</span><br><span class=\"line\">    return true;                   //原型方法</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Sub(val)&#123;</span><br><span class=\"line\">    Super.call(this,val);     //继承Super</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype=new Super();     //继承Super</span><br><span class=\"line\">var sub1=new Sub(1);</span><br><span class=\"line\">var sub2=new Sub(2);</span><br><span class=\"line\">alert(sub1.val);        //1</span><br><span class=\"line\">alert(sub2.val);       //2</span><br><span class=\"line\">alert(sub1.getSuper==sub2.getSuper);//true</span><br></pre></td></tr></table></figure>\n<p>小结：</p>\n<ol>\n<li>复用了方法，子类又有各自的属性。</li>\n<li>因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例的属性覆盖掉，也存在内存浪费。</li>\n</ol>\n<h3 id=\"原型式继承（类似于对象复制）\"><a href=\"#原型式继承（类似于对象复制）\" class=\"headerlink\" title=\"原型式继承（类似于对象复制）\"></a>原型式继承（类似于对象复制）</h3><p>创建新对象–&gt;返回该对象–&gt;增强（添加属性/方法）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 生孩子函数 beget：龙beget龙，凤beget凤</span><br><span class=\"line\">//创建新的obj的对象实例</span><br><span class=\"line\">function beget(obj)&#123;   </span><br><span class=\"line\">    var F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 生孩子</span><br><span class=\"line\">var sub = beget(new Super());   // 核心</span><br><span class=\"line\">// 添加属性</span><br><span class=\"line\">sub.attr1 = 1;</span><br><span class=\"line\">sub.attr2 = 2;</span><br><span class=\"line\">alert(sub.val);     // 1</span><br><span class=\"line\">alert(sub.arr);     // 1</span><br><span class=\"line\">alert(sub.attr1);   // 1</span><br><span class=\"line\">不像继承？</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3><p>创建新对象–&gt;增强–&gt;返回该对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 生孩子函数 beget：龙beget龙，凤beget凤。</span><br><span class=\"line\">function beget(obj)&#123;   </span><br><span class=\"line\">    var F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function getSubObject(obj)&#123;</span><br><span class=\"line\">    // 创建新对象</span><br><span class=\"line\">    var clone = beget(obj); // 核心</span><br><span class=\"line\">    // 添加属性</span><br><span class=\"line\">    clone.attr1 = 1;</span><br><span class=\"line\">    clone.attr2 = 2;</span><br><span class=\"line\"> </span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">var sub = getSubObject(new Super());</span><br><span class=\"line\">alert(sub.val);     // 1</span><br><span class=\"line\">alert(sub.arr);     // 1</span><br><span class=\"line\">alert(sub.attr1);   // 1</span><br><span class=\"line\">给原型式继承穿个马甲？</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生组合式继承（最佳，但组合继承最常用）\"><a href=\"#寄生组合式继承（最佳，但组合继承最常用）\" class=\"headerlink\" title=\"寄生组合式继承（最佳，但组合继承最常用）\"></a>寄生组合式继承（最佳，但组合继承最常用）</h3><p>有缺陷的寄生式继承+不完美的组合继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 生孩子函数 beget：龙beget龙，凤beget凤</span><br><span class=\"line\">//创建新的obj的对象实例</span><br><span class=\"line\">function beget(obj)&#123;   </span><br><span class=\"line\">    var F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;  </span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.getSuper = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 继承</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//继承，把实例赋给Sub的原型</span><br><span class=\"line\">var proto = beget(Super.prototype); </span><br><span class=\"line\">proto.constructor = Sub;           </span><br><span class=\"line\">Sub.prototype = proto;             </span><br><span class=\"line\"> </span><br><span class=\"line\">var sub = new Sub();</span><br><span class=\"line\">alert(sub.val);  //1</span><br><span class=\"line\">alert(sub.arr);  //1</span><br></pre></td></tr></table></figure>\n<p>大总结：加油！棒棒哒！熬过这一章其余就轻松啦啦啦！已经写得尽可能详细了，多多复习！</p>\n<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><h2 id=\"创建对象-1\"><a href=\"#创建对象-1\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class father &#123;</span><br><span class=\"line\">    constructor(name,age)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;  //方法与方法之间不需要逗号分隔</span><br><span class=\"line\">    run()&#123;</span><br><span class=\"line\">        console.log(&quot;ok&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var ming = new father(&quot;ming&quot;,20);</span><br><span class=\"line\">ming.run(); //ok</span><br><span class=\"line\">console.log(ming.name); //ming</span><br></pre></td></tr></table></figure>\n<h2 id=\"继承-1\"><a href=\"#继承-1\" class=\"headerlink\" title=\"继承\"></a>继承</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends father &#123;</span><br><span class=\"line\">    constructor(name,age,sex)&#123;</span><br><span class=\"line\">        super(); //super方法要放在最前面</span><br><span class=\"line\">        this.sex = sex; //添加新属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run()&#123; //重写run方法</span><br><span class=\"line\">   \t  \tconsole.log(&quot;true&quot;);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \tget()&#123;</span><br><span class=\"line\">   \t    //添加新方法</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var hong = new son(&quot;hong&quot;,2,&quot;女&quot;);</span><br><span class=\"line\">hong.run(); //true</span><br><span class=\"line\">console.log(hong.sex);  //女</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单词不要拼错：constructor</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"理解对象\"><a href=\"#理解对象\" class=\"headerlink\" title=\"理解对象\"></a>理解对象</h1><h3 id=\"面向对象和面向过程\"><a href=\"#面向对象和面向过程\" class=\"headerlink\" title=\"面向对象和面向过程\"></a>面向对象和面向过程</h3><ul>\n<li>面向过程是分析出解决问题所需要的步骤，然后用函数把步骤一步一步实现，使用时一个一个依次调用就可以了。</li>\n<li>面向对象是把构成问题事务分解为各个对象，建立对象的目的是为了描述某个事物在整个解决问题的步骤中的行为。<h3 id=\"概念（我讲得通俗一点）\"><a href=\"#概念（我讲得通俗一点）\" class=\"headerlink\" title=\"概念（我讲得通俗一点）\"></a>概念（我讲得通俗一点）</h3></li>\n<li><h4 id=\"类：js中没有类的概念，取了一个新的名字—原型对象\"><a href=\"#类：js中没有类的概念，取了一个新的名字—原型对象\" class=\"headerlink\" title=\"类：js中没有类的概念，取了一个新的名字—原型对象\"></a>类：js中没有类的概念，取了一个新的名字—原型对象</h4></li>\n<li><h4 id=\"原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物\"><a href=\"#原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物\" class=\"headerlink\" title=\"原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物\"></a>原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物</h4></li>\n<li><h4 id=\"对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物\"><a href=\"#对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物\" class=\"headerlink\" title=\"对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物\"></a>对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物</h4></li>\n</ul>\n<h3 id=\"对象的属性类型\"><a href=\"#对象的属性类型\" class=\"headerlink\" title=\"对象的属性类型\"></a>对象的属性类型</h3><p>一般为基本数据类型，也可以是另外的对象</p>\n<ul>\n<li><h4 id=\"数据属性\"><a href=\"#数据属性\" class=\"headerlink\" title=\"数据属性\"></a>数据属性</h4></li>\n<li><h4 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h4><blockquote>\n<h5 id=\"其特性详见书中139，感觉不会常用\"><a href=\"#其特性详见书中139，感觉不会常用\" class=\"headerlink\" title=\"其特性详见书中139，感觉不会常用\"></a>其特性详见书中139，感觉不会常用</h5></blockquote>\n</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li>在js中一切都是对象     </li>\n<li>原型对象其实也是对象                 </li>\n<li>判断一个对象实例具体是什么类型用instanceof运算符<br>（引用类型中有详讲）</li>\n<li>面向对象三大要素：封装、继承、多态。</li>\n</ol>\n<hr>\n<h1 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h1><h3 id=\"工厂模式（最古老）\"><a href=\"#工厂模式（最古老）\" class=\"headerlink\" title=\"工厂模式（最古老）\"></a>工厂模式（最古老）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个能够根据接受的参数来构建一个包含所有必要信息的对象的函数</span><br><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    var o=new Object();   //创建对象实例，但无法得知对象的类型</span><br><span class=\"line\">    o.name=name;                 //添加属性</span><br><span class=\"line\">    o.age=age;</span><br><span class=\"line\">    o.sayName=function()&#123;       //添加方法</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return o;                  //返回对象引用       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=Person(&quot;greg&quot;,27);//调用函数创建对象实例</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    this.name=name;              //实例属性</span><br><span class=\"line\">    this.age=age;</span><br><span class=\"line\">    this.sayName=function()&#123;  //实例方法（不同实例地址不一样）</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=new Person(&quot;greg&quot;,27);</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;  &#125;</span><br><span class=\"line\">Person.prototype=&#123;</span><br><span class=\"line\">    constructor:Person, //强制指向Person</span><br><span class=\"line\">    name:&quot;greg&quot;,        //原型属性</span><br><span class=\"line\">    friend:[&quot;blue&quot;,&quot;yellow&quot;],</span><br><span class=\"line\">    sayName:function()&#123;  //原型方法（共享，地址一样）</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var person1=new Person();</span><br><span class=\"line\">var person2=new Person();</span><br><span class=\"line\">person1.name=&quot;Lee&quot;;   //重写person1的名字</span><br><span class=\"line\">alert(person1.name);  //Lee</span><br><span class=\"line\">alert(person2.name);  //Greg</span><br><span class=\"line\">person1.friend.push(&quot;black&quot;);</span><br><span class=\"line\">alert(person1.friend); //blue，yellow,black</span><br><span class=\"line\">alert(person2.friend);//blue，yellow,black</span><br></pre></td></tr></table></figure>\n<p>小结：  </p>\n<ol>\n<li>属性的查找是先从实例中找，实例中没有该属性，便从原型中找 </li>\n<li>数组friend添加了一个项，是先从person1中找数组修改，由于没找到，所以顺着原型链找到原型中的数组并修改了</li>\n<li>实例对象的<strong>proto</strong>指向，其构造函数的原型。构造函数的prototype获得构造函数的原型。构造函数原型的constructor指向对应的构造函数</li>\n</ol>\n<h3 id=\"组合使用构造函数模式和原型模式（最佳）\"><a href=\"#组合使用构造函数模式和原型模式（最佳）\" class=\"headerlink\" title=\"组合使用构造函数模式和原型模式（最佳）\"></a>组合使用构造函数模式和原型模式（最佳）</h3><p>构造函数模式定义实例属性<br>原型模式定义方法和原型属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    this.name=name;         //实例属性</span><br><span class=\"line\">    this.age=age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype=&#123;</span><br><span class=\"line\">    constructor:Person,    //原型属性（共享）</span><br><span class=\"line\">    sayName:function()&#123;    //原型方法（共享）</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var person1=new Person(&quot;Greg&quot;,27);</span><br><span class=\"line\">person1.sayName();      //&quot;Greg&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    this.name=name;</span><br><span class=\"line\">    this.age=age;</span><br><span class=\"line\">    //仅在第一次调用时初始化</span><br><span class=\"line\">    if(typeof this.sayName!=&quot;function&quot;)&#123;</span><br><span class=\"line\">        person.prototype.sayName=function()&#123;</span><br><span class=\"line\">            alert(this.name);  //将原型方法封装在构造函数中</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=new Person(&quot;Greg&quot;,27);</span><br><span class=\"line\">person1.sayName();      //&quot;Greg&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生构造函数模式（工厂模式-构造函数模式）\"><a href=\"#寄生构造函数模式（工厂模式-构造函数模式）\" class=\"headerlink\" title=\"寄生构造函数模式（工厂模式+构造函数模式）\"></a>寄生构造函数模式（工厂模式+构造函数模式）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    var o=new Object();</span><br><span class=\"line\">    o.name=name;</span><br><span class=\"line\">    o.age=age;</span><br><span class=\"line\">    o.sayName=function()&#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=new Person(&quot;Greg&quot;,27);</span><br><span class=\"line\">person1.sayName();</span><br><span class=\"line\">不能确定对象关系，不推荐使用</span><br></pre></td></tr></table></figure>\n<h3 id=\"稳妥构造函数模式\"><a href=\"#稳妥构造函数模式\" class=\"headerlink\" title=\"稳妥构造函数模式\"></a>稳妥构造函数模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    var o=new Object();</span><br><span class=\"line\">    //可以在这里定义*私有*属性和方法</span><br><span class=\"line\">    o.sayName=function()&#123;</span><br><span class=\"line\">    alert(name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1=Person(&quot;Greg&quot;,27);</span><br><span class=\"line\">person1.sayName();</span><br><span class=\"line\">不引用this，不使用new操作符</span><br><span class=\"line\">但除了sayName()方法没有别的方法访问原始数据，安全性很高</span><br></pre></td></tr></table></figure>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val=1;</span><br><span class=\"line\">    this.arr=[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.getSuper=function()&#123;</span><br><span class=\"line\">    return true;                   //原型方法</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Sub()&#123;  &#125;</span><br><span class=\"line\">//继承Super，把Super的对象实例赋给Sub的原型</span><br><span class=\"line\">Sub.prototype=new Super(); </span><br><span class=\"line\">var sub1=new Sub();</span><br><span class=\"line\">var sub2=new Sub();</span><br><span class=\"line\">var super1=new Super();</span><br><span class=\"line\">sub1.val=2;</span><br><span class=\"line\">alert(sub1.val);//2</span><br><span class=\"line\">alert(sub2.val);//1</span><br><span class=\"line\">sub1.arr.push(2);</span><br><span class=\"line\">alert(sub1.arr);//1,2</span><br><span class=\"line\">alert(sub2.arr);//1,2</span><br><span class=\"line\">Sub.prototype.getSuper=function()&#123;  //重写方法</span><br><span class=\"line\">    return false;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(sub1.getSuper());//false  //调用重写后的方法</span><br><span class=\"line\">alert(super1.getSuper());//true  //调用原来的方法</span><br></pre></td></tr></table></figure>\n<p>小结：     </p>\n<ol>\n<li>重写方法或添加新方法需写在继承后        </li>\n<li>属性查找是先从对象实例中找，没有就顺着原型链继续向上查找</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n<li>父类方法和属性得到复用，子类实例没有自己的属性</li>\n</ol>\n<h3 id=\"借用构造函数继承\"><a href=\"#借用构造函数继承\" class=\"headerlink\" title=\"借用构造函数继承\"></a>借用构造函数继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super(val)&#123;</span><br><span class=\"line\">    this.val=val;</span><br><span class=\"line\">    this.arr=[1];</span><br><span class=\"line\">    this.getSuper=function()&#123;  &#125;;//方法在构造函数中，无法复用</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub(val)&#123;</span><br><span class=\"line\">    Super.call(this,val); //继承Super，类似于对象冒充</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sub1=new Sub(1);</span><br><span class=\"line\">var sub2=new Sub(2);</span><br><span class=\"line\">alert(sub1.val);        //1</span><br><span class=\"line\">alert(sub2.val);       //2</span><br><span class=\"line\">alert(sub1.getSuper==sub2.getSuper);//false</span><br><span class=\"line\">每个子类实例都有新的方法地址，内存要爆炸了！！！</span><br></pre></td></tr></table></figure>\n<p>小结：<br>子类的每个实例都有自己的属性、方法，不会相互影响，但是占用内存。</p>\n<h3 id=\"组合继承（最常用）\"><a href=\"#组合继承（最常用）\" class=\"headerlink\" title=\"组合继承（最常用）\"></a>组合继承（最常用）</h3><p>原型链：对原型属性和方法的继承<br>借用构造函数：对实例属性的继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super(val)&#123;</span><br><span class=\"line\">    this.val=val;</span><br><span class=\"line\">    this.arr=[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.getSuper=function()&#123;</span><br><span class=\"line\">    return true;                   //原型方法</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Sub(val)&#123;</span><br><span class=\"line\">    Super.call(this,val);     //继承Super</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype=new Super();     //继承Super</span><br><span class=\"line\">var sub1=new Sub(1);</span><br><span class=\"line\">var sub2=new Sub(2);</span><br><span class=\"line\">alert(sub1.val);        //1</span><br><span class=\"line\">alert(sub2.val);       //2</span><br><span class=\"line\">alert(sub1.getSuper==sub2.getSuper);//true</span><br></pre></td></tr></table></figure>\n<p>小结：</p>\n<ol>\n<li>复用了方法，子类又有各自的属性。</li>\n<li>因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例的属性覆盖掉，也存在内存浪费。</li>\n</ol>\n<h3 id=\"原型式继承（类似于对象复制）\"><a href=\"#原型式继承（类似于对象复制）\" class=\"headerlink\" title=\"原型式继承（类似于对象复制）\"></a>原型式继承（类似于对象复制）</h3><p>创建新对象–&gt;返回该对象–&gt;增强（添加属性/方法）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 生孩子函数 beget：龙beget龙，凤beget凤</span><br><span class=\"line\">//创建新的obj的对象实例</span><br><span class=\"line\">function beget(obj)&#123;   </span><br><span class=\"line\">    var F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 生孩子</span><br><span class=\"line\">var sub = beget(new Super());   // 核心</span><br><span class=\"line\">// 添加属性</span><br><span class=\"line\">sub.attr1 = 1;</span><br><span class=\"line\">sub.attr2 = 2;</span><br><span class=\"line\">alert(sub.val);     // 1</span><br><span class=\"line\">alert(sub.arr);     // 1</span><br><span class=\"line\">alert(sub.attr1);   // 1</span><br><span class=\"line\">不像继承？</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3><p>创建新对象–&gt;增强–&gt;返回该对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 生孩子函数 beget：龙beget龙，凤beget凤。</span><br><span class=\"line\">function beget(obj)&#123;   </span><br><span class=\"line\">    var F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function getSubObject(obj)&#123;</span><br><span class=\"line\">    // 创建新对象</span><br><span class=\"line\">    var clone = beget(obj); // 核心</span><br><span class=\"line\">    // 添加属性</span><br><span class=\"line\">    clone.attr1 = 1;</span><br><span class=\"line\">    clone.attr2 = 2;</span><br><span class=\"line\"> </span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">var sub = getSubObject(new Super());</span><br><span class=\"line\">alert(sub.val);     // 1</span><br><span class=\"line\">alert(sub.arr);     // 1</span><br><span class=\"line\">alert(sub.attr1);   // 1</span><br><span class=\"line\">给原型式继承穿个马甲？</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生组合式继承（最佳，但组合继承最常用）\"><a href=\"#寄生组合式继承（最佳，但组合继承最常用）\" class=\"headerlink\" title=\"寄生组合式继承（最佳，但组合继承最常用）\"></a>寄生组合式继承（最佳，但组合继承最常用）</h3><p>有缺陷的寄生式继承+不完美的组合继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 生孩子函数 beget：龙beget龙，凤beget凤</span><br><span class=\"line\">//创建新的obj的对象实例</span><br><span class=\"line\">function beget(obj)&#123;   </span><br><span class=\"line\">    var F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;  </span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.getSuper = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 继承</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//继承，把实例赋给Sub的原型</span><br><span class=\"line\">var proto = beget(Super.prototype); </span><br><span class=\"line\">proto.constructor = Sub;           </span><br><span class=\"line\">Sub.prototype = proto;             </span><br><span class=\"line\"> </span><br><span class=\"line\">var sub = new Sub();</span><br><span class=\"line\">alert(sub.val);  //1</span><br><span class=\"line\">alert(sub.arr);  //1</span><br></pre></td></tr></table></figure>\n<p>大总结：加油！棒棒哒！熬过这一章其余就轻松啦啦啦！已经写得尽可能详细了，多多复习！</p>\n<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><h2 id=\"创建对象-1\"><a href=\"#创建对象-1\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class father &#123;</span><br><span class=\"line\">    constructor(name,age)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;  //方法与方法之间不需要逗号分隔</span><br><span class=\"line\">    run()&#123;</span><br><span class=\"line\">        console.log(&quot;ok&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var ming = new father(&quot;ming&quot;,20);</span><br><span class=\"line\">ming.run(); //ok</span><br><span class=\"line\">console.log(ming.name); //ming</span><br></pre></td></tr></table></figure>\n<h2 id=\"继承-1\"><a href=\"#继承-1\" class=\"headerlink\" title=\"继承\"></a>继承</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends father &#123;</span><br><span class=\"line\">    constructor(name,age,sex)&#123;</span><br><span class=\"line\">        super(); //super方法要放在最前面</span><br><span class=\"line\">        this.sex = sex; //添加新属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run()&#123; //重写run方法</span><br><span class=\"line\">   \t  \tconsole.log(&quot;true&quot;);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \tget()&#123;</span><br><span class=\"line\">   \t    //添加新方法</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var hong = new son(&quot;hong&quot;,2,&quot;女&quot;);</span><br><span class=\"line\">hong.run(); //true</span><br><span class=\"line\">console.log(hong.sex);  //女</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单词不要拼错：constructor</p>\n</blockquote>\n"},{"title":"函数表达式","Date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"\n# 函数表达式\n## 定义函数的方式\n\n#### 使用函数声明\n\n```\nfunction 函数名(参数){\n    //函数体\n}\n可通过name属性访问函数名（即标识符）（有何意义？）\nalert(函数名.name);//函数名   \n\n```\n\n#### 使用函数表达式\n\n这种情况下创建的函数叫匿名函数    \n顾名思义，因为 function关键字后面没有函数名（即标识符）\n```\nvar 变量=function(){\n    //函数体\n};\n\n```\n\n#### 两者的主要区别\n\n（1） 函数声明无论置于调用语句前后，解析器都会先读取函数声明  \n\n> 后面不能跟圆括号\n\n由于函数声明的一个重要特征---*函数声明提升*（在执行代码之前会先读取函数声明）这意味着可以把函数声明放在调用它的语句后面\n\n（2）函数表达式则要等到解析器执行到它所在代码行才被真正执行\n> 后面可以跟圆括号，表示立即自我执行\n\n则函数表达式需要先把函数赋值给变量，再调用函数\n\n# 递归\n\n### 递归函数\n是在一个函数通过名字调用自身的情况下构成的\n\n```\nfunction factorial(num){\n    if(num<=1){\n        return 1;\n    }else{\n        return num*factorial(num-1);\n    }\n}\n\n```\n缺点：把该函数保存在另一个变量中，且将factorial变量设置为null时（即当函数名改变了时），导致错误\n\n### 改进\narguments.callee是一个指向正在执行的函数的指针，通俗一点讲就是指向拥有arguments对象的函数\n\n```\nfunction factorial(num){\n    if(num<=1){\n        return 1;\n    }else{          //arguments.callee代替函数名\n        return num*arguments.callee(num-1);\n    }\n}\n\n```\n\n# 闭包\n### 概念\n在讲述闭包之前必须先引入几个概念：  \n**函数的执行环境**(excution context)、**活动对**象(call object)、  \n**作用域**(scope)、**作用域链**(scope chain)  \n以函数a从定义到执行的过程为例阐述：\n\n①  当*定义*函数a的时候，js解释器会将函数a的**作用域链**设置为定义a时a所在的“环境”，如果a是一个全局函数，则作用域链中只有全局变量对象。\n\n②  当*执行*函数a的时候，a会进入相应的**执行环境**。  \n\n③ 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的**作用域**，其值就为第1步中作用域链。\n\n④ 然后执行环境会创建一个**活动对象**（活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问）。创建完活动对象后，把活动对象添加到a的作用域链的*最顶端*。   \n\n⑤下一步是在活动对象上添加一个**arguments属性**，它保存着调用函数a时所传递的参数。\n\n⑥ 最后把**所有函数a的形参和内部的函数b的引用**也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 \n\na的作用域链（本质上是一个指向变量对象的指针列表）包含\n- 本地活动对象：arguments属性，a的变量，函数\n- 全局变量对象\n\n### 小结\n\n- 闭包是指有权访问另一个函数作用域中的变量的函数，通过模拟全局作用域，使局部变量变为全局变量\n闭包就是将函数内部和函数外部连接起来的一座桥梁 \n\n创建闭包的常用方式：在一个函数内部创建另一个函数\n\n- JavaScript中所有的function都是一个闭包。\n\n不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。\n\n- 闭包的用途\n\n1、使其可以访问其外部函数作用域中的变量    \n2、可以实现局部变量驻留在内存中从而累加    \n通常函数的作用域及其所有变量会在函数执行结束后被销毁。  \n\n但由于闭包（内部函数）的作用域链包含外部函数（非全局）的活动对象。当函数返回一个闭包时，函数的作用域将会一直在内存中保存到闭包不存在为止\n\n- 关于this对象\n\n闭包运行时this指向window\n\n```\nvar name=\"The window\";\nvar object={\n    name:\"The Object\",\n    getNameFunc:function(){\n        return function(){\n            return this.name; //这里的作用域，this指向window\n        };\n    }\n};\nalert(object.getNameFunc()()); //\"The window\"\n\n```\n\n1. 改进1\n\n可适用对象冒充的方式使this指向object\n\n```\nalert(object.getNameFunc().call(object)); //对象冒充\n\n```\n\n2. 改进2  \n\n访问作用域中的this/arguments对象，必须将对该对象的引用（this）保存到另一个闭包能够访问的变量中\n\n```\nvar name=\"The window\";\nvar object={\n    name:\"The Object\",\n    getNameFunc:function(){\n        var that=this;  //这里的作用域，this指向object\n        return function(){\n            return that.name; \n        };\n    }\n};\nalert(object.getNameFunc()()); //\"The Object\"\n不过这个不会常用，太绕了！！！\n理解思路即可\n\n```\n\n3. 改进3  \n\n这不是闭包，也不算改进，只是通常是用这种来表示\n\n```\nvar name=\"The window\";\nvar object={\n    name:\"The Object\",\n    getNameFunc:function(){\n            return this.name; \n    }\n};\nalert(object.getNameFunc()); //\"The Object\"\n\n```\n\n# 模仿块级作用域\n在JavaScript中，从变量有定义开始，就可以在函数内部随处访问它，即使错误地重新声明同一个变量，也不会改变它的值，当然，重新赋值是会改变的\n\n```\n(function(){\n    //这里是块级作用域\n})();\n\nJavaScript将function关键字当作一个函数声明的开始，\n而函数声明后面不能跟圆括号，给函数声明加上一对圆括\n号即转换成函数表达式，后面就可以跟圆括号了\n\n```\n使用块级作用域，匿名函数中定义的任何变量，都会在执行结束时被销毁   \n这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数，能有效防止命名冲突\n\n# 私有变量\n严格来讲，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过有一个私有变量的概念   \n私有变量包括**函数的参数**、**局部变量**和**在函数内部定义的其他函数**\n\n- ### 特权方法\n有权访问私有变量的公有方法，在公共域可见，不可被修改，只能替换/删除\n\n> 在这里提出一个问题：在函数外部私有变量不可访问，又为什么用特权方法使之可以访问呢？为什么不直接舍弃而用公有方法呢？  \n> （个人理解）私有变量除了不可访问还不可修改，可隐藏那些不该被直接修改的数据，但私有变量在函数外部不可见，因此通过特权方法访问它们但也仅仅是访问而已\n\n- ### 创建特权方法的方式\n#### 方法1\n在构造函数中定义特权方法\n\n```\nfunction MyObject(){\n     //私有变量和私有函数\n    var privateVariable=10;       \n    function privateFunction(){   \n        return true;\n    }\n    //特权方法\n    this.publicMethod=function(){\n        privateVariable++;\n        return privateFunction();\n    };\n}\n\n```\n\n#### 方法2\n在私有作用域中定义私有变量和函数，通过构造函数的原型定义特权方法\n\n```\n(function(){\n    //私有变量和私有函数\n    var privateVariable=10;       \n    function privateFunction(){   \n        return true;\n    }\n    //构造函数,在函数中不带var的变量为全局变量\n    MyObject=function(){  };     //有点像原型模式创建对象\n    //公有/特权方法\n    MyObject.prototype.publicMethod=function(){\n        privateVariable++;\n        return privateFunction();\n    };\n})();  //匿名函数的自我执行\n\n```\n#### 方法3\n模块模式  \n前两种方法是用于以**构造函数的方式**创建私有变量和特权方法的  \n这种是用于以**对象字面量的方式**为*单例*创建私有变量和特权方法的\n- 单例：只有一个实例的对象，其实为对象字面量声明方式，永远实例化一次\n\n```\n//以对象字面量的方式创建单例对象\nvar singleton={\n    name:value,\n    method:function(){\n        //这里是方法的代码\n    }\n}\n//为单例对象添加私有变量和特权方法使其增强\nvar singleton=function(){\n    //私有变量和私有函数\n    var privateVariable=10;       \n    function privateFunction(){   \n        return true;\n    }\n    //公有/特权方法和属性\n    return{\n        publicProperty:true,\n        publicMethod:function(){\n            privateVariable++;\n         return privateFunction();\n        }\n    };\n}();  //匿名函数的自我执行\n\n```\n\n#### 方法4\n增强的模块模式   \n在返回对象之前加入对其增强的代码  \n适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况\n\n```\nvar singleton=function(){\n    //私有变量和私有函数\n    var privateVariable=10;       \n    function privateFunction(){   \n        return true;\n    }\n    //创建对象\n    var object=new CustomType();\n    //公有/特权方法和属\n        object.publicProperty:true,\n        object.publicMethod=function(){\n            privateVariable++;\n         return privateFunction();\n        };\n    //返回这个对象\n    return object;\n}();  //匿名函数的自我执行\n\n```\n\n","source":"_posts/js高级程序设计/函数表达式.md","raw":"---\ntitle: 函数表达式\nDate: 2018-05-03\ntags: [红宝书]\ncategories: 红宝书\ncomments: true\n---\n\n# 函数表达式\n## 定义函数的方式\n\n#### 使用函数声明\n\n```\nfunction 函数名(参数){\n    //函数体\n}\n可通过name属性访问函数名（即标识符）（有何意义？）\nalert(函数名.name);//函数名   \n\n```\n\n#### 使用函数表达式\n\n这种情况下创建的函数叫匿名函数    \n顾名思义，因为 function关键字后面没有函数名（即标识符）\n```\nvar 变量=function(){\n    //函数体\n};\n\n```\n\n#### 两者的主要区别\n\n（1） 函数声明无论置于调用语句前后，解析器都会先读取函数声明  \n\n> 后面不能跟圆括号\n\n由于函数声明的一个重要特征---*函数声明提升*（在执行代码之前会先读取函数声明）这意味着可以把函数声明放在调用它的语句后面\n\n（2）函数表达式则要等到解析器执行到它所在代码行才被真正执行\n> 后面可以跟圆括号，表示立即自我执行\n\n则函数表达式需要先把函数赋值给变量，再调用函数\n\n# 递归\n\n### 递归函数\n是在一个函数通过名字调用自身的情况下构成的\n\n```\nfunction factorial(num){\n    if(num<=1){\n        return 1;\n    }else{\n        return num*factorial(num-1);\n    }\n}\n\n```\n缺点：把该函数保存在另一个变量中，且将factorial变量设置为null时（即当函数名改变了时），导致错误\n\n### 改进\narguments.callee是一个指向正在执行的函数的指针，通俗一点讲就是指向拥有arguments对象的函数\n\n```\nfunction factorial(num){\n    if(num<=1){\n        return 1;\n    }else{          //arguments.callee代替函数名\n        return num*arguments.callee(num-1);\n    }\n}\n\n```\n\n# 闭包\n### 概念\n在讲述闭包之前必须先引入几个概念：  \n**函数的执行环境**(excution context)、**活动对**象(call object)、  \n**作用域**(scope)、**作用域链**(scope chain)  \n以函数a从定义到执行的过程为例阐述：\n\n①  当*定义*函数a的时候，js解释器会将函数a的**作用域链**设置为定义a时a所在的“环境”，如果a是一个全局函数，则作用域链中只有全局变量对象。\n\n②  当*执行*函数a的时候，a会进入相应的**执行环境**。  \n\n③ 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的**作用域**，其值就为第1步中作用域链。\n\n④ 然后执行环境会创建一个**活动对象**（活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问）。创建完活动对象后，把活动对象添加到a的作用域链的*最顶端*。   \n\n⑤下一步是在活动对象上添加一个**arguments属性**，它保存着调用函数a时所传递的参数。\n\n⑥ 最后把**所有函数a的形参和内部的函数b的引用**也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 \n\na的作用域链（本质上是一个指向变量对象的指针列表）包含\n- 本地活动对象：arguments属性，a的变量，函数\n- 全局变量对象\n\n### 小结\n\n- 闭包是指有权访问另一个函数作用域中的变量的函数，通过模拟全局作用域，使局部变量变为全局变量\n闭包就是将函数内部和函数外部连接起来的一座桥梁 \n\n创建闭包的常用方式：在一个函数内部创建另一个函数\n\n- JavaScript中所有的function都是一个闭包。\n\n不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。\n\n- 闭包的用途\n\n1、使其可以访问其外部函数作用域中的变量    \n2、可以实现局部变量驻留在内存中从而累加    \n通常函数的作用域及其所有变量会在函数执行结束后被销毁。  \n\n但由于闭包（内部函数）的作用域链包含外部函数（非全局）的活动对象。当函数返回一个闭包时，函数的作用域将会一直在内存中保存到闭包不存在为止\n\n- 关于this对象\n\n闭包运行时this指向window\n\n```\nvar name=\"The window\";\nvar object={\n    name:\"The Object\",\n    getNameFunc:function(){\n        return function(){\n            return this.name; //这里的作用域，this指向window\n        };\n    }\n};\nalert(object.getNameFunc()()); //\"The window\"\n\n```\n\n1. 改进1\n\n可适用对象冒充的方式使this指向object\n\n```\nalert(object.getNameFunc().call(object)); //对象冒充\n\n```\n\n2. 改进2  \n\n访问作用域中的this/arguments对象，必须将对该对象的引用（this）保存到另一个闭包能够访问的变量中\n\n```\nvar name=\"The window\";\nvar object={\n    name:\"The Object\",\n    getNameFunc:function(){\n        var that=this;  //这里的作用域，this指向object\n        return function(){\n            return that.name; \n        };\n    }\n};\nalert(object.getNameFunc()()); //\"The Object\"\n不过这个不会常用，太绕了！！！\n理解思路即可\n\n```\n\n3. 改进3  \n\n这不是闭包，也不算改进，只是通常是用这种来表示\n\n```\nvar name=\"The window\";\nvar object={\n    name:\"The Object\",\n    getNameFunc:function(){\n            return this.name; \n    }\n};\nalert(object.getNameFunc()); //\"The Object\"\n\n```\n\n# 模仿块级作用域\n在JavaScript中，从变量有定义开始，就可以在函数内部随处访问它，即使错误地重新声明同一个变量，也不会改变它的值，当然，重新赋值是会改变的\n\n```\n(function(){\n    //这里是块级作用域\n})();\n\nJavaScript将function关键字当作一个函数声明的开始，\n而函数声明后面不能跟圆括号，给函数声明加上一对圆括\n号即转换成函数表达式，后面就可以跟圆括号了\n\n```\n使用块级作用域，匿名函数中定义的任何变量，都会在执行结束时被销毁   \n这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数，能有效防止命名冲突\n\n# 私有变量\n严格来讲，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过有一个私有变量的概念   \n私有变量包括**函数的参数**、**局部变量**和**在函数内部定义的其他函数**\n\n- ### 特权方法\n有权访问私有变量的公有方法，在公共域可见，不可被修改，只能替换/删除\n\n> 在这里提出一个问题：在函数外部私有变量不可访问，又为什么用特权方法使之可以访问呢？为什么不直接舍弃而用公有方法呢？  \n> （个人理解）私有变量除了不可访问还不可修改，可隐藏那些不该被直接修改的数据，但私有变量在函数外部不可见，因此通过特权方法访问它们但也仅仅是访问而已\n\n- ### 创建特权方法的方式\n#### 方法1\n在构造函数中定义特权方法\n\n```\nfunction MyObject(){\n     //私有变量和私有函数\n    var privateVariable=10;       \n    function privateFunction(){   \n        return true;\n    }\n    //特权方法\n    this.publicMethod=function(){\n        privateVariable++;\n        return privateFunction();\n    };\n}\n\n```\n\n#### 方法2\n在私有作用域中定义私有变量和函数，通过构造函数的原型定义特权方法\n\n```\n(function(){\n    //私有变量和私有函数\n    var privateVariable=10;       \n    function privateFunction(){   \n        return true;\n    }\n    //构造函数,在函数中不带var的变量为全局变量\n    MyObject=function(){  };     //有点像原型模式创建对象\n    //公有/特权方法\n    MyObject.prototype.publicMethod=function(){\n        privateVariable++;\n        return privateFunction();\n    };\n})();  //匿名函数的自我执行\n\n```\n#### 方法3\n模块模式  \n前两种方法是用于以**构造函数的方式**创建私有变量和特权方法的  \n这种是用于以**对象字面量的方式**为*单例*创建私有变量和特权方法的\n- 单例：只有一个实例的对象，其实为对象字面量声明方式，永远实例化一次\n\n```\n//以对象字面量的方式创建单例对象\nvar singleton={\n    name:value,\n    method:function(){\n        //这里是方法的代码\n    }\n}\n//为单例对象添加私有变量和特权方法使其增强\nvar singleton=function(){\n    //私有变量和私有函数\n    var privateVariable=10;       \n    function privateFunction(){   \n        return true;\n    }\n    //公有/特权方法和属性\n    return{\n        publicProperty:true,\n        publicMethod:function(){\n            privateVariable++;\n         return privateFunction();\n        }\n    };\n}();  //匿名函数的自我执行\n\n```\n\n#### 方法4\n增强的模块模式   \n在返回对象之前加入对其增强的代码  \n适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况\n\n```\nvar singleton=function(){\n    //私有变量和私有函数\n    var privateVariable=10;       \n    function privateFunction(){   \n        return true;\n    }\n    //创建对象\n    var object=new CustomType();\n    //公有/特权方法和属\n        object.publicProperty:true,\n        object.publicMethod=function(){\n            privateVariable++;\n         return privateFunction();\n        };\n    //返回这个对象\n    return object;\n}();  //匿名函数的自我执行\n\n```\n\n","slug":"js高级程序设计/函数表达式","published":1,"date":"2018-05-03T14:35:50.114Z","updated":"2018-05-03T14:58:04.237Z","layout":"post","photos":[],"link":"","_id":"cka6kintj00geqgu94skhk41g","content":"<h1 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h1><h2 id=\"定义函数的方式\"><a href=\"#定义函数的方式\" class=\"headerlink\" title=\"定义函数的方式\"></a>定义函数的方式</h2><h4 id=\"使用函数声明\"><a href=\"#使用函数声明\" class=\"headerlink\" title=\"使用函数声明\"></a>使用函数声明</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function 函数名(参数)&#123;</span><br><span class=\"line\">    //函数体</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">可通过name属性访问函数名（即标识符）（有何意义？）</span><br><span class=\"line\">alert(函数名.name);//函数名</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用函数表达式\"><a href=\"#使用函数表达式\" class=\"headerlink\" title=\"使用函数表达式\"></a>使用函数表达式</h4><p>这种情况下创建的函数叫匿名函数<br>顾名思义，因为 function关键字后面没有函数名（即标识符）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 变量=function()&#123;</span><br><span class=\"line\">    //函数体</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"两者的主要区别\"><a href=\"#两者的主要区别\" class=\"headerlink\" title=\"两者的主要区别\"></a>两者的主要区别</h4><p>（1） 函数声明无论置于调用语句前后，解析器都会先读取函数声明  </p>\n<blockquote>\n<p>后面不能跟圆括号</p>\n</blockquote>\n<p>由于函数声明的一个重要特征—<em>函数声明提升</em>（在执行代码之前会先读取函数声明）这意味着可以把函数声明放在调用它的语句后面</p>\n<p>（2）函数表达式则要等到解析器执行到它所在代码行才被真正执行</p>\n<blockquote>\n<p>后面可以跟圆括号，表示立即自我执行</p>\n</blockquote>\n<p>则函数表达式需要先把函数赋值给变量，再调用函数</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><h3 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h3><p>是在一个函数通过名字调用自身的情况下构成的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(num)&#123;</span><br><span class=\"line\">    if(num&lt;=1)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return num*factorial(num-1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：把该函数保存在另一个变量中，且将factorial变量设置为null时（即当函数名改变了时），导致错误</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>arguments.callee是一个指向正在执行的函数的指针，通俗一点讲就是指向拥有arguments对象的函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(num)&#123;</span><br><span class=\"line\">    if(num&lt;=1)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;else&#123;          //arguments.callee代替函数名</span><br><span class=\"line\">        return num*arguments.callee(num-1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>在讲述闭包之前必须先引入几个概念：<br><strong>函数的执行环境</strong>(excution context)、<strong>活动对</strong>象(call object)、<br><strong>作用域</strong>(scope)、<strong>作用域链</strong>(scope chain)<br>以函数a从定义到执行的过程为例阐述：</p>\n<p>①  当<em>定义</em>函数a的时候，js解释器会将函数a的<strong>作用域链</strong>设置为定义a时a所在的“环境”，如果a是一个全局函数，则作用域链中只有全局变量对象。</p>\n<p>②  当<em>执行</em>函数a的时候，a会进入相应的<strong>执行环境</strong>。  </p>\n<p>③ 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的<strong>作用域</strong>，其值就为第1步中作用域链。</p>\n<p>④ 然后执行环境会创建一个<strong>活动对象</strong>（活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问）。创建完活动对象后，把活动对象添加到a的作用域链的<em>最顶端</em>。   </p>\n<p>⑤下一步是在活动对象上添加一个<strong>arguments属性</strong>，它保存着调用函数a时所传递的参数。</p>\n<p>⑥ 最后把<strong>所有函数a的形参和内部的函数b的引用</strong>也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 </p>\n<p>a的作用域链（本质上是一个指向变量对象的指针列表）包含</p>\n<ul>\n<li>本地活动对象：arguments属性，a的变量，函数</li>\n<li>全局变量对象</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>闭包是指有权访问另一个函数作用域中的变量的函数，通过模拟全局作用域，使局部变量变为全局变量<br>闭包就是将函数内部和函数外部连接起来的一座桥梁 </li>\n</ul>\n<p>创建闭包的常用方式：在一个函数内部创建另一个函数</p>\n<ul>\n<li>JavaScript中所有的function都是一个闭包。</li>\n</ul>\n<p>不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。</p>\n<ul>\n<li>闭包的用途</li>\n</ul>\n<p>1、使其可以访问其外部函数作用域中的变量<br>2、可以实现局部变量驻留在内存中从而累加<br>通常函数的作用域及其所有变量会在函数执行结束后被销毁。  </p>\n<p>但由于闭包（内部函数）的作用域链包含外部函数（非全局）的活动对象。当函数返回一个闭包时，函数的作用域将会一直在内存中保存到闭包不存在为止</p>\n<ul>\n<li>关于this对象</li>\n</ul>\n<p>闭包运行时this指向window</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name=&quot;The window&quot;;</span><br><span class=\"line\">var object=&#123;</span><br><span class=\"line\">    name:&quot;The Object&quot;,</span><br><span class=\"line\">    getNameFunc:function()&#123;</span><br><span class=\"line\">        return function()&#123;</span><br><span class=\"line\">            return this.name; //这里的作用域，this指向window</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()()); //&quot;The window&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>改进1</li>\n</ol>\n<p>可适用对象冒充的方式使this指向object</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(object.getNameFunc().call(object)); //对象冒充</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>改进2  </li>\n</ol>\n<p>访问作用域中的this/arguments对象，必须将对该对象的引用（this）保存到另一个闭包能够访问的变量中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name=&quot;The window&quot;;</span><br><span class=\"line\">var object=&#123;</span><br><span class=\"line\">    name:&quot;The Object&quot;,</span><br><span class=\"line\">    getNameFunc:function()&#123;</span><br><span class=\"line\">        var that=this;  //这里的作用域，this指向object</span><br><span class=\"line\">        return function()&#123;</span><br><span class=\"line\">            return that.name; </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()()); //&quot;The Object&quot;</span><br><span class=\"line\">不过这个不会常用，太绕了！！！</span><br><span class=\"line\">理解思路即可</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>改进3  </li>\n</ol>\n<p>这不是闭包，也不算改进，只是通常是用这种来表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name=&quot;The window&quot;;</span><br><span class=\"line\">var object=&#123;</span><br><span class=\"line\">    name:&quot;The Object&quot;,</span><br><span class=\"line\">    getNameFunc:function()&#123;</span><br><span class=\"line\">            return this.name; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()); //&quot;The Object&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h1><p>在JavaScript中，从变量有定义开始，就可以在函数内部随处访问它，即使错误地重新声明同一个变量，也不会改变它的值，当然，重新赋值是会改变的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    //这里是块级作用域</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript将function关键字当作一个函数声明的开始，</span><br><span class=\"line\">而函数声明后面不能跟圆括号，给函数声明加上一对圆括</span><br><span class=\"line\">号即转换成函数表达式，后面就可以跟圆括号了</span><br></pre></td></tr></table></figure>\n<p>使用块级作用域，匿名函数中定义的任何变量，都会在执行结束时被销毁<br>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数，能有效防止命名冲突</p>\n<h1 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h1><p>严格来讲，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过有一个私有变量的概念<br>私有变量包括<strong>函数的参数</strong>、<strong>局部变量</strong>和<strong>在函数内部定义的其他函数</strong></p>\n<ul>\n<li><h3 id=\"特权方法\"><a href=\"#特权方法\" class=\"headerlink\" title=\"特权方法\"></a>特权方法</h3>有权访问私有变量的公有方法，在公共域可见，不可被修改，只能替换/删除</li>\n</ul>\n<blockquote>\n<p>在这里提出一个问题：在函数外部私有变量不可访问，又为什么用特权方法使之可以访问呢？为什么不直接舍弃而用公有方法呢？<br>（个人理解）私有变量除了不可访问还不可修改，可隐藏那些不该被直接修改的数据，但私有变量在函数外部不可见，因此通过特权方法访问它们但也仅仅是访问而已</p>\n</blockquote>\n<ul>\n<li><h3 id=\"创建特权方法的方式\"><a href=\"#创建特权方法的方式\" class=\"headerlink\" title=\"创建特权方法的方式\"></a>创建特权方法的方式</h3><h4 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h4>在构造函数中定义特权方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyObject()&#123;</span><br><span class=\"line\">     //私有变量和私有函数</span><br><span class=\"line\">    var privateVariable=10;       </span><br><span class=\"line\">    function privateFunction()&#123;   </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //特权方法</span><br><span class=\"line\">    this.publicMethod=function()&#123;</span><br><span class=\"line\">        privateVariable++;</span><br><span class=\"line\">        return privateFunction();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h4><p>在私有作用域中定义私有变量和函数，通过构造函数的原型定义特权方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    //私有变量和私有函数</span><br><span class=\"line\">    var privateVariable=10;       </span><br><span class=\"line\">    function privateFunction()&#123;   </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //构造函数,在函数中不带var的变量为全局变量</span><br><span class=\"line\">    MyObject=function()&#123;  &#125;;     //有点像原型模式创建对象</span><br><span class=\"line\">    //公有/特权方法</span><br><span class=\"line\">    MyObject.prototype.publicMethod=function()&#123;</span><br><span class=\"line\">        privateVariable++;</span><br><span class=\"line\">        return privateFunction();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();  //匿名函数的自我执行</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法3\"><a href=\"#方法3\" class=\"headerlink\" title=\"方法3\"></a>方法3</h4><p>模块模式<br>前两种方法是用于以<strong>构造函数的方式</strong>创建私有变量和特权方法的<br>这种是用于以<strong>对象字面量的方式</strong>为<em>单例</em>创建私有变量和特权方法的</p>\n<ul>\n<li>单例：只有一个实例的对象，其实为对象字面量声明方式，永远实例化一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//以对象字面量的方式创建单例对象</span><br><span class=\"line\">var singleton=&#123;</span><br><span class=\"line\">    name:value,</span><br><span class=\"line\">    method:function()&#123;</span><br><span class=\"line\">        //这里是方法的代码</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//为单例对象添加私有变量和特权方法使其增强</span><br><span class=\"line\">var singleton=function()&#123;</span><br><span class=\"line\">    //私有变量和私有函数</span><br><span class=\"line\">    var privateVariable=10;       </span><br><span class=\"line\">    function privateFunction()&#123;   </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //公有/特权方法和属性</span><br><span class=\"line\">    return&#123;</span><br><span class=\"line\">        publicProperty:true,</span><br><span class=\"line\">        publicMethod:function()&#123;</span><br><span class=\"line\">            privateVariable++;</span><br><span class=\"line\">         return privateFunction();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;();  //匿名函数的自我执行</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法4\"><a href=\"#方法4\" class=\"headerlink\" title=\"方法4\"></a>方法4</h4><p>增强的模块模式<br>在返回对象之前加入对其增强的代码<br>适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var singleton=function()&#123;</span><br><span class=\"line\">    //私有变量和私有函数</span><br><span class=\"line\">    var privateVariable=10;       </span><br><span class=\"line\">    function privateFunction()&#123;   </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //创建对象</span><br><span class=\"line\">    var object=new CustomType();</span><br><span class=\"line\">    //公有/特权方法和属</span><br><span class=\"line\">        object.publicProperty:true,</span><br><span class=\"line\">        object.publicMethod=function()&#123;</span><br><span class=\"line\">            privateVariable++;</span><br><span class=\"line\">         return privateFunction();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    //返回这个对象</span><br><span class=\"line\">    return object;</span><br><span class=\"line\">&#125;();  //匿名函数的自我执行</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h1><h2 id=\"定义函数的方式\"><a href=\"#定义函数的方式\" class=\"headerlink\" title=\"定义函数的方式\"></a>定义函数的方式</h2><h4 id=\"使用函数声明\"><a href=\"#使用函数声明\" class=\"headerlink\" title=\"使用函数声明\"></a>使用函数声明</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function 函数名(参数)&#123;</span><br><span class=\"line\">    //函数体</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">可通过name属性访问函数名（即标识符）（有何意义？）</span><br><span class=\"line\">alert(函数名.name);//函数名</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用函数表达式\"><a href=\"#使用函数表达式\" class=\"headerlink\" title=\"使用函数表达式\"></a>使用函数表达式</h4><p>这种情况下创建的函数叫匿名函数<br>顾名思义，因为 function关键字后面没有函数名（即标识符）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 变量=function()&#123;</span><br><span class=\"line\">    //函数体</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"两者的主要区别\"><a href=\"#两者的主要区别\" class=\"headerlink\" title=\"两者的主要区别\"></a>两者的主要区别</h4><p>（1） 函数声明无论置于调用语句前后，解析器都会先读取函数声明  </p>\n<blockquote>\n<p>后面不能跟圆括号</p>\n</blockquote>\n<p>由于函数声明的一个重要特征—<em>函数声明提升</em>（在执行代码之前会先读取函数声明）这意味着可以把函数声明放在调用它的语句后面</p>\n<p>（2）函数表达式则要等到解析器执行到它所在代码行才被真正执行</p>\n<blockquote>\n<p>后面可以跟圆括号，表示立即自我执行</p>\n</blockquote>\n<p>则函数表达式需要先把函数赋值给变量，再调用函数</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><h3 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h3><p>是在一个函数通过名字调用自身的情况下构成的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(num)&#123;</span><br><span class=\"line\">    if(num&lt;=1)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return num*factorial(num-1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：把该函数保存在另一个变量中，且将factorial变量设置为null时（即当函数名改变了时），导致错误</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>arguments.callee是一个指向正在执行的函数的指针，通俗一点讲就是指向拥有arguments对象的函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(num)&#123;</span><br><span class=\"line\">    if(num&lt;=1)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;else&#123;          //arguments.callee代替函数名</span><br><span class=\"line\">        return num*arguments.callee(num-1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>在讲述闭包之前必须先引入几个概念：<br><strong>函数的执行环境</strong>(excution context)、<strong>活动对</strong>象(call object)、<br><strong>作用域</strong>(scope)、<strong>作用域链</strong>(scope chain)<br>以函数a从定义到执行的过程为例阐述：</p>\n<p>①  当<em>定义</em>函数a的时候，js解释器会将函数a的<strong>作用域链</strong>设置为定义a时a所在的“环境”，如果a是一个全局函数，则作用域链中只有全局变量对象。</p>\n<p>②  当<em>执行</em>函数a的时候，a会进入相应的<strong>执行环境</strong>。  </p>\n<p>③ 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的<strong>作用域</strong>，其值就为第1步中作用域链。</p>\n<p>④ 然后执行环境会创建一个<strong>活动对象</strong>（活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问）。创建完活动对象后，把活动对象添加到a的作用域链的<em>最顶端</em>。   </p>\n<p>⑤下一步是在活动对象上添加一个<strong>arguments属性</strong>，它保存着调用函数a时所传递的参数。</p>\n<p>⑥ 最后把<strong>所有函数a的形参和内部的函数b的引用</strong>也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 </p>\n<p>a的作用域链（本质上是一个指向变量对象的指针列表）包含</p>\n<ul>\n<li>本地活动对象：arguments属性，a的变量，函数</li>\n<li>全局变量对象</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>闭包是指有权访问另一个函数作用域中的变量的函数，通过模拟全局作用域，使局部变量变为全局变量<br>闭包就是将函数内部和函数外部连接起来的一座桥梁 </li>\n</ul>\n<p>创建闭包的常用方式：在一个函数内部创建另一个函数</p>\n<ul>\n<li>JavaScript中所有的function都是一个闭包。</li>\n</ul>\n<p>不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。</p>\n<ul>\n<li>闭包的用途</li>\n</ul>\n<p>1、使其可以访问其外部函数作用域中的变量<br>2、可以实现局部变量驻留在内存中从而累加<br>通常函数的作用域及其所有变量会在函数执行结束后被销毁。  </p>\n<p>但由于闭包（内部函数）的作用域链包含外部函数（非全局）的活动对象。当函数返回一个闭包时，函数的作用域将会一直在内存中保存到闭包不存在为止</p>\n<ul>\n<li>关于this对象</li>\n</ul>\n<p>闭包运行时this指向window</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name=&quot;The window&quot;;</span><br><span class=\"line\">var object=&#123;</span><br><span class=\"line\">    name:&quot;The Object&quot;,</span><br><span class=\"line\">    getNameFunc:function()&#123;</span><br><span class=\"line\">        return function()&#123;</span><br><span class=\"line\">            return this.name; //这里的作用域，this指向window</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()()); //&quot;The window&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>改进1</li>\n</ol>\n<p>可适用对象冒充的方式使this指向object</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(object.getNameFunc().call(object)); //对象冒充</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>改进2  </li>\n</ol>\n<p>访问作用域中的this/arguments对象，必须将对该对象的引用（this）保存到另一个闭包能够访问的变量中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name=&quot;The window&quot;;</span><br><span class=\"line\">var object=&#123;</span><br><span class=\"line\">    name:&quot;The Object&quot;,</span><br><span class=\"line\">    getNameFunc:function()&#123;</span><br><span class=\"line\">        var that=this;  //这里的作用域，this指向object</span><br><span class=\"line\">        return function()&#123;</span><br><span class=\"line\">            return that.name; </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()()); //&quot;The Object&quot;</span><br><span class=\"line\">不过这个不会常用，太绕了！！！</span><br><span class=\"line\">理解思路即可</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>改进3  </li>\n</ol>\n<p>这不是闭包，也不算改进，只是通常是用这种来表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name=&quot;The window&quot;;</span><br><span class=\"line\">var object=&#123;</span><br><span class=\"line\">    name:&quot;The Object&quot;,</span><br><span class=\"line\">    getNameFunc:function()&#123;</span><br><span class=\"line\">            return this.name; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()); //&quot;The Object&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h1><p>在JavaScript中，从变量有定义开始，就可以在函数内部随处访问它，即使错误地重新声明同一个变量，也不会改变它的值，当然，重新赋值是会改变的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    //这里是块级作用域</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript将function关键字当作一个函数声明的开始，</span><br><span class=\"line\">而函数声明后面不能跟圆括号，给函数声明加上一对圆括</span><br><span class=\"line\">号即转换成函数表达式，后面就可以跟圆括号了</span><br></pre></td></tr></table></figure>\n<p>使用块级作用域，匿名函数中定义的任何变量，都会在执行结束时被销毁<br>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数，能有效防止命名冲突</p>\n<h1 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h1><p>严格来讲，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过有一个私有变量的概念<br>私有变量包括<strong>函数的参数</strong>、<strong>局部变量</strong>和<strong>在函数内部定义的其他函数</strong></p>\n<ul>\n<li><h3 id=\"特权方法\"><a href=\"#特权方法\" class=\"headerlink\" title=\"特权方法\"></a>特权方法</h3>有权访问私有变量的公有方法，在公共域可见，不可被修改，只能替换/删除</li>\n</ul>\n<blockquote>\n<p>在这里提出一个问题：在函数外部私有变量不可访问，又为什么用特权方法使之可以访问呢？为什么不直接舍弃而用公有方法呢？<br>（个人理解）私有变量除了不可访问还不可修改，可隐藏那些不该被直接修改的数据，但私有变量在函数外部不可见，因此通过特权方法访问它们但也仅仅是访问而已</p>\n</blockquote>\n<ul>\n<li><h3 id=\"创建特权方法的方式\"><a href=\"#创建特权方法的方式\" class=\"headerlink\" title=\"创建特权方法的方式\"></a>创建特权方法的方式</h3><h4 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h4>在构造函数中定义特权方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyObject()&#123;</span><br><span class=\"line\">     //私有变量和私有函数</span><br><span class=\"line\">    var privateVariable=10;       </span><br><span class=\"line\">    function privateFunction()&#123;   </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //特权方法</span><br><span class=\"line\">    this.publicMethod=function()&#123;</span><br><span class=\"line\">        privateVariable++;</span><br><span class=\"line\">        return privateFunction();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h4><p>在私有作用域中定义私有变量和函数，通过构造函数的原型定义特权方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    //私有变量和私有函数</span><br><span class=\"line\">    var privateVariable=10;       </span><br><span class=\"line\">    function privateFunction()&#123;   </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //构造函数,在函数中不带var的变量为全局变量</span><br><span class=\"line\">    MyObject=function()&#123;  &#125;;     //有点像原型模式创建对象</span><br><span class=\"line\">    //公有/特权方法</span><br><span class=\"line\">    MyObject.prototype.publicMethod=function()&#123;</span><br><span class=\"line\">        privateVariable++;</span><br><span class=\"line\">        return privateFunction();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();  //匿名函数的自我执行</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法3\"><a href=\"#方法3\" class=\"headerlink\" title=\"方法3\"></a>方法3</h4><p>模块模式<br>前两种方法是用于以<strong>构造函数的方式</strong>创建私有变量和特权方法的<br>这种是用于以<strong>对象字面量的方式</strong>为<em>单例</em>创建私有变量和特权方法的</p>\n<ul>\n<li>单例：只有一个实例的对象，其实为对象字面量声明方式，永远实例化一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//以对象字面量的方式创建单例对象</span><br><span class=\"line\">var singleton=&#123;</span><br><span class=\"line\">    name:value,</span><br><span class=\"line\">    method:function()&#123;</span><br><span class=\"line\">        //这里是方法的代码</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//为单例对象添加私有变量和特权方法使其增强</span><br><span class=\"line\">var singleton=function()&#123;</span><br><span class=\"line\">    //私有变量和私有函数</span><br><span class=\"line\">    var privateVariable=10;       </span><br><span class=\"line\">    function privateFunction()&#123;   </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //公有/特权方法和属性</span><br><span class=\"line\">    return&#123;</span><br><span class=\"line\">        publicProperty:true,</span><br><span class=\"line\">        publicMethod:function()&#123;</span><br><span class=\"line\">            privateVariable++;</span><br><span class=\"line\">         return privateFunction();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;();  //匿名函数的自我执行</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法4\"><a href=\"#方法4\" class=\"headerlink\" title=\"方法4\"></a>方法4</h4><p>增强的模块模式<br>在返回对象之前加入对其增强的代码<br>适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var singleton=function()&#123;</span><br><span class=\"line\">    //私有变量和私有函数</span><br><span class=\"line\">    var privateVariable=10;       </span><br><span class=\"line\">    function privateFunction()&#123;   </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //创建对象</span><br><span class=\"line\">    var object=new CustomType();</span><br><span class=\"line\">    //公有/特权方法和属</span><br><span class=\"line\">        object.publicProperty:true,</span><br><span class=\"line\">        object.publicMethod=function()&#123;</span><br><span class=\"line\">            privateVariable++;</span><br><span class=\"line\">         return privateFunction();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    //返回这个对象</span><br><span class=\"line\">    return object;</span><br><span class=\"line\">&#125;();  //匿名函数的自我执行</span><br></pre></td></tr></table></figure>\n"},{"title":"前端学习路线规划","Date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"\n# 前端学习路线规划\n## 一、代码编写工具\n### **sublime Text 3**:\n 1. sublime text编辑器单从界面看非常简洁，可以说让人一见倾心的感觉。完全符合码农的口味~~。功能上也不复杂，就跟记事本似的，很容易上手。\n \n 2. 可以自由扩展，sublime提供了安装插件的方式，可以任意安装你想要的插件.\n \n## 二、学习路线规划\n\n### 1.  熟练使用 HTML、CSS\nHTML 是标签语言，可以构建前端页面的骨架；CSS是层叠样式控制表，可以构建前端页面的外貌\n\n这部分比较简单，到网上搜资料，书籍视频非常多。css中盒子模型，流动，block，inline，层叠，样式优先级等这些比较重要。最后再深入了解下浏览器差异性，ie9以下兼容简单了解就行了，ie9以下浏览器被淘汰掉是趋势，低版本没必要浪费大量时间去学习兼容主流浏览器，google chrome浏览器、firefox浏览器、safari浏览器、opera浏览器即可。浏览器差异内容很多，建议在实践中多多积累。\n\n```\n推荐书籍：《Head First HTML 与 CSS (第2版)》\n          《CSS 禅意花园(修订版)》\n```\n\n### 2.javascript部分（最重要的部分）\n难点，也是重点，要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，有很多比较抽象的概念，必须要深入理解，比如闭包、原型、面向对象、封装等，要理解透彻。看书是必不可少的，找一本优秀的js书从头到尾深入学习了。另外，js面向对象编程必须要学习，非常重要，个人推荐一本书《javascript高级程序设计》。边学边练，实践出真知。\n\n\n```\n推荐教程：网易云课堂上 李炎恢老师的视频，讲得很详细，讲的是和那本红宝书一样的内容\n          多动手写demo\n推荐书籍：《Javascript 权威指南》\n         《JavaScript 高级程序设计(第3版)》\n```\n\n\n### 3.jQuery学习（这不是一个框架，是一个类库）\n这些基础知识掌握好之后，还需要学jQuery，这是一个非常优秀的Javascript库，大型开发必备。它简化了Javascript的复杂操作，消除了Javascript跨平台兼容问题，提供了大量实用方法，有良好的文档和帮助手册，是一个非常成熟的Javascript库。\n\n\n```\n推荐教程：网易云课堂上 李炎恢老师的视频，多动手写demo\n推荐书籍：《锋利的jquery》\n```\n\n\n### 4.ajax的学习\n通过在后台与服务器进行数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，ajax是现在前端后台交互的主要方式。\n     \n```\n掌握的知识点：js原生的发送ajax的方法\n             jq的简便的发送ajax的方法\n```\n\n### 5.git\nGit是目前世界上最先进的分布式版本控制系统，适合于在团队合作时进行版本控制，提高开发效率\n\n```\n推荐教程：廖雪峰老师的关于git的教程博客\n```\n\n### 6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性\n熟练使用 HTML、CSS、JavaScript 还需要我们理解其语言最新相关标准：HTML5、CSS3 和 ES6(ECMAScript6)。\n\n- HTML 5 里新增了许多特性：语义化和新的音频、视频支持等；\n- CSS 3 被划分为模块，解决了 CSS2 为等待各个标准统一而耗费大量时间才能推进的不足之处，同时也提供了 2D、3D、动画效果等新特性；\n- ECMAScript6 等于 JavaScript - DOM - BOM，是 JavaScript 在 2015 年的最新标准，因为 ES6 对标准改动较大，前端开发者常常将一个前端项目是否支持 ES6 作为推进前端新技术的重要桥梁之一。ES6 将箭头函数、let 变量声明命令、Promise 编程、模块化编程等新特性纳入其标准中，得到了各大浏览器最新版本的支持。\n\n\n```\n扩展阅读：《ES6 标准入门(第2版)》\n          《深入理解ES6》\n```\n\n### 7.掌握浏览器兼容、响应式布局相关解决方案\n早期占据浏览器半壁江山的IE浏览器上存在的众多浏览器兼容问题，耗费了当时前端开发者的大量开发时间。虽然说现在的前端开发者已经不需要考虑太多的浏览器兼容问题，对其概念的了解有利于了解前端历史包袱或在未来足以应对一些面向特殊群体(早期 IE 浏览器使用者)的前端项目。\n**关于IE浏览器的兼容性问题在李炎恢老师的那个视频有详细的讲解**\n\n响应式布局和单页面应用是当代前端开发者的必备技能。从 Web Pages 到 Web App 时代，我们开发的前端项目有越来越多的可能需要同时在电脑端和手机端进行访问，一个有良好响应式布局的前端项目可以一个代码运行在多种不同分辨率的平台之上。\n\n## 三、现在前端主流的框架\n### 1. vuejs :2016年最火的前端框架（MVVC框架）\n\n是一套用于构建用户界面的渐进式框架Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n**常用于单页面应用的开发**\n\n\n```\n掌握的要点：(vue全家桶)\n   1.vue-router\n   2.vuex\n   3.vue-resource\n   4.vue-cli\n   5.Element-ui\n   \n推荐教程：详细阅读官网教程，中国人自己研发的，有中文版，不难\n```\n### 2. Reactjs\nReact 是一个用于构建用户界面的 javascript 库。\n\nReact主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。\n\nReact 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。\n\nReact 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\n\n**React特点：**\n\n```\n1.声明式设计 −React采用声明范式，可以轻松描述应用。\n2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。\n3.灵活 −React可以与已知的库或框架很好地配合。\n4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。\n5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。\n6.单向响应的数据流 − React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\n\n\n```\n\n```\n掌握的知识点：（React全家桶技术）\n  1.Reactjs\n  2.React生命周期\n  3.React Router\n  4.Redux\n  5.React Native(主要用于移动端的开发)\n```\n## 3.AngularJS（国外开发大型项目常用框架）\nAngularJS的四大功能：\n1. MVC\n\n  将后台的MVC模式写入了前端语言中。我总觉得前端语言将来会很叼，从node.js开始我就又一种这样的感觉。可能在很久之后取代后端语言不是没有可能的。\n  \n 2. 模块化\n\n  就是一系列函数的集合，当应用被启动时，这些函数就会被执行。主要利用angular.module来定义模块。也是Angular.js的亮点。\n  \n3. 指令属性\n\n我自己的理解就是比html标签更加具有属性和方法的指令标签\n\n4. 双向数据绑定\n\n传统的数据绑定是单向绑定，数据只能从model和controller生成需要的html，但是不能返过来使用。只是单方向的。双向数据绑定:也就是说我在前面填写，后面直接生成代码，将填写的显示出来。双向的意思就是如果view修改了属性值，那么model机会看到这个改变。相反也是一样的。\n\n## 4. 小程序（类似一个前端开发框架）\n```\n推荐教程：官网上的小程序开发文档，尝试动手写一下小程序\n```\n\n\n## 5.nodejs(前端用来写后台的工具)\n\n简单的说 Node.js 就是运行在服务端的 JavaScript。\n\nNode.js 是一个基于Chrome JavaScript 运行时建立的一个平台。\n\nNode.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。\n```\n推荐教程：官网的教程\n```\n\n\n## 四、一些常用的ui框架\n   #### 1. Bootstrape：最好的响应式css框架\n   #### 2. Element-ui：完美适应vuejs的ui框架\n   #### 3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。\n   #### 4. Aliceui\n   #### 5.Echart：最好的图表制作框架\n   \n   ####   ·····\n   \n## 六、前端最好掌握的一些常用技能\n   1. Markdown笔记的使用，程序员专用笔记本\n   2. github的使用：全球最大的开源代码网站，在上面你可以找到全世界所有出名项目的源代码，被称为人类的知识宝库。\n   3. 用github page搭建个人博客，上传个人项目到github上，面试加分必备项\n   4. 移动端的开发\n   5. 前端web开发命名规范，谷歌、百度命名标准\n   \n      等等·······","source":"_posts/前端/前端学习路线规划.md","raw":"---\ntitle: 前端学习路线规划\nDate: 2018-05-03\ntags: [前端]\ncategories: 前端\ncomments: true\n---\n\n# 前端学习路线规划\n## 一、代码编写工具\n### **sublime Text 3**:\n 1. sublime text编辑器单从界面看非常简洁，可以说让人一见倾心的感觉。完全符合码农的口味~~。功能上也不复杂，就跟记事本似的，很容易上手。\n \n 2. 可以自由扩展，sublime提供了安装插件的方式，可以任意安装你想要的插件.\n \n## 二、学习路线规划\n\n### 1.  熟练使用 HTML、CSS\nHTML 是标签语言，可以构建前端页面的骨架；CSS是层叠样式控制表，可以构建前端页面的外貌\n\n这部分比较简单，到网上搜资料，书籍视频非常多。css中盒子模型，流动，block，inline，层叠，样式优先级等这些比较重要。最后再深入了解下浏览器差异性，ie9以下兼容简单了解就行了，ie9以下浏览器被淘汰掉是趋势，低版本没必要浪费大量时间去学习兼容主流浏览器，google chrome浏览器、firefox浏览器、safari浏览器、opera浏览器即可。浏览器差异内容很多，建议在实践中多多积累。\n\n```\n推荐书籍：《Head First HTML 与 CSS (第2版)》\n          《CSS 禅意花园(修订版)》\n```\n\n### 2.javascript部分（最重要的部分）\n难点，也是重点，要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，有很多比较抽象的概念，必须要深入理解，比如闭包、原型、面向对象、封装等，要理解透彻。看书是必不可少的，找一本优秀的js书从头到尾深入学习了。另外，js面向对象编程必须要学习，非常重要，个人推荐一本书《javascript高级程序设计》。边学边练，实践出真知。\n\n\n```\n推荐教程：网易云课堂上 李炎恢老师的视频，讲得很详细，讲的是和那本红宝书一样的内容\n          多动手写demo\n推荐书籍：《Javascript 权威指南》\n         《JavaScript 高级程序设计(第3版)》\n```\n\n\n### 3.jQuery学习（这不是一个框架，是一个类库）\n这些基础知识掌握好之后，还需要学jQuery，这是一个非常优秀的Javascript库，大型开发必备。它简化了Javascript的复杂操作，消除了Javascript跨平台兼容问题，提供了大量实用方法，有良好的文档和帮助手册，是一个非常成熟的Javascript库。\n\n\n```\n推荐教程：网易云课堂上 李炎恢老师的视频，多动手写demo\n推荐书籍：《锋利的jquery》\n```\n\n\n### 4.ajax的学习\n通过在后台与服务器进行数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，ajax是现在前端后台交互的主要方式。\n     \n```\n掌握的知识点：js原生的发送ajax的方法\n             jq的简便的发送ajax的方法\n```\n\n### 5.git\nGit是目前世界上最先进的分布式版本控制系统，适合于在团队合作时进行版本控制，提高开发效率\n\n```\n推荐教程：廖雪峰老师的关于git的教程博客\n```\n\n### 6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性\n熟练使用 HTML、CSS、JavaScript 还需要我们理解其语言最新相关标准：HTML5、CSS3 和 ES6(ECMAScript6)。\n\n- HTML 5 里新增了许多特性：语义化和新的音频、视频支持等；\n- CSS 3 被划分为模块，解决了 CSS2 为等待各个标准统一而耗费大量时间才能推进的不足之处，同时也提供了 2D、3D、动画效果等新特性；\n- ECMAScript6 等于 JavaScript - DOM - BOM，是 JavaScript 在 2015 年的最新标准，因为 ES6 对标准改动较大，前端开发者常常将一个前端项目是否支持 ES6 作为推进前端新技术的重要桥梁之一。ES6 将箭头函数、let 变量声明命令、Promise 编程、模块化编程等新特性纳入其标准中，得到了各大浏览器最新版本的支持。\n\n\n```\n扩展阅读：《ES6 标准入门(第2版)》\n          《深入理解ES6》\n```\n\n### 7.掌握浏览器兼容、响应式布局相关解决方案\n早期占据浏览器半壁江山的IE浏览器上存在的众多浏览器兼容问题，耗费了当时前端开发者的大量开发时间。虽然说现在的前端开发者已经不需要考虑太多的浏览器兼容问题，对其概念的了解有利于了解前端历史包袱或在未来足以应对一些面向特殊群体(早期 IE 浏览器使用者)的前端项目。\n**关于IE浏览器的兼容性问题在李炎恢老师的那个视频有详细的讲解**\n\n响应式布局和单页面应用是当代前端开发者的必备技能。从 Web Pages 到 Web App 时代，我们开发的前端项目有越来越多的可能需要同时在电脑端和手机端进行访问，一个有良好响应式布局的前端项目可以一个代码运行在多种不同分辨率的平台之上。\n\n## 三、现在前端主流的框架\n### 1. vuejs :2016年最火的前端框架（MVVC框架）\n\n是一套用于构建用户界面的渐进式框架Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n**常用于单页面应用的开发**\n\n\n```\n掌握的要点：(vue全家桶)\n   1.vue-router\n   2.vuex\n   3.vue-resource\n   4.vue-cli\n   5.Element-ui\n   \n推荐教程：详细阅读官网教程，中国人自己研发的，有中文版，不难\n```\n### 2. Reactjs\nReact 是一个用于构建用户界面的 javascript 库。\n\nReact主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。\n\nReact 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。\n\nReact 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\n\n**React特点：**\n\n```\n1.声明式设计 −React采用声明范式，可以轻松描述应用。\n2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。\n3.灵活 −React可以与已知的库或框架很好地配合。\n4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。\n5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。\n6.单向响应的数据流 − React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\n\n\n```\n\n```\n掌握的知识点：（React全家桶技术）\n  1.Reactjs\n  2.React生命周期\n  3.React Router\n  4.Redux\n  5.React Native(主要用于移动端的开发)\n```\n## 3.AngularJS（国外开发大型项目常用框架）\nAngularJS的四大功能：\n1. MVC\n\n  将后台的MVC模式写入了前端语言中。我总觉得前端语言将来会很叼，从node.js开始我就又一种这样的感觉。可能在很久之后取代后端语言不是没有可能的。\n  \n 2. 模块化\n\n  就是一系列函数的集合，当应用被启动时，这些函数就会被执行。主要利用angular.module来定义模块。也是Angular.js的亮点。\n  \n3. 指令属性\n\n我自己的理解就是比html标签更加具有属性和方法的指令标签\n\n4. 双向数据绑定\n\n传统的数据绑定是单向绑定，数据只能从model和controller生成需要的html，但是不能返过来使用。只是单方向的。双向数据绑定:也就是说我在前面填写，后面直接生成代码，将填写的显示出来。双向的意思就是如果view修改了属性值，那么model机会看到这个改变。相反也是一样的。\n\n## 4. 小程序（类似一个前端开发框架）\n```\n推荐教程：官网上的小程序开发文档，尝试动手写一下小程序\n```\n\n\n## 5.nodejs(前端用来写后台的工具)\n\n简单的说 Node.js 就是运行在服务端的 JavaScript。\n\nNode.js 是一个基于Chrome JavaScript 运行时建立的一个平台。\n\nNode.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。\n```\n推荐教程：官网的教程\n```\n\n\n## 四、一些常用的ui框架\n   #### 1. Bootstrape：最好的响应式css框架\n   #### 2. Element-ui：完美适应vuejs的ui框架\n   #### 3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。\n   #### 4. Aliceui\n   #### 5.Echart：最好的图表制作框架\n   \n   ####   ·····\n   \n## 六、前端最好掌握的一些常用技能\n   1. Markdown笔记的使用，程序员专用笔记本\n   2. github的使用：全球最大的开源代码网站，在上面你可以找到全世界所有出名项目的源代码，被称为人类的知识宝库。\n   3. 用github page搭建个人博客，上传个人项目到github上，面试加分必备项\n   4. 移动端的开发\n   5. 前端web开发命名规范，谷歌、百度命名标准\n   \n      等等·······","slug":"前端/前端学习路线规划","published":1,"date":"2018-05-03T13:47:18.640Z","updated":"2018-05-03T14:02:35.206Z","layout":"post","photos":[],"link":"","_id":"cka6kints00giqgu96qgzu3ni","content":"<h1 id=\"前端学习路线规划\"><a href=\"#前端学习路线规划\" class=\"headerlink\" title=\"前端学习路线规划\"></a>前端学习路线规划</h1><h2 id=\"一、代码编写工具\"><a href=\"#一、代码编写工具\" class=\"headerlink\" title=\"一、代码编写工具\"></a>一、代码编写工具</h2><h3 id=\"sublime-Text-3\"><a href=\"#sublime-Text-3\" class=\"headerlink\" title=\"sublime Text 3:\"></a><strong>sublime Text 3</strong>:</h3><ol>\n<li><p>sublime text编辑器单从界面看非常简洁，可以说让人一见倾心的感觉。完全符合码农的口味~~。功能上也不复杂，就跟记事本似的，很容易上手。</p>\n</li>\n<li><p>可以自由扩展，sublime提供了安装插件的方式，可以任意安装你想要的插件.</p>\n</li>\n</ol>\n<h2 id=\"二、学习路线规划\"><a href=\"#二、学习路线规划\" class=\"headerlink\" title=\"二、学习路线规划\"></a>二、学习路线规划</h2><h3 id=\"1-熟练使用-HTML、CSS\"><a href=\"#1-熟练使用-HTML、CSS\" class=\"headerlink\" title=\"1.  熟练使用 HTML、CSS\"></a>1.  熟练使用 HTML、CSS</h3><p>HTML 是标签语言，可以构建前端页面的骨架；CSS是层叠样式控制表，可以构建前端页面的外貌</p>\n<p>这部分比较简单，到网上搜资料，书籍视频非常多。css中盒子模型，流动，block，inline，层叠，样式优先级等这些比较重要。最后再深入了解下浏览器差异性，ie9以下兼容简单了解就行了，ie9以下浏览器被淘汰掉是趋势，低版本没必要浪费大量时间去学习兼容主流浏览器，google chrome浏览器、firefox浏览器、safari浏览器、opera浏览器即可。浏览器差异内容很多，建议在实践中多多积累。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐书籍：《Head First HTML 与 CSS (第2版)》</span><br><span class=\"line\">          《CSS 禅意花园(修订版)》</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-javascript部分（最重要的部分）\"><a href=\"#2-javascript部分（最重要的部分）\" class=\"headerlink\" title=\"2.javascript部分（最重要的部分）\"></a>2.javascript部分（最重要的部分）</h3><p>难点，也是重点，要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，有很多比较抽象的概念，必须要深入理解，比如闭包、原型、面向对象、封装等，要理解透彻。看书是必不可少的，找一本优秀的js书从头到尾深入学习了。另外，js面向对象编程必须要学习，非常重要，个人推荐一本书《javascript高级程序设计》。边学边练，实践出真知。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：网易云课堂上 李炎恢老师的视频，讲得很详细，讲的是和那本红宝书一样的内容</span><br><span class=\"line\">          多动手写demo</span><br><span class=\"line\">推荐书籍：《Javascript 权威指南》</span><br><span class=\"line\">         《JavaScript 高级程序设计(第3版)》</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-jQuery学习（这不是一个框架，是一个类库）\"><a href=\"#3-jQuery学习（这不是一个框架，是一个类库）\" class=\"headerlink\" title=\"3.jQuery学习（这不是一个框架，是一个类库）\"></a>3.jQuery学习（这不是一个框架，是一个类库）</h3><p>这些基础知识掌握好之后，还需要学jQuery，这是一个非常优秀的Javascript库，大型开发必备。它简化了Javascript的复杂操作，消除了Javascript跨平台兼容问题，提供了大量实用方法，有良好的文档和帮助手册，是一个非常成熟的Javascript库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：网易云课堂上 李炎恢老师的视频，多动手写demo</span><br><span class=\"line\">推荐书籍：《锋利的jquery》</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-ajax的学习\"><a href=\"#4-ajax的学习\" class=\"headerlink\" title=\"4.ajax的学习\"></a>4.ajax的学习</h3><p>通过在后台与服务器进行数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，ajax是现在前端后台交互的主要方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">掌握的知识点：js原生的发送ajax的方法</span><br><span class=\"line\">             jq的简便的发送ajax的方法</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-git\"><a href=\"#5-git\" class=\"headerlink\" title=\"5.git\"></a>5.git</h3><p>Git是目前世界上最先进的分布式版本控制系统，适合于在团队合作时进行版本控制，提高开发效率</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：廖雪峰老师的关于git的教程博客</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-理解前端语言新标准-HTML5、CSS3、ES6-及其特性\"><a href=\"#6-理解前端语言新标准-HTML5、CSS3、ES6-及其特性\" class=\"headerlink\" title=\"6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性\"></a>6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性</h3><p>熟练使用 HTML、CSS、JavaScript 还需要我们理解其语言最新相关标准：HTML5、CSS3 和 ES6(ECMAScript6)。</p>\n<ul>\n<li>HTML 5 里新增了许多特性：语义化和新的音频、视频支持等；</li>\n<li>CSS 3 被划分为模块，解决了 CSS2 为等待各个标准统一而耗费大量时间才能推进的不足之处，同时也提供了 2D、3D、动画效果等新特性；</li>\n<li>ECMAScript6 等于 JavaScript - DOM - BOM，是 JavaScript 在 2015 年的最新标准，因为 ES6 对标准改动较大，前端开发者常常将一个前端项目是否支持 ES6 作为推进前端新技术的重要桥梁之一。ES6 将箭头函数、let 变量声明命令、Promise 编程、模块化编程等新特性纳入其标准中，得到了各大浏览器最新版本的支持。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">扩展阅读：《ES6 标准入门(第2版)》</span><br><span class=\"line\">          《深入理解ES6》</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-掌握浏览器兼容、响应式布局相关解决方案\"><a href=\"#7-掌握浏览器兼容、响应式布局相关解决方案\" class=\"headerlink\" title=\"7.掌握浏览器兼容、响应式布局相关解决方案\"></a>7.掌握浏览器兼容、响应式布局相关解决方案</h3><p>早期占据浏览器半壁江山的IE浏览器上存在的众多浏览器兼容问题，耗费了当时前端开发者的大量开发时间。虽然说现在的前端开发者已经不需要考虑太多的浏览器兼容问题，对其概念的了解有利于了解前端历史包袱或在未来足以应对一些面向特殊群体(早期 IE 浏览器使用者)的前端项目。<br><strong>关于IE浏览器的兼容性问题在李炎恢老师的那个视频有详细的讲解</strong></p>\n<p>响应式布局和单页面应用是当代前端开发者的必备技能。从 Web Pages 到 Web App 时代，我们开发的前端项目有越来越多的可能需要同时在电脑端和手机端进行访问，一个有良好响应式布局的前端项目可以一个代码运行在多种不同分辨率的平台之上。</p>\n<h2 id=\"三、现在前端主流的框架\"><a href=\"#三、现在前端主流的框架\" class=\"headerlink\" title=\"三、现在前端主流的框架\"></a>三、现在前端主流的框架</h2><h3 id=\"1-vuejs-2016年最火的前端框架（MVVC框架）\"><a href=\"#1-vuejs-2016年最火的前端框架（MVVC框架）\" class=\"headerlink\" title=\"1. vuejs :2016年最火的前端框架（MVVC框架）\"></a>1. vuejs :2016年最火的前端框架（MVVC框架）</h3><p>是一套用于构建用户界面的渐进式框架Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<p><strong>常用于单页面应用的开发</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">掌握的要点：(vue全家桶)</span><br><span class=\"line\">   1.vue-router</span><br><span class=\"line\">   2.vuex</span><br><span class=\"line\">   3.vue-resource</span><br><span class=\"line\">   4.vue-cli</span><br><span class=\"line\">   5.Element-ui</span><br><span class=\"line\">   </span><br><span class=\"line\">推荐教程：详细阅读官网教程，中国人自己研发的，有中文版，不难</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-Reactjs\"><a href=\"#2-Reactjs\" class=\"headerlink\" title=\"2. Reactjs\"></a>2. Reactjs</h3><p>React 是一个用于构建用户界面的 javascript 库。</p>\n<p>React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。</p>\n<p>React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。</p>\n<p>React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>\n<p><strong>React特点：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.声明式设计 −React采用声明范式，可以轻松描述应用。</span><br><span class=\"line\">2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。</span><br><span class=\"line\">3.灵活 −React可以与已知的库或框架很好地配合。</span><br><span class=\"line\">4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</span><br><span class=\"line\">5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</span><br><span class=\"line\">6.单向响应的数据流 − React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">掌握的知识点：（React全家桶技术）</span><br><span class=\"line\">  1.Reactjs</span><br><span class=\"line\">  2.React生命周期</span><br><span class=\"line\">  3.React Router</span><br><span class=\"line\">  4.Redux</span><br><span class=\"line\">  5.React Native(主要用于移动端的开发)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-AngularJS（国外开发大型项目常用框架）\"><a href=\"#3-AngularJS（国外开发大型项目常用框架）\" class=\"headerlink\" title=\"3.AngularJS（国外开发大型项目常用框架）\"></a>3.AngularJS（国外开发大型项目常用框架）</h2><p>AngularJS的四大功能：</p>\n<ol>\n<li><p>MVC</p>\n<p>将后台的MVC模式写入了前端语言中。我总觉得前端语言将来会很叼，从node.js开始我就又一种这样的感觉。可能在很久之后取代后端语言不是没有可能的。</p>\n<ol start=\"2\">\n<li>模块化</li>\n</ol>\n<p>就是一系列函数的集合，当应用被启动时，这些函数就会被执行。主要利用angular.module来定义模块。也是Angular.js的亮点。</p>\n</li>\n<li><p>指令属性</p>\n</li>\n</ol>\n<p>我自己的理解就是比html标签更加具有属性和方法的指令标签</p>\n<ol start=\"4\">\n<li>双向数据绑定</li>\n</ol>\n<p>传统的数据绑定是单向绑定，数据只能从model和controller生成需要的html，但是不能返过来使用。只是单方向的。双向数据绑定:也就是说我在前面填写，后面直接生成代码，将填写的显示出来。双向的意思就是如果view修改了属性值，那么model机会看到这个改变。相反也是一样的。</p>\n<h2 id=\"4-小程序（类似一个前端开发框架）\"><a href=\"#4-小程序（类似一个前端开发框架）\" class=\"headerlink\" title=\"4. 小程序（类似一个前端开发框架）\"></a>4. 小程序（类似一个前端开发框架）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：官网上的小程序开发文档，尝试动手写一下小程序</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-nodejs-前端用来写后台的工具\"><a href=\"#5-nodejs-前端用来写后台的工具\" class=\"headerlink\" title=\"5.nodejs(前端用来写后台的工具)\"></a>5.nodejs(前端用来写后台的工具)</h2><p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>\n<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>\n<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：官网的教程</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"四、一些常用的ui框架\"><a href=\"#四、一些常用的ui框架\" class=\"headerlink\" title=\"四、一些常用的ui框架\"></a>四、一些常用的ui框架</h2><h4 id=\"1-Bootstrape：最好的响应式css框架\"><a href=\"#1-Bootstrape：最好的响应式css框架\" class=\"headerlink\" title=\"1. Bootstrape：最好的响应式css框架\"></a>1. Bootstrape：最好的响应式css框架</h4><h4 id=\"2-Element-ui：完美适应vuejs的ui框架\"><a href=\"#2-Element-ui：完美适应vuejs的ui框架\" class=\"headerlink\" title=\"2. Element-ui：完美适应vuejs的ui框架\"></a>2. Element-ui：完美适应vuejs的ui框架</h4><h4 id=\"3-Amazeui：Amaze-UI-是一个轻量级、-Mobile-first-的前端框架-基于开源社区流行前端框架编写的。\"><a href=\"#3-Amazeui：Amaze-UI-是一个轻量级、-Mobile-first-的前端框架-基于开源社区流行前端框架编写的。\" class=\"headerlink\" title=\"3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。\"></a>3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。</h4><h4 id=\"4-Aliceui\"><a href=\"#4-Aliceui\" class=\"headerlink\" title=\"4. Aliceui\"></a>4. Aliceui</h4><h4 id=\"5-Echart：最好的图表制作框架\"><a href=\"#5-Echart：最好的图表制作框架\" class=\"headerlink\" title=\"5.Echart：最好的图表制作框架\"></a>5.Echart：最好的图表制作框架</h4><h4 id=\"·····\"><a href=\"#·····\" class=\"headerlink\" title=\"·····\"></a>·····</h4><h2 id=\"六、前端最好掌握的一些常用技能\"><a href=\"#六、前端最好掌握的一些常用技能\" class=\"headerlink\" title=\"六、前端最好掌握的一些常用技能\"></a>六、前端最好掌握的一些常用技能</h2><ol>\n<li>Markdown笔记的使用，程序员专用笔记本</li>\n<li>github的使用：全球最大的开源代码网站，在上面你可以找到全世界所有出名项目的源代码，被称为人类的知识宝库。</li>\n<li>用github page搭建个人博客，上传个人项目到github上，面试加分必备项</li>\n<li>移动端的开发</li>\n<li><p>前端web开发命名规范，谷歌、百度命名标准</p>\n<p>等等·······</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端学习路线规划\"><a href=\"#前端学习路线规划\" class=\"headerlink\" title=\"前端学习路线规划\"></a>前端学习路线规划</h1><h2 id=\"一、代码编写工具\"><a href=\"#一、代码编写工具\" class=\"headerlink\" title=\"一、代码编写工具\"></a>一、代码编写工具</h2><h3 id=\"sublime-Text-3\"><a href=\"#sublime-Text-3\" class=\"headerlink\" title=\"sublime Text 3:\"></a><strong>sublime Text 3</strong>:</h3><ol>\n<li><p>sublime text编辑器单从界面看非常简洁，可以说让人一见倾心的感觉。完全符合码农的口味~~。功能上也不复杂，就跟记事本似的，很容易上手。</p>\n</li>\n<li><p>可以自由扩展，sublime提供了安装插件的方式，可以任意安装你想要的插件.</p>\n</li>\n</ol>\n<h2 id=\"二、学习路线规划\"><a href=\"#二、学习路线规划\" class=\"headerlink\" title=\"二、学习路线规划\"></a>二、学习路线规划</h2><h3 id=\"1-熟练使用-HTML、CSS\"><a href=\"#1-熟练使用-HTML、CSS\" class=\"headerlink\" title=\"1.  熟练使用 HTML、CSS\"></a>1.  熟练使用 HTML、CSS</h3><p>HTML 是标签语言，可以构建前端页面的骨架；CSS是层叠样式控制表，可以构建前端页面的外貌</p>\n<p>这部分比较简单，到网上搜资料，书籍视频非常多。css中盒子模型，流动，block，inline，层叠，样式优先级等这些比较重要。最后再深入了解下浏览器差异性，ie9以下兼容简单了解就行了，ie9以下浏览器被淘汰掉是趋势，低版本没必要浪费大量时间去学习兼容主流浏览器，google chrome浏览器、firefox浏览器、safari浏览器、opera浏览器即可。浏览器差异内容很多，建议在实践中多多积累。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐书籍：《Head First HTML 与 CSS (第2版)》</span><br><span class=\"line\">          《CSS 禅意花园(修订版)》</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-javascript部分（最重要的部分）\"><a href=\"#2-javascript部分（最重要的部分）\" class=\"headerlink\" title=\"2.javascript部分（最重要的部分）\"></a>2.javascript部分（最重要的部分）</h3><p>难点，也是重点，要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，有很多比较抽象的概念，必须要深入理解，比如闭包、原型、面向对象、封装等，要理解透彻。看书是必不可少的，找一本优秀的js书从头到尾深入学习了。另外，js面向对象编程必须要学习，非常重要，个人推荐一本书《javascript高级程序设计》。边学边练，实践出真知。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：网易云课堂上 李炎恢老师的视频，讲得很详细，讲的是和那本红宝书一样的内容</span><br><span class=\"line\">          多动手写demo</span><br><span class=\"line\">推荐书籍：《Javascript 权威指南》</span><br><span class=\"line\">         《JavaScript 高级程序设计(第3版)》</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-jQuery学习（这不是一个框架，是一个类库）\"><a href=\"#3-jQuery学习（这不是一个框架，是一个类库）\" class=\"headerlink\" title=\"3.jQuery学习（这不是一个框架，是一个类库）\"></a>3.jQuery学习（这不是一个框架，是一个类库）</h3><p>这些基础知识掌握好之后，还需要学jQuery，这是一个非常优秀的Javascript库，大型开发必备。它简化了Javascript的复杂操作，消除了Javascript跨平台兼容问题，提供了大量实用方法，有良好的文档和帮助手册，是一个非常成熟的Javascript库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：网易云课堂上 李炎恢老师的视频，多动手写demo</span><br><span class=\"line\">推荐书籍：《锋利的jquery》</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-ajax的学习\"><a href=\"#4-ajax的学习\" class=\"headerlink\" title=\"4.ajax的学习\"></a>4.ajax的学习</h3><p>通过在后台与服务器进行数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，ajax是现在前端后台交互的主要方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">掌握的知识点：js原生的发送ajax的方法</span><br><span class=\"line\">             jq的简便的发送ajax的方法</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-git\"><a href=\"#5-git\" class=\"headerlink\" title=\"5.git\"></a>5.git</h3><p>Git是目前世界上最先进的分布式版本控制系统，适合于在团队合作时进行版本控制，提高开发效率</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：廖雪峰老师的关于git的教程博客</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-理解前端语言新标准-HTML5、CSS3、ES6-及其特性\"><a href=\"#6-理解前端语言新标准-HTML5、CSS3、ES6-及其特性\" class=\"headerlink\" title=\"6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性\"></a>6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性</h3><p>熟练使用 HTML、CSS、JavaScript 还需要我们理解其语言最新相关标准：HTML5、CSS3 和 ES6(ECMAScript6)。</p>\n<ul>\n<li>HTML 5 里新增了许多特性：语义化和新的音频、视频支持等；</li>\n<li>CSS 3 被划分为模块，解决了 CSS2 为等待各个标准统一而耗费大量时间才能推进的不足之处，同时也提供了 2D、3D、动画效果等新特性；</li>\n<li>ECMAScript6 等于 JavaScript - DOM - BOM，是 JavaScript 在 2015 年的最新标准，因为 ES6 对标准改动较大，前端开发者常常将一个前端项目是否支持 ES6 作为推进前端新技术的重要桥梁之一。ES6 将箭头函数、let 变量声明命令、Promise 编程、模块化编程等新特性纳入其标准中，得到了各大浏览器最新版本的支持。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">扩展阅读：《ES6 标准入门(第2版)》</span><br><span class=\"line\">          《深入理解ES6》</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-掌握浏览器兼容、响应式布局相关解决方案\"><a href=\"#7-掌握浏览器兼容、响应式布局相关解决方案\" class=\"headerlink\" title=\"7.掌握浏览器兼容、响应式布局相关解决方案\"></a>7.掌握浏览器兼容、响应式布局相关解决方案</h3><p>早期占据浏览器半壁江山的IE浏览器上存在的众多浏览器兼容问题，耗费了当时前端开发者的大量开发时间。虽然说现在的前端开发者已经不需要考虑太多的浏览器兼容问题，对其概念的了解有利于了解前端历史包袱或在未来足以应对一些面向特殊群体(早期 IE 浏览器使用者)的前端项目。<br><strong>关于IE浏览器的兼容性问题在李炎恢老师的那个视频有详细的讲解</strong></p>\n<p>响应式布局和单页面应用是当代前端开发者的必备技能。从 Web Pages 到 Web App 时代，我们开发的前端项目有越来越多的可能需要同时在电脑端和手机端进行访问，一个有良好响应式布局的前端项目可以一个代码运行在多种不同分辨率的平台之上。</p>\n<h2 id=\"三、现在前端主流的框架\"><a href=\"#三、现在前端主流的框架\" class=\"headerlink\" title=\"三、现在前端主流的框架\"></a>三、现在前端主流的框架</h2><h3 id=\"1-vuejs-2016年最火的前端框架（MVVC框架）\"><a href=\"#1-vuejs-2016年最火的前端框架（MVVC框架）\" class=\"headerlink\" title=\"1. vuejs :2016年最火的前端框架（MVVC框架）\"></a>1. vuejs :2016年最火的前端框架（MVVC框架）</h3><p>是一套用于构建用户界面的渐进式框架Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<p><strong>常用于单页面应用的开发</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">掌握的要点：(vue全家桶)</span><br><span class=\"line\">   1.vue-router</span><br><span class=\"line\">   2.vuex</span><br><span class=\"line\">   3.vue-resource</span><br><span class=\"line\">   4.vue-cli</span><br><span class=\"line\">   5.Element-ui</span><br><span class=\"line\">   </span><br><span class=\"line\">推荐教程：详细阅读官网教程，中国人自己研发的，有中文版，不难</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-Reactjs\"><a href=\"#2-Reactjs\" class=\"headerlink\" title=\"2. Reactjs\"></a>2. Reactjs</h3><p>React 是一个用于构建用户界面的 javascript 库。</p>\n<p>React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。</p>\n<p>React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。</p>\n<p>React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>\n<p><strong>React特点：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.声明式设计 −React采用声明范式，可以轻松描述应用。</span><br><span class=\"line\">2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。</span><br><span class=\"line\">3.灵活 −React可以与已知的库或框架很好地配合。</span><br><span class=\"line\">4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</span><br><span class=\"line\">5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</span><br><span class=\"line\">6.单向响应的数据流 − React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">掌握的知识点：（React全家桶技术）</span><br><span class=\"line\">  1.Reactjs</span><br><span class=\"line\">  2.React生命周期</span><br><span class=\"line\">  3.React Router</span><br><span class=\"line\">  4.Redux</span><br><span class=\"line\">  5.React Native(主要用于移动端的开发)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-AngularJS（国外开发大型项目常用框架）\"><a href=\"#3-AngularJS（国外开发大型项目常用框架）\" class=\"headerlink\" title=\"3.AngularJS（国外开发大型项目常用框架）\"></a>3.AngularJS（国外开发大型项目常用框架）</h2><p>AngularJS的四大功能：</p>\n<ol>\n<li><p>MVC</p>\n<p>将后台的MVC模式写入了前端语言中。我总觉得前端语言将来会很叼，从node.js开始我就又一种这样的感觉。可能在很久之后取代后端语言不是没有可能的。</p>\n<ol start=\"2\">\n<li>模块化</li>\n</ol>\n<p>就是一系列函数的集合，当应用被启动时，这些函数就会被执行。主要利用angular.module来定义模块。也是Angular.js的亮点。</p>\n</li>\n<li><p>指令属性</p>\n</li>\n</ol>\n<p>我自己的理解就是比html标签更加具有属性和方法的指令标签</p>\n<ol start=\"4\">\n<li>双向数据绑定</li>\n</ol>\n<p>传统的数据绑定是单向绑定，数据只能从model和controller生成需要的html，但是不能返过来使用。只是单方向的。双向数据绑定:也就是说我在前面填写，后面直接生成代码，将填写的显示出来。双向的意思就是如果view修改了属性值，那么model机会看到这个改变。相反也是一样的。</p>\n<h2 id=\"4-小程序（类似一个前端开发框架）\"><a href=\"#4-小程序（类似一个前端开发框架）\" class=\"headerlink\" title=\"4. 小程序（类似一个前端开发框架）\"></a>4. 小程序（类似一个前端开发框架）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：官网上的小程序开发文档，尝试动手写一下小程序</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-nodejs-前端用来写后台的工具\"><a href=\"#5-nodejs-前端用来写后台的工具\" class=\"headerlink\" title=\"5.nodejs(前端用来写后台的工具)\"></a>5.nodejs(前端用来写后台的工具)</h2><p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>\n<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>\n<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推荐教程：官网的教程</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"四、一些常用的ui框架\"><a href=\"#四、一些常用的ui框架\" class=\"headerlink\" title=\"四、一些常用的ui框架\"></a>四、一些常用的ui框架</h2><h4 id=\"1-Bootstrape：最好的响应式css框架\"><a href=\"#1-Bootstrape：最好的响应式css框架\" class=\"headerlink\" title=\"1. Bootstrape：最好的响应式css框架\"></a>1. Bootstrape：最好的响应式css框架</h4><h4 id=\"2-Element-ui：完美适应vuejs的ui框架\"><a href=\"#2-Element-ui：完美适应vuejs的ui框架\" class=\"headerlink\" title=\"2. Element-ui：完美适应vuejs的ui框架\"></a>2. Element-ui：完美适应vuejs的ui框架</h4><h4 id=\"3-Amazeui：Amaze-UI-是一个轻量级、-Mobile-first-的前端框架-基于开源社区流行前端框架编写的。\"><a href=\"#3-Amazeui：Amaze-UI-是一个轻量级、-Mobile-first-的前端框架-基于开源社区流行前端框架编写的。\" class=\"headerlink\" title=\"3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。\"></a>3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。</h4><h4 id=\"4-Aliceui\"><a href=\"#4-Aliceui\" class=\"headerlink\" title=\"4. Aliceui\"></a>4. Aliceui</h4><h4 id=\"5-Echart：最好的图表制作框架\"><a href=\"#5-Echart：最好的图表制作框架\" class=\"headerlink\" title=\"5.Echart：最好的图表制作框架\"></a>5.Echart：最好的图表制作框架</h4><h4 id=\"·····\"><a href=\"#·····\" class=\"headerlink\" title=\"·····\"></a>·····</h4><h2 id=\"六、前端最好掌握的一些常用技能\"><a href=\"#六、前端最好掌握的一些常用技能\" class=\"headerlink\" title=\"六、前端最好掌握的一些常用技能\"></a>六、前端最好掌握的一些常用技能</h2><ol>\n<li>Markdown笔记的使用，程序员专用笔记本</li>\n<li>github的使用：全球最大的开源代码网站，在上面你可以找到全世界所有出名项目的源代码，被称为人类的知识宝库。</li>\n<li>用github page搭建个人博客，上传个人项目到github上，面试加分必备项</li>\n<li>移动端的开发</li>\n<li><p>前端web开发命名规范，谷歌、百度命名标准</p>\n<p>等等·······</p>\n</li>\n</ol>\n"},{"title":"git：git使用","Date":"2020-03-16T16:00:00.000Z","comments":1,"_content":"\ngit的简介、安装就不罗嗦了，详细的教程可参考   \n[廖雪峰的git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n\n\n# 创建版本库（初始化一个git仓库）\n### 第一步\n选择一个合适的地方，创建一个空目录learngit\n\n```\n$ mkdir learngit\n$ cd learngit\n$ pwd\n\n```\npwd命令用于显示当前目录\n\n### 第二步\n通过git init命令把这个目录变成Git可以管理的仓库\n\n```\n$ git init\n\n```\n1、此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n2、如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。\n\n\n# 添加文件到Git仓库\n\n编写一个readme.txt文件\n内容为：\n\n```\nGit is a version control system.\nGit is free software.\n\n```\n### 第一步\n用命令git add告诉Git，把文件添加到仓库\n\n```\n$ git add readme.txt\n\n```\n1、执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功 \n\n2、add可反复多次使用，添加多个文件\n### 第二步\n用命令git commit告诉Git，把文件提交到仓库\n\n```\n$ git commit -m \"wrote a readme file\"\n\n```\n1、-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的  \n\n2、commit可以一次提交很多文件，所以你可以多次add不同的文件\n\n# 修改文件并提交\n\n修改readme.txt文件，改成如下内容\n\n```\nGit is a distributed version control system.\nGit is free software.\n\n```\n## git status\n运行git status命令看看结果\n\n```\n$ git status\n\n```\ngit status命令可以让我们时刻掌握仓库当前的状态\n\n## git diff\n比如有一个项目，隔了好几天没碰过了，想要继续写的时候，又忘了上次是怎么修改的，那么   \n运行git diff命令看看具体修改了什么内容\n\n```\n$ git diff readme.txt\n\n```\ngit diff顾名思义就是查看difference\n\n## 提交修改（与提交新文件一样）\n\n### 第一步\ngit add\n\n```\n$ git add readme.txt\n\n```\n\n### 第二步\ngit commit\n\n```\n$ git commit -m \"add distributed\"\n\n```\n\n# 版本回退\n\n现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了\n\n版本一：wrote a readme file\n\n```\nGit is a version control system.\nGit is free software.\n\n```\n版本二：add distributed\n\n```\nGit is a distributed version control system.\nGit is free software.\n\n```\n\n## git log\n运行git log命令可以查看每次修改的历史记录\n\n```\n$ git log\n\n```\n\n该命令显示从最近到最远的提交日志\n\n## 回退\n   \n###  git reset  \n运行git reset命令把版本二回退到版本一\n\n```\n$ git reset --hard HEAD     //当前版本\n$ git reset --hard HEAD^    //回退到上一个版本\n$ git reset --hard HEAD^^   //回退到上上一个版本\n\n```\n若有多个版本，可继续使用git reset命令回退\n\n### cat <file>\n看看readme.txt的内容是不是版本一\n\n```\n$ cat readme.txt\n\n```\n\n## 后悔回退，恢复版本\n\n此时，使用git log看一下版本库里的版本，哎呀，版本二不见了  \n那如果此时我又后悔了，我想要回退之前的版本了\n\n```\n$ git reset --hard 所需版本的commit id\n\n```\ncommit id不知道怎么办？？？  \n1、不怕，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到回退前执行git log后的版本库，每一个版本的commit后那一长串乱码一样的东西就是该版本的commit id了  \n当然，commit id很长，没必要写全，写前几位就好了（一般七位吧）\n\n恢复版本二\n\n```\n$ git reset --hard f3ab58\n\n```\n\n2、可是，当你关掉了命令行窗口后才后悔怎么办？？？  \n不怕，在Git中，总是有后悔药可以吃的 \n\nGit提供了一个命令git reflog用来记录你的每一次命令\n\n```\n$ git reflog\n\n```\n又可以找回所需版本的commit id了\n\n\n# 工作区与暂存区\n\n## 工作区\n就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区\n\n## 版本库\n工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库\n\nGit的版本库里存了很多东西  \n1、最重要的就是称为stage（或者叫index）的暂存区  \n2、还有Git为我们自动创建的第一个分支master  \n3、以及指向master的一个指针叫HEAD\n\n![image](https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0)\n\n\n前面讲了提交新文件到Git版本库：\n\n第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支\n\n# 撤销修改\n\n## git checkout -- file\n\n场景一（仅修改了文件） \n\n有一次头脑混乱，在readme.txt中加了一行乱码，死定了，要赶紧手动删掉，以为这样就没事了吗？不，事儿可大了，运行git status查看\n\n```\n$ git status\n\n```\n会显示改动了readme.txt\n\n这时候，运行**git checkout -- file**丢弃工作区的修改即可\n\n```\n$ git checkout -- readme.txt\n\n```\n有两种情况（都是修改了工作区的文件导致工作区与版本库不一致）：\n\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态\n\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态\n\n## git reset HEAD file\n\n场景二（修改文件后，git add到暂存区了）\n\n有一次头脑更混乱，不仅在readme.txt中加了一行乱码，还git add到暂存区了 \n\n幸好，用git status查看\n\n```\n$ git status\n\n```\n显示还没有提交\n\n这时候运行命令**git reset HEAD file**可以把暂存区的修改撤销掉（unstage），重新放回工作区即可\n\n```\n$ git reset HEAD readme.txt\n\n```\n\n再用git status查看\n\n```\n$ git status\n\n```\n现在暂存区是干净的，工作区有修改，回到场景一即可\n\n```\n$ git checkout -- readme.txt\n\n```\n\n\n## 版本回退\n\n场景三（改了文件，不仅添加了，还提交了）\n\n回到上上一个内容**版本回退**了\n\n\n# 删除文件\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了\n\n```\n$ rm test.txt\n\n```\nGit知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了\n\n```\n$ git status\n\n```\n此时有两种情况\n\n## 第一种情况\n\n确实要从版本库中删除该文件\n\n运行命令git rm删掉\n\n```\n$ git rm test.txt\n\n```\n\n并且git commit\n\n```\n$ git commit -m \"remove test.txt\"\n\n```\n\n## 第二种情况\n删错了\n\n因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本\n\n```\n$ git checkout -- test.txt\n\n```\ngit checkout -- file 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”\n\n\n# 远程仓库\n\ngit的杀手级功能---远程仓库    \n这个世界上有个叫GitHub的神奇的网站，这个网站是提供Git仓库托管服务的，只要注册一个GitHub账号，就可以免费获得Git远程仓库\n\n## 设置SSH Key\n由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的\n### 第一步\n创建SSH Key\n\n在用户主目录下，看看有没有.ssh目录；如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件；如果已经有了，可直接跳到下一步\n\n如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key\n\n```\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\n\n```\n一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码\n\n### 第二步\n登陆GitHub，打开“Account settings”，“SSH Keys”页面，\n\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n## 把本地项目添加到远程库\n\n### 第一步\n通过命令git init把项目文件夹变成Git可管理的仓库\n\n```\n$ git init\n```\n\n### 第二步\n把项目粘贴到这个本地Git仓库里面\n\n```\n$ git add .\n```\n\n### 第三步\n\n把项目提交到仓库\n\n```\n$ git commit -m \"注释\"\n```\n\n### 第四步\n登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库\n\n目前，在GitHub上的这个learngit仓库还是空的\n\n### 第五步\n\n\n在本地的learngit仓库下运行命令\n\n```\n$ git remote add origin git@github.com:michaelliao/learngit.git\n\n```\nmichaelliao替换成自己的GitHub账户名   \n使本地仓库关联远程库  \n添加后，远程库的名字就是origin，这是Git默认的叫法\n\n### 第六步\n把本地库的所有内容推送到远程库上\n\n```\n$ git push -u origin master\n\n```\n### 最后的最后\n从现在起，只要本地作了提交，就可以运行命令把本地master分支的最新修改推送至GitHub\n\n```\n$ git push origin master\n\n```\n\n## 从远程库克隆到本地库\n\n### 第一步\n登陆GitHub，创建一个新的仓库，名字叫gitskills    \n勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件\n\n### 第二步\n用命令git clone克隆一个本地库\n\n```\n$ git clone git@github.com:michaelliao/gitskills.git\n\n```\nmichaelliao替换成自己的GitHub账户名\n\n# 分支管理\n\n## 创建与合并分支\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点\n\n![image](https://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0)\n\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长\n\n### 第一步\n创建dev分支\n\n```\n$ git branch dev\n\n```\n切换到dev分支\n\n```\n$ git checkout dev\n\n```\n可合并为创建并切换到dev分支\n\n```\n$ git checkout -b dev\n\n```\n\n### 第二步\n用git branch命令查看当前分支\n\n```\n$ git branch\n* dev\n  master\n\n```\ngit branch命令会列出所有分支，当前分支前面会标一个*号\n\n### 第三步\n\n在dev分支上正常提交    \n比如对readme.txt做个修改，加上一行\n\n```\nCreating a new branch is quick.\n\n```\n然后提交\n\n```\n$ git add readme.txt \n$ git commit -m \"branch test\"\n\n```\n\n### 第四步\n现在，dev分支的工作完成，我们就可以切换回master分支\n\n```\n$ git checkout master\n\n```\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变\n![image](https://www.liaoxuefeng.com/files/attachments/001384908892295909f96758654469cad60dc50edfa9abd000/0)\n\n### 第五步\n把dev分支的工作成果合并到master分支上\n\n```\n$ git merge dev\n\n```\ngit merge命令用于合并指定分支到当前分支    \n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式\n\n### 第六步\n合并完成后，就可以放心地删除dev分支了\n\n```\n$ git branch -d dev\n\n```\n删除后，查看branch，就只剩下master分支了\n\n```\n$ git branch\n* master\n\n```\n\n## 解决冲突\n### 第一步\n此时，创建了一个新的分支feature1\n\n```\n$ git checkout -b feature1\n\n```\n在readme.txt最后添加一行并提交\n\n```\nCreating a new branch is quick AND simple.\n\n```\n\n### 第二步\n切换到master分支\n\n```\n$ git checkout master\n\n```\n在master分支上readme.txt最后添加一行并提交\n\n```\nCreating a new branch is quick & simple.\n\n```\n\n\n此时，master分支和feature1分支各自都分别有新的提交\n![image](https://www.liaoxuefeng.com/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0)\n\n### 第三步\n由于两个分支各自有修改，两者合并起来可能会有冲突\n\n```\n$ git merge feature1\n\n```\ngit status会告诉我们冲突的文件\n\n```\n$ git status\n\n```\n也可以查看readme.txt的内容\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n\n```\n\n### 第四步\n此时，需要手动修改冲突内容\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nCreating a new branch is quick and simple.\n\n```\n再提交\n\n```\n$ git add readme.txt \n$ git commit -m \"conflict fixed\"\n\n```\n现在，master分支和feature1分支变成这样\n![image](https://www.liaoxuefeng.com/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0)\n用带参数的git log也可以看到分支的合并情况\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n\n```\n\n### 第五步\n最后，删除feature1分支\n\n```\n$ git branch -d feature1\n\n```\n\n## 分支管理策略\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息\n### 第一步\n创建并切换dev分支\n\n```\n$ git checkout -b dev\n\n```\n### 第二步\n修改readme.txt文件，并提交一个新的commit\n\n```\n$ git add readme.txt \n$ git commit -m \"add merge\"\n\n```\n### 第三步\n切换回master\n\n```\n$ git checkout master\n\n```\n### 第四步\n准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward\n\n```\n$ git merge --no-ff -m \"merge with no-ff\" dev\n\n```\n加上-m参数，把commit描述写进去\n\n合并后，我们用git log看看分支历史\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n\n```\n![image](https://cdn.webxueyuan.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0)\n\n## Bug分支\n\n某天突然接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug\n\n### 第一步\n\n把当前工作现场“储藏”起来，等以后恢复现场后继续工作\n\n```\n$ git stash\n\n```\n现在，用git status查看工作区，就是干净的\n\n### 第二步\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支\n\n```\n$ git checkout master\n\n```\n\n```\n$ git checkout -b issue-101\n\n```\n\n### 第三步\n\n修复bug，然后提交\n\n```\n$ git add readme.txt \n$ git commit -m \"fix bug 101\"\n\n```\n\n### 第四步\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支\n\n```\n$ git checkout master\n\n```\n\n```\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\n\n```\n\n```\n$ git branch -d issue-101\n\n```\n\n### 第五步\n\n接着回到dev分支干活了\n\n```\n$ git checkout dev\n\n```\n\n```\n$ git status\n\n```\n工作区是干净的，用git stash list命令看看刚才的工作现场存到哪去了？\n\n```\n$ git stash list\n\n```\n### 第六步\n\n恢复stash内容\n\n一种是用git stash apply恢复，然后用git stash drop删除stash内容\n\n另一种方式是用git stash pop，恢复的同时把stash内容也删了\n\n```\n$ git stash pop\n\n```\n可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash\n\n```\n$ git stash apply stash@{0}\n\n```\n### 疑问\n\n#### 第一个问题\n在dev中工作，在master中创建分支修改bug，好像互不相干呀，为什么要stash呢？\n\n暂存区是公用的，如果不通过stash命令隐藏，会带到其它分支（issue-101）去\n\n#### 第二个问题\n为什么要创建分支修改bug呢，直接在master中改不就好了吗？  \n\n实际项目中，这个bug可能很麻烦，你需要修复一天的时间才能搞定，如果你不创建101分支，那么这时候你们组内其他小伙伴也要紧急修复线上一个bug，但是他的bug可能就1分钟。他修复好了却不能上线，因为你没有创建分支，要等你一天，才能把你处理好的正确代码一起上线。   \n可能也会觉得创建分支不够效率，但是工作中稳健很重要\n\n## Feature分支\n每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支\n\n### 第一步\n开发并提交\n\n```\n$ git checkout -b feature-vulcan\n\n```\n\n```\n$ git add vulcan.py\n$ git commit -m \"add feature vulcan\"\n\n```\n### 第二步\n切回dev，准备合并\n\n```\n$ git checkout dev\n\n```\n### 第三步\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除\n但是，由于种种原因，新功能取消，这个分支必须就地销毁\n\n```\n$ git branch -d feature-vulcan\n\n```\n销毁失败\n\nGit友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改       \n如果要强行删除，需要使用命令git branch -D feature-vulcan\n\n```\n$ git branch -D feature-vulcan\n\n```\n\n## 多人协作\n查看远程库的信息\n\n```\n$ git remote\n\n```\n显示更详细的信息\n\n```\n$ git remote -v\n\n```\n### 推送分支\n推送分支，就是把该分支上的所有本地提交推送到远程库\n\n推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上\n\n```\n$ git push origin master\n\n```\n或推送其他分支\n\n```\n$ git push origin dev\n\n```\n注意：\n\n1、master分支是主分支，因此要时刻与远程同步；\n\n2、dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\n3、bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\n4、feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n### 抓取分支\n当push失败时，则因为远程分支比你的本地更新\n\n先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送\n\n```\n$ git pull\n\n```\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接\n\n设置dev和origin/dev的链接\n\n```\n$ git branch --set-upstream dev origin/dev\n\n```\n再pull\n\n```\n$ git pull\n\n```\ngit pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样\n\n解决后，提交，再push\n\n# 标签管理\n### 创建标签\n首先，切换到需要打标签的分支上\n\n```\n$ git branch\n* dev\n  master\n$ git checkout master\nSwitched to branch 'master'\n\n```\n创建一个新标签\n\n```\n$ git tag <name>\n```\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字\n\n```\n$ git tag -a <tagname> -m \"blablabla...\"\n```\n\n查看所有标签\n\n```\n$ git tag  //按字母排序\n$ git show <tagname>\n```\n默认标签是打在最新提交的commit上的\n\n有时候，如果忘了打标签\n\n方法是找到历史提交的commit id\n\n```\n$ git log --pretty=oneline --abbrev-commit\n```\n然后打上标签就可以了\n```\n$ git tag <name> <commit id>\n```\n\n### 未完待续","source":"_posts/git/git：git使用.md","raw":"---\ntitle: git：git使用\nDate: 2020-03-17\ntags: [git]\ncategories: git\ncomments: true\n---\n\ngit的简介、安装就不罗嗦了，详细的教程可参考   \n[廖雪峰的git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n\n\n# 创建版本库（初始化一个git仓库）\n### 第一步\n选择一个合适的地方，创建一个空目录learngit\n\n```\n$ mkdir learngit\n$ cd learngit\n$ pwd\n\n```\npwd命令用于显示当前目录\n\n### 第二步\n通过git init命令把这个目录变成Git可以管理的仓库\n\n```\n$ git init\n\n```\n1、此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n2、如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。\n\n\n# 添加文件到Git仓库\n\n编写一个readme.txt文件\n内容为：\n\n```\nGit is a version control system.\nGit is free software.\n\n```\n### 第一步\n用命令git add告诉Git，把文件添加到仓库\n\n```\n$ git add readme.txt\n\n```\n1、执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功 \n\n2、add可反复多次使用，添加多个文件\n### 第二步\n用命令git commit告诉Git，把文件提交到仓库\n\n```\n$ git commit -m \"wrote a readme file\"\n\n```\n1、-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的  \n\n2、commit可以一次提交很多文件，所以你可以多次add不同的文件\n\n# 修改文件并提交\n\n修改readme.txt文件，改成如下内容\n\n```\nGit is a distributed version control system.\nGit is free software.\n\n```\n## git status\n运行git status命令看看结果\n\n```\n$ git status\n\n```\ngit status命令可以让我们时刻掌握仓库当前的状态\n\n## git diff\n比如有一个项目，隔了好几天没碰过了，想要继续写的时候，又忘了上次是怎么修改的，那么   \n运行git diff命令看看具体修改了什么内容\n\n```\n$ git diff readme.txt\n\n```\ngit diff顾名思义就是查看difference\n\n## 提交修改（与提交新文件一样）\n\n### 第一步\ngit add\n\n```\n$ git add readme.txt\n\n```\n\n### 第二步\ngit commit\n\n```\n$ git commit -m \"add distributed\"\n\n```\n\n# 版本回退\n\n现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了\n\n版本一：wrote a readme file\n\n```\nGit is a version control system.\nGit is free software.\n\n```\n版本二：add distributed\n\n```\nGit is a distributed version control system.\nGit is free software.\n\n```\n\n## git log\n运行git log命令可以查看每次修改的历史记录\n\n```\n$ git log\n\n```\n\n该命令显示从最近到最远的提交日志\n\n## 回退\n   \n###  git reset  \n运行git reset命令把版本二回退到版本一\n\n```\n$ git reset --hard HEAD     //当前版本\n$ git reset --hard HEAD^    //回退到上一个版本\n$ git reset --hard HEAD^^   //回退到上上一个版本\n\n```\n若有多个版本，可继续使用git reset命令回退\n\n### cat <file>\n看看readme.txt的内容是不是版本一\n\n```\n$ cat readme.txt\n\n```\n\n## 后悔回退，恢复版本\n\n此时，使用git log看一下版本库里的版本，哎呀，版本二不见了  \n那如果此时我又后悔了，我想要回退之前的版本了\n\n```\n$ git reset --hard 所需版本的commit id\n\n```\ncommit id不知道怎么办？？？  \n1、不怕，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到回退前执行git log后的版本库，每一个版本的commit后那一长串乱码一样的东西就是该版本的commit id了  \n当然，commit id很长，没必要写全，写前几位就好了（一般七位吧）\n\n恢复版本二\n\n```\n$ git reset --hard f3ab58\n\n```\n\n2、可是，当你关掉了命令行窗口后才后悔怎么办？？？  \n不怕，在Git中，总是有后悔药可以吃的 \n\nGit提供了一个命令git reflog用来记录你的每一次命令\n\n```\n$ git reflog\n\n```\n又可以找回所需版本的commit id了\n\n\n# 工作区与暂存区\n\n## 工作区\n就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区\n\n## 版本库\n工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库\n\nGit的版本库里存了很多东西  \n1、最重要的就是称为stage（或者叫index）的暂存区  \n2、还有Git为我们自动创建的第一个分支master  \n3、以及指向master的一个指针叫HEAD\n\n![image](https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0)\n\n\n前面讲了提交新文件到Git版本库：\n\n第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支\n\n# 撤销修改\n\n## git checkout -- file\n\n场景一（仅修改了文件） \n\n有一次头脑混乱，在readme.txt中加了一行乱码，死定了，要赶紧手动删掉，以为这样就没事了吗？不，事儿可大了，运行git status查看\n\n```\n$ git status\n\n```\n会显示改动了readme.txt\n\n这时候，运行**git checkout -- file**丢弃工作区的修改即可\n\n```\n$ git checkout -- readme.txt\n\n```\n有两种情况（都是修改了工作区的文件导致工作区与版本库不一致）：\n\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态\n\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态\n\n## git reset HEAD file\n\n场景二（修改文件后，git add到暂存区了）\n\n有一次头脑更混乱，不仅在readme.txt中加了一行乱码，还git add到暂存区了 \n\n幸好，用git status查看\n\n```\n$ git status\n\n```\n显示还没有提交\n\n这时候运行命令**git reset HEAD file**可以把暂存区的修改撤销掉（unstage），重新放回工作区即可\n\n```\n$ git reset HEAD readme.txt\n\n```\n\n再用git status查看\n\n```\n$ git status\n\n```\n现在暂存区是干净的，工作区有修改，回到场景一即可\n\n```\n$ git checkout -- readme.txt\n\n```\n\n\n## 版本回退\n\n场景三（改了文件，不仅添加了，还提交了）\n\n回到上上一个内容**版本回退**了\n\n\n# 删除文件\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了\n\n```\n$ rm test.txt\n\n```\nGit知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了\n\n```\n$ git status\n\n```\n此时有两种情况\n\n## 第一种情况\n\n确实要从版本库中删除该文件\n\n运行命令git rm删掉\n\n```\n$ git rm test.txt\n\n```\n\n并且git commit\n\n```\n$ git commit -m \"remove test.txt\"\n\n```\n\n## 第二种情况\n删错了\n\n因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本\n\n```\n$ git checkout -- test.txt\n\n```\ngit checkout -- file 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”\n\n\n# 远程仓库\n\ngit的杀手级功能---远程仓库    \n这个世界上有个叫GitHub的神奇的网站，这个网站是提供Git仓库托管服务的，只要注册一个GitHub账号，就可以免费获得Git远程仓库\n\n## 设置SSH Key\n由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的\n### 第一步\n创建SSH Key\n\n在用户主目录下，看看有没有.ssh目录；如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件；如果已经有了，可直接跳到下一步\n\n如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key\n\n```\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\n\n```\n一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码\n\n### 第二步\n登陆GitHub，打开“Account settings”，“SSH Keys”页面，\n\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n## 把本地项目添加到远程库\n\n### 第一步\n通过命令git init把项目文件夹变成Git可管理的仓库\n\n```\n$ git init\n```\n\n### 第二步\n把项目粘贴到这个本地Git仓库里面\n\n```\n$ git add .\n```\n\n### 第三步\n\n把项目提交到仓库\n\n```\n$ git commit -m \"注释\"\n```\n\n### 第四步\n登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库\n\n目前，在GitHub上的这个learngit仓库还是空的\n\n### 第五步\n\n\n在本地的learngit仓库下运行命令\n\n```\n$ git remote add origin git@github.com:michaelliao/learngit.git\n\n```\nmichaelliao替换成自己的GitHub账户名   \n使本地仓库关联远程库  \n添加后，远程库的名字就是origin，这是Git默认的叫法\n\n### 第六步\n把本地库的所有内容推送到远程库上\n\n```\n$ git push -u origin master\n\n```\n### 最后的最后\n从现在起，只要本地作了提交，就可以运行命令把本地master分支的最新修改推送至GitHub\n\n```\n$ git push origin master\n\n```\n\n## 从远程库克隆到本地库\n\n### 第一步\n登陆GitHub，创建一个新的仓库，名字叫gitskills    \n勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件\n\n### 第二步\n用命令git clone克隆一个本地库\n\n```\n$ git clone git@github.com:michaelliao/gitskills.git\n\n```\nmichaelliao替换成自己的GitHub账户名\n\n# 分支管理\n\n## 创建与合并分支\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点\n\n![image](https://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0)\n\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长\n\n### 第一步\n创建dev分支\n\n```\n$ git branch dev\n\n```\n切换到dev分支\n\n```\n$ git checkout dev\n\n```\n可合并为创建并切换到dev分支\n\n```\n$ git checkout -b dev\n\n```\n\n### 第二步\n用git branch命令查看当前分支\n\n```\n$ git branch\n* dev\n  master\n\n```\ngit branch命令会列出所有分支，当前分支前面会标一个*号\n\n### 第三步\n\n在dev分支上正常提交    \n比如对readme.txt做个修改，加上一行\n\n```\nCreating a new branch is quick.\n\n```\n然后提交\n\n```\n$ git add readme.txt \n$ git commit -m \"branch test\"\n\n```\n\n### 第四步\n现在，dev分支的工作完成，我们就可以切换回master分支\n\n```\n$ git checkout master\n\n```\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变\n![image](https://www.liaoxuefeng.com/files/attachments/001384908892295909f96758654469cad60dc50edfa9abd000/0)\n\n### 第五步\n把dev分支的工作成果合并到master分支上\n\n```\n$ git merge dev\n\n```\ngit merge命令用于合并指定分支到当前分支    \n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式\n\n### 第六步\n合并完成后，就可以放心地删除dev分支了\n\n```\n$ git branch -d dev\n\n```\n删除后，查看branch，就只剩下master分支了\n\n```\n$ git branch\n* master\n\n```\n\n## 解决冲突\n### 第一步\n此时，创建了一个新的分支feature1\n\n```\n$ git checkout -b feature1\n\n```\n在readme.txt最后添加一行并提交\n\n```\nCreating a new branch is quick AND simple.\n\n```\n\n### 第二步\n切换到master分支\n\n```\n$ git checkout master\n\n```\n在master分支上readme.txt最后添加一行并提交\n\n```\nCreating a new branch is quick & simple.\n\n```\n\n\n此时，master分支和feature1分支各自都分别有新的提交\n![image](https://www.liaoxuefeng.com/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0)\n\n### 第三步\n由于两个分支各自有修改，两者合并起来可能会有冲突\n\n```\n$ git merge feature1\n\n```\ngit status会告诉我们冲突的文件\n\n```\n$ git status\n\n```\n也可以查看readme.txt的内容\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n\n```\n\n### 第四步\n此时，需要手动修改冲突内容\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nCreating a new branch is quick and simple.\n\n```\n再提交\n\n```\n$ git add readme.txt \n$ git commit -m \"conflict fixed\"\n\n```\n现在，master分支和feature1分支变成这样\n![image](https://www.liaoxuefeng.com/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0)\n用带参数的git log也可以看到分支的合并情况\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n\n```\n\n### 第五步\n最后，删除feature1分支\n\n```\n$ git branch -d feature1\n\n```\n\n## 分支管理策略\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息\n### 第一步\n创建并切换dev分支\n\n```\n$ git checkout -b dev\n\n```\n### 第二步\n修改readme.txt文件，并提交一个新的commit\n\n```\n$ git add readme.txt \n$ git commit -m \"add merge\"\n\n```\n### 第三步\n切换回master\n\n```\n$ git checkout master\n\n```\n### 第四步\n准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward\n\n```\n$ git merge --no-ff -m \"merge with no-ff\" dev\n\n```\n加上-m参数，把commit描述写进去\n\n合并后，我们用git log看看分支历史\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n\n```\n![image](https://cdn.webxueyuan.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0)\n\n## Bug分支\n\n某天突然接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug\n\n### 第一步\n\n把当前工作现场“储藏”起来，等以后恢复现场后继续工作\n\n```\n$ git stash\n\n```\n现在，用git status查看工作区，就是干净的\n\n### 第二步\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支\n\n```\n$ git checkout master\n\n```\n\n```\n$ git checkout -b issue-101\n\n```\n\n### 第三步\n\n修复bug，然后提交\n\n```\n$ git add readme.txt \n$ git commit -m \"fix bug 101\"\n\n```\n\n### 第四步\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支\n\n```\n$ git checkout master\n\n```\n\n```\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\n\n```\n\n```\n$ git branch -d issue-101\n\n```\n\n### 第五步\n\n接着回到dev分支干活了\n\n```\n$ git checkout dev\n\n```\n\n```\n$ git status\n\n```\n工作区是干净的，用git stash list命令看看刚才的工作现场存到哪去了？\n\n```\n$ git stash list\n\n```\n### 第六步\n\n恢复stash内容\n\n一种是用git stash apply恢复，然后用git stash drop删除stash内容\n\n另一种方式是用git stash pop，恢复的同时把stash内容也删了\n\n```\n$ git stash pop\n\n```\n可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash\n\n```\n$ git stash apply stash@{0}\n\n```\n### 疑问\n\n#### 第一个问题\n在dev中工作，在master中创建分支修改bug，好像互不相干呀，为什么要stash呢？\n\n暂存区是公用的，如果不通过stash命令隐藏，会带到其它分支（issue-101）去\n\n#### 第二个问题\n为什么要创建分支修改bug呢，直接在master中改不就好了吗？  \n\n实际项目中，这个bug可能很麻烦，你需要修复一天的时间才能搞定，如果你不创建101分支，那么这时候你们组内其他小伙伴也要紧急修复线上一个bug，但是他的bug可能就1分钟。他修复好了却不能上线，因为你没有创建分支，要等你一天，才能把你处理好的正确代码一起上线。   \n可能也会觉得创建分支不够效率，但是工作中稳健很重要\n\n## Feature分支\n每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支\n\n### 第一步\n开发并提交\n\n```\n$ git checkout -b feature-vulcan\n\n```\n\n```\n$ git add vulcan.py\n$ git commit -m \"add feature vulcan\"\n\n```\n### 第二步\n切回dev，准备合并\n\n```\n$ git checkout dev\n\n```\n### 第三步\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除\n但是，由于种种原因，新功能取消，这个分支必须就地销毁\n\n```\n$ git branch -d feature-vulcan\n\n```\n销毁失败\n\nGit友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改       \n如果要强行删除，需要使用命令git branch -D feature-vulcan\n\n```\n$ git branch -D feature-vulcan\n\n```\n\n## 多人协作\n查看远程库的信息\n\n```\n$ git remote\n\n```\n显示更详细的信息\n\n```\n$ git remote -v\n\n```\n### 推送分支\n推送分支，就是把该分支上的所有本地提交推送到远程库\n\n推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上\n\n```\n$ git push origin master\n\n```\n或推送其他分支\n\n```\n$ git push origin dev\n\n```\n注意：\n\n1、master分支是主分支，因此要时刻与远程同步；\n\n2、dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\n3、bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\n4、feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n### 抓取分支\n当push失败时，则因为远程分支比你的本地更新\n\n先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送\n\n```\n$ git pull\n\n```\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接\n\n设置dev和origin/dev的链接\n\n```\n$ git branch --set-upstream dev origin/dev\n\n```\n再pull\n\n```\n$ git pull\n\n```\ngit pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样\n\n解决后，提交，再push\n\n# 标签管理\n### 创建标签\n首先，切换到需要打标签的分支上\n\n```\n$ git branch\n* dev\n  master\n$ git checkout master\nSwitched to branch 'master'\n\n```\n创建一个新标签\n\n```\n$ git tag <name>\n```\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字\n\n```\n$ git tag -a <tagname> -m \"blablabla...\"\n```\n\n查看所有标签\n\n```\n$ git tag  //按字母排序\n$ git show <tagname>\n```\n默认标签是打在最新提交的commit上的\n\n有时候，如果忘了打标签\n\n方法是找到历史提交的commit id\n\n```\n$ git log --pretty=oneline --abbrev-commit\n```\n然后打上标签就可以了\n```\n$ git tag <name> <commit id>\n```\n\n### 未完待续","slug":"git/git：git使用","published":1,"date":"2020-03-17T08:52:47.944Z","updated":"2020-03-17T08:54:26.116Z","layout":"post","photos":[],"link":"","_id":"cka6kinum00gpqgu9op48q2b5","content":"<p>git的简介、安装就不罗嗦了，详细的教程可参考<br><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">廖雪峰的git教程</a></p>\n<h1 id=\"创建版本库（初始化一个git仓库）\"><a href=\"#创建版本库（初始化一个git仓库）\" class=\"headerlink\" title=\"创建版本库（初始化一个git仓库）\"></a>创建版本库（初始化一个git仓库）</h1><h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>选择一个合适的地方，创建一个空目录learngit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir learngit</span><br><span class=\"line\">$ cd learngit</span><br><span class=\"line\">$ pwd</span><br></pre></td></tr></table></figure>\n<p>pwd命令用于显示当前目录</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>通过git init命令把这个目录变成Git可以管理的仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n<p>1、此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>\n<p>2、如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>\n<h1 id=\"添加文件到Git仓库\"><a href=\"#添加文件到Git仓库\" class=\"headerlink\" title=\"添加文件到Git仓库\"></a>添加文件到Git仓库</h1><p>编写一个readme.txt文件<br>内容为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n<h3 id=\"第一步-1\"><a href=\"#第一步-1\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>用命令git add告诉Git，把文件添加到仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br></pre></td></tr></table></figure>\n<p>1、执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功 </p>\n<p>2、add可反复多次使用，添加多个文件</p>\n<h3 id=\"第二步-1\"><a href=\"#第二步-1\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>用命令git commit告诉Git，把文件提交到仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>\n<p>1、-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的  </p>\n<p>2、commit可以一次提交很多文件，所以你可以多次add不同的文件</p>\n<h1 id=\"修改文件并提交\"><a href=\"#修改文件并提交\" class=\"headerlink\" title=\"修改文件并提交\"></a>修改文件并提交</h1><p>修改readme.txt文件，改成如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n<h2 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h2><p>运行git status命令看看结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>git status命令可以让我们时刻掌握仓库当前的状态</p>\n<h2 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h2><p>比如有一个项目，隔了好几天没碰过了，想要继续写的时候，又忘了上次是怎么修改的，那么<br>运行git diff命令看看具体修改了什么内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff readme.txt</span><br></pre></td></tr></table></figure>\n<p>git diff顾名思义就是查看difference</p>\n<h2 id=\"提交修改（与提交新文件一样）\"><a href=\"#提交修改（与提交新文件一样）\" class=\"headerlink\" title=\"提交修改（与提交新文件一样）\"></a>提交修改（与提交新文件一样）</h2><h3 id=\"第一步-2\"><a href=\"#第一步-2\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>git add</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-2\"><a href=\"#第二步-2\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>git commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;add distributed&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h1><p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了</p>\n<p>版本一：wrote a readme file</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n<p>版本二：add distributed</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n<h2 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h2><p>运行git log命令可以查看每次修改的历史记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<p>该命令显示从最近到最远的提交日志</p>\n<h2 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h2><h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><p>运行git reset命令把版本二回退到版本一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard HEAD     //当前版本</span><br><span class=\"line\">$ git reset --hard HEAD^    //回退到上一个版本</span><br><span class=\"line\">$ git reset --hard HEAD^^   //回退到上上一个版本</span><br></pre></td></tr></table></figure>\n<p>若有多个版本，可继续使用git reset命令回退</p>\n<h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat \"></a>cat <file></file></h3><p>看看readme.txt的内容是不是版本一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat readme.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"后悔回退，恢复版本\"><a href=\"#后悔回退，恢复版本\" class=\"headerlink\" title=\"后悔回退，恢复版本\"></a>后悔回退，恢复版本</h2><p>此时，使用git log看一下版本库里的版本，哎呀，版本二不见了<br>那如果此时我又后悔了，我想要回退之前的版本了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard 所需版本的commit id</span><br></pre></td></tr></table></figure>\n<p>commit id不知道怎么办？？？<br>1、不怕，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到回退前执行git log后的版本库，每一个版本的commit后那一长串乱码一样的东西就是该版本的commit id了<br>当然，commit id很长，没必要写全，写前几位就好了（一般七位吧）</p>\n<p>恢复版本二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard f3ab58</span><br></pre></td></tr></table></figure>\n<p>2、可是，当你关掉了命令行窗口后才后悔怎么办？？？<br>不怕，在Git中，总是有后悔药可以吃的 </p>\n<p>Git提供了一个命令git reflog用来记录你的每一次命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<p>又可以找回所需版本的commit id了</p>\n<h1 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h1><h2 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h2><p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区</p>\n<h2 id=\"版本库\"><a href=\"#版本库\" class=\"headerlink\" title=\"版本库\"></a>版本库</h2><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库</p>\n<p>Git的版本库里存了很多东西<br>1、最重要的就是称为stage（或者叫index）的暂存区<br>2、还有Git为我们自动创建的第一个分支master<br>3、以及指向master的一个指针叫HEAD</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0\" alt=\"image\"></p>\n<p>前面讲了提交新文件到Git版本库：</p>\n<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>\n<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支</p>\n<h1 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h1><h2 id=\"git-checkout-–-file\"><a href=\"#git-checkout-–-file\" class=\"headerlink\" title=\"git checkout – file\"></a>git checkout – file</h2><p>场景一（仅修改了文件） </p>\n<p>有一次头脑混乱，在readme.txt中加了一行乱码，死定了，要赶紧手动删掉，以为这样就没事了吗？不，事儿可大了，运行git status查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>会显示改动了readme.txt</p>\n<p>这时候，运行<strong>git checkout – file</strong>丢弃工作区的修改即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>\n<p>有两种情况（都是修改了工作区的文件导致工作区与版本库不一致）：</p>\n<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态</p>\n<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态</p>\n<h2 id=\"git-reset-HEAD-file\"><a href=\"#git-reset-HEAD-file\" class=\"headerlink\" title=\"git reset HEAD file\"></a>git reset HEAD file</h2><p>场景二（修改文件后，git add到暂存区了）</p>\n<p>有一次头脑更混乱，不仅在readme.txt中加了一行乱码，还git add到暂存区了 </p>\n<p>幸好，用git status查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>显示还没有提交</p>\n<p>这时候运行命令<strong>git reset HEAD file</strong>可以把暂存区的修改撤销掉（unstage），重新放回工作区即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD readme.txt</span><br></pre></td></tr></table></figure>\n<p>再用git status查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>现在暂存区是干净的，工作区有修改，回到场景一即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"版本回退-1\"><a href=\"#版本回退-1\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><p>场景三（改了文件，不仅添加了，还提交了）</p>\n<p>回到上上一个内容<strong>版本回退</strong>了</p>\n<h1 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h1><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm test.txt</span><br></pre></td></tr></table></figure>\n<p>Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>此时有两种情况</p>\n<h2 id=\"第一种情况\"><a href=\"#第一种情况\" class=\"headerlink\" title=\"第一种情况\"></a>第一种情况</h2><p>确实要从版本库中删除该文件</p>\n<p>运行命令git rm删掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm test.txt</span><br></pre></td></tr></table></figure>\n<p>并且git commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二种情况\"><a href=\"#第二种情况\" class=\"headerlink\" title=\"第二种情况\"></a>第二种情况</h2><p>删错了</p>\n<p>因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>\n<p>git checkout – file 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p>\n<h1 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h1><p>git的杀手级功能—远程仓库<br>这个世界上有个叫GitHub的神奇的网站，这个网站是提供Git仓库托管服务的，只要注册一个GitHub账号，就可以免费获得Git远程仓库</p>\n<h2 id=\"设置SSH-Key\"><a href=\"#设置SSH-Key\" class=\"headerlink\" title=\"设置SSH Key\"></a>设置SSH Key</h2><p>由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的</p>\n<h3 id=\"第一步-3\"><a href=\"#第一步-3\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>创建SSH Key</p>\n<p>在用户主目录下，看看有没有.ssh目录；如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件；如果已经有了，可直接跳到下一步</p>\n<p>如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码</p>\n<h3 id=\"第二步-3\"><a href=\"#第二步-3\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>登陆GitHub，打开“Account settings”，“SSH Keys”页面，</p>\n<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p>\n<h2 id=\"把本地项目添加到远程库\"><a href=\"#把本地项目添加到远程库\" class=\"headerlink\" title=\"把本地项目添加到远程库\"></a>把本地项目添加到远程库</h2><h3 id=\"第一步-4\"><a href=\"#第一步-4\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>通过命令git init把项目文件夹变成Git可管理的仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-4\"><a href=\"#第二步-4\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>把项目粘贴到这个本地Git仓库里面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>把项目提交到仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;注释&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>\n<p>目前，在GitHub上的这个learngit仓库还是空的</p>\n<h3 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>在本地的learngit仓库下运行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>\n<p>michaelliao替换成自己的GitHub账户名<br>使本地仓库关联远程库<br>添加后，远程库的名字就是origin，这是Git默认的叫法</p>\n<h3 id=\"第六步\"><a href=\"#第六步\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><p>把本地库的所有内容推送到远程库上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n<h3 id=\"最后的最后\"><a href=\"#最后的最后\" class=\"headerlink\" title=\"最后的最后\"></a>最后的最后</h3><p>从现在起，只要本地作了提交，就可以运行命令把本地master分支的最新修改推送至GitHub</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<h2 id=\"从远程库克隆到本地库\"><a href=\"#从远程库克隆到本地库\" class=\"headerlink\" title=\"从远程库克隆到本地库\"></a>从远程库克隆到本地库</h2><h3 id=\"第一步-5\"><a href=\"#第一步-5\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>登陆GitHub，创建一个新的仓库，名字叫gitskills<br>勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件</p>\n<h3 id=\"第二步-5\"><a href=\"#第二步-5\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>用命令git clone克隆一个本地库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure>\n<p>michaelliao替换成自己的GitHub账户名</p>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><h2 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h2><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0\" alt=\"image\"></p>\n<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长</p>\n<h3 id=\"第一步-6\"><a href=\"#第一步-6\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>创建dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch dev</span><br></pre></td></tr></table></figure>\n<p>切换到dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br></pre></td></tr></table></figure>\n<p>可合并为创建并切换到dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-6\"><a href=\"#第二步-6\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>用git branch命令查看当前分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br></pre></td></tr></table></figure>\n<p>git branch命令会列出所有分支，当前分支前面会标一个*号</p>\n<h3 id=\"第三步-1\"><a href=\"#第三步-1\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>在dev分支上正常提交<br>比如对readme.txt做个修改，加上一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick.</span><br></pre></td></tr></table></figure>\n<p>然后提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;branch test&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步-1\"><a href=\"#第四步-1\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>现在，dev分支的工作完成，我们就可以切换回master分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变<br><img src=\"https://www.liaoxuefeng.com/files/attachments/001384908892295909f96758654469cad60dc50edfa9abd000/0\" alt=\"image\"></p>\n<h3 id=\"第五步-1\"><a href=\"#第五步-1\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>把dev分支的工作成果合并到master分支上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge dev</span><br></pre></td></tr></table></figure>\n<p>git merge命令用于合并指定分支到当前分支<br>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式</p>\n<h3 id=\"第六步-1\"><a href=\"#第六步-1\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><p>合并完成后，就可以放心地删除dev分支了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d dev</span><br></pre></td></tr></table></figure>\n<p>删除后，查看branch，就只剩下master分支了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h2><h3 id=\"第一步-7\"><a href=\"#第一步-7\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>此时，创建了一个新的分支feature1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b feature1</span><br></pre></td></tr></table></figure>\n<p>在readme.txt最后添加一行并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-7\"><a href=\"#第二步-7\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>切换到master分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<p>在master分支上readme.txt最后添加一行并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure>\n<p>此时，master分支和feature1分支各自都分别有新的提交<br><img src=\"https://www.liaoxuefeng.com/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0\" alt=\"image\"></p>\n<h3 id=\"第三步-2\"><a href=\"#第三步-2\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>由于两个分支各自有修改，两者合并起来可能会有冲突</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge feature1</span><br></pre></td></tr></table></figure>\n<p>git status会告诉我们冲突的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>也可以查看readme.txt的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br><span class=\"line\">=======</span><br><span class=\"line\">Creating a new branch is quick AND simple.</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步-2\"><a href=\"#第四步-2\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>此时，需要手动修改冲突内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>\n<p>再提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;conflict fixed&quot;</span><br></pre></td></tr></table></figure>\n<p>现在，master分支和feature1分支变成这样<br><img src=\"https://www.liaoxuefeng.com/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0\" alt=\"image\"><br>用带参数的git log也可以看到分支的合并情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>\n<h3 id=\"第五步-2\"><a href=\"#第五步-2\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>最后，删除feature1分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d feature1</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>\n<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p>\n<h3 id=\"第一步-8\"><a href=\"#第一步-8\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>创建并切换dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-8\"><a href=\"#第二步-8\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>修改readme.txt文件，并提交一个新的commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;add merge&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步-3\"><a href=\"#第三步-3\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>切换回master</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步-3\"><a href=\"#第四步-3\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>\n<p>加上-m参数，把commit描述写进去</p>\n<p>合并后，我们用git log看看分支历史</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.webxueyuan.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0\" alt=\"image\"></p>\n<h2 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h2><p>某天突然接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug</p>\n<h3 id=\"第一步-9\"><a href=\"#第一步-9\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br></pre></td></tr></table></figure>\n<p>现在，用git status查看工作区，就是干净的</p>\n<h3 id=\"第二步-9\"><a href=\"#第二步-9\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b issue-101</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步-4\"><a href=\"#第三步-4\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>修复bug，然后提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;fix bug 101&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步-4\"><a href=\"#第四步-4\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d issue-101</span><br></pre></td></tr></table></figure>\n<h3 id=\"第五步-3\"><a href=\"#第五步-3\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>接着回到dev分支干活了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>工作区是干净的，用git stash list命令看看刚才的工作现场存到哪去了？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br></pre></td></tr></table></figure>\n<h3 id=\"第六步-2\"><a href=\"#第六步-2\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><p>恢复stash内容</p>\n<p>一种是用git stash apply恢复，然后用git stash drop删除stash内容</p>\n<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<p>可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h3><h4 id=\"第一个问题\"><a href=\"#第一个问题\" class=\"headerlink\" title=\"第一个问题\"></a>第一个问题</h4><p>在dev中工作，在master中创建分支修改bug，好像互不相干呀，为什么要stash呢？</p>\n<p>暂存区是公用的，如果不通过stash命令隐藏，会带到其它分支（issue-101）去</p>\n<h4 id=\"第二个问题\"><a href=\"#第二个问题\" class=\"headerlink\" title=\"第二个问题\"></a>第二个问题</h4><p>为什么要创建分支修改bug呢，直接在master中改不就好了吗？  </p>\n<p>实际项目中，这个bug可能很麻烦，你需要修复一天的时间才能搞定，如果你不创建101分支，那么这时候你们组内其他小伙伴也要紧急修复线上一个bug，但是他的bug可能就1分钟。他修复好了却不能上线，因为你没有创建分支，要等你一天，才能把你处理好的正确代码一起上线。<br>可能也会觉得创建分支不够效率，但是工作中稳健很重要</p>\n<h2 id=\"Feature分支\"><a href=\"#Feature分支\" class=\"headerlink\" title=\"Feature分支\"></a>Feature分支</h2><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支</p>\n<h3 id=\"第一步-10\"><a href=\"#第一步-10\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>开发并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b feature-vulcan</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add vulcan.py</span><br><span class=\"line\">$ git commit -m &quot;add feature vulcan&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-10\"><a href=\"#第二步-10\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>切回dev，准备合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步-5\"><a href=\"#第三步-5\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除<br>但是，由于种种原因，新功能取消，这个分支必须就地销毁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d feature-vulcan</span><br></pre></td></tr></table></figure>\n<p>销毁失败</p>\n<p>Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改<br>如果要强行删除，需要使用命令git branch -D feature-vulcan</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -D feature-vulcan</span><br></pre></td></tr></table></figure>\n<h2 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h2><p>查看远程库的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote</span><br></pre></td></tr></table></figure>\n<p>显示更详细的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"推送分支\"><a href=\"#推送分支\" class=\"headerlink\" title=\"推送分支\"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库</p>\n<p>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<p>或推送其他分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin dev</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p>1、master分支是主分支，因此要时刻与远程同步；</p>\n<p>2、dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>\n<p>3、bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>\n<p>4、feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>\n<h3 id=\"抓取分支\"><a href=\"#抓取分支\" class=\"headerlink\" title=\"抓取分支\"></a>抓取分支</h3><p>当push失败时，则因为远程分支比你的本地更新</p>\n<p>先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br></pre></td></tr></table></figure>\n<p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接</p>\n<p>设置dev和origin/dev的链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --set-upstream dev origin/dev</span><br></pre></td></tr></table></figure>\n<p>再pull</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br></pre></td></tr></table></figure>\n<p>git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样</p>\n<p>解决后，提交，再push</p>\n<h1 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h1><h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><p>首先，切换到需要打标签的分支上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure>\n<p>创建一个新标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag &lt;name&gt;</span><br></pre></td></tr></table></figure>\n<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</span><br></pre></td></tr></table></figure>\n<p>查看所有标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag  //按字母排序</span><br><span class=\"line\">$ git show &lt;tagname&gt;</span><br></pre></td></tr></table></figure>\n<p>默认标签是打在最新提交的commit上的</p>\n<p>有时候，如果忘了打标签</p>\n<p>方法是找到历史提交的commit id</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>\n<p>然后打上标签就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag &lt;name&gt; &lt;commit id&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h3>","site":{"data":{}},"excerpt":"","more":"<p>git的简介、安装就不罗嗦了，详细的教程可参考<br><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">廖雪峰的git教程</a></p>\n<h1 id=\"创建版本库（初始化一个git仓库）\"><a href=\"#创建版本库（初始化一个git仓库）\" class=\"headerlink\" title=\"创建版本库（初始化一个git仓库）\"></a>创建版本库（初始化一个git仓库）</h1><h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>选择一个合适的地方，创建一个空目录learngit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir learngit</span><br><span class=\"line\">$ cd learngit</span><br><span class=\"line\">$ pwd</span><br></pre></td></tr></table></figure>\n<p>pwd命令用于显示当前目录</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>通过git init命令把这个目录变成Git可以管理的仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n<p>1、此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>\n<p>2、如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>\n<h1 id=\"添加文件到Git仓库\"><a href=\"#添加文件到Git仓库\" class=\"headerlink\" title=\"添加文件到Git仓库\"></a>添加文件到Git仓库</h1><p>编写一个readme.txt文件<br>内容为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n<h3 id=\"第一步-1\"><a href=\"#第一步-1\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>用命令git add告诉Git，把文件添加到仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br></pre></td></tr></table></figure>\n<p>1、执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功 </p>\n<p>2、add可反复多次使用，添加多个文件</p>\n<h3 id=\"第二步-1\"><a href=\"#第二步-1\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>用命令git commit告诉Git，把文件提交到仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>\n<p>1、-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的  </p>\n<p>2、commit可以一次提交很多文件，所以你可以多次add不同的文件</p>\n<h1 id=\"修改文件并提交\"><a href=\"#修改文件并提交\" class=\"headerlink\" title=\"修改文件并提交\"></a>修改文件并提交</h1><p>修改readme.txt文件，改成如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n<h2 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h2><p>运行git status命令看看结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>git status命令可以让我们时刻掌握仓库当前的状态</p>\n<h2 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h2><p>比如有一个项目，隔了好几天没碰过了，想要继续写的时候，又忘了上次是怎么修改的，那么<br>运行git diff命令看看具体修改了什么内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff readme.txt</span><br></pre></td></tr></table></figure>\n<p>git diff顾名思义就是查看difference</p>\n<h2 id=\"提交修改（与提交新文件一样）\"><a href=\"#提交修改（与提交新文件一样）\" class=\"headerlink\" title=\"提交修改（与提交新文件一样）\"></a>提交修改（与提交新文件一样）</h2><h3 id=\"第一步-2\"><a href=\"#第一步-2\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>git add</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-2\"><a href=\"#第二步-2\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>git commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;add distributed&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h1><p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了</p>\n<p>版本一：wrote a readme file</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n<p>版本二：add distributed</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n<h2 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h2><p>运行git log命令可以查看每次修改的历史记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<p>该命令显示从最近到最远的提交日志</p>\n<h2 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h2><h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><p>运行git reset命令把版本二回退到版本一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard HEAD     //当前版本</span><br><span class=\"line\">$ git reset --hard HEAD^    //回退到上一个版本</span><br><span class=\"line\">$ git reset --hard HEAD^^   //回退到上上一个版本</span><br></pre></td></tr></table></figure>\n<p>若有多个版本，可继续使用git reset命令回退</p>\n<h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat \"></a>cat <file></file></h3><p>看看readme.txt的内容是不是版本一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat readme.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"后悔回退，恢复版本\"><a href=\"#后悔回退，恢复版本\" class=\"headerlink\" title=\"后悔回退，恢复版本\"></a>后悔回退，恢复版本</h2><p>此时，使用git log看一下版本库里的版本，哎呀，版本二不见了<br>那如果此时我又后悔了，我想要回退之前的版本了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard 所需版本的commit id</span><br></pre></td></tr></table></figure>\n<p>commit id不知道怎么办？？？<br>1、不怕，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到回退前执行git log后的版本库，每一个版本的commit后那一长串乱码一样的东西就是该版本的commit id了<br>当然，commit id很长，没必要写全，写前几位就好了（一般七位吧）</p>\n<p>恢复版本二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard f3ab58</span><br></pre></td></tr></table></figure>\n<p>2、可是，当你关掉了命令行窗口后才后悔怎么办？？？<br>不怕，在Git中，总是有后悔药可以吃的 </p>\n<p>Git提供了一个命令git reflog用来记录你的每一次命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<p>又可以找回所需版本的commit id了</p>\n<h1 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h1><h2 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h2><p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区</p>\n<h2 id=\"版本库\"><a href=\"#版本库\" class=\"headerlink\" title=\"版本库\"></a>版本库</h2><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库</p>\n<p>Git的版本库里存了很多东西<br>1、最重要的就是称为stage（或者叫index）的暂存区<br>2、还有Git为我们自动创建的第一个分支master<br>3、以及指向master的一个指针叫HEAD</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0\" alt=\"image\"></p>\n<p>前面讲了提交新文件到Git版本库：</p>\n<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>\n<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支</p>\n<h1 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h1><h2 id=\"git-checkout-–-file\"><a href=\"#git-checkout-–-file\" class=\"headerlink\" title=\"git checkout – file\"></a>git checkout – file</h2><p>场景一（仅修改了文件） </p>\n<p>有一次头脑混乱，在readme.txt中加了一行乱码，死定了，要赶紧手动删掉，以为这样就没事了吗？不，事儿可大了，运行git status查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>会显示改动了readme.txt</p>\n<p>这时候，运行<strong>git checkout – file</strong>丢弃工作区的修改即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>\n<p>有两种情况（都是修改了工作区的文件导致工作区与版本库不一致）：</p>\n<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态</p>\n<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态</p>\n<h2 id=\"git-reset-HEAD-file\"><a href=\"#git-reset-HEAD-file\" class=\"headerlink\" title=\"git reset HEAD file\"></a>git reset HEAD file</h2><p>场景二（修改文件后，git add到暂存区了）</p>\n<p>有一次头脑更混乱，不仅在readme.txt中加了一行乱码，还git add到暂存区了 </p>\n<p>幸好，用git status查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>显示还没有提交</p>\n<p>这时候运行命令<strong>git reset HEAD file</strong>可以把暂存区的修改撤销掉（unstage），重新放回工作区即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD readme.txt</span><br></pre></td></tr></table></figure>\n<p>再用git status查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>现在暂存区是干净的，工作区有修改，回到场景一即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"版本回退-1\"><a href=\"#版本回退-1\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><p>场景三（改了文件，不仅添加了，还提交了）</p>\n<p>回到上上一个内容<strong>版本回退</strong>了</p>\n<h1 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h1><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm test.txt</span><br></pre></td></tr></table></figure>\n<p>Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>此时有两种情况</p>\n<h2 id=\"第一种情况\"><a href=\"#第一种情况\" class=\"headerlink\" title=\"第一种情况\"></a>第一种情况</h2><p>确实要从版本库中删除该文件</p>\n<p>运行命令git rm删掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm test.txt</span><br></pre></td></tr></table></figure>\n<p>并且git commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二种情况\"><a href=\"#第二种情况\" class=\"headerlink\" title=\"第二种情况\"></a>第二种情况</h2><p>删错了</p>\n<p>因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>\n<p>git checkout – file 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p>\n<h1 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h1><p>git的杀手级功能—远程仓库<br>这个世界上有个叫GitHub的神奇的网站，这个网站是提供Git仓库托管服务的，只要注册一个GitHub账号，就可以免费获得Git远程仓库</p>\n<h2 id=\"设置SSH-Key\"><a href=\"#设置SSH-Key\" class=\"headerlink\" title=\"设置SSH Key\"></a>设置SSH Key</h2><p>由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的</p>\n<h3 id=\"第一步-3\"><a href=\"#第一步-3\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>创建SSH Key</p>\n<p>在用户主目录下，看看有没有.ssh目录；如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件；如果已经有了，可直接跳到下一步</p>\n<p>如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码</p>\n<h3 id=\"第二步-3\"><a href=\"#第二步-3\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>登陆GitHub，打开“Account settings”，“SSH Keys”页面，</p>\n<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p>\n<h2 id=\"把本地项目添加到远程库\"><a href=\"#把本地项目添加到远程库\" class=\"headerlink\" title=\"把本地项目添加到远程库\"></a>把本地项目添加到远程库</h2><h3 id=\"第一步-4\"><a href=\"#第一步-4\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>通过命令git init把项目文件夹变成Git可管理的仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-4\"><a href=\"#第二步-4\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>把项目粘贴到这个本地Git仓库里面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>把项目提交到仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;注释&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>\n<p>目前，在GitHub上的这个learngit仓库还是空的</p>\n<h3 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>在本地的learngit仓库下运行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>\n<p>michaelliao替换成自己的GitHub账户名<br>使本地仓库关联远程库<br>添加后，远程库的名字就是origin，这是Git默认的叫法</p>\n<h3 id=\"第六步\"><a href=\"#第六步\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><p>把本地库的所有内容推送到远程库上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n<h3 id=\"最后的最后\"><a href=\"#最后的最后\" class=\"headerlink\" title=\"最后的最后\"></a>最后的最后</h3><p>从现在起，只要本地作了提交，就可以运行命令把本地master分支的最新修改推送至GitHub</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<h2 id=\"从远程库克隆到本地库\"><a href=\"#从远程库克隆到本地库\" class=\"headerlink\" title=\"从远程库克隆到本地库\"></a>从远程库克隆到本地库</h2><h3 id=\"第一步-5\"><a href=\"#第一步-5\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>登陆GitHub，创建一个新的仓库，名字叫gitskills<br>勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件</p>\n<h3 id=\"第二步-5\"><a href=\"#第二步-5\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>用命令git clone克隆一个本地库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure>\n<p>michaelliao替换成自己的GitHub账户名</p>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><h2 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h2><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0\" alt=\"image\"></p>\n<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长</p>\n<h3 id=\"第一步-6\"><a href=\"#第一步-6\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>创建dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch dev</span><br></pre></td></tr></table></figure>\n<p>切换到dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br></pre></td></tr></table></figure>\n<p>可合并为创建并切换到dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-6\"><a href=\"#第二步-6\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>用git branch命令查看当前分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br></pre></td></tr></table></figure>\n<p>git branch命令会列出所有分支，当前分支前面会标一个*号</p>\n<h3 id=\"第三步-1\"><a href=\"#第三步-1\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>在dev分支上正常提交<br>比如对readme.txt做个修改，加上一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick.</span><br></pre></td></tr></table></figure>\n<p>然后提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;branch test&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步-1\"><a href=\"#第四步-1\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>现在，dev分支的工作完成，我们就可以切换回master分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变<br><img src=\"https://www.liaoxuefeng.com/files/attachments/001384908892295909f96758654469cad60dc50edfa9abd000/0\" alt=\"image\"></p>\n<h3 id=\"第五步-1\"><a href=\"#第五步-1\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>把dev分支的工作成果合并到master分支上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge dev</span><br></pre></td></tr></table></figure>\n<p>git merge命令用于合并指定分支到当前分支<br>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式</p>\n<h3 id=\"第六步-1\"><a href=\"#第六步-1\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><p>合并完成后，就可以放心地删除dev分支了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d dev</span><br></pre></td></tr></table></figure>\n<p>删除后，查看branch，就只剩下master分支了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h2><h3 id=\"第一步-7\"><a href=\"#第一步-7\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>此时，创建了一个新的分支feature1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b feature1</span><br></pre></td></tr></table></figure>\n<p>在readme.txt最后添加一行并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-7\"><a href=\"#第二步-7\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>切换到master分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<p>在master分支上readme.txt最后添加一行并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure>\n<p>此时，master分支和feature1分支各自都分别有新的提交<br><img src=\"https://www.liaoxuefeng.com/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0\" alt=\"image\"></p>\n<h3 id=\"第三步-2\"><a href=\"#第三步-2\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>由于两个分支各自有修改，两者合并起来可能会有冲突</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge feature1</span><br></pre></td></tr></table></figure>\n<p>git status会告诉我们冲突的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>也可以查看readme.txt的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br><span class=\"line\">=======</span><br><span class=\"line\">Creating a new branch is quick AND simple.</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步-2\"><a href=\"#第四步-2\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>此时，需要手动修改冲突内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>\n<p>再提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;conflict fixed&quot;</span><br></pre></td></tr></table></figure>\n<p>现在，master分支和feature1分支变成这样<br><img src=\"https://www.liaoxuefeng.com/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0\" alt=\"image\"><br>用带参数的git log也可以看到分支的合并情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>\n<h3 id=\"第五步-2\"><a href=\"#第五步-2\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>最后，删除feature1分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d feature1</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>\n<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p>\n<h3 id=\"第一步-8\"><a href=\"#第一步-8\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>创建并切换dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-8\"><a href=\"#第二步-8\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>修改readme.txt文件，并提交一个新的commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;add merge&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步-3\"><a href=\"#第三步-3\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>切换回master</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步-3\"><a href=\"#第四步-3\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>\n<p>加上-m参数，把commit描述写进去</p>\n<p>合并后，我们用git log看看分支历史</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.webxueyuan.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0\" alt=\"image\"></p>\n<h2 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h2><p>某天突然接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug</p>\n<h3 id=\"第一步-9\"><a href=\"#第一步-9\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br></pre></td></tr></table></figure>\n<p>现在，用git status查看工作区，就是干净的</p>\n<h3 id=\"第二步-9\"><a href=\"#第二步-9\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b issue-101</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步-4\"><a href=\"#第三步-4\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>修复bug，然后提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;fix bug 101&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第四步-4\"><a href=\"#第四步-4\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d issue-101</span><br></pre></td></tr></table></figure>\n<h3 id=\"第五步-3\"><a href=\"#第五步-3\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>接着回到dev分支干活了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>工作区是干净的，用git stash list命令看看刚才的工作现场存到哪去了？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br></pre></td></tr></table></figure>\n<h3 id=\"第六步-2\"><a href=\"#第六步-2\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><p>恢复stash内容</p>\n<p>一种是用git stash apply恢复，然后用git stash drop删除stash内容</p>\n<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<p>可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h3><h4 id=\"第一个问题\"><a href=\"#第一个问题\" class=\"headerlink\" title=\"第一个问题\"></a>第一个问题</h4><p>在dev中工作，在master中创建分支修改bug，好像互不相干呀，为什么要stash呢？</p>\n<p>暂存区是公用的，如果不通过stash命令隐藏，会带到其它分支（issue-101）去</p>\n<h4 id=\"第二个问题\"><a href=\"#第二个问题\" class=\"headerlink\" title=\"第二个问题\"></a>第二个问题</h4><p>为什么要创建分支修改bug呢，直接在master中改不就好了吗？  </p>\n<p>实际项目中，这个bug可能很麻烦，你需要修复一天的时间才能搞定，如果你不创建101分支，那么这时候你们组内其他小伙伴也要紧急修复线上一个bug，但是他的bug可能就1分钟。他修复好了却不能上线，因为你没有创建分支，要等你一天，才能把你处理好的正确代码一起上线。<br>可能也会觉得创建分支不够效率，但是工作中稳健很重要</p>\n<h2 id=\"Feature分支\"><a href=\"#Feature分支\" class=\"headerlink\" title=\"Feature分支\"></a>Feature分支</h2><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支</p>\n<h3 id=\"第一步-10\"><a href=\"#第一步-10\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>开发并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b feature-vulcan</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add vulcan.py</span><br><span class=\"line\">$ git commit -m &quot;add feature vulcan&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步-10\"><a href=\"#第二步-10\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>切回dev，准备合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步-5\"><a href=\"#第三步-5\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除<br>但是，由于种种原因，新功能取消，这个分支必须就地销毁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d feature-vulcan</span><br></pre></td></tr></table></figure>\n<p>销毁失败</p>\n<p>Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改<br>如果要强行删除，需要使用命令git branch -D feature-vulcan</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -D feature-vulcan</span><br></pre></td></tr></table></figure>\n<h2 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h2><p>查看远程库的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote</span><br></pre></td></tr></table></figure>\n<p>显示更详细的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"推送分支\"><a href=\"#推送分支\" class=\"headerlink\" title=\"推送分支\"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库</p>\n<p>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<p>或推送其他分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin dev</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p>1、master分支是主分支，因此要时刻与远程同步；</p>\n<p>2、dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>\n<p>3、bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>\n<p>4、feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>\n<h3 id=\"抓取分支\"><a href=\"#抓取分支\" class=\"headerlink\" title=\"抓取分支\"></a>抓取分支</h3><p>当push失败时，则因为远程分支比你的本地更新</p>\n<p>先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br></pre></td></tr></table></figure>\n<p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接</p>\n<p>设置dev和origin/dev的链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --set-upstream dev origin/dev</span><br></pre></td></tr></table></figure>\n<p>再pull</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br></pre></td></tr></table></figure>\n<p>git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样</p>\n<p>解决后，提交，再push</p>\n<h1 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h1><h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><p>首先，切换到需要打标签的分支上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure>\n<p>创建一个新标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag &lt;name&gt;</span><br></pre></td></tr></table></figure>\n<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</span><br></pre></td></tr></table></figure>\n<p>查看所有标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag  //按字母排序</span><br><span class=\"line\">$ git show &lt;tagname&gt;</span><br></pre></td></tr></table></figure>\n<p>默认标签是打在最新提交的commit上的</p>\n<p>有时候，如果忘了打标签</p>\n<p>方法是找到历史提交的commit id</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>\n<p>然后打上标签就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag &lt;name&gt; &lt;commit id&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h3>"},{"title":"CSS：BFC","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### BFC定义\n块级格式化上下文，是指一个独立的块级渲染区域。该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。\n\n### BFC生成\n满足下列css声明之一的元素便会生成BFC\n- 根元素或其它包含它的元素\n- float的值不为none；\n- overflow的值不为visible；\n- position的值不为static；\n- display的值为inline-block、table-cell、table-caption；\n- flex boxes (元素的display: flex或inline-flex)；\n\n### BFC布局规则\n- 内部的元素会在垂直方向一个接一个地排列，可以理解为是BFC中的一个常规流\n- 元素垂直方向的距离由margin决定，即属于同一个BFC的两个相邻盒子的margin可能会发生重叠\n- 每个元素的左外边距与包含块的左边界相接触(从左往右，否则相反)，即使存在浮动也是如此，这说明BFC中的子元素不会超出它的包含块\n- BFC的区域不会与float元素区域重叠\n- 计算BFC的高度时，浮动子元素也参与计算\n- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然\n- 位于不同BFC下的相邻元素之间不会发生margin重叠\n\n### BFC的应用\n#### 解决margin塌陷和margin合并问题\n- margin塌陷为父子元素都设置margin，只取最大的一个。解决方法为父元素触发bfc，使其遵循bgc渲染规则。\n- margin合并的原理为它们处于同一个BFC中，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。解决方法为在其中一个元素外面包裹一层容器，并触发容器生成一个BFC（overflow：hidden），使两个元素处于不同的BFC。\n\n#### 解决高度塌陷问题\n当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。\n\n给父元素设置overflow：hidden可以清除子元素的浮动是应用了BFC的原理：给父元素设置overflow：hidden触发了BFC，形成一个独立的渲染区域，所以内部的元素就不会影响外面的布局，BFC把浮动的子元素的高度当作自己的高度去处理溢出，从外面看起来就是清除了浮动\n\n#### 解决侵占浮动元素的问题\n当一个元素浮动，另一个元素不浮动时，浮动元素因为脱离文档流，就会盖在不浮动的元素上。\n\n解决方法：不浮动的元素也设为浮动，或者添加overflow：hidden\n\n原理：为不浮动的元素建立BFC环境，BFC不与float box重叠。","source":"_posts/css/css：BFC.md","raw":"---\ntitle: CSS：BFC\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### BFC定义\n块级格式化上下文，是指一个独立的块级渲染区域。该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。\n\n### BFC生成\n满足下列css声明之一的元素便会生成BFC\n- 根元素或其它包含它的元素\n- float的值不为none；\n- overflow的值不为visible；\n- position的值不为static；\n- display的值为inline-block、table-cell、table-caption；\n- flex boxes (元素的display: flex或inline-flex)；\n\n### BFC布局规则\n- 内部的元素会在垂直方向一个接一个地排列，可以理解为是BFC中的一个常规流\n- 元素垂直方向的距离由margin决定，即属于同一个BFC的两个相邻盒子的margin可能会发生重叠\n- 每个元素的左外边距与包含块的左边界相接触(从左往右，否则相反)，即使存在浮动也是如此，这说明BFC中的子元素不会超出它的包含块\n- BFC的区域不会与float元素区域重叠\n- 计算BFC的高度时，浮动子元素也参与计算\n- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然\n- 位于不同BFC下的相邻元素之间不会发生margin重叠\n\n### BFC的应用\n#### 解决margin塌陷和margin合并问题\n- margin塌陷为父子元素都设置margin，只取最大的一个。解决方法为父元素触发bfc，使其遵循bgc渲染规则。\n- margin合并的原理为它们处于同一个BFC中，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。解决方法为在其中一个元素外面包裹一层容器，并触发容器生成一个BFC（overflow：hidden），使两个元素处于不同的BFC。\n\n#### 解决高度塌陷问题\n当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。\n\n给父元素设置overflow：hidden可以清除子元素的浮动是应用了BFC的原理：给父元素设置overflow：hidden触发了BFC，形成一个独立的渲染区域，所以内部的元素就不会影响外面的布局，BFC把浮动的子元素的高度当作自己的高度去处理溢出，从外面看起来就是清除了浮动\n\n#### 解决侵占浮动元素的问题\n当一个元素浮动，另一个元素不浮动时，浮动元素因为脱离文档流，就会盖在不浮动的元素上。\n\n解决方法：不浮动的元素也设为浮动，或者添加overflow：hidden\n\n原理：为不浮动的元素建立BFC环境，BFC不与float box重叠。","slug":"css/css：BFC","published":1,"date":"2020-05-14T08:48:32.778Z","updated":"2020-05-14T08:50:42.536Z","layout":"post","photos":[],"link":"","_id":"cka6kwrv90000rcu9hf3j45ld","content":"<h3 id=\"BFC定义\"><a href=\"#BFC定义\" class=\"headerlink\" title=\"BFC定义\"></a>BFC定义</h3><p>块级格式化上下文，是指一个独立的块级渲染区域。该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。</p>\n<h3 id=\"BFC生成\"><a href=\"#BFC生成\" class=\"headerlink\" title=\"BFC生成\"></a>BFC生成</h3><p>满足下列css声明之一的元素便会生成BFC</p>\n<ul>\n<li>根元素或其它包含它的元素</li>\n<li>float的值不为none；</li>\n<li>overflow的值不为visible；</li>\n<li>position的值不为static；</li>\n<li>display的值为inline-block、table-cell、table-caption；</li>\n<li>flex boxes (元素的display: flex或inline-flex)；</li>\n</ul>\n<h3 id=\"BFC布局规则\"><a href=\"#BFC布局规则\" class=\"headerlink\" title=\"BFC布局规则\"></a>BFC布局规则</h3><ul>\n<li>内部的元素会在垂直方向一个接一个地排列，可以理解为是BFC中的一个常规流</li>\n<li>元素垂直方向的距离由margin决定，即属于同一个BFC的两个相邻盒子的margin可能会发生重叠</li>\n<li>每个元素的左外边距与包含块的左边界相接触(从左往右，否则相反)，即使存在浮动也是如此，这说明BFC中的子元素不会超出它的包含块</li>\n<li>BFC的区域不会与float元素区域重叠</li>\n<li>计算BFC的高度时，浮动子元素也参与计算</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>\n<li>位于不同BFC下的相邻元素之间不会发生margin重叠</li>\n</ul>\n<h3 id=\"BFC的应用\"><a href=\"#BFC的应用\" class=\"headerlink\" title=\"BFC的应用\"></a>BFC的应用</h3><h4 id=\"解决margin塌陷和margin合并问题\"><a href=\"#解决margin塌陷和margin合并问题\" class=\"headerlink\" title=\"解决margin塌陷和margin合并问题\"></a>解决margin塌陷和margin合并问题</h4><ul>\n<li>margin塌陷为父子元素都设置margin，只取最大的一个。解决方法为父元素触发bfc，使其遵循bgc渲染规则。</li>\n<li>margin合并的原理为它们处于同一个BFC中，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。解决方法为在其中一个元素外面包裹一层容器，并触发容器生成一个BFC（overflow：hidden），使两个元素处于不同的BFC。</li>\n</ul>\n<h4 id=\"解决高度塌陷问题\"><a href=\"#解决高度塌陷问题\" class=\"headerlink\" title=\"解决高度塌陷问题\"></a>解决高度塌陷问题</h4><p>当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。</p>\n<p>给父元素设置overflow：hidden可以清除子元素的浮动是应用了BFC的原理：给父元素设置overflow：hidden触发了BFC，形成一个独立的渲染区域，所以内部的元素就不会影响外面的布局，BFC把浮动的子元素的高度当作自己的高度去处理溢出，从外面看起来就是清除了浮动</p>\n<h4 id=\"解决侵占浮动元素的问题\"><a href=\"#解决侵占浮动元素的问题\" class=\"headerlink\" title=\"解决侵占浮动元素的问题\"></a>解决侵占浮动元素的问题</h4><p>当一个元素浮动，另一个元素不浮动时，浮动元素因为脱离文档流，就会盖在不浮动的元素上。</p>\n<p>解决方法：不浮动的元素也设为浮动，或者添加overflow：hidden</p>\n<p>原理：为不浮动的元素建立BFC环境，BFC不与float box重叠。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"BFC定义\"><a href=\"#BFC定义\" class=\"headerlink\" title=\"BFC定义\"></a>BFC定义</h3><p>块级格式化上下文，是指一个独立的块级渲染区域。该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。</p>\n<h3 id=\"BFC生成\"><a href=\"#BFC生成\" class=\"headerlink\" title=\"BFC生成\"></a>BFC生成</h3><p>满足下列css声明之一的元素便会生成BFC</p>\n<ul>\n<li>根元素或其它包含它的元素</li>\n<li>float的值不为none；</li>\n<li>overflow的值不为visible；</li>\n<li>position的值不为static；</li>\n<li>display的值为inline-block、table-cell、table-caption；</li>\n<li>flex boxes (元素的display: flex或inline-flex)；</li>\n</ul>\n<h3 id=\"BFC布局规则\"><a href=\"#BFC布局规则\" class=\"headerlink\" title=\"BFC布局规则\"></a>BFC布局规则</h3><ul>\n<li>内部的元素会在垂直方向一个接一个地排列，可以理解为是BFC中的一个常规流</li>\n<li>元素垂直方向的距离由margin决定，即属于同一个BFC的两个相邻盒子的margin可能会发生重叠</li>\n<li>每个元素的左外边距与包含块的左边界相接触(从左往右，否则相反)，即使存在浮动也是如此，这说明BFC中的子元素不会超出它的包含块</li>\n<li>BFC的区域不会与float元素区域重叠</li>\n<li>计算BFC的高度时，浮动子元素也参与计算</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>\n<li>位于不同BFC下的相邻元素之间不会发生margin重叠</li>\n</ul>\n<h3 id=\"BFC的应用\"><a href=\"#BFC的应用\" class=\"headerlink\" title=\"BFC的应用\"></a>BFC的应用</h3><h4 id=\"解决margin塌陷和margin合并问题\"><a href=\"#解决margin塌陷和margin合并问题\" class=\"headerlink\" title=\"解决margin塌陷和margin合并问题\"></a>解决margin塌陷和margin合并问题</h4><ul>\n<li>margin塌陷为父子元素都设置margin，只取最大的一个。解决方法为父元素触发bfc，使其遵循bgc渲染规则。</li>\n<li>margin合并的原理为它们处于同一个BFC中，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。解决方法为在其中一个元素外面包裹一层容器，并触发容器生成一个BFC（overflow：hidden），使两个元素处于不同的BFC。</li>\n</ul>\n<h4 id=\"解决高度塌陷问题\"><a href=\"#解决高度塌陷问题\" class=\"headerlink\" title=\"解决高度塌陷问题\"></a>解决高度塌陷问题</h4><p>当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。</p>\n<p>给父元素设置overflow：hidden可以清除子元素的浮动是应用了BFC的原理：给父元素设置overflow：hidden触发了BFC，形成一个独立的渲染区域，所以内部的元素就不会影响外面的布局，BFC把浮动的子元素的高度当作自己的高度去处理溢出，从外面看起来就是清除了浮动</p>\n<h4 id=\"解决侵占浮动元素的问题\"><a href=\"#解决侵占浮动元素的问题\" class=\"headerlink\" title=\"解决侵占浮动元素的问题\"></a>解决侵占浮动元素的问题</h4><p>当一个元素浮动，另一个元素不浮动时，浮动元素因为脱离文档流，就会盖在不浮动的元素上。</p>\n<p>解决方法：不浮动的元素也设为浮动，或者添加overflow：hidden</p>\n<p>原理：为不浮动的元素建立BFC环境，BFC不与float box重叠。</p>\n"},{"title":"CSS：margin塌陷","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n标准文档流中，垂直方向的margin不叠加，以较大的为准。\n原理是他们处于同一个BFC中。\n1. 给父盒子添加border。\n2. 给父盒子添加padding。\n3. 给父盒子添加overflow:hidden。\n4. 给父盒子添加position:fixed。\n5. 给父盒子添加display:table。\n6. 给子元素的前面加一个兄弟元素\n```\ncontent:\"\";\noverflow:hidden;\n```\n","source":"_posts/css/css：margin塌陷.md","raw":"---\ntitle: CSS：margin塌陷\nDate: 2019-03-26\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n标准文档流中，垂直方向的margin不叠加，以较大的为准。\n原理是他们处于同一个BFC中。\n1. 给父盒子添加border。\n2. 给父盒子添加padding。\n3. 给父盒子添加overflow:hidden。\n4. 给父盒子添加position:fixed。\n5. 给父盒子添加display:table。\n6. 给子元素的前面加一个兄弟元素\n```\ncontent:\"\";\noverflow:hidden;\n```\n","slug":"css/css：margin塌陷","published":1,"date":"2019-03-26T07:43:55.939Z","updated":"2019-03-26T07:45:20.128Z","layout":"post","photos":[],"link":"","_id":"cka6kwrvt0001rcu9h09hdvay","content":"<p>标准文档流中，垂直方向的margin不叠加，以较大的为准。<br>原理是他们处于同一个BFC中。</p>\n<ol>\n<li>给父盒子添加border。</li>\n<li>给父盒子添加padding。</li>\n<li>给父盒子添加overflow:hidden。</li>\n<li>给父盒子添加position:fixed。</li>\n<li>给父盒子添加display:table。</li>\n<li>给子元素的前面加一个兄弟元素<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content:&quot;&quot;;</span><br><span class=\"line\">overflow:hidden;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>标准文档流中，垂直方向的margin不叠加，以较大的为准。<br>原理是他们处于同一个BFC中。</p>\n<ol>\n<li>给父盒子添加border。</li>\n<li>给父盒子添加padding。</li>\n<li>给父盒子添加overflow:hidden。</li>\n<li>给父盒子添加position:fixed。</li>\n<li>给父盒子添加display:table。</li>\n<li>给子元素的前面加一个兄弟元素<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content:&quot;&quot;;</span><br><span class=\"line\">overflow:hidden;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"CSS：flex布局","Date":"2019-04-22T16:00:00.000Z","comments":1,"_content":"\n## 前言\nflex布局称为弹性布局。任何一个容器都可以指定为 Flex 布局。\n> 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效\n\n## 基本概念\n采用 Flex 布局的元素，称为 Flex 容器，简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目，简称\"项目\"。\n- 水平的主轴（main axis）\n- 垂直的交叉轴（cross axis）\n- 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end\n- 交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n## 容器的属性\n\n### flex-direction\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n- row（默认值）：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿\n\n### flex-wrap\n\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n### flex-flow\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n```\n.box {\n  flex-flow: <flex-direction> <flex-wrap>;\n}\n\n```\n\n### justify-content\njustify-content属性定义了项目在主轴上的对齐方式。\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)\n\n### align-items\nalign-items属性定义项目在交叉轴上如何对齐。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n\n### align-content\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n\n## 项目的属性\n\n### order\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n### flex-grow\n- flex-grow属性定义项目的放大比例，默认为0。\n- 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。\n- 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。（即把剩余空间划分为四份，属性为2的占两份，属性为1的占一份）。\n\n### flex-shrink\n- flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n- 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。数值大的缩小得多。\n- 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n- 负值对该属性无效。\n\n### flex-basis\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n### flex\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n```\n.item {\n  flex: <flex-grow> <flex-shrink> <flex-basis>; \n}\n```\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n### align-self\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto。\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n- auto：表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n","source":"_posts/css/css：flex布局.md","raw":"---\ntitle: CSS：flex布局\nDate: 2019-04-23\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n## 前言\nflex布局称为弹性布局。任何一个容器都可以指定为 Flex 布局。\n> 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效\n\n## 基本概念\n采用 Flex 布局的元素，称为 Flex 容器，简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目，简称\"项目\"。\n- 水平的主轴（main axis）\n- 垂直的交叉轴（cross axis）\n- 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end\n- 交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n## 容器的属性\n\n### flex-direction\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n- row（默认值）：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿\n\n### flex-wrap\n\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n### flex-flow\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n```\n.box {\n  flex-flow: <flex-direction> <flex-wrap>;\n}\n\n```\n\n### justify-content\njustify-content属性定义了项目在主轴上的对齐方式。\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)\n\n### align-items\nalign-items属性定义项目在交叉轴上如何对齐。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n\n### align-content\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n\n## 项目的属性\n\n### order\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n### flex-grow\n- flex-grow属性定义项目的放大比例，默认为0。\n- 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。\n- 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。（即把剩余空间划分为四份，属性为2的占两份，属性为1的占一份）。\n\n### flex-shrink\n- flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n- 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。数值大的缩小得多。\n- 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n- 负值对该属性无效。\n\n### flex-basis\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n### flex\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n```\n.item {\n  flex: <flex-grow> <flex-shrink> <flex-basis>; \n}\n```\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n### align-self\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto。\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n- auto：表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n","slug":"css/css：flex布局","published":1,"date":"2019-04-23T14:18:43.728Z","updated":"2019-04-23T14:20:48.736Z","layout":"post","photos":[],"link":"","_id":"cka6kwrw30003rcu9kudp9l4z","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>flex布局称为弹性布局。任何一个容器都可以指定为 Flex 布局。</p>\n<blockquote>\n<p>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</p>\n</blockquote>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器，简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目，简称”项目”。</p>\n<ul>\n<li>水平的主轴（main axis）</li>\n<li>垂直的交叉轴（cross axis）</li>\n<li>主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end</li>\n<li>交叉轴的开始位置叫做cross start，结束位置叫做cross end。</li>\n</ul>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png\" alt=\"image\"></p>\n<h2 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h2><h3 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a>flex-direction</h3><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿</li>\n</ul>\n<h3 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a>flex-wrap</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p>\n<ul>\n<li>nowrap（默认）：不换行。</li>\n<li>wrap：换行，第一行在上方。</li>\n<li>wrap-reverse：换行，第一行在下方。</li>\n</ul>\n<h3 id=\"flex-flow\"><a href=\"#flex-flow\" class=\"headerlink\" title=\"flex-flow\"></a>flex-flow</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h3><p>justify-content属性定义了项目在主轴上的对齐方式。</p>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png\" alt=\"image\"></p>\n<h3 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h3><p>align-items属性定义项目在交叉轴上如何对齐。</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png\" alt=\"image\"></p>\n<h3 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a>align-content</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png\" alt=\"image\"></p>\n<h2 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h2><h3 id=\"order\"><a href=\"#order\" class=\"headerlink\" title=\"order\"></a>order</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>\n<h3 id=\"flex-grow\"><a href=\"#flex-grow\" class=\"headerlink\" title=\"flex-grow\"></a>flex-grow</h3><ul>\n<li>flex-grow属性定义项目的放大比例，默认为0。</li>\n<li>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。</li>\n<li>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。（即把剩余空间划分为四份，属性为2的占两份，属性为1的占一份）。</li>\n</ul>\n<h3 id=\"flex-shrink\"><a href=\"#flex-shrink\" class=\"headerlink\" title=\"flex-shrink\"></a>flex-shrink</h3><ul>\n<li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>\n<li>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。数值大的缩小得多。</li>\n<li>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</li>\n<li>负值对该属性无效。</li>\n</ul>\n<h3 id=\"flex-basis\"><a href=\"#flex-basis\" class=\"headerlink\" title=\"flex-basis\"></a>flex-basis</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>\n<h3 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a>align-self</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto。</p>\n<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>\n<ul>\n<li>auto：表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>flex布局称为弹性布局。任何一个容器都可以指定为 Flex 布局。</p>\n<blockquote>\n<p>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</p>\n</blockquote>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器，简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目，简称”项目”。</p>\n<ul>\n<li>水平的主轴（main axis）</li>\n<li>垂直的交叉轴（cross axis）</li>\n<li>主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end</li>\n<li>交叉轴的开始位置叫做cross start，结束位置叫做cross end。</li>\n</ul>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png\" alt=\"image\"></p>\n<h2 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h2><h3 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a>flex-direction</h3><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿</li>\n</ul>\n<h3 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a>flex-wrap</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p>\n<ul>\n<li>nowrap（默认）：不换行。</li>\n<li>wrap：换行，第一行在上方。</li>\n<li>wrap-reverse：换行，第一行在下方。</li>\n</ul>\n<h3 id=\"flex-flow\"><a href=\"#flex-flow\" class=\"headerlink\" title=\"flex-flow\"></a>flex-flow</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h3><p>justify-content属性定义了项目在主轴上的对齐方式。</p>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png\" alt=\"image\"></p>\n<h3 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h3><p>align-items属性定义项目在交叉轴上如何对齐。</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png\" alt=\"image\"></p>\n<h3 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a>align-content</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png\" alt=\"image\"></p>\n<h2 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h2><h3 id=\"order\"><a href=\"#order\" class=\"headerlink\" title=\"order\"></a>order</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>\n<h3 id=\"flex-grow\"><a href=\"#flex-grow\" class=\"headerlink\" title=\"flex-grow\"></a>flex-grow</h3><ul>\n<li>flex-grow属性定义项目的放大比例，默认为0。</li>\n<li>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。</li>\n<li>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。（即把剩余空间划分为四份，属性为2的占两份，属性为1的占一份）。</li>\n</ul>\n<h3 id=\"flex-shrink\"><a href=\"#flex-shrink\" class=\"headerlink\" title=\"flex-shrink\"></a>flex-shrink</h3><ul>\n<li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>\n<li>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。数值大的缩小得多。</li>\n<li>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</li>\n<li>负值对该属性无效。</li>\n</ul>\n<h3 id=\"flex-basis\"><a href=\"#flex-basis\" class=\"headerlink\" title=\"flex-basis\"></a>flex-basis</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>\n<h3 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a>align-self</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto。</p>\n<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>\n<ul>\n<li>auto：表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n"},{"title":"CSS：line-height","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### line-height\n在应用到一个块级元素时，它定义了该元素中基线之间的最小距离\n\n```\nline-height:15px;//行间距为15px\nline-height:150%;//行间距=当前的字体尺寸*150%\nline-height:1.5;//行间距=当前的字体尺寸*1.5\nline-height:1.5em;//行间距=当前的字体尺寸*1.5（若当前没有设置，继承父元素）\n```\n","source":"_posts/css/css：line-height.md","raw":"---\ntitle: CSS：line-height\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### line-height\n在应用到一个块级元素时，它定义了该元素中基线之间的最小距离\n\n```\nline-height:15px;//行间距为15px\nline-height:150%;//行间距=当前的字体尺寸*150%\nline-height:1.5;//行间距=当前的字体尺寸*1.5\nline-height:1.5em;//行间距=当前的字体尺寸*1.5（若当前没有设置，继承父元素）\n```\n","slug":"css/css：line-height","published":1,"date":"2020-05-14T08:49:02.479Z","updated":"2020-05-14T08:51:43.974Z","layout":"post","photos":[],"link":"","_id":"cka6kwrwf0005rcu9rjpulhzz","content":"<h3 id=\"line-height\"><a href=\"#line-height\" class=\"headerlink\" title=\"line-height\"></a>line-height</h3><p>在应用到一个块级元素时，它定义了该元素中基线之间的最小距离</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">line-height:15px;//行间距为15px</span><br><span class=\"line\">line-height:150%;//行间距=当前的字体尺寸*150%</span><br><span class=\"line\">line-height:1.5;//行间距=当前的字体尺寸*1.5</span><br><span class=\"line\">line-height:1.5em;//行间距=当前的字体尺寸*1.5（若当前没有设置，继承父元素）</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"line-height\"><a href=\"#line-height\" class=\"headerlink\" title=\"line-height\"></a>line-height</h3><p>在应用到一个块级元素时，它定义了该元素中基线之间的最小距离</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">line-height:15px;//行间距为15px</span><br><span class=\"line\">line-height:150%;//行间距=当前的字体尺寸*150%</span><br><span class=\"line\">line-height:1.5;//行间距=当前的字体尺寸*1.5</span><br><span class=\"line\">line-height:1.5em;//行间距=当前的字体尺寸*1.5（若当前没有设置，继承父元素）</span><br></pre></td></tr></table></figure>\n"},{"title":"CSS：margin塌陷和margin合并","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### margin塌陷\n- 父子嵌套元素在垂直方向的margin,父子元素是结合在一起的,他们两个的margin会取其中最大的值。\n- 正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位。\n- 但由于margin的塌陷,父级相对浏览器定位.而子级没有相对父级定位,子级相对父级,就像坍塌了一样。\n\n#### 体现\n![image](https://images2018.cnblogs.com/blog/1413878/201807/1413878-20180727113555586-1719243599.png)\n1. 红色方块margin-top为100px\n2. 现在给里面的小方块设置margin-top:100px，发现两个方块位置没动\n3. 而当给里面的小方块设置margin-top:150px，小方块带着大方块往下移动了50px（100和150取了150，里面的小方块依然紧贴大方块最上面）\n\n#### 解决\n1. 给父元素设置边框或内边距(不建议使用)\n2. 给父元素添加某些条件触发bfc(块级格式上下文),改变父级的渲染规则\n    1. position:absolute/fixed\n    2. display:inline-block;\n    3. float:left/right\n    4. overflow:hidden\n\n\n### margin合并\n- 标准文档流中，两个兄弟结构的元素在垂直方向上的margin不叠加，是合并的，以较大的为准。\n- 原因是他们处于同一个BFC中。\n- 解决margin塌陷的原理是使两个元素处于不同的bfc中，不同的bfc是不会发生margin塌陷的\n\n### 解决\n1. 给其中一个元素添加盒子div并触发bfc\n2. 给两个元素都添加盒子div并触发bfc\n    1. position:absolute/fixed\n    2. display:inline-block;\n    3. float:left/right\n    4. overflow:hidden\n\n","source":"_posts/css/css：margin塌陷和margin合并.md","raw":"---\ntitle: CSS：margin塌陷和margin合并\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### margin塌陷\n- 父子嵌套元素在垂直方向的margin,父子元素是结合在一起的,他们两个的margin会取其中最大的值。\n- 正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位。\n- 但由于margin的塌陷,父级相对浏览器定位.而子级没有相对父级定位,子级相对父级,就像坍塌了一样。\n\n#### 体现\n![image](https://images2018.cnblogs.com/blog/1413878/201807/1413878-20180727113555586-1719243599.png)\n1. 红色方块margin-top为100px\n2. 现在给里面的小方块设置margin-top:100px，发现两个方块位置没动\n3. 而当给里面的小方块设置margin-top:150px，小方块带着大方块往下移动了50px（100和150取了150，里面的小方块依然紧贴大方块最上面）\n\n#### 解决\n1. 给父元素设置边框或内边距(不建议使用)\n2. 给父元素添加某些条件触发bfc(块级格式上下文),改变父级的渲染规则\n    1. position:absolute/fixed\n    2. display:inline-block;\n    3. float:left/right\n    4. overflow:hidden\n\n\n### margin合并\n- 标准文档流中，两个兄弟结构的元素在垂直方向上的margin不叠加，是合并的，以较大的为准。\n- 原因是他们处于同一个BFC中。\n- 解决margin塌陷的原理是使两个元素处于不同的bfc中，不同的bfc是不会发生margin塌陷的\n\n### 解决\n1. 给其中一个元素添加盒子div并触发bfc\n2. 给两个元素都添加盒子div并触发bfc\n    1. position:absolute/fixed\n    2. display:inline-block;\n    3. float:left/right\n    4. overflow:hidden\n\n","slug":"css/css：margin塌陷和margin合并","published":1,"date":"2020-05-14T08:48:27.211Z","updated":"2020-05-14T08:50:57.101Z","layout":"post","photos":[],"link":"","_id":"cka6kwrwl0008rcu9vepujkpy","content":"<h3 id=\"margin塌陷\"><a href=\"#margin塌陷\" class=\"headerlink\" title=\"margin塌陷\"></a>margin塌陷</h3><ul>\n<li>父子嵌套元素在垂直方向的margin,父子元素是结合在一起的,他们两个的margin会取其中最大的值。</li>\n<li>正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位。</li>\n<li>但由于margin的塌陷,父级相对浏览器定位.而子级没有相对父级定位,子级相对父级,就像坍塌了一样。</li>\n</ul>\n<h4 id=\"体现\"><a href=\"#体现\" class=\"headerlink\" title=\"体现\"></a>体现</h4><p><img src=\"https://images2018.cnblogs.com/blog/1413878/201807/1413878-20180727113555586-1719243599.png\" alt=\"image\"></p>\n<ol>\n<li>红色方块margin-top为100px</li>\n<li>现在给里面的小方块设置margin-top:100px，发现两个方块位置没动</li>\n<li>而当给里面的小方块设置margin-top:150px，小方块带着大方块往下移动了50px（100和150取了150，里面的小方块依然紧贴大方块最上面）</li>\n</ol>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><ol>\n<li>给父元素设置边框或内边距(不建议使用)</li>\n<li>给父元素添加某些条件触发bfc(块级格式上下文),改变父级的渲染规则<ol>\n<li>position:absolute/fixed</li>\n<li>display:inline-block;</li>\n<li>float:left/right</li>\n<li>overflow:hidden</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"margin合并\"><a href=\"#margin合并\" class=\"headerlink\" title=\"margin合并\"></a>margin合并</h3><ul>\n<li>标准文档流中，两个兄弟结构的元素在垂直方向上的margin不叠加，是合并的，以较大的为准。</li>\n<li>原因是他们处于同一个BFC中。</li>\n<li>解决margin塌陷的原理是使两个元素处于不同的bfc中，不同的bfc是不会发生margin塌陷的</li>\n</ul>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a>解决</h3><ol>\n<li>给其中一个元素添加盒子div并触发bfc</li>\n<li>给两个元素都添加盒子div并触发bfc<ol>\n<li>position:absolute/fixed</li>\n<li>display:inline-block;</li>\n<li>float:left/right</li>\n<li>overflow:hidden</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"margin塌陷\"><a href=\"#margin塌陷\" class=\"headerlink\" title=\"margin塌陷\"></a>margin塌陷</h3><ul>\n<li>父子嵌套元素在垂直方向的margin,父子元素是结合在一起的,他们两个的margin会取其中最大的值。</li>\n<li>正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位。</li>\n<li>但由于margin的塌陷,父级相对浏览器定位.而子级没有相对父级定位,子级相对父级,就像坍塌了一样。</li>\n</ul>\n<h4 id=\"体现\"><a href=\"#体现\" class=\"headerlink\" title=\"体现\"></a>体现</h4><p><img src=\"https://images2018.cnblogs.com/blog/1413878/201807/1413878-20180727113555586-1719243599.png\" alt=\"image\"></p>\n<ol>\n<li>红色方块margin-top为100px</li>\n<li>现在给里面的小方块设置margin-top:100px，发现两个方块位置没动</li>\n<li>而当给里面的小方块设置margin-top:150px，小方块带着大方块往下移动了50px（100和150取了150，里面的小方块依然紧贴大方块最上面）</li>\n</ol>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><ol>\n<li>给父元素设置边框或内边距(不建议使用)</li>\n<li>给父元素添加某些条件触发bfc(块级格式上下文),改变父级的渲染规则<ol>\n<li>position:absolute/fixed</li>\n<li>display:inline-block;</li>\n<li>float:left/right</li>\n<li>overflow:hidden</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"margin合并\"><a href=\"#margin合并\" class=\"headerlink\" title=\"margin合并\"></a>margin合并</h3><ul>\n<li>标准文档流中，两个兄弟结构的元素在垂直方向上的margin不叠加，是合并的，以较大的为准。</li>\n<li>原因是他们处于同一个BFC中。</li>\n<li>解决margin塌陷的原理是使两个元素处于不同的bfc中，不同的bfc是不会发生margin塌陷的</li>\n</ul>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a>解决</h3><ol>\n<li>给其中一个元素添加盒子div并触发bfc</li>\n<li>给两个元素都添加盒子div并触发bfc<ol>\n<li>position:absolute/fixed</li>\n<li>display:inline-block;</li>\n<li>float:left/right</li>\n<li>overflow:hidden</li>\n</ol>\n</li>\n</ol>\n"},{"title":"CSS：position","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### position:static\n没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。\n\n### position:fixed\n相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。\n> 一定要设置宽度\n\n### position:relative\n1. 相对于元素自身正常位置定位，元素在正常的文档流中占位。\n2. 当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。\n\n### position:absolute\n1. 元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。\n2. 必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，margin和padding仍能影响其的位置，但脱离文档流，不占据位置，和其他元素形成折叠。\n3. 如果top、bottom都未指定，则其顶端将与原文档流位置一致，即垂直保持位置不变。\n4. 绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会\n5. 绝对定位对象头部超过可视区域会被裁掉。\n\n### position:inherit\n规定应该从父元素继承 position 属性的值。\n\n### z-index\n1. 如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。\n2. 需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。","source":"_posts/css/css：position.md","raw":"---\ntitle: CSS：position\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### position:static\n没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。\n\n### position:fixed\n相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。\n> 一定要设置宽度\n\n### position:relative\n1. 相对于元素自身正常位置定位，元素在正常的文档流中占位。\n2. 当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。\n\n### position:absolute\n1. 元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。\n2. 必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，margin和padding仍能影响其的位置，但脱离文档流，不占据位置，和其他元素形成折叠。\n3. 如果top、bottom都未指定，则其顶端将与原文档流位置一致，即垂直保持位置不变。\n4. 绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会\n5. 绝对定位对象头部超过可视区域会被裁掉。\n\n### position:inherit\n规定应该从父元素继承 position 属性的值。\n\n### z-index\n1. 如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。\n2. 需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。","slug":"css/css：position","published":1,"date":"2020-05-14T08:48:15.872Z","updated":"2020-05-14T08:50:06.797Z","layout":"post","photos":[],"link":"","_id":"cka6kwrws000brcu9vaknvw7y","content":"<h3 id=\"position-static\"><a href=\"#position-static\" class=\"headerlink\" title=\"position:static\"></a>position:static</h3><p>没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。</p>\n<h3 id=\"position-fixed\"><a href=\"#position-fixed\" class=\"headerlink\" title=\"position:fixed\"></a>position:fixed</h3><p>相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。</p>\n<blockquote>\n<p>一定要设置宽度</p>\n</blockquote>\n<h3 id=\"position-relative\"><a href=\"#position-relative\" class=\"headerlink\" title=\"position:relative\"></a>position:relative</h3><ol>\n<li>相对于元素自身正常位置定位，元素在正常的文档流中占位。</li>\n<li>当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。</li>\n</ol>\n<h3 id=\"position-absolute\"><a href=\"#position-absolute\" class=\"headerlink\" title=\"position:absolute\"></a>position:absolute</h3><ol>\n<li>元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。</li>\n<li>必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，margin和padding仍能影响其的位置，但脱离文档流，不占据位置，和其他元素形成折叠。</li>\n<li>如果top、bottom都未指定，则其顶端将与原文档流位置一致，即垂直保持位置不变。</li>\n<li>绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会</li>\n<li>绝对定位对象头部超过可视区域会被裁掉。</li>\n</ol>\n<h3 id=\"position-inherit\"><a href=\"#position-inherit\" class=\"headerlink\" title=\"position:inherit\"></a>position:inherit</h3><p>规定应该从父元素继承 position 属性的值。</p>\n<h3 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h3><ol>\n<li>如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。</li>\n<li>需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"position-static\"><a href=\"#position-static\" class=\"headerlink\" title=\"position:static\"></a>position:static</h3><p>没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。</p>\n<h3 id=\"position-fixed\"><a href=\"#position-fixed\" class=\"headerlink\" title=\"position:fixed\"></a>position:fixed</h3><p>相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。</p>\n<blockquote>\n<p>一定要设置宽度</p>\n</blockquote>\n<h3 id=\"position-relative\"><a href=\"#position-relative\" class=\"headerlink\" title=\"position:relative\"></a>position:relative</h3><ol>\n<li>相对于元素自身正常位置定位，元素在正常的文档流中占位。</li>\n<li>当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。</li>\n</ol>\n<h3 id=\"position-absolute\"><a href=\"#position-absolute\" class=\"headerlink\" title=\"position:absolute\"></a>position:absolute</h3><ol>\n<li>元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。</li>\n<li>必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，margin和padding仍能影响其的位置，但脱离文档流，不占据位置，和其他元素形成折叠。</li>\n<li>如果top、bottom都未指定，则其顶端将与原文档流位置一致，即垂直保持位置不变。</li>\n<li>绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会</li>\n<li>绝对定位对象头部超过可视区域会被裁掉。</li>\n</ol>\n<h3 id=\"position-inherit\"><a href=\"#position-inherit\" class=\"headerlink\" title=\"position:inherit\"></a>position:inherit</h3><p>规定应该从父元素继承 position 属性的值。</p>\n<h3 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h3><ol>\n<li>如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。</li>\n<li>需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。</li>\n</ol>\n"},{"title":"CSS：优先级","Date":"2019-04-22T16:00:00.000Z","comments":1,"_content":"\n从高到低\n1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。\n2. 内联样式，作为style属性写在元素内的样式\n3. id选择器\n4. 标签[指定属性] 如 button[type=file]\n5. 类选择器\n6. 标签选择器\n7. 通配符选择器","source":"_posts/css/css：优先级.md","raw":"---\ntitle: CSS：优先级\nDate: 2019-04-23\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n从高到低\n1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。\n2. 内联样式，作为style属性写在元素内的样式\n3. id选择器\n4. 标签[指定属性] 如 button[type=file]\n5. 类选择器\n6. 标签选择器\n7. 通配符选择器","slug":"css/css：优先级","published":1,"date":"2019-04-23T14:18:54.552Z","updated":"2019-04-23T14:21:05.914Z","layout":"post","photos":[],"link":"","_id":"cka6kwrwx000ercu968d0wm3x","content":"<p>从高到低</p>\n<ol>\n<li>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</li>\n<li>内联样式，作为style属性写在元素内的样式</li>\n<li>id选择器</li>\n<li>标签[指定属性] 如 button[type=file]</li>\n<li>类选择器</li>\n<li>标签选择器</li>\n<li>通配符选择器</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>从高到低</p>\n<ol>\n<li>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</li>\n<li>内联样式，作为style属性写在元素内的样式</li>\n<li>id选择器</li>\n<li>标签[指定属性] 如 button[type=file]</li>\n<li>类选择器</li>\n<li>标签选择器</li>\n<li>通配符选择器</li>\n</ol>\n"},{"title":"CSS：各种单位","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### %\n- padding和margin的%垂直水平方向都是基于父元素的宽度计算\n### px（pixel，像素）\n是一个虚拟长度单位，是计算机系统的数字化图像长度单位。\n#### 物理像素（px）\n设备能控制显示的最小单位\n#### 逻辑像素（px）\n又称css像素，浏览器使用的抽象单位，而不是实际存在的\n#### 设备独立像素（dip或dp）\n独立于设备的用于逻辑上衡量像素的单位，包括了CSS像素\n#### 设备像素缩放比（dpr）\n- dpr=物理像素/逻辑像素\n- 1px = (dpr)^2 * dp\n- dpr=ppi/160\n#### 屏幕像素密度（PPI）\n- 每英寸内有多少个设备像素点（物理像素） \n- PPI越高，像素数越高，图像越清晰\n\n![image](https://upload-images.jianshu.io/upload_images/11999503-9eb3c16bf53e5fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 屏幕分辨率（XxY）\n指屏幕上垂直有x个物理像素，水平有y个物理像素。\n#### 屏幕尺寸（x in）\n指屏幕对角线的长度有x英寸\n\n### em（相对长度单位）\n- 子元素字体大小的em是相对于父元素字体大小，如果自身定义了font-size按自身来计算。\n- 元素的width/height/padding/margin用em的话是相对于自身的font-size。\n- 最多取到小数点后三位。\n\n### rem（根em）\n- 相对于html元素上字体的大小。\n- 1rem等于html元素上字体设置的大小。\n\n### vw、vh\n- 1vw等于视窗宽度的1%。\n- 1vh等于视窗高度的1%。\n\n单位 | 含义\n---|---\nvw | 相对于视图窗口的宽度，视窗宽度为100vw\nvh | 相对于视图窗口的高度，视窗高度为100vh\nvmin | vw和vh中的较小值\nvmax | vw和vh中的较大值\n","source":"_posts/css/css：各种单位.md","raw":"---\ntitle: CSS：各种单位\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### %\n- padding和margin的%垂直水平方向都是基于父元素的宽度计算\n### px（pixel，像素）\n是一个虚拟长度单位，是计算机系统的数字化图像长度单位。\n#### 物理像素（px）\n设备能控制显示的最小单位\n#### 逻辑像素（px）\n又称css像素，浏览器使用的抽象单位，而不是实际存在的\n#### 设备独立像素（dip或dp）\n独立于设备的用于逻辑上衡量像素的单位，包括了CSS像素\n#### 设备像素缩放比（dpr）\n- dpr=物理像素/逻辑像素\n- 1px = (dpr)^2 * dp\n- dpr=ppi/160\n#### 屏幕像素密度（PPI）\n- 每英寸内有多少个设备像素点（物理像素） \n- PPI越高，像素数越高，图像越清晰\n\n![image](https://upload-images.jianshu.io/upload_images/11999503-9eb3c16bf53e5fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 屏幕分辨率（XxY）\n指屏幕上垂直有x个物理像素，水平有y个物理像素。\n#### 屏幕尺寸（x in）\n指屏幕对角线的长度有x英寸\n\n### em（相对长度单位）\n- 子元素字体大小的em是相对于父元素字体大小，如果自身定义了font-size按自身来计算。\n- 元素的width/height/padding/margin用em的话是相对于自身的font-size。\n- 最多取到小数点后三位。\n\n### rem（根em）\n- 相对于html元素上字体的大小。\n- 1rem等于html元素上字体设置的大小。\n\n### vw、vh\n- 1vw等于视窗宽度的1%。\n- 1vh等于视窗高度的1%。\n\n单位 | 含义\n---|---\nvw | 相对于视图窗口的宽度，视窗宽度为100vw\nvh | 相对于视图窗口的高度，视窗高度为100vh\nvmin | vw和vh中的较小值\nvmax | vw和vh中的较大值\n","slug":"css/css：各种单位","published":1,"date":"2020-05-14T08:48:43.788Z","updated":"2020-05-14T08:50:23.755Z","layout":"post","photos":[],"link":"","_id":"cka6kwrx4000hrcu9skvmwdhp","content":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"%\"></a>%</h3><ul>\n<li>padding和margin的%垂直水平方向都是基于父元素的宽度计算<h3 id=\"px（pixel，像素）\"><a href=\"#px（pixel，像素）\" class=\"headerlink\" title=\"px（pixel，像素）\"></a>px（pixel，像素）</h3>是一个虚拟长度单位，是计算机系统的数字化图像长度单位。<h4 id=\"物理像素（px）\"><a href=\"#物理像素（px）\" class=\"headerlink\" title=\"物理像素（px）\"></a>物理像素（px）</h4>设备能控制显示的最小单位<h4 id=\"逻辑像素（px）\"><a href=\"#逻辑像素（px）\" class=\"headerlink\" title=\"逻辑像素（px）\"></a>逻辑像素（px）</h4>又称css像素，浏览器使用的抽象单位，而不是实际存在的<h4 id=\"设备独立像素（dip或dp）\"><a href=\"#设备独立像素（dip或dp）\" class=\"headerlink\" title=\"设备独立像素（dip或dp）\"></a>设备独立像素（dip或dp）</h4>独立于设备的用于逻辑上衡量像素的单位，包括了CSS像素<h4 id=\"设备像素缩放比（dpr）\"><a href=\"#设备像素缩放比（dpr）\" class=\"headerlink\" title=\"设备像素缩放比（dpr）\"></a>设备像素缩放比（dpr）</h4></li>\n<li>dpr=物理像素/逻辑像素</li>\n<li>1px = (dpr)^2 * dp</li>\n<li>dpr=ppi/160<h4 id=\"屏幕像素密度（PPI）\"><a href=\"#屏幕像素密度（PPI）\" class=\"headerlink\" title=\"屏幕像素密度（PPI）\"></a>屏幕像素密度（PPI）</h4></li>\n<li>每英寸内有多少个设备像素点（物理像素） </li>\n<li>PPI越高，像素数越高，图像越清晰</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11999503-9eb3c16bf53e5fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"屏幕分辨率（XxY）\"><a href=\"#屏幕分辨率（XxY）\" class=\"headerlink\" title=\"屏幕分辨率（XxY）\"></a>屏幕分辨率（XxY）</h4><p>指屏幕上垂直有x个物理像素，水平有y个物理像素。</p>\n<h4 id=\"屏幕尺寸（x-in）\"><a href=\"#屏幕尺寸（x-in）\" class=\"headerlink\" title=\"屏幕尺寸（x in）\"></a>屏幕尺寸（x in）</h4><p>指屏幕对角线的长度有x英寸</p>\n<h3 id=\"em（相对长度单位）\"><a href=\"#em（相对长度单位）\" class=\"headerlink\" title=\"em（相对长度单位）\"></a>em（相对长度单位）</h3><ul>\n<li>子元素字体大小的em是相对于父元素字体大小，如果自身定义了font-size按自身来计算。</li>\n<li>元素的width/height/padding/margin用em的话是相对于自身的font-size。</li>\n<li>最多取到小数点后三位。</li>\n</ul>\n<h3 id=\"rem（根em）\"><a href=\"#rem（根em）\" class=\"headerlink\" title=\"rem（根em）\"></a>rem（根em）</h3><ul>\n<li>相对于html元素上字体的大小。</li>\n<li>1rem等于html元素上字体设置的大小。</li>\n</ul>\n<h3 id=\"vw、vh\"><a href=\"#vw、vh\" class=\"headerlink\" title=\"vw、vh\"></a>vw、vh</h3><ul>\n<li>1vw等于视窗宽度的1%。</li>\n<li>1vh等于视窗高度的1%。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>单位</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vw</td>\n<td>相对于视图窗口的宽度，视窗宽度为100vw</td>\n</tr>\n<tr>\n<td>vh</td>\n<td>相对于视图窗口的高度，视窗高度为100vh</td>\n</tr>\n<tr>\n<td>vmin</td>\n<td>vw和vh中的较小值</td>\n</tr>\n<tr>\n<td>vmax</td>\n<td>vw和vh中的较大值</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"%\"></a>%</h3><ul>\n<li>padding和margin的%垂直水平方向都是基于父元素的宽度计算<h3 id=\"px（pixel，像素）\"><a href=\"#px（pixel，像素）\" class=\"headerlink\" title=\"px（pixel，像素）\"></a>px（pixel，像素）</h3>是一个虚拟长度单位，是计算机系统的数字化图像长度单位。<h4 id=\"物理像素（px）\"><a href=\"#物理像素（px）\" class=\"headerlink\" title=\"物理像素（px）\"></a>物理像素（px）</h4>设备能控制显示的最小单位<h4 id=\"逻辑像素（px）\"><a href=\"#逻辑像素（px）\" class=\"headerlink\" title=\"逻辑像素（px）\"></a>逻辑像素（px）</h4>又称css像素，浏览器使用的抽象单位，而不是实际存在的<h4 id=\"设备独立像素（dip或dp）\"><a href=\"#设备独立像素（dip或dp）\" class=\"headerlink\" title=\"设备独立像素（dip或dp）\"></a>设备独立像素（dip或dp）</h4>独立于设备的用于逻辑上衡量像素的单位，包括了CSS像素<h4 id=\"设备像素缩放比（dpr）\"><a href=\"#设备像素缩放比（dpr）\" class=\"headerlink\" title=\"设备像素缩放比（dpr）\"></a>设备像素缩放比（dpr）</h4></li>\n<li>dpr=物理像素/逻辑像素</li>\n<li>1px = (dpr)^2 * dp</li>\n<li>dpr=ppi/160<h4 id=\"屏幕像素密度（PPI）\"><a href=\"#屏幕像素密度（PPI）\" class=\"headerlink\" title=\"屏幕像素密度（PPI）\"></a>屏幕像素密度（PPI）</h4></li>\n<li>每英寸内有多少个设备像素点（物理像素） </li>\n<li>PPI越高，像素数越高，图像越清晰</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11999503-9eb3c16bf53e5fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"屏幕分辨率（XxY）\"><a href=\"#屏幕分辨率（XxY）\" class=\"headerlink\" title=\"屏幕分辨率（XxY）\"></a>屏幕分辨率（XxY）</h4><p>指屏幕上垂直有x个物理像素，水平有y个物理像素。</p>\n<h4 id=\"屏幕尺寸（x-in）\"><a href=\"#屏幕尺寸（x-in）\" class=\"headerlink\" title=\"屏幕尺寸（x in）\"></a>屏幕尺寸（x in）</h4><p>指屏幕对角线的长度有x英寸</p>\n<h3 id=\"em（相对长度单位）\"><a href=\"#em（相对长度单位）\" class=\"headerlink\" title=\"em（相对长度单位）\"></a>em（相对长度单位）</h3><ul>\n<li>子元素字体大小的em是相对于父元素字体大小，如果自身定义了font-size按自身来计算。</li>\n<li>元素的width/height/padding/margin用em的话是相对于自身的font-size。</li>\n<li>最多取到小数点后三位。</li>\n</ul>\n<h3 id=\"rem（根em）\"><a href=\"#rem（根em）\" class=\"headerlink\" title=\"rem（根em）\"></a>rem（根em）</h3><ul>\n<li>相对于html元素上字体的大小。</li>\n<li>1rem等于html元素上字体设置的大小。</li>\n</ul>\n<h3 id=\"vw、vh\"><a href=\"#vw、vh\" class=\"headerlink\" title=\"vw、vh\"></a>vw、vh</h3><ul>\n<li>1vw等于视窗宽度的1%。</li>\n<li>1vh等于视窗高度的1%。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>单位</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vw</td>\n<td>相对于视图窗口的宽度，视窗宽度为100vw</td>\n</tr>\n<tr>\n<td>vh</td>\n<td>相对于视图窗口的高度，视窗高度为100vh</td>\n</tr>\n<tr>\n<td>vmin</td>\n<td>vw和vh中的较小值</td>\n</tr>\n<tr>\n<td>vmax</td>\n<td>vw和vh中的较大值</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"CSS：圣杯布局和双飞翼布局","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 圣杯布局\n\n![image](https://upload-images.jianshu.io/upload_images/3790386-5c28ce46aa0b924f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/764)\n\n1. header和footer占屏幕全部宽度，高度固定\n2. 中间的contaier部分是一个三栏布局\n3. left和right宽度固定，middle自适应填满整个区域；高度为三栏中最大的高度\n\n#### 浮动\n```\n<header class=\"header\">header</header>\n  <div class=\"container\">\n      <div class=\"middle\">middle</div>\n      <div class=\"left\">left</div>\n      <div class=\"right\">right</div>\n  </div>\n<footer class=\"footer\">footer</footer>\n```\n```\n.header{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n\n// 中间部分center设置100%撑满\n// 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了\n.middle{\n  float: left;\n  width: 100%;\n  height:100%;\n  background-color:pink;\n}\n\n// 设置left的 margin-left: -100%;，让left回到上一行最左侧\n.left {\n  float: left;\n  width: 100px;\n  height: 100%;\n  margin-left: -100%;\n  background: black;\n}\n\n// left回到第一行后，right位于第二行的最左侧\n// 设置margin-left把right拉回第一行的最右侧\n.right{\n  float: left;\n  width:100px;\n  height:100%;\n  margin-left: -100px;\n  background-color:black;\n}\n// left和right这会把middle给遮住了\n// 所以这时给外层的container设置 padding，给left和right空出位置\n.container{\n  height: 300px;\n  padding: 0 100px;\n}\n.footer{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n```\n\n#### flex布局\n```\n<header class=\"header\">header</header>\n  <div class=\"container\">\n      <div class=\"left\">left</div>\n      <div class=\"middle\">middle</div>\n      <div class=\"right\">right</div>\n  </div>\n<footer class=\"footer\">footer</footer>\n```\n```\n//middle占据除left和right之外的剩余所有空间，并不被遮挡\n.header{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n.container{\n  display: flex;\n  height:300px;\n}\n.left{\n  width:100px;\n  height:100%;\n  background-color:black;\n}\n.middle{\n  flex:1;//middle占据剩余所有空间\n  height:100%;\n  background-color:pink;\n}\n.right{\n  width:100px;\n  height:100%;\n  background-color:black;\n}\n.footer{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n```\n#### 绝对定位\n以上两种dom结构均可\n```\n.header{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n.container{\n  height:300px;\n  position: relative;\n  padding: 0 100px;\n}\n.left{\n  position: absolute;\n  top: 0;\n  left: 0;\n  width:100px;\n  height:100%;\n  background-color:black;\n}\n.middle{\n  height:100%;\n  background-color:pink;\n}\n.right{\n  position: absolute;\n  top:0;\n  right: 0;\n  width:100px;\n  height:100%;\n  background-color:black;\n}\n.footer{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n```\n### 双飞翼布局\n双飞翼布局和圣杯布局几乎一样，区别在于处理middle中被遮挡的部分。\n- 圣杯布局是在三栏布局的父容器中设置padding。\n- 双飞翼布局是在middle中再放一个div用来显示内容，为其设置margin。\n\n\n```\n<header>header</header>\n    <div class=\"container\">\n        <div class=\"middle\">\n            <div class=\"main\">middle</div>\n        </div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n    </div>\n<footer>footer</footer>\n```\n\n```\n//使用圣杯布局的浮动和绝对定位时设置，同时把container中的padding去除\n.main{\n  margin:0 100px;\n}\n```\n\n","source":"_posts/css/css：圣杯布局和双飞翼布局.md","raw":"---\ntitle: CSS：圣杯布局和双飞翼布局\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### 圣杯布局\n\n![image](https://upload-images.jianshu.io/upload_images/3790386-5c28ce46aa0b924f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/764)\n\n1. header和footer占屏幕全部宽度，高度固定\n2. 中间的contaier部分是一个三栏布局\n3. left和right宽度固定，middle自适应填满整个区域；高度为三栏中最大的高度\n\n#### 浮动\n```\n<header class=\"header\">header</header>\n  <div class=\"container\">\n      <div class=\"middle\">middle</div>\n      <div class=\"left\">left</div>\n      <div class=\"right\">right</div>\n  </div>\n<footer class=\"footer\">footer</footer>\n```\n```\n.header{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n\n// 中间部分center设置100%撑满\n// 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了\n.middle{\n  float: left;\n  width: 100%;\n  height:100%;\n  background-color:pink;\n}\n\n// 设置left的 margin-left: -100%;，让left回到上一行最左侧\n.left {\n  float: left;\n  width: 100px;\n  height: 100%;\n  margin-left: -100%;\n  background: black;\n}\n\n// left回到第一行后，right位于第二行的最左侧\n// 设置margin-left把right拉回第一行的最右侧\n.right{\n  float: left;\n  width:100px;\n  height:100%;\n  margin-left: -100px;\n  background-color:black;\n}\n// left和right这会把middle给遮住了\n// 所以这时给外层的container设置 padding，给left和right空出位置\n.container{\n  height: 300px;\n  padding: 0 100px;\n}\n.footer{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n```\n\n#### flex布局\n```\n<header class=\"header\">header</header>\n  <div class=\"container\">\n      <div class=\"left\">left</div>\n      <div class=\"middle\">middle</div>\n      <div class=\"right\">right</div>\n  </div>\n<footer class=\"footer\">footer</footer>\n```\n```\n//middle占据除left和right之外的剩余所有空间，并不被遮挡\n.header{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n.container{\n  display: flex;\n  height:300px;\n}\n.left{\n  width:100px;\n  height:100%;\n  background-color:black;\n}\n.middle{\n  flex:1;//middle占据剩余所有空间\n  height:100%;\n  background-color:pink;\n}\n.right{\n  width:100px;\n  height:100%;\n  background-color:black;\n}\n.footer{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n```\n#### 绝对定位\n以上两种dom结构均可\n```\n.header{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n.container{\n  height:300px;\n  position: relative;\n  padding: 0 100px;\n}\n.left{\n  position: absolute;\n  top: 0;\n  left: 0;\n  width:100px;\n  height:100%;\n  background-color:black;\n}\n.middle{\n  height:100%;\n  background-color:pink;\n}\n.right{\n  position: absolute;\n  top:0;\n  right: 0;\n  width:100px;\n  height:100%;\n  background-color:black;\n}\n.footer{\n  height:50px;\n  width:100%;\n  border:1px solid black;\n}\n```\n### 双飞翼布局\n双飞翼布局和圣杯布局几乎一样，区别在于处理middle中被遮挡的部分。\n- 圣杯布局是在三栏布局的父容器中设置padding。\n- 双飞翼布局是在middle中再放一个div用来显示内容，为其设置margin。\n\n\n```\n<header>header</header>\n    <div class=\"container\">\n        <div class=\"middle\">\n            <div class=\"main\">middle</div>\n        </div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n    </div>\n<footer>footer</footer>\n```\n\n```\n//使用圣杯布局的浮动和绝对定位时设置，同时把container中的padding去除\n.main{\n  margin:0 100px;\n}\n```\n\n","slug":"css/css：圣杯布局和双飞翼布局","published":1,"date":"2020-05-14T08:48:55.726Z","updated":"2020-05-14T08:52:06.865Z","layout":"post","photos":[],"link":"","_id":"cka6kwrx9000krcu9s9laxdgg","content":"<h3 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/3790386-5c28ce46aa0b924f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/764\" alt=\"image\"></p>\n<ol>\n<li>header和footer占屏幕全部宽度，高度固定</li>\n<li>中间的contaier部分是一个三栏布局</li>\n<li>left和right宽度固定，middle自适应填满整个区域；高度为三栏中最大的高度</li>\n</ol>\n<h4 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt;</span><br><span class=\"line\">  &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.header&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 中间部分center设置100%撑满</span><br><span class=\"line\">// 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了</span><br><span class=\"line\">.middle&#123;</span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置left的 margin-left: -100%;，让left回到上一行最左侧</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  margin-left: -100%;</span><br><span class=\"line\">  background: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// left回到第一行后，right位于第二行的最左侧</span><br><span class=\"line\">// 设置margin-left把right拉回第一行的最右侧</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  margin-left: -100px;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// left和right这会把middle给遮住了</span><br><span class=\"line\">// 所以这时给外层的container设置 padding，给left和right空出位置</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  height: 300px;</span><br><span class=\"line\">  padding: 0 100px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.footer&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt;</span><br><span class=\"line\">  &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//middle占据除left和right之外的剩余所有空间，并不被遮挡</span><br><span class=\"line\">.header&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  height:300px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left&#123;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.middle&#123;</span><br><span class=\"line\">  flex:1;//middle占据剩余所有空间</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.footer&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"绝对定位\"><a href=\"#绝对定位\" class=\"headerlink\" title=\"绝对定位\"></a>绝对定位</h4><p>以上两种dom结构均可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.header&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  height:300px;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  padding: 0 100px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.middle&#123;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  top:0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.footer&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h3><p>双飞翼布局和圣杯布局几乎一样，区别在于处理middle中被遮挡的部分。</p>\n<ul>\n<li>圣杯布局是在三栏布局的父容器中设置padding。</li>\n<li>双飞翼布局是在middle中再放一个div用来显示内容，为其设置margin。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header&gt;header&lt;/header&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;middle&quot;&gt;</span><br><span class=\"line\">            &lt;div class=&quot;main&quot;&gt;middle&lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;footer&gt;footer&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用圣杯布局的浮动和绝对定位时设置，同时把container中的padding去除</span><br><span class=\"line\">.main&#123;</span><br><span class=\"line\">  margin:0 100px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/3790386-5c28ce46aa0b924f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/764\" alt=\"image\"></p>\n<ol>\n<li>header和footer占屏幕全部宽度，高度固定</li>\n<li>中间的contaier部分是一个三栏布局</li>\n<li>left和right宽度固定，middle自适应填满整个区域；高度为三栏中最大的高度</li>\n</ol>\n<h4 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt;</span><br><span class=\"line\">  &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.header&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 中间部分center设置100%撑满</span><br><span class=\"line\">// 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了</span><br><span class=\"line\">.middle&#123;</span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置left的 margin-left: -100%;，让left回到上一行最左侧</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  margin-left: -100%;</span><br><span class=\"line\">  background: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// left回到第一行后，right位于第二行的最左侧</span><br><span class=\"line\">// 设置margin-left把right拉回第一行的最右侧</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  margin-left: -100px;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// left和right这会把middle给遮住了</span><br><span class=\"line\">// 所以这时给外层的container设置 padding，给left和right空出位置</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  height: 300px;</span><br><span class=\"line\">  padding: 0 100px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.footer&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt;</span><br><span class=\"line\">  &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//middle占据除left和right之外的剩余所有空间，并不被遮挡</span><br><span class=\"line\">.header&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  height:300px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left&#123;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.middle&#123;</span><br><span class=\"line\">  flex:1;//middle占据剩余所有空间</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.footer&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"绝对定位\"><a href=\"#绝对定位\" class=\"headerlink\" title=\"绝对定位\"></a>绝对定位</h4><p>以上两种dom结构均可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.header&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  height:300px;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  padding: 0 100px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.middle&#123;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  top:0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  background-color:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.footer&#123;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  border:1px solid black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h3><p>双飞翼布局和圣杯布局几乎一样，区别在于处理middle中被遮挡的部分。</p>\n<ul>\n<li>圣杯布局是在三栏布局的父容器中设置padding。</li>\n<li>双飞翼布局是在middle中再放一个div用来显示内容，为其设置margin。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header&gt;header&lt;/header&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;middle&quot;&gt;</span><br><span class=\"line\">            &lt;div class=&quot;main&quot;&gt;middle&lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;footer&gt;footer&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用圣杯布局的浮动和绝对定位时设置，同时把container中的padding去除</span><br><span class=\"line\">.main&#123;</span><br><span class=\"line\">  margin:0 100px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"CSS：垂直居中","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n## 基于绝对定位\n### 要求元素具有固定的高度和宽度\n```\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    margin-top:-20px;\n    margin-left:-20px;\n    height:40px;\n    width:40px;\n}\n```\n\n```\n//借助calc()函数\n{\n    position:absolute;\n    top:calc(50%-20px);\n    left:calc(50%-20px);\n    height:40px;\n    width:40px;\n}\n```\n### 不需要在偏移量中把元素尺寸写死\n\n```\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    transform:translate(-50%,-50%);\n}\n```\n\n## 基于Flex布局\n\n```\n{\n    display:flex;\n    justify-content:center;//使子元素水平居中\n    align-items:center;//使子元素垂直居中\n    height:40px;\n}\n```\n\n## 基于table布局\n\n```\n{\n    display: table-cell;\n    vertical-align: middle;//使子元素垂直居中\n    text-align: center;//使子元素水平居中\n}\n```\n\n","source":"_posts/css/css：垂直居中.md","raw":"---\ntitle: CSS：垂直居中\nDate: 2019-03-26\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n## 基于绝对定位\n### 要求元素具有固定的高度和宽度\n```\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    margin-top:-20px;\n    margin-left:-20px;\n    height:40px;\n    width:40px;\n}\n```\n\n```\n//借助calc()函数\n{\n    position:absolute;\n    top:calc(50%-20px);\n    left:calc(50%-20px);\n    height:40px;\n    width:40px;\n}\n```\n### 不需要在偏移量中把元素尺寸写死\n\n```\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    transform:translate(-50%,-50%);\n}\n```\n\n## 基于Flex布局\n\n```\n{\n    display:flex;\n    justify-content:center;//使子元素水平居中\n    align-items:center;//使子元素垂直居中\n    height:40px;\n}\n```\n\n## 基于table布局\n\n```\n{\n    display: table-cell;\n    vertical-align: middle;//使子元素垂直居中\n    text-align: center;//使子元素水平居中\n}\n```\n\n","slug":"css/css：垂直居中","published":1,"date":"2019-03-26T03:46:23.318Z","updated":"2019-03-26T08:47:25.983Z","layout":"post","photos":[],"link":"","_id":"cka6kwrxf000nrcu9p09lv1tj","content":"<h2 id=\"基于绝对定位\"><a href=\"#基于绝对定位\" class=\"headerlink\" title=\"基于绝对定位\"></a>基于绝对定位</h2><h3 id=\"要求元素具有固定的高度和宽度\"><a href=\"#要求元素具有固定的高度和宽度\" class=\"headerlink\" title=\"要求元素具有固定的高度和宽度\"></a>要求元素具有固定的高度和宽度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:50%;</span><br><span class=\"line\">    left:50%;</span><br><span class=\"line\">    margin-top:-20px;</span><br><span class=\"line\">    margin-left:-20px;</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    width:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//借助calc()函数</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:calc(50%-20px);</span><br><span class=\"line\">    left:calc(50%-20px);</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    width:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不需要在偏移量中把元素尺寸写死\"><a href=\"#不需要在偏移量中把元素尺寸写死\" class=\"headerlink\" title=\"不需要在偏移量中把元素尺寸写死\"></a>不需要在偏移量中把元素尺寸写死</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:50%;</span><br><span class=\"line\">    left:50%;</span><br><span class=\"line\">    transform:translate(-50%,-50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基于Flex布局\"><a href=\"#基于Flex布局\" class=\"headerlink\" title=\"基于Flex布局\"></a>基于Flex布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display:flex;</span><br><span class=\"line\">    justify-content:center;//使子元素水平居中</span><br><span class=\"line\">    align-items:center;//使子元素垂直居中</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基于table布局\"><a href=\"#基于table布局\" class=\"headerlink\" title=\"基于table布局\"></a>基于table布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display: table-cell;</span><br><span class=\"line\">    vertical-align: middle;//使子元素垂直居中</span><br><span class=\"line\">    text-align: center;//使子元素水平居中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基于绝对定位\"><a href=\"#基于绝对定位\" class=\"headerlink\" title=\"基于绝对定位\"></a>基于绝对定位</h2><h3 id=\"要求元素具有固定的高度和宽度\"><a href=\"#要求元素具有固定的高度和宽度\" class=\"headerlink\" title=\"要求元素具有固定的高度和宽度\"></a>要求元素具有固定的高度和宽度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:50%;</span><br><span class=\"line\">    left:50%;</span><br><span class=\"line\">    margin-top:-20px;</span><br><span class=\"line\">    margin-left:-20px;</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    width:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//借助calc()函数</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:calc(50%-20px);</span><br><span class=\"line\">    left:calc(50%-20px);</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    width:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不需要在偏移量中把元素尺寸写死\"><a href=\"#不需要在偏移量中把元素尺寸写死\" class=\"headerlink\" title=\"不需要在偏移量中把元素尺寸写死\"></a>不需要在偏移量中把元素尺寸写死</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:50%;</span><br><span class=\"line\">    left:50%;</span><br><span class=\"line\">    transform:translate(-50%,-50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基于Flex布局\"><a href=\"#基于Flex布局\" class=\"headerlink\" title=\"基于Flex布局\"></a>基于Flex布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display:flex;</span><br><span class=\"line\">    justify-content:center;//使子元素水平居中</span><br><span class=\"line\">    align-items:center;//使子元素垂直居中</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基于table布局\"><a href=\"#基于table布局\" class=\"headerlink\" title=\"基于table布局\"></a>基于table布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display: table-cell;</span><br><span class=\"line\">    vertical-align: middle;//使子元素垂直居中</span><br><span class=\"line\">    text-align: center;//使子元素水平居中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"CSS：垂直水平居中","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n## 基于绝对定位\n### 要求元素具有固定的高度和宽度\n```\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    margin-top:-20px;\n    margin-left:-20px;\n    height:40px;\n    width:40px;\n}\n```\n局限性：不能自适应，边距大小与padding，box-sizing有关\n\n借助calc()函数\n\n```\n{\n    position:absolute;\n    top:calc(50%-20px);\n    left:calc(50%-20px);\n    height:40px;\n    width:40px;\n}\n```\n### 不需要在偏移量中把元素尺寸写死\n\n```\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    transform:translate(-50%,-50%);\n}\n```\n局限性：ie8不支持\n## 基于Flex布局\n\n```\n{\n    display:flex;\n    justify-content:center;//使子元素水平居中\n    align-items:center;//使子元素垂直居中\n    height:40px;\n}\n```\n局限性：ie7/8不兼容\n## 基于table布局\n\n```\n{\n    display: table-cell;\n    vertical-align: middle;//使子元素垂直居中\n    text-align: center;//使子元素水平居中\n}\n```\n局限性：需要额外html标记\n## 基于inline-block\n```\n{\n    display: inline-block;\n    vertical-align: middle;//使元素垂直居中\n    text-align: center;//使元素水平居中\n}\n```\n## 只有文字\n\n```\n{\n    line-height: 24px;//使元素垂直居中\n    text-align: center;//使元素水平居中\n}\n```\n","source":"_posts/css/css：垂直水平居中.md","raw":"---\ntitle: CSS：垂直水平居中\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n## 基于绝对定位\n### 要求元素具有固定的高度和宽度\n```\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    margin-top:-20px;\n    margin-left:-20px;\n    height:40px;\n    width:40px;\n}\n```\n局限性：不能自适应，边距大小与padding，box-sizing有关\n\n借助calc()函数\n\n```\n{\n    position:absolute;\n    top:calc(50%-20px);\n    left:calc(50%-20px);\n    height:40px;\n    width:40px;\n}\n```\n### 不需要在偏移量中把元素尺寸写死\n\n```\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    transform:translate(-50%,-50%);\n}\n```\n局限性：ie8不支持\n## 基于Flex布局\n\n```\n{\n    display:flex;\n    justify-content:center;//使子元素水平居中\n    align-items:center;//使子元素垂直居中\n    height:40px;\n}\n```\n局限性：ie7/8不兼容\n## 基于table布局\n\n```\n{\n    display: table-cell;\n    vertical-align: middle;//使子元素垂直居中\n    text-align: center;//使子元素水平居中\n}\n```\n局限性：需要额外html标记\n## 基于inline-block\n```\n{\n    display: inline-block;\n    vertical-align: middle;//使元素垂直居中\n    text-align: center;//使元素水平居中\n}\n```\n## 只有文字\n\n```\n{\n    line-height: 24px;//使元素垂直居中\n    text-align: center;//使元素水平居中\n}\n```\n","slug":"css/css：垂直水平居中","published":1,"date":"2020-05-14T08:49:07.918Z","updated":"2020-05-14T08:51:36.343Z","layout":"post","photos":[],"link":"","_id":"cka6kwrxn000qrcu9kqyqx9cg","content":"<h2 id=\"基于绝对定位\"><a href=\"#基于绝对定位\" class=\"headerlink\" title=\"基于绝对定位\"></a>基于绝对定位</h2><h3 id=\"要求元素具有固定的高度和宽度\"><a href=\"#要求元素具有固定的高度和宽度\" class=\"headerlink\" title=\"要求元素具有固定的高度和宽度\"></a>要求元素具有固定的高度和宽度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:50%;</span><br><span class=\"line\">    left:50%;</span><br><span class=\"line\">    margin-top:-20px;</span><br><span class=\"line\">    margin-left:-20px;</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    width:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：不能自适应，边距大小与padding，box-sizing有关</p>\n<p>借助calc()函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:calc(50%-20px);</span><br><span class=\"line\">    left:calc(50%-20px);</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    width:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不需要在偏移量中把元素尺寸写死\"><a href=\"#不需要在偏移量中把元素尺寸写死\" class=\"headerlink\" title=\"不需要在偏移量中把元素尺寸写死\"></a>不需要在偏移量中把元素尺寸写死</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:50%;</span><br><span class=\"line\">    left:50%;</span><br><span class=\"line\">    transform:translate(-50%,-50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：ie8不支持</p>\n<h2 id=\"基于Flex布局\"><a href=\"#基于Flex布局\" class=\"headerlink\" title=\"基于Flex布局\"></a>基于Flex布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display:flex;</span><br><span class=\"line\">    justify-content:center;//使子元素水平居中</span><br><span class=\"line\">    align-items:center;//使子元素垂直居中</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：ie7/8不兼容</p>\n<h2 id=\"基于table布局\"><a href=\"#基于table布局\" class=\"headerlink\" title=\"基于table布局\"></a>基于table布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display: table-cell;</span><br><span class=\"line\">    vertical-align: middle;//使子元素垂直居中</span><br><span class=\"line\">    text-align: center;//使子元素水平居中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：需要额外html标记</p>\n<h2 id=\"基于inline-block\"><a href=\"#基于inline-block\" class=\"headerlink\" title=\"基于inline-block\"></a>基于inline-block</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    vertical-align: middle;//使元素垂直居中</span><br><span class=\"line\">    text-align: center;//使元素水平居中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"只有文字\"><a href=\"#只有文字\" class=\"headerlink\" title=\"只有文字\"></a>只有文字</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    line-height: 24px;//使元素垂直居中</span><br><span class=\"line\">    text-align: center;//使元素水平居中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基于绝对定位\"><a href=\"#基于绝对定位\" class=\"headerlink\" title=\"基于绝对定位\"></a>基于绝对定位</h2><h3 id=\"要求元素具有固定的高度和宽度\"><a href=\"#要求元素具有固定的高度和宽度\" class=\"headerlink\" title=\"要求元素具有固定的高度和宽度\"></a>要求元素具有固定的高度和宽度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:50%;</span><br><span class=\"line\">    left:50%;</span><br><span class=\"line\">    margin-top:-20px;</span><br><span class=\"line\">    margin-left:-20px;</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    width:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：不能自适应，边距大小与padding，box-sizing有关</p>\n<p>借助calc()函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:calc(50%-20px);</span><br><span class=\"line\">    left:calc(50%-20px);</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    width:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不需要在偏移量中把元素尺寸写死\"><a href=\"#不需要在偏移量中把元素尺寸写死\" class=\"headerlink\" title=\"不需要在偏移量中把元素尺寸写死\"></a>不需要在偏移量中把元素尺寸写死</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    top:50%;</span><br><span class=\"line\">    left:50%;</span><br><span class=\"line\">    transform:translate(-50%,-50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：ie8不支持</p>\n<h2 id=\"基于Flex布局\"><a href=\"#基于Flex布局\" class=\"headerlink\" title=\"基于Flex布局\"></a>基于Flex布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display:flex;</span><br><span class=\"line\">    justify-content:center;//使子元素水平居中</span><br><span class=\"line\">    align-items:center;//使子元素垂直居中</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：ie7/8不兼容</p>\n<h2 id=\"基于table布局\"><a href=\"#基于table布局\" class=\"headerlink\" title=\"基于table布局\"></a>基于table布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display: table-cell;</span><br><span class=\"line\">    vertical-align: middle;//使子元素垂直居中</span><br><span class=\"line\">    text-align: center;//使子元素水平居中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：需要额外html标记</p>\n<h2 id=\"基于inline-block\"><a href=\"#基于inline-block\" class=\"headerlink\" title=\"基于inline-block\"></a>基于inline-block</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    vertical-align: middle;//使元素垂直居中</span><br><span class=\"line\">    text-align: center;//使元素水平居中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"只有文字\"><a href=\"#只有文字\" class=\"headerlink\" title=\"只有文字\"></a>只有文字</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    line-height: 24px;//使元素垂直居中</span><br><span class=\"line\">    text-align: center;//使元素水平居中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"CSS：模块化","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n## 文件结构\n### 常见文件结构\n一个项目的CSS最基本结构通常是下面这样的：\n\n- base.css\n- common.css\n- pages.css\n\n复杂一点的项目可能是这样分：\n\n- base.css\n- header.css\n- footer.css\n- sidebar.css\n- forms.css\n- icons.css\n- buttons.css\n- dropdown.css\n- modals.css\n- layout.css\n- index.css\n- user.css\n- admin.css\n- pages.css\n\n如果后期不打算合并CSS的，建议尽可能减少 CSS 文件的数量。\n\n### SMACSS\nSMACSS 的全称叫 Scalable and Modular Architecture for CSS。即可扩展和模块化的CSS架构。\n\nSMACSS将样式分成5种类型：Base，Layout，Module，State，Theme\n- Base: 基础样式表，定义了基本的样式，我们平时写CSS比如reset.css就是属于基础样式表，另外我认为清除浮动，一些动画也可以归类为基础样式。\n- Layout: 布局样式，用于实现网页的基本布局，搭起整个网页的基本骨架。\n- Module: 网页中不同的区域有这个不同的功能，这些功能是相对独立的，我们可以称其为模块。模块是独立的，可重用的组件，它们不依赖于布局组件，可以安全的删除修改而不影响其他模块。\n- State: 状态样式，通常和js一起配合使用，表示某个组件或功能不同的状态，比如菜单选中状态，按钮不可用状态等。\n- Theme: 主题皮肤，对于可更换皮肤的站点来说，这个是很有必要的，分离了结构和皮肤，根据不同的皮肤应用不同的样式文件。\n\n## css选择器命名规则\n它的每一条规则都是全局的，在 CSS 预处理出现之前，这很容易造成命名上的冲突。    当涉及到多人维护同一段 CSS 代码时，命名的意义表达，也会影响到维护效率。\n- 使用独一无二的规则。命名唯一。\n- 使用简短的命名。\n- 嵌套层级不宜过深，建议控制在3层以内。\n\n### BEM\nBEM是Block，Element，Modifier的缩写。是比较流行的一种 CSS 命名方式。\n- Block：在BEM的理论中，一个网页是由block组成的，比如头部是个block，内容是block，logo也是block，一个block可能由几个子block组成。\n- Element：element是block的一部分，具有某种功能，element依赖于block，比如在logo中，img是logo的一个element，在菜单中，菜单项是菜单的一个element\n- Modifier：modifier是用来修饰block或者element的，它表示block或者element在外观或行为上的改变\n\n```\n命名规则如下：\n.block {}\n.block__element {}\n.block--modifier {}\n例如：\n.login {}\n.login__btn {}\n.login__btn--reset {}\n.login__btn--confirm {}\n```\n下划线（__）被用来区分元素，而用连字符(--)是用来修饰元素的。\n\n### SUIT\nSuit起源于BEM，但是它对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来.","source":"_posts/css/css：模块化.md","raw":"---\ntitle: CSS：模块化\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n## 文件结构\n### 常见文件结构\n一个项目的CSS最基本结构通常是下面这样的：\n\n- base.css\n- common.css\n- pages.css\n\n复杂一点的项目可能是这样分：\n\n- base.css\n- header.css\n- footer.css\n- sidebar.css\n- forms.css\n- icons.css\n- buttons.css\n- dropdown.css\n- modals.css\n- layout.css\n- index.css\n- user.css\n- admin.css\n- pages.css\n\n如果后期不打算合并CSS的，建议尽可能减少 CSS 文件的数量。\n\n### SMACSS\nSMACSS 的全称叫 Scalable and Modular Architecture for CSS。即可扩展和模块化的CSS架构。\n\nSMACSS将样式分成5种类型：Base，Layout，Module，State，Theme\n- Base: 基础样式表，定义了基本的样式，我们平时写CSS比如reset.css就是属于基础样式表，另外我认为清除浮动，一些动画也可以归类为基础样式。\n- Layout: 布局样式，用于实现网页的基本布局，搭起整个网页的基本骨架。\n- Module: 网页中不同的区域有这个不同的功能，这些功能是相对独立的，我们可以称其为模块。模块是独立的，可重用的组件，它们不依赖于布局组件，可以安全的删除修改而不影响其他模块。\n- State: 状态样式，通常和js一起配合使用，表示某个组件或功能不同的状态，比如菜单选中状态，按钮不可用状态等。\n- Theme: 主题皮肤，对于可更换皮肤的站点来说，这个是很有必要的，分离了结构和皮肤，根据不同的皮肤应用不同的样式文件。\n\n## css选择器命名规则\n它的每一条规则都是全局的，在 CSS 预处理出现之前，这很容易造成命名上的冲突。    当涉及到多人维护同一段 CSS 代码时，命名的意义表达，也会影响到维护效率。\n- 使用独一无二的规则。命名唯一。\n- 使用简短的命名。\n- 嵌套层级不宜过深，建议控制在3层以内。\n\n### BEM\nBEM是Block，Element，Modifier的缩写。是比较流行的一种 CSS 命名方式。\n- Block：在BEM的理论中，一个网页是由block组成的，比如头部是个block，内容是block，logo也是block，一个block可能由几个子block组成。\n- Element：element是block的一部分，具有某种功能，element依赖于block，比如在logo中，img是logo的一个element，在菜单中，菜单项是菜单的一个element\n- Modifier：modifier是用来修饰block或者element的，它表示block或者element在外观或行为上的改变\n\n```\n命名规则如下：\n.block {}\n.block__element {}\n.block--modifier {}\n例如：\n.login {}\n.login__btn {}\n.login__btn--reset {}\n.login__btn--confirm {}\n```\n下划线（__）被用来区分元素，而用连字符(--)是用来修饰元素的。\n\n### SUIT\nSuit起源于BEM，但是它对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来.","slug":"css/css：模块化","published":1,"date":"2020-05-14T08:48:10.815Z","updated":"2020-05-14T08:49:48.858Z","layout":"post","photos":[],"link":"","_id":"cka6kwrxt000trcu95mcy43fn","content":"<h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><h3 id=\"常见文件结构\"><a href=\"#常见文件结构\" class=\"headerlink\" title=\"常见文件结构\"></a>常见文件结构</h3><p>一个项目的CSS最基本结构通常是下面这样的：</p>\n<ul>\n<li>base.css</li>\n<li>common.css</li>\n<li>pages.css</li>\n</ul>\n<p>复杂一点的项目可能是这样分：</p>\n<ul>\n<li>base.css</li>\n<li>header.css</li>\n<li>footer.css</li>\n<li>sidebar.css</li>\n<li>forms.css</li>\n<li>icons.css</li>\n<li>buttons.css</li>\n<li>dropdown.css</li>\n<li>modals.css</li>\n<li>layout.css</li>\n<li>index.css</li>\n<li>user.css</li>\n<li>admin.css</li>\n<li>pages.css</li>\n</ul>\n<p>如果后期不打算合并CSS的，建议尽可能减少 CSS 文件的数量。</p>\n<h3 id=\"SMACSS\"><a href=\"#SMACSS\" class=\"headerlink\" title=\"SMACSS\"></a>SMACSS</h3><p>SMACSS 的全称叫 Scalable and Modular Architecture for CSS。即可扩展和模块化的CSS架构。</p>\n<p>SMACSS将样式分成5种类型：Base，Layout，Module，State，Theme</p>\n<ul>\n<li>Base: 基础样式表，定义了基本的样式，我们平时写CSS比如reset.css就是属于基础样式表，另外我认为清除浮动，一些动画也可以归类为基础样式。</li>\n<li>Layout: 布局样式，用于实现网页的基本布局，搭起整个网页的基本骨架。</li>\n<li>Module: 网页中不同的区域有这个不同的功能，这些功能是相对独立的，我们可以称其为模块。模块是独立的，可重用的组件，它们不依赖于布局组件，可以安全的删除修改而不影响其他模块。</li>\n<li>State: 状态样式，通常和js一起配合使用，表示某个组件或功能不同的状态，比如菜单选中状态，按钮不可用状态等。</li>\n<li>Theme: 主题皮肤，对于可更换皮肤的站点来说，这个是很有必要的，分离了结构和皮肤，根据不同的皮肤应用不同的样式文件。</li>\n</ul>\n<h2 id=\"css选择器命名规则\"><a href=\"#css选择器命名规则\" class=\"headerlink\" title=\"css选择器命名规则\"></a>css选择器命名规则</h2><p>它的每一条规则都是全局的，在 CSS 预处理出现之前，这很容易造成命名上的冲突。    当涉及到多人维护同一段 CSS 代码时，命名的意义表达，也会影响到维护效率。</p>\n<ul>\n<li>使用独一无二的规则。命名唯一。</li>\n<li>使用简短的命名。</li>\n<li>嵌套层级不宜过深，建议控制在3层以内。</li>\n</ul>\n<h3 id=\"BEM\"><a href=\"#BEM\" class=\"headerlink\" title=\"BEM\"></a>BEM</h3><p>BEM是Block，Element，Modifier的缩写。是比较流行的一种 CSS 命名方式。</p>\n<ul>\n<li>Block：在BEM的理论中，一个网页是由block组成的，比如头部是个block，内容是block，logo也是block，一个block可能由几个子block组成。</li>\n<li>Element：element是block的一部分，具有某种功能，element依赖于block，比如在logo中，img是logo的一个element，在菜单中，菜单项是菜单的一个element</li>\n<li>Modifier：modifier是用来修饰block或者element的，它表示block或者element在外观或行为上的改变</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命名规则如下：</span><br><span class=\"line\">.block &#123;&#125;</span><br><span class=\"line\">.block__element &#123;&#125;</span><br><span class=\"line\">.block--modifier &#123;&#125;</span><br><span class=\"line\">例如：</span><br><span class=\"line\">.login &#123;&#125;</span><br><span class=\"line\">.login__btn &#123;&#125;</span><br><span class=\"line\">.login__btn--reset &#123;&#125;</span><br><span class=\"line\">.login__btn--confirm &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>下划线（__）被用来区分元素，而用连字符(–)是用来修饰元素的。</p>\n<h3 id=\"SUIT\"><a href=\"#SUIT\" class=\"headerlink\" title=\"SUIT\"></a>SUIT</h3><p>Suit起源于BEM，但是它对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><h3 id=\"常见文件结构\"><a href=\"#常见文件结构\" class=\"headerlink\" title=\"常见文件结构\"></a>常见文件结构</h3><p>一个项目的CSS最基本结构通常是下面这样的：</p>\n<ul>\n<li>base.css</li>\n<li>common.css</li>\n<li>pages.css</li>\n</ul>\n<p>复杂一点的项目可能是这样分：</p>\n<ul>\n<li>base.css</li>\n<li>header.css</li>\n<li>footer.css</li>\n<li>sidebar.css</li>\n<li>forms.css</li>\n<li>icons.css</li>\n<li>buttons.css</li>\n<li>dropdown.css</li>\n<li>modals.css</li>\n<li>layout.css</li>\n<li>index.css</li>\n<li>user.css</li>\n<li>admin.css</li>\n<li>pages.css</li>\n</ul>\n<p>如果后期不打算合并CSS的，建议尽可能减少 CSS 文件的数量。</p>\n<h3 id=\"SMACSS\"><a href=\"#SMACSS\" class=\"headerlink\" title=\"SMACSS\"></a>SMACSS</h3><p>SMACSS 的全称叫 Scalable and Modular Architecture for CSS。即可扩展和模块化的CSS架构。</p>\n<p>SMACSS将样式分成5种类型：Base，Layout，Module，State，Theme</p>\n<ul>\n<li>Base: 基础样式表，定义了基本的样式，我们平时写CSS比如reset.css就是属于基础样式表，另外我认为清除浮动，一些动画也可以归类为基础样式。</li>\n<li>Layout: 布局样式，用于实现网页的基本布局，搭起整个网页的基本骨架。</li>\n<li>Module: 网页中不同的区域有这个不同的功能，这些功能是相对独立的，我们可以称其为模块。模块是独立的，可重用的组件，它们不依赖于布局组件，可以安全的删除修改而不影响其他模块。</li>\n<li>State: 状态样式，通常和js一起配合使用，表示某个组件或功能不同的状态，比如菜单选中状态，按钮不可用状态等。</li>\n<li>Theme: 主题皮肤，对于可更换皮肤的站点来说，这个是很有必要的，分离了结构和皮肤，根据不同的皮肤应用不同的样式文件。</li>\n</ul>\n<h2 id=\"css选择器命名规则\"><a href=\"#css选择器命名规则\" class=\"headerlink\" title=\"css选择器命名规则\"></a>css选择器命名规则</h2><p>它的每一条规则都是全局的，在 CSS 预处理出现之前，这很容易造成命名上的冲突。    当涉及到多人维护同一段 CSS 代码时，命名的意义表达，也会影响到维护效率。</p>\n<ul>\n<li>使用独一无二的规则。命名唯一。</li>\n<li>使用简短的命名。</li>\n<li>嵌套层级不宜过深，建议控制在3层以内。</li>\n</ul>\n<h3 id=\"BEM\"><a href=\"#BEM\" class=\"headerlink\" title=\"BEM\"></a>BEM</h3><p>BEM是Block，Element，Modifier的缩写。是比较流行的一种 CSS 命名方式。</p>\n<ul>\n<li>Block：在BEM的理论中，一个网页是由block组成的，比如头部是个block，内容是block，logo也是block，一个block可能由几个子block组成。</li>\n<li>Element：element是block的一部分，具有某种功能，element依赖于block，比如在logo中，img是logo的一个element，在菜单中，菜单项是菜单的一个element</li>\n<li>Modifier：modifier是用来修饰block或者element的，它表示block或者element在外观或行为上的改变</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命名规则如下：</span><br><span class=\"line\">.block &#123;&#125;</span><br><span class=\"line\">.block__element &#123;&#125;</span><br><span class=\"line\">.block--modifier &#123;&#125;</span><br><span class=\"line\">例如：</span><br><span class=\"line\">.login &#123;&#125;</span><br><span class=\"line\">.login__btn &#123;&#125;</span><br><span class=\"line\">.login__btn--reset &#123;&#125;</span><br><span class=\"line\">.login__btn--confirm &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>下划线（__）被用来区分元素，而用连字符(–)是用来修饰元素的。</p>\n<h3 id=\"SUIT\"><a href=\"#SUIT\" class=\"headerlink\" title=\"SUIT\"></a>SUIT</h3><p>Suit起源于BEM，但是它对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来.</p>\n"},{"title":"CSS：清除浮动","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n浮动产生影响\n1. 给父元素设置高度。\n2. 给父元素设置overflow:hidden;\n3. 父元素也设置浮动。\n4. 在结尾处添加空div标签clear:both\n5. 父元素定义伪类::after\n```\n::after{\n\t\tclear: both;\n\t\tcontent: \"\";\n\t\tdisplay: block;\n\t}\n```\n6. 父元素定义display:table","source":"_posts/css/css：清除浮动.md","raw":"---\ntitle: CSS：清除浮动\nDate: 2019-03-26\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n浮动产生影响\n1. 给父元素设置高度。\n2. 给父元素设置overflow:hidden;\n3. 父元素也设置浮动。\n4. 在结尾处添加空div标签clear:both\n5. 父元素定义伪类::after\n```\n::after{\n\t\tclear: both;\n\t\tcontent: \"\";\n\t\tdisplay: block;\n\t}\n```\n6. 父元素定义display:table","slug":"css/css：清除浮动","published":1,"date":"2019-03-26T03:46:16.466Z","updated":"2019-03-26T03:44:26.710Z","layout":"post","photos":[],"link":"","_id":"cka6kwrxy000wrcu9glxtuzoe","content":"<p>浮动产生影响</p>\n<ol>\n<li>给父元素设置高度。</li>\n<li>给父元素设置overflow:hidden;</li>\n<li>父元素也设置浮动。</li>\n<li>在结尾处添加空div标签clear:both</li>\n<li><p>父元素定义伪类::after</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::after&#123;</span><br><span class=\"line\">\t\tclear: both;</span><br><span class=\"line\">\t\tcontent: &quot;&quot;;</span><br><span class=\"line\">\t\tdisplay: block;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>父元素定义display:table</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>浮动产生影响</p>\n<ol>\n<li>给父元素设置高度。</li>\n<li>给父元素设置overflow:hidden;</li>\n<li>父元素也设置浮动。</li>\n<li>在结尾处添加空div标签clear:both</li>\n<li><p>父元素定义伪类::after</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::after&#123;</span><br><span class=\"line\">\t\tclear: both;</span><br><span class=\"line\">\t\tcontent: &quot;&quot;;</span><br><span class=\"line\">\t\tdisplay: block;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>父元素定义display:table</p>\n</li>\n</ol>\n"},{"title":"CSS：盒模型","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 标准模型\n\n```\n盒模型宽高 = margin + border + padding + content\n元素宽高（元素占据的位置） = content\n```\n![image](https://img-blog.csdn.net/20180324150509906?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3a2trazE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n### IE盒模型\n\n```\n盒模型宽高 = margin + 元素宽高\n元素宽高（元素占据的位置） = border + padding + content\n```\n\n![image](https://img-blog.csdn.net/20180324150533356?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3a2trazE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n### 修改盒模型（box-sizing）\n\nbox-sizing\n- content-box：默认属性，标准盒模型\n- border-box：使元素宽高包括padding和border，内容区的实际宽度会是元素宽高减去border + padding的计算值。（即IE盒模型）\n","source":"_posts/css/css：盒模型.md","raw":"---\ntitle: CSS：盒模型\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### 标准模型\n\n```\n盒模型宽高 = margin + border + padding + content\n元素宽高（元素占据的位置） = content\n```\n![image](https://img-blog.csdn.net/20180324150509906?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3a2trazE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n### IE盒模型\n\n```\n盒模型宽高 = margin + 元素宽高\n元素宽高（元素占据的位置） = border + padding + content\n```\n\n![image](https://img-blog.csdn.net/20180324150533356?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3a2trazE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n### 修改盒模型（box-sizing）\n\nbox-sizing\n- content-box：默认属性，标准盒模型\n- border-box：使元素宽高包括padding和border，内容区的实际宽度会是元素宽高减去border + padding的计算值。（即IE盒模型）\n","slug":"css/css：盒模型","published":1,"date":"2020-05-14T08:48:05.321Z","updated":"2020-05-14T08:51:22.268Z","layout":"post","photos":[],"link":"","_id":"cka6kwry3000zrcu9jc7z4lpo","content":"<h3 id=\"标准模型\"><a href=\"#标准模型\" class=\"headerlink\" title=\"标准模型\"></a>标准模型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">盒模型宽高 = margin + border + padding + content</span><br><span class=\"line\">元素宽高（元素占据的位置） = content</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdn.net/20180324150509906?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3a2trazE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"IE盒模型\"><a href=\"#IE盒模型\" class=\"headerlink\" title=\"IE盒模型\"></a>IE盒模型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">盒模型宽高 = margin + 元素宽高</span><br><span class=\"line\">元素宽高（元素占据的位置） = border + padding + content</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdn.net/20180324150533356?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3a2trazE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"修改盒模型（box-sizing）\"><a href=\"#修改盒模型（box-sizing）\" class=\"headerlink\" title=\"修改盒模型（box-sizing）\"></a>修改盒模型（box-sizing）</h3><p>box-sizing</p>\n<ul>\n<li>content-box：默认属性，标准盒模型</li>\n<li>border-box：使元素宽高包括padding和border，内容区的实际宽度会是元素宽高减去border + padding的计算值。（即IE盒模型）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"标准模型\"><a href=\"#标准模型\" class=\"headerlink\" title=\"标准模型\"></a>标准模型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">盒模型宽高 = margin + border + padding + content</span><br><span class=\"line\">元素宽高（元素占据的位置） = content</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdn.net/20180324150509906?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3a2trazE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"IE盒模型\"><a href=\"#IE盒模型\" class=\"headerlink\" title=\"IE盒模型\"></a>IE盒模型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">盒模型宽高 = margin + 元素宽高</span><br><span class=\"line\">元素宽高（元素占据的位置） = border + padding + content</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdn.net/20180324150533356?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3a2trazE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"修改盒模型（box-sizing）\"><a href=\"#修改盒模型（box-sizing）\" class=\"headerlink\" title=\"修改盒模型（box-sizing）\"></a>修改盒模型（box-sizing）</h3><p>box-sizing</p>\n<ul>\n<li>content-box：默认属性，标准盒模型</li>\n<li>border-box：使元素宽高包括padding和border，内容区的实际宽度会是元素宽高减去border + padding的计算值。（即IE盒模型）</li>\n</ul>\n"},{"title":"CSS：等宽的三栏布局","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n```\n<div class=\"box\">\n    <div class=\"left\"></div>    \n    <div class=\"center\"></div>\n    <div class=\"right\"></div>\n</div>\n```\n\n### float\n\n```\n.box {\n  width: 100%;\n  height: 200px;\n  background: black;\n}\n.left, .center, .right {\n  width: 33.33%;\n  height: 100%;\n  float: left;\n  background: #FFA54F;\n}\n.center {\n  background: #FFA500;\n}\n.right{\n  background: #FFA07A;\n}\n```\n\n### flex\n\n```\n.box {\n  width: 100%;\n  height: 200px;\n  background: black;\n  display: flex;\n}\n.left, .center, .right {\n  width: 33.33%;\n  height: 100%;\n  background: #FFA54F;\n}\n.center {\n  background: #FFA500;\n}\n.right{\n  background: #FFA07A;\n}\n```\n\n### table\n\n```\n.box {\n  width: 100%;\n  height: 200px;\n  background: black;\n  display: table;\n}\n.left, .center, .right {\n  display: table-cell;\n  width: 33.33%;\n  height: 100%;\n  background: #FFA54F;\n}\n.center {\n  background: #FFA500;\n}\n.right{\n  background: #FFA07A;\n}\n```\n","source":"_posts/css/css：等宽的三栏布局.md","raw":"---\ntitle: CSS：等宽的三栏布局\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n```\n<div class=\"box\">\n    <div class=\"left\"></div>    \n    <div class=\"center\"></div>\n    <div class=\"right\"></div>\n</div>\n```\n\n### float\n\n```\n.box {\n  width: 100%;\n  height: 200px;\n  background: black;\n}\n.left, .center, .right {\n  width: 33.33%;\n  height: 100%;\n  float: left;\n  background: #FFA54F;\n}\n.center {\n  background: #FFA500;\n}\n.right{\n  background: #FFA07A;\n}\n```\n\n### flex\n\n```\n.box {\n  width: 100%;\n  height: 200px;\n  background: black;\n  display: flex;\n}\n.left, .center, .right {\n  width: 33.33%;\n  height: 100%;\n  background: #FFA54F;\n}\n.center {\n  background: #FFA500;\n}\n.right{\n  background: #FFA07A;\n}\n```\n\n### table\n\n```\n.box {\n  width: 100%;\n  height: 200px;\n  background: black;\n  display: table;\n}\n.left, .center, .right {\n  display: table-cell;\n  width: 33.33%;\n  height: 100%;\n  background: #FFA54F;\n}\n.center {\n  background: #FFA500;\n}\n.right{\n  background: #FFA07A;\n}\n```\n","slug":"css/css：等宽的三栏布局","published":1,"date":"2020-05-14T08:48:22.141Z","updated":"2020-05-14T08:51:08.515Z","layout":"post","photos":[],"link":"","_id":"cka6kwry80012rcu92zp7xnu5","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    </span><br><span class=\"line\">    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left, .center, .right &#123;</span><br><span class=\"line\">  width: 33.33%;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  background: #FFA54F;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.center &#123;</span><br><span class=\"line\">  background: #FFA500;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  background: #FFA07A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: black;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left, .center, .right &#123;</span><br><span class=\"line\">  width: 33.33%;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  background: #FFA54F;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.center &#123;</span><br><span class=\"line\">  background: #FFA500;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  background: #FFA07A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: black;</span><br><span class=\"line\">  display: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left, .center, .right &#123;</span><br><span class=\"line\">  display: table-cell;</span><br><span class=\"line\">  width: 33.33%;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  background: #FFA54F;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.center &#123;</span><br><span class=\"line\">  background: #FFA500;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  background: #FFA07A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    </span><br><span class=\"line\">    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left, .center, .right &#123;</span><br><span class=\"line\">  width: 33.33%;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  background: #FFA54F;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.center &#123;</span><br><span class=\"line\">  background: #FFA500;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  background: #FFA07A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: black;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left, .center, .right &#123;</span><br><span class=\"line\">  width: 33.33%;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  background: #FFA54F;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.center &#123;</span><br><span class=\"line\">  background: #FFA500;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  background: #FFA07A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: black;</span><br><span class=\"line\">  display: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left, .center, .right &#123;</span><br><span class=\"line\">  display: table-cell;</span><br><span class=\"line\">  width: 33.33%;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  background: #FFA54F;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.center &#123;</span><br><span class=\"line\">  background: #FFA500;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;</span><br><span class=\"line\">  background: #FFA07A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"CSS：选择器","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 选择器优先级\n从高到低\n1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。\n2. 内联样式，作为style属性写在元素内的样式\n3. id选择器\n4. class带伪类，如 .input:first-child\n5. 标签[指定属性]，如 input[type='file']\n6. 类选择器\n> 标签带伪类，如input:first-child，与5、6按css的顺序排优先级\n7. 标签选择器\n8. 通配符选择器\n\n### 属性选择器\n属性选择器支持正则匹配\n\n选择器 | 含义\n---|---\ntag[attr] | 匹配具有attr属性的所有元素，不考虑它的值\ntag[attr='val'] | 匹配attr属性值等于val的所有元素\ntag[attr^='val'] |  匹配attr属性值以指定的值val开头的所有元素\ntag[attr$='val'] |  匹配attr属性值以指定的值val结尾的所有元素\ntag[attr*='val'] |  匹配attr属性值中包含指定的值val的所有元素\n\n- tag为标签名\n- attr为属性\n- val为属性值\n\n### 选择器解析\n- CSS选择器时==从右往左解析==的\n- 尽量少使用不必要的层级关系","source":"_posts/css/css：选择器.md","raw":"---\ntitle: CSS：选择器\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### 选择器优先级\n从高到低\n1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。\n2. 内联样式，作为style属性写在元素内的样式\n3. id选择器\n4. class带伪类，如 .input:first-child\n5. 标签[指定属性]，如 input[type='file']\n6. 类选择器\n> 标签带伪类，如input:first-child，与5、6按css的顺序排优先级\n7. 标签选择器\n8. 通配符选择器\n\n### 属性选择器\n属性选择器支持正则匹配\n\n选择器 | 含义\n---|---\ntag[attr] | 匹配具有attr属性的所有元素，不考虑它的值\ntag[attr='val'] | 匹配attr属性值等于val的所有元素\ntag[attr^='val'] |  匹配attr属性值以指定的值val开头的所有元素\ntag[attr$='val'] |  匹配attr属性值以指定的值val结尾的所有元素\ntag[attr*='val'] |  匹配attr属性值中包含指定的值val的所有元素\n\n- tag为标签名\n- attr为属性\n- val为属性值\n\n### 选择器解析\n- CSS选择器时==从右往左解析==的\n- 尽量少使用不必要的层级关系","slug":"css/css：选择器","published":1,"date":"2020-05-14T08:48:49.717Z","updated":"2020-05-14T08:52:16.653Z","layout":"post","photos":[],"link":"","_id":"cka6kwryd0015rcu9bphv7cim","content":"<h3 id=\"选择器优先级\"><a href=\"#选择器优先级\" class=\"headerlink\" title=\"选择器优先级\"></a>选择器优先级</h3><p>从高到低</p>\n<ol>\n<li>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</li>\n<li>内联样式，作为style属性写在元素内的样式</li>\n<li>id选择器</li>\n<li>class带伪类，如 .input:first-child</li>\n<li>标签[指定属性]，如 input[type=’file’]</li>\n<li>类选择器<blockquote>\n<p>标签带伪类，如input:first-child，与5、6按css的顺序排优先级</p>\n</blockquote>\n</li>\n<li>标签选择器</li>\n<li>通配符选择器</li>\n</ol>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>属性选择器支持正则匹配</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>tag[attr]</td>\n<td>匹配具有attr属性的所有元素，不考虑它的值</td>\n</tr>\n<tr>\n<td>tag[attr=’val’]</td>\n<td>匹配attr属性值等于val的所有元素</td>\n</tr>\n<tr>\n<td>tag[attr^=’val’]</td>\n<td>匹配attr属性值以指定的值val开头的所有元素</td>\n</tr>\n<tr>\n<td>tag[attr$=’val’]</td>\n<td>匹配attr属性值以指定的值val结尾的所有元素</td>\n</tr>\n<tr>\n<td>tag[attr*=’val’]</td>\n<td>匹配attr属性值中包含指定的值val的所有元素</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>tag为标签名</li>\n<li>attr为属性</li>\n<li>val为属性值</li>\n</ul>\n<h3 id=\"选择器解析\"><a href=\"#选择器解析\" class=\"headerlink\" title=\"选择器解析\"></a>选择器解析</h3><ul>\n<li>CSS选择器时==从右往左解析==的</li>\n<li>尽量少使用不必要的层级关系</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"选择器优先级\"><a href=\"#选择器优先级\" class=\"headerlink\" title=\"选择器优先级\"></a>选择器优先级</h3><p>从高到低</p>\n<ol>\n<li>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</li>\n<li>内联样式，作为style属性写在元素内的样式</li>\n<li>id选择器</li>\n<li>class带伪类，如 .input:first-child</li>\n<li>标签[指定属性]，如 input[type=’file’]</li>\n<li>类选择器<blockquote>\n<p>标签带伪类，如input:first-child，与5、6按css的顺序排优先级</p>\n</blockquote>\n</li>\n<li>标签选择器</li>\n<li>通配符选择器</li>\n</ol>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>属性选择器支持正则匹配</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>tag[attr]</td>\n<td>匹配具有attr属性的所有元素，不考虑它的值</td>\n</tr>\n<tr>\n<td>tag[attr=’val’]</td>\n<td>匹配attr属性值等于val的所有元素</td>\n</tr>\n<tr>\n<td>tag[attr^=’val’]</td>\n<td>匹配attr属性值以指定的值val开头的所有元素</td>\n</tr>\n<tr>\n<td>tag[attr$=’val’]</td>\n<td>匹配attr属性值以指定的值val结尾的所有元素</td>\n</tr>\n<tr>\n<td>tag[attr*=’val’]</td>\n<td>匹配attr属性值中包含指定的值val的所有元素</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>tag为标签名</li>\n<li>attr为属性</li>\n<li>val为属性值</li>\n</ul>\n<h3 id=\"选择器解析\"><a href=\"#选择器解析\" class=\"headerlink\" title=\"选择器解析\"></a>选择器解析</h3><ul>\n<li>CSS选择器时==从右往左解析==的</li>\n<li>尽量少使用不必要的层级关系</li>\n</ul>\n"},{"title":"CSS：隐藏元素","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n1. display:none\n2. visibility: hidden\n3. opacity: 0\n\n### 空间占据\n- display隐藏后不占据空间，会产生回流和重绘\n- 其余两个虽隐藏，但仍占据空间，只会引起重绘\n\n### 子元素继承\n- display不会被继承，父元素都不存在了，子元素自然也不会显示\n- visibility会被子元素继承，可以通过设置子元素visibility为visible使其显示\n- opacity也会被子元素继承，但不能通过设置子元素opacity为1使其显示\n\n### 事件绑定\n- display隐藏后已经不存在了，肯定也无法触发事件\n- 其余两个虽隐藏，但仍存在，可以触发事件\n\n### 过渡动画\ntransition对display和visibility无效，对opacity有效","source":"_posts/css/css：隐藏元素.md","raw":"---\ntitle: CSS：隐藏元素\nDate: 2020-05-14\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n1. display:none\n2. visibility: hidden\n3. opacity: 0\n\n### 空间占据\n- display隐藏后不占据空间，会产生回流和重绘\n- 其余两个虽隐藏，但仍占据空间，只会引起重绘\n\n### 子元素继承\n- display不会被继承，父元素都不存在了，子元素自然也不会显示\n- visibility会被子元素继承，可以通过设置子元素visibility为visible使其显示\n- opacity也会被子元素继承，但不能通过设置子元素opacity为1使其显示\n\n### 事件绑定\n- display隐藏后已经不存在了，肯定也无法触发事件\n- 其余两个虽隐藏，但仍存在，可以触发事件\n\n### 过渡动画\ntransition对display和visibility无效，对opacity有效","slug":"css/css：隐藏元素","published":1,"date":"2020-05-14T08:48:38.618Z","updated":"2020-05-14T08:50:34.053Z","layout":"post","photos":[],"link":"","_id":"cka6kwryh0018rcu9rpfjw3cl","content":"<ol>\n<li>display:none</li>\n<li>visibility: hidden</li>\n<li>opacity: 0</li>\n</ol>\n<h3 id=\"空间占据\"><a href=\"#空间占据\" class=\"headerlink\" title=\"空间占据\"></a>空间占据</h3><ul>\n<li>display隐藏后不占据空间，会产生回流和重绘</li>\n<li>其余两个虽隐藏，但仍占据空间，只会引起重绘</li>\n</ul>\n<h3 id=\"子元素继承\"><a href=\"#子元素继承\" class=\"headerlink\" title=\"子元素继承\"></a>子元素继承</h3><ul>\n<li>display不会被继承，父元素都不存在了，子元素自然也不会显示</li>\n<li>visibility会被子元素继承，可以通过设置子元素visibility为visible使其显示</li>\n<li>opacity也会被子元素继承，但不能通过设置子元素opacity为1使其显示</li>\n</ul>\n<h3 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h3><ul>\n<li>display隐藏后已经不存在了，肯定也无法触发事件</li>\n<li>其余两个虽隐藏，但仍存在，可以触发事件</li>\n</ul>\n<h3 id=\"过渡动画\"><a href=\"#过渡动画\" class=\"headerlink\" title=\"过渡动画\"></a>过渡动画</h3><p>transition对display和visibility无效，对opacity有效</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>display:none</li>\n<li>visibility: hidden</li>\n<li>opacity: 0</li>\n</ol>\n<h3 id=\"空间占据\"><a href=\"#空间占据\" class=\"headerlink\" title=\"空间占据\"></a>空间占据</h3><ul>\n<li>display隐藏后不占据空间，会产生回流和重绘</li>\n<li>其余两个虽隐藏，但仍占据空间，只会引起重绘</li>\n</ul>\n<h3 id=\"子元素继承\"><a href=\"#子元素继承\" class=\"headerlink\" title=\"子元素继承\"></a>子元素继承</h3><ul>\n<li>display不会被继承，父元素都不存在了，子元素自然也不会显示</li>\n<li>visibility会被子元素继承，可以通过设置子元素visibility为visible使其显示</li>\n<li>opacity也会被子元素继承，但不能通过设置子元素opacity为1使其显示</li>\n</ul>\n<h3 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h3><ul>\n<li>display隐藏后已经不存在了，肯定也无法触发事件</li>\n<li>其余两个虽隐藏，但仍存在，可以触发事件</li>\n</ul>\n<h3 id=\"过渡动画\"><a href=\"#过渡动画\" class=\"headerlink\" title=\"过渡动画\"></a>过渡动画</h3><p>transition对display和visibility无效，对opacity有效</p>\n"},{"title":"js：==和===","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n都是用来检测两个操作数是否相等\n\n### 基础类型\n对于如string、number、null、undefined、boolean等基本数据类型\n==：\n- 对于同一类型的比较，会直接进行值的比较。\n- 对于不同类型的比较，会先进行类型转换，再进行值的比较。\n    1. 如果一个是null，一个是undefined，那么相等。\n    2. 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。\n\n===：\n- 对于同一类型的比较，会直接进行值的比较。\n- 对于不同类型的比较，结果一定是不相等。即不仅进行值的比较，还要进行类型的比较。\n\n### 高级类型\n对于array、object等高级类型，\\==和===是没有区别的，都是进行“指针地址”的比较。\n\n### 基础类型和高级类型\n==：\n- 将高级类型转换为基础类型，进行值的比较。\n\n```\nconsole.log([66]==66); //true\nconsole.log([66,1]==66);  //false\n```\n\n===：\n- 类型不同，结果一定为不相等。\n","source":"_posts/js/js：==和===.md","raw":"---\ntitle: js：==和===\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n都是用来检测两个操作数是否相等\n\n### 基础类型\n对于如string、number、null、undefined、boolean等基本数据类型\n==：\n- 对于同一类型的比较，会直接进行值的比较。\n- 对于不同类型的比较，会先进行类型转换，再进行值的比较。\n    1. 如果一个是null，一个是undefined，那么相等。\n    2. 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。\n\n===：\n- 对于同一类型的比较，会直接进行值的比较。\n- 对于不同类型的比较，结果一定是不相等。即不仅进行值的比较，还要进行类型的比较。\n\n### 高级类型\n对于array、object等高级类型，\\==和===是没有区别的，都是进行“指针地址”的比较。\n\n### 基础类型和高级类型\n==：\n- 将高级类型转换为基础类型，进行值的比较。\n\n```\nconsole.log([66]==66); //true\nconsole.log([66,1]==66);  //false\n```\n\n===：\n- 类型不同，结果一定为不相等。\n","slug":"js/js：==和===","published":1,"date":"2020-05-14T08:55:12.263Z","updated":"2020-05-14T09:00:12.304Z","layout":"post","photos":[],"link":"","_id":"cka6kwryn001brcu9ztcjkumw","content":"<p>都是用来检测两个操作数是否相等</p>\n<h3 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h3><p>对于如string、number、null、undefined、boolean等基本数据类型<br>==：</p>\n<ul>\n<li>对于同一类型的比较，会直接进行值的比较。</li>\n<li>对于不同类型的比较，会先进行类型转换，再进行值的比较。<ol>\n<li>如果一个是null，一个是undefined，那么相等。</li>\n<li>如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。</li>\n</ol>\n</li>\n</ul>\n<p>===：</p>\n<ul>\n<li>对于同一类型的比较，会直接进行值的比较。</li>\n<li>对于不同类型的比较，结果一定是不相等。即不仅进行值的比较，还要进行类型的比较。</li>\n</ul>\n<h3 id=\"高级类型\"><a href=\"#高级类型\" class=\"headerlink\" title=\"高级类型\"></a>高级类型</h3><p>对于array、object等高级类型，\\==和===是没有区别的，都是进行“指针地址”的比较。</p>\n<h3 id=\"基础类型和高级类型\"><a href=\"#基础类型和高级类型\" class=\"headerlink\" title=\"基础类型和高级类型\"></a>基础类型和高级类型</h3><p>==：</p>\n<ul>\n<li>将高级类型转换为基础类型，进行值的比较。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([66]==66); //true</span><br><span class=\"line\">console.log([66,1]==66);  //false</span><br></pre></td></tr></table></figure>\n<p>===：</p>\n<ul>\n<li>类型不同，结果一定为不相等。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>都是用来检测两个操作数是否相等</p>\n<h3 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h3><p>对于如string、number、null、undefined、boolean等基本数据类型<br>==：</p>\n<ul>\n<li>对于同一类型的比较，会直接进行值的比较。</li>\n<li>对于不同类型的比较，会先进行类型转换，再进行值的比较。<ol>\n<li>如果一个是null，一个是undefined，那么相等。</li>\n<li>如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。</li>\n</ol>\n</li>\n</ul>\n<p>===：</p>\n<ul>\n<li>对于同一类型的比较，会直接进行值的比较。</li>\n<li>对于不同类型的比较，结果一定是不相等。即不仅进行值的比较，还要进行类型的比较。</li>\n</ul>\n<h3 id=\"高级类型\"><a href=\"#高级类型\" class=\"headerlink\" title=\"高级类型\"></a>高级类型</h3><p>对于array、object等高级类型，\\==和===是没有区别的，都是进行“指针地址”的比较。</p>\n<h3 id=\"基础类型和高级类型\"><a href=\"#基础类型和高级类型\" class=\"headerlink\" title=\"基础类型和高级类型\"></a>基础类型和高级类型</h3><p>==：</p>\n<ul>\n<li>将高级类型转换为基础类型，进行值的比较。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([66]==66); //true</span><br><span class=\"line\">console.log([66,1]==66);  //false</span><br></pre></td></tr></table></figure>\n<p>===：</p>\n<ul>\n<li>类型不同，结果一定为不相等。</li>\n</ul>\n"},{"title":"js：Math的常用方法","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"```\n1. Math.sqrt()：计算平方根\n2. Math.cbrt()：计算立方根\n3. Math.pow(a, b)：计算a的b次方\n4. Math.max(a,b,c...)：计算最大值\n5. Math.min(a,b,c...)：计算最小值\n6. Math.abs()：求绝对值 \n7. Math.ceil()：向上取整\n8. Math.floor()：向下取整\n9. Math.random()：取得一个[0.0,1.0)的随机数 \n10. Math.rint()： 四舍五入，返回double值。注意.5的时候会取偶数\n11. Math.round()： 四舍五入，float时返回int值，double时返回long值\n```","source":"_posts/js/js：Math的常用方法.md","raw":"---\ntitle: js：Math的常用方法\nDate: 2019-03-26\ntags: [JS]\ncategories: JS\ncomments: true\n---\n```\n1. Math.sqrt()：计算平方根\n2. Math.cbrt()：计算立方根\n3. Math.pow(a, b)：计算a的b次方\n4. Math.max(a,b,c...)：计算最大值\n5. Math.min(a,b,c...)：计算最小值\n6. Math.abs()：求绝对值 \n7. Math.ceil()：向上取整\n8. Math.floor()：向下取整\n9. Math.random()：取得一个[0.0,1.0)的随机数 \n10. Math.rint()： 四舍五入，返回double值。注意.5的时候会取偶数\n11. Math.round()： 四舍五入，float时返回int值，double时返回long值\n```","slug":"js/js：Math的常用方法","published":1,"date":"2019-03-26T07:44:34.474Z","updated":"2020-05-14T09:08:41.570Z","layout":"post","photos":[],"link":"","_id":"cka6kwryw001ercu9thdzy3u4","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Math.sqrt()：计算平方根</span><br><span class=\"line\">2. Math.cbrt()：计算立方根</span><br><span class=\"line\">3. Math.pow(a, b)：计算a的b次方</span><br><span class=\"line\">4. Math.max(a,b,c...)：计算最大值</span><br><span class=\"line\">5. Math.min(a,b,c...)：计算最小值</span><br><span class=\"line\">6. Math.abs()：求绝对值 </span><br><span class=\"line\">7. Math.ceil()：向上取整</span><br><span class=\"line\">8. Math.floor()：向下取整</span><br><span class=\"line\">9. Math.random()：取得一个[0.0,1.0)的随机数 </span><br><span class=\"line\">10. Math.rint()： 四舍五入，返回double值。注意.5的时候会取偶数</span><br><span class=\"line\">11. Math.round()： 四舍五入，float时返回int值，double时返回long值</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Math.sqrt()：计算平方根</span><br><span class=\"line\">2. Math.cbrt()：计算立方根</span><br><span class=\"line\">3. Math.pow(a, b)：计算a的b次方</span><br><span class=\"line\">4. Math.max(a,b,c...)：计算最大值</span><br><span class=\"line\">5. Math.min(a,b,c...)：计算最小值</span><br><span class=\"line\">6. Math.abs()：求绝对值 </span><br><span class=\"line\">7. Math.ceil()：向上取整</span><br><span class=\"line\">8. Math.floor()：向下取整</span><br><span class=\"line\">9. Math.random()：取得一个[0.0,1.0)的随机数 </span><br><span class=\"line\">10. Math.rint()： 四舍五入，返回double值。注意.5的时候会取偶数</span><br><span class=\"line\">11. Math.round()： 四舍五入，float时返回int值，double时返回long值</span><br></pre></td></tr></table></figure>"},{"title":"js：ajax","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 核心\nXMLHttpRequest，一个js对象，一个构造函数。\n#### 方法\n- open()：准备启动一个AJAX请求；\n- setRequestHeader()：设置请求头部信息；\n- send()：发送AJAX请求；\n- getResponseHeader(): 获得响应头部信息；\n- getAllResponseHeader()：获得一个包含所有头部信息的长字符串；\n- abort()：取消异步请求；\n- 另外，浏览器还为该对象提供了一个onreadystatechange监听事件，大明湖readyState属性改变时，就会触发该事件发送。\n> 为了确保浏览器的兼容性，最好在调用open方法之前指定事件处理程序。\n#### 属性\n- responseText：包含响应主体返回文本；\n- responseXML：如果响应的内容类型时 text/xml或 application/xml，该属性将保存包含着相应数据的XML DOM文档；\n- status：响应的HTTP状态；\n- statusText：HTTP状态的说明；\n- readyState：表示“请求”/“响应”过程的当前活动阶段\n\n### 拓展\n1. 什么是ajax？ajax作用是什么？ \n```\najax是用来与后台交互的一种技术。用来实现客户端服务器的异步通信效果，实现页面的局部刷新。\n```\n2. 原生js ajax发送http请求需要几个步骤？分别是什么？\n```\n//1：创建XMLHttpRequest对象\nvar xhr = new XMLHttpRequest();\n//2：设置请求参数（请求方式，url，是否异步请求）\nxhr.open(\"GET\",url,false);\n//3：设置请求头部(也可以不设置)\nxhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\n//支持跨域发送cookie\nxhr.withCredentials = true;\n//4：发送请求\nxhr.send(null);\n//5：设置事件处理程序\nxhr.onreadystatechange = function(){\n    if(xhr.readystate == 4){\n        if(xhr.status == 200){\n            console.log(xhr.responseText);\n        }else{\n            console.log(\"出错了\");\n        }\n    }\n}\n```\n3. readyState的取值？\n\n```\n0：(未初始化)还没有调用open()方法。\n1：(启动)已调用open()方法，但send()方法还没调用。\n2：(发送)send()方法已经调用，请求已发送，但未接收到响应。\n3：(交互)服务器端发送响应，客户端正在解析响应内容。\n4：(完成)响应内容解析完成，可以在客户端调用了。\n```\n4. http的请求方法\n\n```\nget：获取服务器中的资源。\npost：传输实体文本\nput：传输文件。要指出资源在服务器中的位置。\nhead：获取页面的首部。\ndelete：删除服务器中的某个资源。\noptions：获取当前url所支持的方法。\ntrace：追踪路径。\nconnect：要求用隧道协议连接代理。\n```\n5. get和post的区别\n\n```\n1. 发送方式：get请求传送的参数放在url上，即http的协议头；post把传送的参数放在http的包体中。\n2. 大小限制：get传的参数有长度限制；post理论上没有限制。\n3. 安全性：get请求传送的数据放在url上，会被缓存，请求保存在浏览器的历史记录中；post不能被缓存。\n```\n\n6. 什么情况造成跨域？如何解决？\n```\n受同源策略限制。协议、子域名、主域名、端口号、ip地址、网址，任一不同都为不同源。\n1. jsonp 只能解决get跨域\n2. CORS：跨域资源共享，通过设置Access-Control-Allow-Origin来允许跨域（主要后台配置）\n3. 设置document.domain\n4. 代理请求解决接口跨域。\njsonp通过script标签进行跨域请求\n①前端设置好回调函数，将回调函数名作为url携带的参数。\n②后端接到请求后，生成一个函数，函数名为前端传来的回调函数名，数据作为参数传入函数，返回js文档。\n③客户端解析并执行返回的js文档，将返回的数据传入回调函数执行。\n```\n7. http状态码（status）\n\n状态码 | 含义\n---|---\n1xx | 请求正在被处理\n2xx | 请求成功被处理\n3xx | 请求需求附加操作，如重定向\n4xx | 客户端出错导致请求无法被处理\n5xx | 服务端处理出错\n\n常用状态码\n- 200  请求成功处理，一切正常\n- 301  永久重定向（新网址替换旧网址，旧网址清零）\n- 302  临时重定向（也是替换，但是旧网址还能参与排名）\n- 304  资源未修改\n- 403  禁止访问\n- 404  页面未找到\n- 405  不允许此请求方法\n- 500  服务器出错\n\n8. 回调函数  \n```\n1.一个函数作为参数传递给另一个函数，在功能下载完成后执行，作为参数的函数即为回调函数。\n2.可用于解决异步。\n3.典型例子即为ajax请求。\n```\n\n9. 回调地狱\n```\n当许多功能需要连续调用,环环相扣依赖时。就会产生函数作为参数层层嵌套的一个效果，这就形成回调地狱。使得代码变得难以理解与维护。\n解决：\n1.保持代码简短，避免使用匿名函数。\n2.模块化。将不同功能的代码封装成不同的模块。\n3.处理每一个错误。为了让代码稳定，永远无法知道这些错误何时发生，所以必须对它们进行计划。\n```\n","source":"_posts/js/js：ajax.md","raw":"---\ntitle: js：ajax\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 核心\nXMLHttpRequest，一个js对象，一个构造函数。\n#### 方法\n- open()：准备启动一个AJAX请求；\n- setRequestHeader()：设置请求头部信息；\n- send()：发送AJAX请求；\n- getResponseHeader(): 获得响应头部信息；\n- getAllResponseHeader()：获得一个包含所有头部信息的长字符串；\n- abort()：取消异步请求；\n- 另外，浏览器还为该对象提供了一个onreadystatechange监听事件，大明湖readyState属性改变时，就会触发该事件发送。\n> 为了确保浏览器的兼容性，最好在调用open方法之前指定事件处理程序。\n#### 属性\n- responseText：包含响应主体返回文本；\n- responseXML：如果响应的内容类型时 text/xml或 application/xml，该属性将保存包含着相应数据的XML DOM文档；\n- status：响应的HTTP状态；\n- statusText：HTTP状态的说明；\n- readyState：表示“请求”/“响应”过程的当前活动阶段\n\n### 拓展\n1. 什么是ajax？ajax作用是什么？ \n```\najax是用来与后台交互的一种技术。用来实现客户端服务器的异步通信效果，实现页面的局部刷新。\n```\n2. 原生js ajax发送http请求需要几个步骤？分别是什么？\n```\n//1：创建XMLHttpRequest对象\nvar xhr = new XMLHttpRequest();\n//2：设置请求参数（请求方式，url，是否异步请求）\nxhr.open(\"GET\",url,false);\n//3：设置请求头部(也可以不设置)\nxhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\n//支持跨域发送cookie\nxhr.withCredentials = true;\n//4：发送请求\nxhr.send(null);\n//5：设置事件处理程序\nxhr.onreadystatechange = function(){\n    if(xhr.readystate == 4){\n        if(xhr.status == 200){\n            console.log(xhr.responseText);\n        }else{\n            console.log(\"出错了\");\n        }\n    }\n}\n```\n3. readyState的取值？\n\n```\n0：(未初始化)还没有调用open()方法。\n1：(启动)已调用open()方法，但send()方法还没调用。\n2：(发送)send()方法已经调用，请求已发送，但未接收到响应。\n3：(交互)服务器端发送响应，客户端正在解析响应内容。\n4：(完成)响应内容解析完成，可以在客户端调用了。\n```\n4. http的请求方法\n\n```\nget：获取服务器中的资源。\npost：传输实体文本\nput：传输文件。要指出资源在服务器中的位置。\nhead：获取页面的首部。\ndelete：删除服务器中的某个资源。\noptions：获取当前url所支持的方法。\ntrace：追踪路径。\nconnect：要求用隧道协议连接代理。\n```\n5. get和post的区别\n\n```\n1. 发送方式：get请求传送的参数放在url上，即http的协议头；post把传送的参数放在http的包体中。\n2. 大小限制：get传的参数有长度限制；post理论上没有限制。\n3. 安全性：get请求传送的数据放在url上，会被缓存，请求保存在浏览器的历史记录中；post不能被缓存。\n```\n\n6. 什么情况造成跨域？如何解决？\n```\n受同源策略限制。协议、子域名、主域名、端口号、ip地址、网址，任一不同都为不同源。\n1. jsonp 只能解决get跨域\n2. CORS：跨域资源共享，通过设置Access-Control-Allow-Origin来允许跨域（主要后台配置）\n3. 设置document.domain\n4. 代理请求解决接口跨域。\njsonp通过script标签进行跨域请求\n①前端设置好回调函数，将回调函数名作为url携带的参数。\n②后端接到请求后，生成一个函数，函数名为前端传来的回调函数名，数据作为参数传入函数，返回js文档。\n③客户端解析并执行返回的js文档，将返回的数据传入回调函数执行。\n```\n7. http状态码（status）\n\n状态码 | 含义\n---|---\n1xx | 请求正在被处理\n2xx | 请求成功被处理\n3xx | 请求需求附加操作，如重定向\n4xx | 客户端出错导致请求无法被处理\n5xx | 服务端处理出错\n\n常用状态码\n- 200  请求成功处理，一切正常\n- 301  永久重定向（新网址替换旧网址，旧网址清零）\n- 302  临时重定向（也是替换，但是旧网址还能参与排名）\n- 304  资源未修改\n- 403  禁止访问\n- 404  页面未找到\n- 405  不允许此请求方法\n- 500  服务器出错\n\n8. 回调函数  \n```\n1.一个函数作为参数传递给另一个函数，在功能下载完成后执行，作为参数的函数即为回调函数。\n2.可用于解决异步。\n3.典型例子即为ajax请求。\n```\n\n9. 回调地狱\n```\n当许多功能需要连续调用,环环相扣依赖时。就会产生函数作为参数层层嵌套的一个效果，这就形成回调地狱。使得代码变得难以理解与维护。\n解决：\n1.保持代码简短，避免使用匿名函数。\n2.模块化。将不同功能的代码封装成不同的模块。\n3.处理每一个错误。为了让代码稳定，永远无法知道这些错误何时发生，所以必须对它们进行计划。\n```\n","slug":"js/js：ajax","published":1,"date":"2020-05-14T08:56:49.634Z","updated":"2020-05-14T09:01:59.213Z","layout":"post","photos":[],"link":"","_id":"cka6kwrz8001hrcu9t1e3ulqt","content":"<h3 id=\"核心\"><a href=\"#核心\" class=\"headerlink\" title=\"核心\"></a>核心</h3><p>XMLHttpRequest，一个js对象，一个构造函数。</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>open()：准备启动一个AJAX请求；</li>\n<li>setRequestHeader()：设置请求头部信息；</li>\n<li>send()：发送AJAX请求；</li>\n<li>getResponseHeader(): 获得响应头部信息；</li>\n<li>getAllResponseHeader()：获得一个包含所有头部信息的长字符串；</li>\n<li>abort()：取消异步请求；</li>\n<li>另外，浏览器还为该对象提供了一个onreadystatechange监听事件，大明湖readyState属性改变时，就会触发该事件发送。<blockquote>\n<p>为了确保浏览器的兼容性，最好在调用open方法之前指定事件处理程序。</p>\n</blockquote>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4></li>\n<li>responseText：包含响应主体返回文本；</li>\n<li>responseXML：如果响应的内容类型时 text/xml或 application/xml，该属性将保存包含着相应数据的XML DOM文档；</li>\n<li>status：响应的HTTP状态；</li>\n<li>statusText：HTTP状态的说明；</li>\n<li>readyState：表示“请求”/“响应”过程的当前活动阶段</li>\n</ul>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><ol>\n<li><p>什么是ajax？ajax作用是什么？ </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax是用来与后台交互的一种技术。用来实现客户端服务器的异步通信效果，实现页面的局部刷新。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>原生js ajax发送http请求需要几个步骤？分别是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1：创建XMLHttpRequest对象</span><br><span class=\"line\">var xhr = new XMLHttpRequest();</span><br><span class=\"line\">//2：设置请求参数（请求方式，url，是否异步请求）</span><br><span class=\"line\">xhr.open(&quot;GET&quot;,url,false);</span><br><span class=\"line\">//3：设置请求头部(也可以不设置)</span><br><span class=\"line\">xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">//支持跨域发送cookie</span><br><span class=\"line\">xhr.withCredentials = true;</span><br><span class=\"line\">//4：发送请求</span><br><span class=\"line\">xhr.send(null);</span><br><span class=\"line\">//5：设置事件处理程序</span><br><span class=\"line\">xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">    if(xhr.readystate == 4)&#123;</span><br><span class=\"line\">        if(xhr.status == 200)&#123;</span><br><span class=\"line\">            console.log(xhr.responseText);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            console.log(&quot;出错了&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>readyState的取值？</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0：(未初始化)还没有调用open()方法。</span><br><span class=\"line\">1：(启动)已调用open()方法，但send()方法还没调用。</span><br><span class=\"line\">2：(发送)send()方法已经调用，请求已发送，但未接收到响应。</span><br><span class=\"line\">3：(交互)服务器端发送响应，客户端正在解析响应内容。</span><br><span class=\"line\">4：(完成)响应内容解析完成，可以在客户端调用了。</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>http的请求方法</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get：获取服务器中的资源。</span><br><span class=\"line\">post：传输实体文本</span><br><span class=\"line\">put：传输文件。要指出资源在服务器中的位置。</span><br><span class=\"line\">head：获取页面的首部。</span><br><span class=\"line\">delete：删除服务器中的某个资源。</span><br><span class=\"line\">options：获取当前url所支持的方法。</span><br><span class=\"line\">trace：追踪路径。</span><br><span class=\"line\">connect：要求用隧道协议连接代理。</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>get和post的区别</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 发送方式：get请求传送的参数放在url上，即http的协议头；post把传送的参数放在http的包体中。</span><br><span class=\"line\">2. 大小限制：get传的参数有长度限制；post理论上没有限制。</span><br><span class=\"line\">3. 安全性：get请求传送的数据放在url上，会被缓存，请求保存在浏览器的历史记录中；post不能被缓存。</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li><p>什么情况造成跨域？如何解决？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">受同源策略限制。协议、子域名、主域名、端口号、ip地址、网址，任一不同都为不同源。</span><br><span class=\"line\">1. jsonp 只能解决get跨域</span><br><span class=\"line\">2. CORS：跨域资源共享，通过设置Access-Control-Allow-Origin来允许跨域（主要后台配置）</span><br><span class=\"line\">3. 设置document.domain</span><br><span class=\"line\">4. 代理请求解决接口跨域。</span><br><span class=\"line\">jsonp通过script标签进行跨域请求</span><br><span class=\"line\">①前端设置好回调函数，将回调函数名作为url携带的参数。</span><br><span class=\"line\">②后端接到请求后，生成一个函数，函数名为前端传来的回调函数名，数据作为参数传入函数，返回js文档。</span><br><span class=\"line\">③客户端解析并执行返回的js文档，将返回的数据传入回调函数执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http状态码（status）</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1xx</td>\n<td>请求正在被处理</td>\n</tr>\n<tr>\n<td>2xx</td>\n<td>请求成功被处理</td>\n</tr>\n<tr>\n<td>3xx</td>\n<td>请求需求附加操作，如重定向</td>\n</tr>\n<tr>\n<td>4xx</td>\n<td>客户端出错导致请求无法被处理</td>\n</tr>\n<tr>\n<td>5xx</td>\n<td>服务端处理出错</td>\n</tr>\n</tbody>\n</table>\n<p>常用状态码</p>\n<ul>\n<li>200  请求成功处理，一切正常</li>\n<li>301  永久重定向（新网址替换旧网址，旧网址清零）</li>\n<li>302  临时重定向（也是替换，但是旧网址还能参与排名）</li>\n<li>304  资源未修改</li>\n<li>403  禁止访问</li>\n<li>404  页面未找到</li>\n<li>405  不允许此请求方法</li>\n<li>500  服务器出错</li>\n</ul>\n<ol start=\"8\">\n<li><p>回调函数  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.一个函数作为参数传递给另一个函数，在功能下载完成后执行，作为参数的函数即为回调函数。</span><br><span class=\"line\">2.可用于解决异步。</span><br><span class=\"line\">3.典型例子即为ajax请求。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>回调地狱</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当许多功能需要连续调用,环环相扣依赖时。就会产生函数作为参数层层嵌套的一个效果，这就形成回调地狱。使得代码变得难以理解与维护。</span><br><span class=\"line\">解决：</span><br><span class=\"line\">1.保持代码简短，避免使用匿名函数。</span><br><span class=\"line\">2.模块化。将不同功能的代码封装成不同的模块。</span><br><span class=\"line\">3.处理每一个错误。为了让代码稳定，永远无法知道这些错误何时发生，所以必须对它们进行计划。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"核心\"><a href=\"#核心\" class=\"headerlink\" title=\"核心\"></a>核心</h3><p>XMLHttpRequest，一个js对象，一个构造函数。</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>open()：准备启动一个AJAX请求；</li>\n<li>setRequestHeader()：设置请求头部信息；</li>\n<li>send()：发送AJAX请求；</li>\n<li>getResponseHeader(): 获得响应头部信息；</li>\n<li>getAllResponseHeader()：获得一个包含所有头部信息的长字符串；</li>\n<li>abort()：取消异步请求；</li>\n<li>另外，浏览器还为该对象提供了一个onreadystatechange监听事件，大明湖readyState属性改变时，就会触发该事件发送。<blockquote>\n<p>为了确保浏览器的兼容性，最好在调用open方法之前指定事件处理程序。</p>\n</blockquote>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4></li>\n<li>responseText：包含响应主体返回文本；</li>\n<li>responseXML：如果响应的内容类型时 text/xml或 application/xml，该属性将保存包含着相应数据的XML DOM文档；</li>\n<li>status：响应的HTTP状态；</li>\n<li>statusText：HTTP状态的说明；</li>\n<li>readyState：表示“请求”/“响应”过程的当前活动阶段</li>\n</ul>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><ol>\n<li><p>什么是ajax？ajax作用是什么？ </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax是用来与后台交互的一种技术。用来实现客户端服务器的异步通信效果，实现页面的局部刷新。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>原生js ajax发送http请求需要几个步骤？分别是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1：创建XMLHttpRequest对象</span><br><span class=\"line\">var xhr = new XMLHttpRequest();</span><br><span class=\"line\">//2：设置请求参数（请求方式，url，是否异步请求）</span><br><span class=\"line\">xhr.open(&quot;GET&quot;,url,false);</span><br><span class=\"line\">//3：设置请求头部(也可以不设置)</span><br><span class=\"line\">xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">//支持跨域发送cookie</span><br><span class=\"line\">xhr.withCredentials = true;</span><br><span class=\"line\">//4：发送请求</span><br><span class=\"line\">xhr.send(null);</span><br><span class=\"line\">//5：设置事件处理程序</span><br><span class=\"line\">xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">    if(xhr.readystate == 4)&#123;</span><br><span class=\"line\">        if(xhr.status == 200)&#123;</span><br><span class=\"line\">            console.log(xhr.responseText);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            console.log(&quot;出错了&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>readyState的取值？</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0：(未初始化)还没有调用open()方法。</span><br><span class=\"line\">1：(启动)已调用open()方法，但send()方法还没调用。</span><br><span class=\"line\">2：(发送)send()方法已经调用，请求已发送，但未接收到响应。</span><br><span class=\"line\">3：(交互)服务器端发送响应，客户端正在解析响应内容。</span><br><span class=\"line\">4：(完成)响应内容解析完成，可以在客户端调用了。</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>http的请求方法</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get：获取服务器中的资源。</span><br><span class=\"line\">post：传输实体文本</span><br><span class=\"line\">put：传输文件。要指出资源在服务器中的位置。</span><br><span class=\"line\">head：获取页面的首部。</span><br><span class=\"line\">delete：删除服务器中的某个资源。</span><br><span class=\"line\">options：获取当前url所支持的方法。</span><br><span class=\"line\">trace：追踪路径。</span><br><span class=\"line\">connect：要求用隧道协议连接代理。</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>get和post的区别</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 发送方式：get请求传送的参数放在url上，即http的协议头；post把传送的参数放在http的包体中。</span><br><span class=\"line\">2. 大小限制：get传的参数有长度限制；post理论上没有限制。</span><br><span class=\"line\">3. 安全性：get请求传送的数据放在url上，会被缓存，请求保存在浏览器的历史记录中；post不能被缓存。</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li><p>什么情况造成跨域？如何解决？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">受同源策略限制。协议、子域名、主域名、端口号、ip地址、网址，任一不同都为不同源。</span><br><span class=\"line\">1. jsonp 只能解决get跨域</span><br><span class=\"line\">2. CORS：跨域资源共享，通过设置Access-Control-Allow-Origin来允许跨域（主要后台配置）</span><br><span class=\"line\">3. 设置document.domain</span><br><span class=\"line\">4. 代理请求解决接口跨域。</span><br><span class=\"line\">jsonp通过script标签进行跨域请求</span><br><span class=\"line\">①前端设置好回调函数，将回调函数名作为url携带的参数。</span><br><span class=\"line\">②后端接到请求后，生成一个函数，函数名为前端传来的回调函数名，数据作为参数传入函数，返回js文档。</span><br><span class=\"line\">③客户端解析并执行返回的js文档，将返回的数据传入回调函数执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http状态码（status）</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1xx</td>\n<td>请求正在被处理</td>\n</tr>\n<tr>\n<td>2xx</td>\n<td>请求成功被处理</td>\n</tr>\n<tr>\n<td>3xx</td>\n<td>请求需求附加操作，如重定向</td>\n</tr>\n<tr>\n<td>4xx</td>\n<td>客户端出错导致请求无法被处理</td>\n</tr>\n<tr>\n<td>5xx</td>\n<td>服务端处理出错</td>\n</tr>\n</tbody>\n</table>\n<p>常用状态码</p>\n<ul>\n<li>200  请求成功处理，一切正常</li>\n<li>301  永久重定向（新网址替换旧网址，旧网址清零）</li>\n<li>302  临时重定向（也是替换，但是旧网址还能参与排名）</li>\n<li>304  资源未修改</li>\n<li>403  禁止访问</li>\n<li>404  页面未找到</li>\n<li>405  不允许此请求方法</li>\n<li>500  服务器出错</li>\n</ul>\n<ol start=\"8\">\n<li><p>回调函数  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.一个函数作为参数传递给另一个函数，在功能下载完成后执行，作为参数的函数即为回调函数。</span><br><span class=\"line\">2.可用于解决异步。</span><br><span class=\"line\">3.典型例子即为ajax请求。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>回调地狱</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当许多功能需要连续调用,环环相扣依赖时。就会产生函数作为参数层层嵌套的一个效果，这就形成回调地狱。使得代码变得难以理解与维护。</span><br><span class=\"line\">解决：</span><br><span class=\"line\">1.保持代码简短，避免使用匿名函数。</span><br><span class=\"line\">2.模块化。将不同功能的代码封装成不同的模块。</span><br><span class=\"line\">3.处理每一个错误。为了让代码稳定，永远无法知道这些错误何时发生，所以必须对它们进行计划。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"js：__proto__和prototype","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### \\_\\_proto\\_\\_\n每一个对象都有的属性（在JS里，万物皆对象），指向构造该对象的构造函数的原型。\n\n### prototype\n- 每一个方法都有的属性，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。\n- 原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。\n\n> 方法也是对象，所以方法既有prototype属性又有__proto__属性\n\n实例对象的__proto__和其自身构造函数的prototype都是指向构造函数的原型。\n\n```\nvar A = function(){} //A是一个方法，也是一个对象\nvar a = new A() //a是由A创造出来的一个对象，不是方法\n\n//对象\nconsole.log(a.__proto__); //Object\nconsole.log(a.prototype); //undefined,因为a不是方法，没有该属性\n\n//方法，也是对象\nconsole.log(A.__proto__); //function () { [native code] }\nconsole.log(A.prototype); //Object\n\nconsole.log(a.__proto__==A.prototype); //true\nconsole.log(a.prototype==undefined); //true\nconsole.log(A.__proto__==Function.prototype); //true\nconsole.log(A.prototype==a.__proto__); //true\n```\n","source":"_posts/js/js：__proto__和prototype.md","raw":"---\ntitle: js：__proto__和prototype\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### \\_\\_proto\\_\\_\n每一个对象都有的属性（在JS里，万物皆对象），指向构造该对象的构造函数的原型。\n\n### prototype\n- 每一个方法都有的属性，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。\n- 原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。\n\n> 方法也是对象，所以方法既有prototype属性又有__proto__属性\n\n实例对象的__proto__和其自身构造函数的prototype都是指向构造函数的原型。\n\n```\nvar A = function(){} //A是一个方法，也是一个对象\nvar a = new A() //a是由A创造出来的一个对象，不是方法\n\n//对象\nconsole.log(a.__proto__); //Object\nconsole.log(a.prototype); //undefined,因为a不是方法，没有该属性\n\n//方法，也是对象\nconsole.log(A.__proto__); //function () { [native code] }\nconsole.log(A.prototype); //Object\n\nconsole.log(a.__proto__==A.prototype); //true\nconsole.log(a.prototype==undefined); //true\nconsole.log(A.__proto__==Function.prototype); //true\nconsole.log(A.prototype==a.__proto__); //true\n```\n","slug":"js/js：__proto__和prototype","published":1,"date":"2020-05-14T08:57:32.200Z","updated":"2020-05-14T09:06:22.118Z","layout":"post","photos":[],"link":"","_id":"cka6kwrze001krcu98w3wbfma","content":"<h3 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"__proto__\"></a>__proto__</h3><p>每一个对象都有的属性（在JS里，万物皆对象），指向构造该对象的构造函数的原型。</p>\n<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h3><ul>\n<li>每一个方法都有的属性，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。</li>\n<li>原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</li>\n</ul>\n<blockquote>\n<p>方法也是对象，所以方法既有prototype属性又有<strong>proto</strong>属性</p>\n</blockquote>\n<p>实例对象的<strong>proto</strong>和其自身构造函数的prototype都是指向构造函数的原型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var A = function()&#123;&#125; //A是一个方法，也是一个对象</span><br><span class=\"line\">var a = new A() //a是由A创造出来的一个对象，不是方法</span><br><span class=\"line\"></span><br><span class=\"line\">//对象</span><br><span class=\"line\">console.log(a.__proto__); //Object</span><br><span class=\"line\">console.log(a.prototype); //undefined,因为a不是方法，没有该属性</span><br><span class=\"line\"></span><br><span class=\"line\">//方法，也是对象</span><br><span class=\"line\">console.log(A.__proto__); //function () &#123; [native code] &#125;</span><br><span class=\"line\">console.log(A.prototype); //Object</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.__proto__==A.prototype); //true</span><br><span class=\"line\">console.log(a.prototype==undefined); //true</span><br><span class=\"line\">console.log(A.__proto__==Function.prototype); //true</span><br><span class=\"line\">console.log(A.prototype==a.__proto__); //true</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"__proto__\"></a>__proto__</h3><p>每一个对象都有的属性（在JS里，万物皆对象），指向构造该对象的构造函数的原型。</p>\n<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h3><ul>\n<li>每一个方法都有的属性，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。</li>\n<li>原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</li>\n</ul>\n<blockquote>\n<p>方法也是对象，所以方法既有prototype属性又有<strong>proto</strong>属性</p>\n</blockquote>\n<p>实例对象的<strong>proto</strong>和其自身构造函数的prototype都是指向构造函数的原型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var A = function()&#123;&#125; //A是一个方法，也是一个对象</span><br><span class=\"line\">var a = new A() //a是由A创造出来的一个对象，不是方法</span><br><span class=\"line\"></span><br><span class=\"line\">//对象</span><br><span class=\"line\">console.log(a.__proto__); //Object</span><br><span class=\"line\">console.log(a.prototype); //undefined,因为a不是方法，没有该属性</span><br><span class=\"line\"></span><br><span class=\"line\">//方法，也是对象</span><br><span class=\"line\">console.log(A.__proto__); //function () &#123; [native code] &#125;</span><br><span class=\"line\">console.log(A.prototype); //Object</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.__proto__==A.prototype); //true</span><br><span class=\"line\">console.log(a.prototype==undefined); //true</span><br><span class=\"line\">console.log(A.__proto__==Function.prototype); //true</span><br><span class=\"line\">console.log(A.prototype==a.__proto__); //true</span><br></pre></td></tr></table></figure>\n"},{"title":"js：new一个函数发生了什么","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n1. 创建一个新对象；\n2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。\n3. 执行构造函数中的代码（为这个新对象添加属性）；\n4. 返回新对象。\n\n\n```\nvar obj = new O();\nvar obj = (function(){\n    var obj = {};\n    //使新对象的__proto__属性指向构造函数的prototype\n    obj.__proto__= O.prototype;\n    //其他赋值语句\n    return obj;\n})();\n```\n","source":"_posts/js/js：new一个函数发生了什么.md","raw":"---\ntitle: js：new一个函数发生了什么\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n1. 创建一个新对象；\n2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。\n3. 执行构造函数中的代码（为这个新对象添加属性）；\n4. 返回新对象。\n\n\n```\nvar obj = new O();\nvar obj = (function(){\n    var obj = {};\n    //使新对象的__proto__属性指向构造函数的prototype\n    obj.__proto__= O.prototype;\n    //其他赋值语句\n    return obj;\n})();\n```\n","slug":"js/js：new一个函数发生了什么","published":1,"date":"2020-05-14T08:55:37.008Z","updated":"2020-05-14T09:00:36.372Z","layout":"post","photos":[],"link":"","_id":"cka6kwrzl001nrcu95omam0eh","content":"<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）；</li>\n<li>返回新对象。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = new O();</span><br><span class=\"line\">var obj = (function()&#123;</span><br><span class=\"line\">    var obj = &#123;&#125;;</span><br><span class=\"line\">    //使新对象的__proto__属性指向构造函数的prototype</span><br><span class=\"line\">    obj.__proto__= O.prototype;</span><br><span class=\"line\">    //其他赋值语句</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）；</li>\n<li>返回新对象。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = new O();</span><br><span class=\"line\">var obj = (function()&#123;</span><br><span class=\"line\">    var obj = &#123;&#125;;</span><br><span class=\"line\">    //使新对象的__proto__属性指向构造函数的prototype</span><br><span class=\"line\">    obj.__proto__= O.prototype;</span><br><span class=\"line\">    //其他赋值语句</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n"},{"title":"js：setTimeout和setInterval","Date":"2019-04-22T16:00:00.000Z","comments":1,"_content":"\n都是延迟一段时间调用回调函数。\n### setTimeout\n- setTimeout只调用一次。\n- setTimeout最短间隔时间为4毫秒。\n### setInterval\n- setInterval会一直循环调用函数，不会自己停止。要用clearInterval(计数器编号)来停止。\n- setInterval最短间隔时间为10毫秒，小于会被调整为10ms。\n\n拓展\n\n使用setInterval有可能定时器代码可能在代码再次被添加到队列之前还没有完成执行，这样有可能导致代码连续运行。   \njs引擎解决：队列无定时器代码才添加。这样有可能导致某些间隔被跳过。","source":"_posts/js/js：setTimeout和setInterval.md","raw":"---\ntitle: js：setTimeout和setInterval\nDate: 2019-04-23\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n都是延迟一段时间调用回调函数。\n### setTimeout\n- setTimeout只调用一次。\n- setTimeout最短间隔时间为4毫秒。\n### setInterval\n- setInterval会一直循环调用函数，不会自己停止。要用clearInterval(计数器编号)来停止。\n- setInterval最短间隔时间为10毫秒，小于会被调整为10ms。\n\n拓展\n\n使用setInterval有可能定时器代码可能在代码再次被添加到队列之前还没有完成执行，这样有可能导致代码连续运行。   \njs引擎解决：队列无定时器代码才添加。这样有可能导致某些间隔被跳过。","slug":"js/js：setTimeout和setInterval","published":1,"date":"2019-04-23T14:22:44.072Z","updated":"2020-05-14T09:08:52.551Z","layout":"post","photos":[],"link":"","_id":"cka6kwrzr001qrcu9ms5pfjrn","content":"<p>都是延迟一段时间调用回调函数。</p>\n<h3 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h3><ul>\n<li>setTimeout只调用一次。</li>\n<li>setTimeout最短间隔时间为4毫秒。<h3 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h3></li>\n<li>setInterval会一直循环调用函数，不会自己停止。要用clearInterval(计数器编号)来停止。</li>\n<li>setInterval最短间隔时间为10毫秒，小于会被调整为10ms。</li>\n</ul>\n<p>拓展</p>\n<p>使用setInterval有可能定时器代码可能在代码再次被添加到队列之前还没有完成执行，这样有可能导致代码连续运行。<br>js引擎解决：队列无定时器代码才添加。这样有可能导致某些间隔被跳过。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>都是延迟一段时间调用回调函数。</p>\n<h3 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h3><ul>\n<li>setTimeout只调用一次。</li>\n<li>setTimeout最短间隔时间为4毫秒。<h3 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h3></li>\n<li>setInterval会一直循环调用函数，不会自己停止。要用clearInterval(计数器编号)来停止。</li>\n<li>setInterval最短间隔时间为10毫秒，小于会被调整为10ms。</li>\n</ul>\n<p>拓展</p>\n<p>使用setInterval有可能定时器代码可能在代码再次被添加到队列之前还没有完成执行，这样有可能导致代码连续运行。<br>js引擎解决：队列无定时器代码才添加。这样有可能导致某些间隔被跳过。</p>\n"},{"title":"js：this指向","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n## 普通函数\n- 普通函数被调用时，即运行时，才会确定该函数内this的指向。\n- this指向调用该函数的对象。\n\n### fn()\n- 不带任何引用形式调用函数，this指向全局对象。\n- 严格模式下this为undefined。\n```\nvar a = 1;\nfunction fn () {\n    console.log(this.a);\n}\nfn(); // 1\n```\n### obj.fn()\nthis指向调用该函数的对象\n```\nvar a = 1;\nvar obj = {\n    a: 2,\n    fn: function () {\n        console.log(this.a);\n    }\n}\nobj.fn(); // 2\n```\n### obj1.obj.fn()\n这种形式的调用结果一样，函数内的this只指向直接调用该函数的对象（obj）\n```\nvar a = 1;\nvar obj = {\n    a: 2,\n    fn: function () {\n        console.log(this.a);\n    }\n}\nvar obj1 = {\n    a: 3,\n    obj\n}\nobj1.obj.fn(); // 2\n```\n### 另一种形式的fn()\n普通函数的this指向只在调用时确定，在调用前无论经过什么操作都不会改变this的指向。\n```\nvar a = 1;\nvar obj = {\n    a: 2,\n    fn: function () {\n        console.log(this.a);\n    }\n}\nvar test = obj.fn\ntest(); // 1\n```\n### 拓展的fn()\n- 当setTimeout中的回调函数为普通函数时，回调函数中的this依然是指向全局对象。\n- 当setTimeout中的回调函数为箭头函数时，this指向定义时函数所在作用域的父级作用域的this。（父级为普通函数this指向调用父级的对象，若父级仍为箭头函数，则需要继续往上找）\n\n```\nvar a = 1;\nvar obj = {\n    a: 2,\n    fn: function () {\n        console.log(this.a);\n    }\n}\nsetTimeout(obj.fn); // 1\n```\nsetTimeout内部\n\n```\nfunction setTimeout (fn,time) {\n    // code...\n    fn(); //没有指明调用的对象，指向全局\n}\n```\n### fn.call()、fn.apply()、fn.bind()\n可以改变this的指向\n\n### new fn()\n- new这个操作符其实是new一个新对象出来，而fn被称为构造函数，可以在这个构造函数中定义一些将要到来的新对象的一些属性。\n- 在构造函数中就是用this来描述这个即将到来的新对象，所以构造函数中的this就是指向被new出来的新对象。\n```\nvar a = 1;\nfunction fn (a) {\n    this.a = a;\n}\nvar b = new fn(2);\nconsole.log(b.a); // 2\n```\n\n\n## 箭头函数\nthis在定义时就已经确定，指向定义时箭头函数所在的作用域（而不是箭头函数的作用域）的父级作用域的this。\n- 若父级作用域为普通函数，则this指向调用父级函数的对象。\n- 若父级作用域为箭头函数，则this指向父级作用域的父级作用域。\n- 如此往上找，直到全局\n\n首先从它的父级作用域中找，如果父级作用域还是箭头函数，再往上找，如此直至找到this的指向，最后是到window。","source":"_posts/js/js：this指向.md","raw":"---\ntitle: js：this指向\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n## 普通函数\n- 普通函数被调用时，即运行时，才会确定该函数内this的指向。\n- this指向调用该函数的对象。\n\n### fn()\n- 不带任何引用形式调用函数，this指向全局对象。\n- 严格模式下this为undefined。\n```\nvar a = 1;\nfunction fn () {\n    console.log(this.a);\n}\nfn(); // 1\n```\n### obj.fn()\nthis指向调用该函数的对象\n```\nvar a = 1;\nvar obj = {\n    a: 2,\n    fn: function () {\n        console.log(this.a);\n    }\n}\nobj.fn(); // 2\n```\n### obj1.obj.fn()\n这种形式的调用结果一样，函数内的this只指向直接调用该函数的对象（obj）\n```\nvar a = 1;\nvar obj = {\n    a: 2,\n    fn: function () {\n        console.log(this.a);\n    }\n}\nvar obj1 = {\n    a: 3,\n    obj\n}\nobj1.obj.fn(); // 2\n```\n### 另一种形式的fn()\n普通函数的this指向只在调用时确定，在调用前无论经过什么操作都不会改变this的指向。\n```\nvar a = 1;\nvar obj = {\n    a: 2,\n    fn: function () {\n        console.log(this.a);\n    }\n}\nvar test = obj.fn\ntest(); // 1\n```\n### 拓展的fn()\n- 当setTimeout中的回调函数为普通函数时，回调函数中的this依然是指向全局对象。\n- 当setTimeout中的回调函数为箭头函数时，this指向定义时函数所在作用域的父级作用域的this。（父级为普通函数this指向调用父级的对象，若父级仍为箭头函数，则需要继续往上找）\n\n```\nvar a = 1;\nvar obj = {\n    a: 2,\n    fn: function () {\n        console.log(this.a);\n    }\n}\nsetTimeout(obj.fn); // 1\n```\nsetTimeout内部\n\n```\nfunction setTimeout (fn,time) {\n    // code...\n    fn(); //没有指明调用的对象，指向全局\n}\n```\n### fn.call()、fn.apply()、fn.bind()\n可以改变this的指向\n\n### new fn()\n- new这个操作符其实是new一个新对象出来，而fn被称为构造函数，可以在这个构造函数中定义一些将要到来的新对象的一些属性。\n- 在构造函数中就是用this来描述这个即将到来的新对象，所以构造函数中的this就是指向被new出来的新对象。\n```\nvar a = 1;\nfunction fn (a) {\n    this.a = a;\n}\nvar b = new fn(2);\nconsole.log(b.a); // 2\n```\n\n\n## 箭头函数\nthis在定义时就已经确定，指向定义时箭头函数所在的作用域（而不是箭头函数的作用域）的父级作用域的this。\n- 若父级作用域为普通函数，则this指向调用父级函数的对象。\n- 若父级作用域为箭头函数，则this指向父级作用域的父级作用域。\n- 如此往上找，直到全局\n\n首先从它的父级作用域中找，如果父级作用域还是箭头函数，再往上找，如此直至找到this的指向，最后是到window。","slug":"js/js：this指向","published":1,"date":"2020-05-14T08:57:06.666Z","updated":"2020-05-14T09:06:47.760Z","layout":"post","photos":[],"link":"","_id":"cka6kwrzx001trcu9fe8evzax","content":"<h2 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h2><ul>\n<li>普通函数被调用时，即运行时，才会确定该函数内this的指向。</li>\n<li>this指向调用该函数的对象。</li>\n</ul>\n<h3 id=\"fn\"><a href=\"#fn\" class=\"headerlink\" title=\"fn()\"></a>fn()</h3><ul>\n<li>不带任何引用形式调用函数，this指向全局对象。</li>\n<li>严格模式下this为undefined。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">function fn () &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(); // 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"obj-fn\"><a href=\"#obj-fn\" class=\"headerlink\" title=\"obj.fn()\"></a>obj.fn()</h3><p>this指向调用该函数的对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    fn: function () &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.fn(); // 2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"obj1-obj-fn\"><a href=\"#obj1-obj-fn\" class=\"headerlink\" title=\"obj1.obj.fn()\"></a>obj1.obj.fn()</h3><p>这种形式的调用结果一样，函数内的this只指向直接调用该函数的对象（obj）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    fn: function () &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">    a: 3,</span><br><span class=\"line\">    obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.obj.fn(); // 2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"另一种形式的fn\"><a href=\"#另一种形式的fn\" class=\"headerlink\" title=\"另一种形式的fn()\"></a>另一种形式的fn()</h3><p>普通函数的this指向只在调用时确定，在调用前无论经过什么操作都不会改变this的指向。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    fn: function () &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var test = obj.fn</span><br><span class=\"line\">test(); // 1</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"拓展的fn\"><a href=\"#拓展的fn\" class=\"headerlink\" title=\"拓展的fn()\"></a>拓展的fn()</h3><ul>\n<li>当setTimeout中的回调函数为普通函数时，回调函数中的this依然是指向全局对象。</li>\n<li>当setTimeout中的回调函数为箭头函数时，this指向定义时函数所在作用域的父级作用域的this。（父级为普通函数this指向调用父级的对象，若父级仍为箭头函数，则需要继续往上找）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    fn: function () &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout(obj.fn); // 1</span><br></pre></td></tr></table></figure>\n<p>setTimeout内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setTimeout (fn,time) &#123;</span><br><span class=\"line\">    // code...</span><br><span class=\"line\">    fn(); //没有指明调用的对象，指向全局</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"fn-call-、fn-apply-、fn-bind\"><a href=\"#fn-call-、fn-apply-、fn-bind\" class=\"headerlink\" title=\"fn.call()、fn.apply()、fn.bind()\"></a>fn.call()、fn.apply()、fn.bind()</h3><p>可以改变this的指向</p>\n<h3 id=\"new-fn\"><a href=\"#new-fn\" class=\"headerlink\" title=\"new fn()\"></a>new fn()</h3><ul>\n<li>new这个操作符其实是new一个新对象出来，而fn被称为构造函数，可以在这个构造函数中定义一些将要到来的新对象的一些属性。</li>\n<li>在构造函数中就是用this来描述这个即将到来的新对象，所以构造函数中的this就是指向被new出来的新对象。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">function fn (a) &#123;</span><br><span class=\"line\">    this.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var b = new fn(2);</span><br><span class=\"line\">console.log(b.a); // 2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>this在定义时就已经确定，指向定义时箭头函数所在的作用域（而不是箭头函数的作用域）的父级作用域的this。</p>\n<ul>\n<li>若父级作用域为普通函数，则this指向调用父级函数的对象。</li>\n<li>若父级作用域为箭头函数，则this指向父级作用域的父级作用域。</li>\n<li>如此往上找，直到全局</li>\n</ul>\n<p>首先从它的父级作用域中找，如果父级作用域还是箭头函数，再往上找，如此直至找到this的指向，最后是到window。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h2><ul>\n<li>普通函数被调用时，即运行时，才会确定该函数内this的指向。</li>\n<li>this指向调用该函数的对象。</li>\n</ul>\n<h3 id=\"fn\"><a href=\"#fn\" class=\"headerlink\" title=\"fn()\"></a>fn()</h3><ul>\n<li>不带任何引用形式调用函数，this指向全局对象。</li>\n<li>严格模式下this为undefined。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">function fn () &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(); // 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"obj-fn\"><a href=\"#obj-fn\" class=\"headerlink\" title=\"obj.fn()\"></a>obj.fn()</h3><p>this指向调用该函数的对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    fn: function () &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.fn(); // 2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"obj1-obj-fn\"><a href=\"#obj1-obj-fn\" class=\"headerlink\" title=\"obj1.obj.fn()\"></a>obj1.obj.fn()</h3><p>这种形式的调用结果一样，函数内的this只指向直接调用该函数的对象（obj）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    fn: function () &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">    a: 3,</span><br><span class=\"line\">    obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.obj.fn(); // 2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"另一种形式的fn\"><a href=\"#另一种形式的fn\" class=\"headerlink\" title=\"另一种形式的fn()\"></a>另一种形式的fn()</h3><p>普通函数的this指向只在调用时确定，在调用前无论经过什么操作都不会改变this的指向。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    fn: function () &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var test = obj.fn</span><br><span class=\"line\">test(); // 1</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"拓展的fn\"><a href=\"#拓展的fn\" class=\"headerlink\" title=\"拓展的fn()\"></a>拓展的fn()</h3><ul>\n<li>当setTimeout中的回调函数为普通函数时，回调函数中的this依然是指向全局对象。</li>\n<li>当setTimeout中的回调函数为箭头函数时，this指向定义时函数所在作用域的父级作用域的this。（父级为普通函数this指向调用父级的对象，若父级仍为箭头函数，则需要继续往上找）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    fn: function () &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout(obj.fn); // 1</span><br></pre></td></tr></table></figure>\n<p>setTimeout内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setTimeout (fn,time) &#123;</span><br><span class=\"line\">    // code...</span><br><span class=\"line\">    fn(); //没有指明调用的对象，指向全局</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"fn-call-、fn-apply-、fn-bind\"><a href=\"#fn-call-、fn-apply-、fn-bind\" class=\"headerlink\" title=\"fn.call()、fn.apply()、fn.bind()\"></a>fn.call()、fn.apply()、fn.bind()</h3><p>可以改变this的指向</p>\n<h3 id=\"new-fn\"><a href=\"#new-fn\" class=\"headerlink\" title=\"new fn()\"></a>new fn()</h3><ul>\n<li>new这个操作符其实是new一个新对象出来，而fn被称为构造函数，可以在这个构造函数中定义一些将要到来的新对象的一些属性。</li>\n<li>在构造函数中就是用this来描述这个即将到来的新对象，所以构造函数中的this就是指向被new出来的新对象。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">function fn (a) &#123;</span><br><span class=\"line\">    this.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var b = new fn(2);</span><br><span class=\"line\">console.log(b.a); // 2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>this在定义时就已经确定，指向定义时箭头函数所在的作用域（而不是箭头函数的作用域）的父级作用域的this。</p>\n<ul>\n<li>若父级作用域为普通函数，则this指向调用父级函数的对象。</li>\n<li>若父级作用域为箭头函数，则this指向父级作用域的父级作用域。</li>\n<li>如此往上找，直到全局</li>\n</ul>\n<p>首先从它的父级作用域中找，如果父级作用域还是箭头函数，再往上找，如此直至找到this的指向，最后是到window。</p>\n"},{"title":"js：typeof和instanceof","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### typeof\n是一个一元运算，放在一个运算数之前，运算数可以是任意类型。    \n返回一个用来表示表达式的数据类型的字符串。 \n一般返回如下结果：\n- number（NaN）\n- string\n- boolean\n- object（对象、数组、null）\n- undefined\n- function\n\n### instanceof\n语法：object instanceof constructor    \n用来检测 constructor.prototype 是否存在于参数 object 的原型链上。    \n用于判断一个变量是否某个对象的实例。\n> 可以用来判断一个对象是否为数组\n\nString和Date对象同时也属于Object类型\n\n\n```\n内部实现方法\nwhile(object.__proto__!==null) {\n　　if(object.__proto__===constructor.prototype) {\n　　　　return true;\n　　　　break;\n　　}\n　　object.__proto__ = object.__proto__.proto__;\n}\nif(object.__proto__==null) {return false;}\n```\n","source":"_posts/js/js：typeof和instanceof.md","raw":"---\ntitle: js：typeof和instanceof\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### typeof\n是一个一元运算，放在一个运算数之前，运算数可以是任意类型。    \n返回一个用来表示表达式的数据类型的字符串。 \n一般返回如下结果：\n- number（NaN）\n- string\n- boolean\n- object（对象、数组、null）\n- undefined\n- function\n\n### instanceof\n语法：object instanceof constructor    \n用来检测 constructor.prototype 是否存在于参数 object 的原型链上。    \n用于判断一个变量是否某个对象的实例。\n> 可以用来判断一个对象是否为数组\n\nString和Date对象同时也属于Object类型\n\n\n```\n内部实现方法\nwhile(object.__proto__!==null) {\n　　if(object.__proto__===constructor.prototype) {\n　　　　return true;\n　　　　break;\n　　}\n　　object.__proto__ = object.__proto__.proto__;\n}\nif(object.__proto__==null) {return false;}\n```\n","slug":"js/js：typeof和instanceof","published":1,"date":"2020-05-14T08:55:48.797Z","updated":"2020-05-14T09:01:24.628Z","layout":"post","photos":[],"link":"","_id":"cka6kws03001wrcu97qxqpv18","content":"<h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><p>是一个一元运算，放在一个运算数之前，运算数可以是任意类型。<br>返回一个用来表示表达式的数据类型的字符串。<br>一般返回如下结果：</p>\n<ul>\n<li>number（NaN）</li>\n<li>string</li>\n<li>boolean</li>\n<li>object（对象、数组、null）</li>\n<li>undefined</li>\n<li>function</li>\n</ul>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><p>语法：object instanceof constructor<br>用来检测 constructor.prototype 是否存在于参数 object 的原型链上。<br>用于判断一个变量是否某个对象的实例。</p>\n<blockquote>\n<p>可以用来判断一个对象是否为数组</p>\n</blockquote>\n<p>String和Date对象同时也属于Object类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内部实现方法</span><br><span class=\"line\">while(object.__proto__!==null) &#123;</span><br><span class=\"line\">　　if(object.__proto__===constructor.prototype) &#123;</span><br><span class=\"line\">　　　　return true;</span><br><span class=\"line\">　　　　break;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　object.__proto__ = object.__proto__.proto__;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if(object.__proto__==null) &#123;return false;&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><p>是一个一元运算，放在一个运算数之前，运算数可以是任意类型。<br>返回一个用来表示表达式的数据类型的字符串。<br>一般返回如下结果：</p>\n<ul>\n<li>number（NaN）</li>\n<li>string</li>\n<li>boolean</li>\n<li>object（对象、数组、null）</li>\n<li>undefined</li>\n<li>function</li>\n</ul>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><p>语法：object instanceof constructor<br>用来检测 constructor.prototype 是否存在于参数 object 的原型链上。<br>用于判断一个变量是否某个对象的实例。</p>\n<blockquote>\n<p>可以用来判断一个对象是否为数组</p>\n</blockquote>\n<p>String和Date对象同时也属于Object类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内部实现方法</span><br><span class=\"line\">while(object.__proto__!==null) &#123;</span><br><span class=\"line\">　　if(object.__proto__===constructor.prototype) &#123;</span><br><span class=\"line\">　　　　return true;</span><br><span class=\"line\">　　　　break;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　object.__proto__ = object.__proto__.proto__;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if(object.__proto__==null) &#123;return false;&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"js：一些关于date的获取方法","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 获知一个月的第一天是星期几\n\n```\n// 当月\n// 先获取第一天的时间戳\nvar first = new Date().setDate(1); \n// 再通过getDay()获取\nvar week = new Date(first).getDay();\n\n// 下个月\n// 先获取年份\nvar year = new Date().getFullYear();\n// 获取下个月的月份\nvar month = new Date().getMonth() + 2;\nvar week = new Date(year, month-1, 1).getDay();\n```\n\n### 获知一个月有多少天\n\n```\n// 当月,下个月同理\n// 先获取年份\nvar year = new Date().getFullYear();\n// 获取月份\nvar month = new Date().getMonth() + 1;\nvar total = new Date(year, month, 0).getDate();\n```\n","source":"_posts/js/js：一些关于date的获取方法.md","raw":"---\ntitle: js：一些关于date的获取方法\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 获知一个月的第一天是星期几\n\n```\n// 当月\n// 先获取第一天的时间戳\nvar first = new Date().setDate(1); \n// 再通过getDay()获取\nvar week = new Date(first).getDay();\n\n// 下个月\n// 先获取年份\nvar year = new Date().getFullYear();\n// 获取下个月的月份\nvar month = new Date().getMonth() + 2;\nvar week = new Date(year, month-1, 1).getDay();\n```\n\n### 获知一个月有多少天\n\n```\n// 当月,下个月同理\n// 先获取年份\nvar year = new Date().getFullYear();\n// 获取月份\nvar month = new Date().getMonth() + 1;\nvar total = new Date(year, month, 0).getDate();\n```\n","slug":"js/js：一些关于date的获取方法","published":1,"date":"2020-05-14T08:56:33.243Z","updated":"2020-05-14T09:02:49.185Z","layout":"post","photos":[],"link":"","_id":"cka6kws09001zrcu9p0ui6t8z","content":"<h3 id=\"获知一个月的第一天是星期几\"><a href=\"#获知一个月的第一天是星期几\" class=\"headerlink\" title=\"获知一个月的第一天是星期几\"></a>获知一个月的第一天是星期几</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当月</span><br><span class=\"line\">// 先获取第一天的时间戳</span><br><span class=\"line\">var first = new Date().setDate(1); </span><br><span class=\"line\">// 再通过getDay()获取</span><br><span class=\"line\">var week = new Date(first).getDay();</span><br><span class=\"line\"></span><br><span class=\"line\">// 下个月</span><br><span class=\"line\">// 先获取年份</span><br><span class=\"line\">var year = new Date().getFullYear();</span><br><span class=\"line\">// 获取下个月的月份</span><br><span class=\"line\">var month = new Date().getMonth() + 2;</span><br><span class=\"line\">var week = new Date(year, month-1, 1).getDay();</span><br></pre></td></tr></table></figure>\n<h3 id=\"获知一个月有多少天\"><a href=\"#获知一个月有多少天\" class=\"headerlink\" title=\"获知一个月有多少天\"></a>获知一个月有多少天</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当月,下个月同理</span><br><span class=\"line\">// 先获取年份</span><br><span class=\"line\">var year = new Date().getFullYear();</span><br><span class=\"line\">// 获取月份</span><br><span class=\"line\">var month = new Date().getMonth() + 1;</span><br><span class=\"line\">var total = new Date(year, month, 0).getDate();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"获知一个月的第一天是星期几\"><a href=\"#获知一个月的第一天是星期几\" class=\"headerlink\" title=\"获知一个月的第一天是星期几\"></a>获知一个月的第一天是星期几</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当月</span><br><span class=\"line\">// 先获取第一天的时间戳</span><br><span class=\"line\">var first = new Date().setDate(1); </span><br><span class=\"line\">// 再通过getDay()获取</span><br><span class=\"line\">var week = new Date(first).getDay();</span><br><span class=\"line\"></span><br><span class=\"line\">// 下个月</span><br><span class=\"line\">// 先获取年份</span><br><span class=\"line\">var year = new Date().getFullYear();</span><br><span class=\"line\">// 获取下个月的月份</span><br><span class=\"line\">var month = new Date().getMonth() + 2;</span><br><span class=\"line\">var week = new Date(year, month-1, 1).getDay();</span><br></pre></td></tr></table></figure>\n<h3 id=\"获知一个月有多少天\"><a href=\"#获知一个月有多少天\" class=\"headerlink\" title=\"获知一个月有多少天\"></a>获知一个月有多少天</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当月,下个月同理</span><br><span class=\"line\">// 先获取年份</span><br><span class=\"line\">var year = new Date().getFullYear();</span><br><span class=\"line\">// 获取月份</span><br><span class=\"line\">var month = new Date().getMonth() + 1;</span><br><span class=\"line\">var total = new Date(year, month, 0).getDate();</span><br></pre></td></tr></table></figure>\n"},{"title":"js：不同类型之间的比较与运算","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n```\n1. 5+'5' // '55'\n2. 5-true // 4\n3. 5-'2' // 3\n4. '21'>3 // true\n5. null===undefined // false\n6. NaN===NaN // false\n```\n- 无论字符串与什么做+运算，最终结果都是拼接而成的字符串\n- 无论数字与什么做-运算，另一方都会被转换成数字进行运算，结果仍为数字\n- 字符串与数字做比较时总会把字符串转换为数字进行比较，当字符串无法转换为数字时，结果总为false\n- ===会进行类型比较，不会进行转换，其余比较均会","source":"_posts/js/js：不同类型之间的比较与运算.md","raw":"---\ntitle: js：不同类型之间的比较与运算\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n```\n1. 5+'5' // '55'\n2. 5-true // 4\n3. 5-'2' // 3\n4. '21'>3 // true\n5. null===undefined // false\n6. NaN===NaN // false\n```\n- 无论字符串与什么做+运算，最终结果都是拼接而成的字符串\n- 无论数字与什么做-运算，另一方都会被转换成数字进行运算，结果仍为数字\n- 字符串与数字做比较时总会把字符串转换为数字进行比较，当字符串无法转换为数字时，结果总为false\n- ===会进行类型比较，不会进行转换，其余比较均会","slug":"js/js：不同类型之间的比较与运算","published":1,"date":"2020-05-14T08:56:27.290Z","updated":"2020-05-14T09:03:05.756Z","layout":"post","photos":[],"link":"","_id":"cka6kws0f0022rcu9brhk4y9l","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 5+&apos;5&apos; // &apos;55&apos;</span><br><span class=\"line\">2. 5-true // 4</span><br><span class=\"line\">3. 5-&apos;2&apos; // 3</span><br><span class=\"line\">4. &apos;21&apos;&gt;3 // true</span><br><span class=\"line\">5. null===undefined // false</span><br><span class=\"line\">6. NaN===NaN // false</span><br></pre></td></tr></table></figure>\n<ul>\n<li>无论字符串与什么做+运算，最终结果都是拼接而成的字符串</li>\n<li>无论数字与什么做-运算，另一方都会被转换成数字进行运算，结果仍为数字</li>\n<li>字符串与数字做比较时总会把字符串转换为数字进行比较，当字符串无法转换为数字时，结果总为false</li>\n<li>===会进行类型比较，不会进行转换，其余比较均会</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 5+&apos;5&apos; // &apos;55&apos;</span><br><span class=\"line\">2. 5-true // 4</span><br><span class=\"line\">3. 5-&apos;2&apos; // 3</span><br><span class=\"line\">4. &apos;21&apos;&gt;3 // true</span><br><span class=\"line\">5. null===undefined // false</span><br><span class=\"line\">6. NaN===NaN // false</span><br></pre></td></tr></table></figure>\n<ul>\n<li>无论字符串与什么做+运算，最终结果都是拼接而成的字符串</li>\n<li>无论数字与什么做-运算，另一方都会被转换成数字进行运算，结果仍为数字</li>\n<li>字符串与数字做比较时总会把字符串转换为数字进行比较，当字符串无法转换为数字时，结果总为false</li>\n<li>===会进行类型比较，不会进行转换，其余比较均会</li>\n</ul>\n"},{"title":"js：事件委托","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 概述\n事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n### 为什么要用\n减少DOM操作，优化性能。\n\n在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。\n### 原理\n事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件。\n\n举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。\n\n\n```\n<ul id=\"ul1\">\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n    <li>444</li>\n</ul>\n\nwindow.onload = function(){\n    var oUl = document.getElementById(\"ul1\");\n   oUl.onclick = function(){\n        alert(123);\n    }\n}\n\n//改进：只有点击li才会触发\nwindow.onload = function(){\n　　var oUl = document.getElementById(\"ul1\");\n　　oUl.onclick = function(ev){\n　　　　var ev = ev || window.event;\n　　　　var target = ev.target || ev.srcElement;\n　　　　if(target.nodeName.toLowerCase() == 'li'){\n　 　　　　　　 alert(123);\n　　　　　　　  alert(target.innerHTML);\n　　　　}\n　　}\n}\n\n//target就可以表示为当前的事件操作的dom，但是不是真正操作dom。\n//这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，\n```\n\n### e.target 和 e.currentTarget\n\n- e.target指向触发事件监听的对象\n- e.currentTarget指向绑定事件监听的对象","source":"_posts/js/js：事件委托.md","raw":"---\ntitle: js：事件委托\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### 概述\n事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n### 为什么要用\n减少DOM操作，优化性能。\n\n在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。\n### 原理\n事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件。\n\n举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。\n\n\n```\n<ul id=\"ul1\">\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n    <li>444</li>\n</ul>\n\nwindow.onload = function(){\n    var oUl = document.getElementById(\"ul1\");\n   oUl.onclick = function(){\n        alert(123);\n    }\n}\n\n//改进：只有点击li才会触发\nwindow.onload = function(){\n　　var oUl = document.getElementById(\"ul1\");\n　　oUl.onclick = function(ev){\n　　　　var ev = ev || window.event;\n　　　　var target = ev.target || ev.srcElement;\n　　　　if(target.nodeName.toLowerCase() == 'li'){\n　 　　　　　　 alert(123);\n　　　　　　　  alert(target.innerHTML);\n　　　　}\n　　}\n}\n\n//target就可以表示为当前的事件操作的dom，但是不是真正操作dom。\n//这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，\n```\n\n### e.target 和 e.currentTarget\n\n- e.target指向触发事件监听的对象\n- e.currentTarget指向绑定事件监听的对象","slug":"js/js：事件委托","published":1,"date":"2020-05-14T08:57:36.912Z","updated":"2020-05-14T09:05:50.443Z","layout":"post","photos":[],"link":"","_id":"cka6kws0k0025rcu9qs7rb0kc","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>\n<h3 id=\"为什么要用\"><a href=\"#为什么要用\" class=\"headerlink\" title=\"为什么要用\"></a>为什么要用</h3><p>减少DOM操作，优化性能。</p>\n<p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件。</p>\n<p>举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class=\"line\">    &lt;li&gt;111&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;222&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;333&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;444&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">window.onload = function()&#123;</span><br><span class=\"line\">    var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class=\"line\">   oUl.onclick = function()&#123;</span><br><span class=\"line\">        alert(123);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//改进：只有点击li才会触发</span><br><span class=\"line\">window.onload = function()&#123;</span><br><span class=\"line\">　　var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class=\"line\">　　oUl.onclick = function(ev)&#123;</span><br><span class=\"line\">　　　　var ev = ev || window.event;</span><br><span class=\"line\">　　　　var target = ev.target || ev.srcElement;</span><br><span class=\"line\">　　　　if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class=\"line\">　 　　　　　　 alert(123);</span><br><span class=\"line\">　　　　　　　  alert(target.innerHTML);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//target就可以表示为当前的事件操作的dom，但是不是真正操作dom。</span><br><span class=\"line\">//这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，</span><br></pre></td></tr></table></figure>\n<h3 id=\"e-target-和-e-currentTarget\"><a href=\"#e-target-和-e-currentTarget\" class=\"headerlink\" title=\"e.target 和 e.currentTarget\"></a>e.target 和 e.currentTarget</h3><ul>\n<li>e.target指向触发事件监听的对象</li>\n<li>e.currentTarget指向绑定事件监听的对象</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>\n<h3 id=\"为什么要用\"><a href=\"#为什么要用\" class=\"headerlink\" title=\"为什么要用\"></a>为什么要用</h3><p>减少DOM操作，优化性能。</p>\n<p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件。</p>\n<p>举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class=\"line\">    &lt;li&gt;111&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;222&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;333&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;444&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">window.onload = function()&#123;</span><br><span class=\"line\">    var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class=\"line\">   oUl.onclick = function()&#123;</span><br><span class=\"line\">        alert(123);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//改进：只有点击li才会触发</span><br><span class=\"line\">window.onload = function()&#123;</span><br><span class=\"line\">　　var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class=\"line\">　　oUl.onclick = function(ev)&#123;</span><br><span class=\"line\">　　　　var ev = ev || window.event;</span><br><span class=\"line\">　　　　var target = ev.target || ev.srcElement;</span><br><span class=\"line\">　　　　if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class=\"line\">　 　　　　　　 alert(123);</span><br><span class=\"line\">　　　　　　　  alert(target.innerHTML);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//target就可以表示为当前的事件操作的dom，但是不是真正操作dom。</span><br><span class=\"line\">//这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，</span><br></pre></td></tr></table></figure>\n<h3 id=\"e-target-和-e-currentTarget\"><a href=\"#e-target-和-e-currentTarget\" class=\"headerlink\" title=\"e.target 和 e.currentTarget\"></a>e.target 和 e.currentTarget</h3><ul>\n<li>e.target指向触发事件监听的对象</li>\n<li>e.currentTarget指向绑定事件监听的对象</li>\n</ul>\n"},{"title":"js：事件循环机制","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 前言\nJavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)\n- 宏任务：包括整体代码script，setTimeout，setInterval\n- 微任务：Promise.then(new Promise是定义后立即执行的)，process.nextTick(node中)\n\n### 事件循环\n1. 先执行同步任务，同步任务立即执行，对于异步任务则是把函数放进event table中，等到满足触发条件后加载到对应的Event Queue中。\n2. 所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。\n3. 接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。","source":"_posts/js/js：事件循环机制Event Loop.md","raw":"---\ntitle: js：事件循环机制\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 前言\nJavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)\n- 宏任务：包括整体代码script，setTimeout，setInterval\n- 微任务：Promise.then(new Promise是定义后立即执行的)，process.nextTick(node中)\n\n### 事件循环\n1. 先执行同步任务，同步任务立即执行，对于异步任务则是把函数放进event table中，等到满足触发条件后加载到对应的Event Queue中。\n2. 所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。\n3. 接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。","slug":"js/js：事件循环机制Event Loop","published":1,"date":"2020-05-14T08:54:53.784Z","updated":"2020-05-14T08:59:48.843Z","layout":"post","photos":[],"link":"","_id":"cka6kws0o0028rcu92xbebtg8","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)</p>\n<ul>\n<li>宏任务：包括整体代码script，setTimeout，setInterval</li>\n<li>微任务：Promise.then(new Promise是定义后立即执行的)，process.nextTick(node中)</li>\n</ul>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><ol>\n<li>先执行同步任务，同步任务立即执行，对于异步任务则是把函数放进event table中，等到满足触发条件后加载到对应的Event Queue中。</li>\n<li>所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。</li>\n<li>接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)</p>\n<ul>\n<li>宏任务：包括整体代码script，setTimeout，setInterval</li>\n<li>微任务：Promise.then(new Promise是定义后立即执行的)，process.nextTick(node中)</li>\n</ul>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><ol>\n<li>先执行同步任务，同步任务立即执行，对于异步任务则是把函数放进event table中，等到满足触发条件后加载到对应的Event Queue中。</li>\n<li>所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。</li>\n<li>接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。</li>\n</ol>\n"},{"title":"js：事件模型","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n```\n<button id=\"btn\">click me</button>\n```\n### DOM0级事件模型\nDOM0级事件模型是早期的事件模型，所有的浏览器都是支持的，而且其实现也是比较简单。没有事件流的概念。\n\n#### 事件绑定监听函数\n直接在dom对象上注册事件\n```\n<button onclick=\"console.log('DOM0')\">\n```\n```\ndocument.getElementById('btn').onclick = function(){\n    console.log('DOM0');\n}\n\n```\n#### 事件移除监听函数\n解除事件是将null复制给事件函数\n\n```\ndocument.getElementById('btn').onclick = null;\n```\n一个dom对象只能注册一个同类型的函数，因为注册多个同类型的函数的话，就会发生覆盖，之前注册的函数就会无效。\n\n### IE事件模型\n事件流：\n- 事件处理阶段：事件到达目标元素，触发目标元素的监听函数。\n- 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n\n#### 事件绑定监听函数\n```\n// attachEvent('事件名称','事件回调');\ndocument.getElementById('btn').attachEvent('onclick', function(){\n    console.log('IE');\n});\n```\n#### 事件移除监听函数\ndetachEvent('要移除的事件名称','要移除的函数');\n\n### DOM2级事件模型\n事件流阶段：\n- 事件捕获阶段：事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n- 处于目标阶段：事件到达目标元素，触发目标元素的监听函数。\n- 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n\n#### 事件绑定监听函数\n一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。\n\nDOM2事件函数不会覆盖DOM0事件函数。\n\n```\n//addEventListener('事件名称','事件回调','捕获/冒泡')\nvar click = document.getElementById('btn');\nclick.addEventListener('click',function(){\n    console.log('DOM2 捕获');\n},true);\nclick.addEventListener('click',function(){\n    console.log('DOM2 冒泡');\n},false);\n```\n第一个参数是事件名称，与DOM0级不同的是没有”on“，另外第三个参数代表是否在捕获阶段进行处理，true代表在捕获阶段进行处理，false代表在冒泡阶段进行处理，默认为false。\n\n#### 事件移除监听函数\nremoveEventListener('要移除的事件名称','要移除的函数')","source":"_posts/js/js：事件模型.md","raw":"---\ntitle: js：事件模型\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n```\n<button id=\"btn\">click me</button>\n```\n### DOM0级事件模型\nDOM0级事件模型是早期的事件模型，所有的浏览器都是支持的，而且其实现也是比较简单。没有事件流的概念。\n\n#### 事件绑定监听函数\n直接在dom对象上注册事件\n```\n<button onclick=\"console.log('DOM0')\">\n```\n```\ndocument.getElementById('btn').onclick = function(){\n    console.log('DOM0');\n}\n\n```\n#### 事件移除监听函数\n解除事件是将null复制给事件函数\n\n```\ndocument.getElementById('btn').onclick = null;\n```\n一个dom对象只能注册一个同类型的函数，因为注册多个同类型的函数的话，就会发生覆盖，之前注册的函数就会无效。\n\n### IE事件模型\n事件流：\n- 事件处理阶段：事件到达目标元素，触发目标元素的监听函数。\n- 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n\n#### 事件绑定监听函数\n```\n// attachEvent('事件名称','事件回调');\ndocument.getElementById('btn').attachEvent('onclick', function(){\n    console.log('IE');\n});\n```\n#### 事件移除监听函数\ndetachEvent('要移除的事件名称','要移除的函数');\n\n### DOM2级事件模型\n事件流阶段：\n- 事件捕获阶段：事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n- 处于目标阶段：事件到达目标元素，触发目标元素的监听函数。\n- 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n\n#### 事件绑定监听函数\n一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。\n\nDOM2事件函数不会覆盖DOM0事件函数。\n\n```\n//addEventListener('事件名称','事件回调','捕获/冒泡')\nvar click = document.getElementById('btn');\nclick.addEventListener('click',function(){\n    console.log('DOM2 捕获');\n},true);\nclick.addEventListener('click',function(){\n    console.log('DOM2 冒泡');\n},false);\n```\n第一个参数是事件名称，与DOM0级不同的是没有”on“，另外第三个参数代表是否在捕获阶段进行处理，true代表在捕获阶段进行处理，false代表在冒泡阶段进行处理，默认为false。\n\n#### 事件移除监听函数\nremoveEventListener('要移除的事件名称','要移除的函数')","slug":"js/js：事件模型","published":1,"date":"2020-05-14T08:57:00.378Z","updated":"2020-05-14T09:04:41.315Z","layout":"post","photos":[],"link":"","_id":"cka6kws0t002brcu9y7p4kp76","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM0级事件模型\"><a href=\"#DOM0级事件模型\" class=\"headerlink\" title=\"DOM0级事件模型\"></a>DOM0级事件模型</h3><p>DOM0级事件模型是早期的事件模型，所有的浏览器都是支持的，而且其实现也是比较简单。没有事件流的概念。</p>\n<h4 id=\"事件绑定监听函数\"><a href=\"#事件绑定监听函数\" class=\"headerlink\" title=\"事件绑定监听函数\"></a>事件绑定监听函数</h4><p>直接在dom对象上注册事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onclick=&quot;console.log(&apos;DOM0&apos;)&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;btn&apos;).onclick = function()&#123;</span><br><span class=\"line\">    console.log(&apos;DOM0&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"事件移除监听函数\"><a href=\"#事件移除监听函数\" class=\"headerlink\" title=\"事件移除监听函数\"></a>事件移除监听函数</h4><p>解除事件是将null复制给事件函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;btn&apos;).onclick = null;</span><br></pre></td></tr></table></figure>\n<p>一个dom对象只能注册一个同类型的函数，因为注册多个同类型的函数的话，就会发生覆盖，之前注册的函数就会无效。</p>\n<h3 id=\"IE事件模型\"><a href=\"#IE事件模型\" class=\"headerlink\" title=\"IE事件模型\"></a>IE事件模型</h3><p>事件流：</p>\n<ul>\n<li>事件处理阶段：事件到达目标元素，触发目标元素的监听函数。</li>\n<li>事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>\n</ul>\n<h4 id=\"事件绑定监听函数-1\"><a href=\"#事件绑定监听函数-1\" class=\"headerlink\" title=\"事件绑定监听函数\"></a>事件绑定监听函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// attachEvent(&apos;事件名称&apos;,&apos;事件回调&apos;);</span><br><span class=\"line\">document.getElementById(&apos;btn&apos;).attachEvent(&apos;onclick&apos;, function()&#123;</span><br><span class=\"line\">    console.log(&apos;IE&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"事件移除监听函数-1\"><a href=\"#事件移除监听函数-1\" class=\"headerlink\" title=\"事件移除监听函数\"></a>事件移除监听函数</h4><p>detachEvent(‘要移除的事件名称’,’要移除的函数’);</p>\n<h3 id=\"DOM2级事件模型\"><a href=\"#DOM2级事件模型\" class=\"headerlink\" title=\"DOM2级事件模型\"></a>DOM2级事件模型</h3><p>事件流阶段：</p>\n<ul>\n<li>事件捕获阶段：事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>\n<li>处于目标阶段：事件到达目标元素，触发目标元素的监听函数。</li>\n<li>事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>\n</ul>\n<h4 id=\"事件绑定监听函数-2\"><a href=\"#事件绑定监听函数-2\" class=\"headerlink\" title=\"事件绑定监听函数\"></a>事件绑定监听函数</h4><p>一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。</p>\n<p>DOM2事件函数不会覆盖DOM0事件函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//addEventListener(&apos;事件名称&apos;,&apos;事件回调&apos;,&apos;捕获/冒泡&apos;)</span><br><span class=\"line\">var click = document.getElementById(&apos;btn&apos;);</span><br><span class=\"line\">click.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class=\"line\">    console.log(&apos;DOM2 捕获&apos;);</span><br><span class=\"line\">&#125;,true);</span><br><span class=\"line\">click.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class=\"line\">    console.log(&apos;DOM2 冒泡&apos;);</span><br><span class=\"line\">&#125;,false);</span><br></pre></td></tr></table></figure>\n<p>第一个参数是事件名称，与DOM0级不同的是没有”on“，另外第三个参数代表是否在捕获阶段进行处理，true代表在捕获阶段进行处理，false代表在冒泡阶段进行处理，默认为false。</p>\n<h4 id=\"事件移除监听函数-2\"><a href=\"#事件移除监听函数-2\" class=\"headerlink\" title=\"事件移除监听函数\"></a>事件移除监听函数</h4><p>removeEventListener(‘要移除的事件名称’,’要移除的函数’)</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM0级事件模型\"><a href=\"#DOM0级事件模型\" class=\"headerlink\" title=\"DOM0级事件模型\"></a>DOM0级事件模型</h3><p>DOM0级事件模型是早期的事件模型，所有的浏览器都是支持的，而且其实现也是比较简单。没有事件流的概念。</p>\n<h4 id=\"事件绑定监听函数\"><a href=\"#事件绑定监听函数\" class=\"headerlink\" title=\"事件绑定监听函数\"></a>事件绑定监听函数</h4><p>直接在dom对象上注册事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onclick=&quot;console.log(&apos;DOM0&apos;)&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;btn&apos;).onclick = function()&#123;</span><br><span class=\"line\">    console.log(&apos;DOM0&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"事件移除监听函数\"><a href=\"#事件移除监听函数\" class=\"headerlink\" title=\"事件移除监听函数\"></a>事件移除监听函数</h4><p>解除事件是将null复制给事件函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;btn&apos;).onclick = null;</span><br></pre></td></tr></table></figure>\n<p>一个dom对象只能注册一个同类型的函数，因为注册多个同类型的函数的话，就会发生覆盖，之前注册的函数就会无效。</p>\n<h3 id=\"IE事件模型\"><a href=\"#IE事件模型\" class=\"headerlink\" title=\"IE事件模型\"></a>IE事件模型</h3><p>事件流：</p>\n<ul>\n<li>事件处理阶段：事件到达目标元素，触发目标元素的监听函数。</li>\n<li>事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>\n</ul>\n<h4 id=\"事件绑定监听函数-1\"><a href=\"#事件绑定监听函数-1\" class=\"headerlink\" title=\"事件绑定监听函数\"></a>事件绑定监听函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// attachEvent(&apos;事件名称&apos;,&apos;事件回调&apos;);</span><br><span class=\"line\">document.getElementById(&apos;btn&apos;).attachEvent(&apos;onclick&apos;, function()&#123;</span><br><span class=\"line\">    console.log(&apos;IE&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"事件移除监听函数-1\"><a href=\"#事件移除监听函数-1\" class=\"headerlink\" title=\"事件移除监听函数\"></a>事件移除监听函数</h4><p>detachEvent(‘要移除的事件名称’,’要移除的函数’);</p>\n<h3 id=\"DOM2级事件模型\"><a href=\"#DOM2级事件模型\" class=\"headerlink\" title=\"DOM2级事件模型\"></a>DOM2级事件模型</h3><p>事件流阶段：</p>\n<ul>\n<li>事件捕获阶段：事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>\n<li>处于目标阶段：事件到达目标元素，触发目标元素的监听函数。</li>\n<li>事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>\n</ul>\n<h4 id=\"事件绑定监听函数-2\"><a href=\"#事件绑定监听函数-2\" class=\"headerlink\" title=\"事件绑定监听函数\"></a>事件绑定监听函数</h4><p>一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。</p>\n<p>DOM2事件函数不会覆盖DOM0事件函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//addEventListener(&apos;事件名称&apos;,&apos;事件回调&apos;,&apos;捕获/冒泡&apos;)</span><br><span class=\"line\">var click = document.getElementById(&apos;btn&apos;);</span><br><span class=\"line\">click.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class=\"line\">    console.log(&apos;DOM2 捕获&apos;);</span><br><span class=\"line\">&#125;,true);</span><br><span class=\"line\">click.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class=\"line\">    console.log(&apos;DOM2 冒泡&apos;);</span><br><span class=\"line\">&#125;,false);</span><br></pre></td></tr></table></figure>\n<p>第一个参数是事件名称，与DOM0级不同的是没有”on“，另外第三个参数代表是否在捕获阶段进行处理，true代表在捕获阶段进行处理，false代表在冒泡阶段进行处理，默认为false。</p>\n<h4 id=\"事件移除监听函数-2\"><a href=\"#事件移除监听函数-2\" class=\"headerlink\" title=\"事件移除监听函数\"></a>事件移除监听函数</h4><p>removeEventListener(‘要移除的事件名称’,’要移除的函数’)</p>\n"},{"title":"js：作用域","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。\n\n### 全局作用域\n在代码任何地方都能访问到的对象拥有全局作用域。   \n拥有作用域的情况：\n- 程序最外层定义的函数或变量。\n- 所有未定义直接赋值的变量，相当于在window对象上创建属性。（不推荐）\n- 所有window对象的属性和方法。\n\n### 局部作用域（函数作用域）\n局部作用域在函数内创建，在函数内可访问，函数外不可访问。\n\n### 变量声明\njs引擎解析js代码时，会先把变量和函数的声明提前进行预解析，然后再去执行其他代码。\n\n直接赋值不会引起变量提升，在执行期间创建，为window的属性，可删除。\n\n### 函数声明\n1. function name(){}直接创建\n2. new Function构建函数创建\n3. 给变量赋值匿名函数方法创建\n```\nvar name = function(){ }\n```\n后两者，在声明前访问，返回undefined。  \n函数名与变量名声明时相同，函数优先声明。\n\n### 作用域链\n- 当代码在一个环境中执行时，一般情况下，会到当前执行环境中访问变量。\n- 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条（即这样逐层的作用域形成的链条）就叫做作用域链。\n- 作用域链是函数被创建的作用域中对象的集合。作用域链保证了对变量和函数的有序访问。\n- 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。\n\n作用域链的前端，始终是当前执行代码所在环境的变量对象。如果当前环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含arguments对象（这个对象在全局环境中不存在）。\n\n全局执行环境的变量对象始终都是作用域链的最后一个对象。\n\njs每一个函数执行时，会先在自己创建的AO上找对应的属性值。若找不到，则往父函数的AO上找，直到找到全局作用域，这样就形成一条作用域链。\n\nVO（变量对象）：函数创建阶段，js解析引擎进行预解析时，所有变量和函数的声明组成VO。\n\nAO（活动对象）：函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，这些变量组成AO。\n\n执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。\n","source":"_posts/js/js：作用域.md","raw":"---\ntitle: js：作用域\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。\n\n### 全局作用域\n在代码任何地方都能访问到的对象拥有全局作用域。   \n拥有作用域的情况：\n- 程序最外层定义的函数或变量。\n- 所有未定义直接赋值的变量，相当于在window对象上创建属性。（不推荐）\n- 所有window对象的属性和方法。\n\n### 局部作用域（函数作用域）\n局部作用域在函数内创建，在函数内可访问，函数外不可访问。\n\n### 变量声明\njs引擎解析js代码时，会先把变量和函数的声明提前进行预解析，然后再去执行其他代码。\n\n直接赋值不会引起变量提升，在执行期间创建，为window的属性，可删除。\n\n### 函数声明\n1. function name(){}直接创建\n2. new Function构建函数创建\n3. 给变量赋值匿名函数方法创建\n```\nvar name = function(){ }\n```\n后两者，在声明前访问，返回undefined。  \n函数名与变量名声明时相同，函数优先声明。\n\n### 作用域链\n- 当代码在一个环境中执行时，一般情况下，会到当前执行环境中访问变量。\n- 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条（即这样逐层的作用域形成的链条）就叫做作用域链。\n- 作用域链是函数被创建的作用域中对象的集合。作用域链保证了对变量和函数的有序访问。\n- 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。\n\n作用域链的前端，始终是当前执行代码所在环境的变量对象。如果当前环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含arguments对象（这个对象在全局环境中不存在）。\n\n全局执行环境的变量对象始终都是作用域链的最后一个对象。\n\njs每一个函数执行时，会先在自己创建的AO上找对应的属性值。若找不到，则往父函数的AO上找，直到找到全局作用域，这样就形成一条作用域链。\n\nVO（变量对象）：函数创建阶段，js解析引擎进行预解析时，所有变量和函数的声明组成VO。\n\nAO（活动对象）：函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，这些变量组成AO。\n\n执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。\n","slug":"js/js：作用域","published":1,"date":"2020-05-14T08:58:00.933Z","updated":"2020-05-14T09:05:42.096Z","layout":"post","photos":[],"link":"","_id":"cka6kws0y002ercu9dmfo774y","content":"<p>作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>\n<h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p>在代码任何地方都能访问到的对象拥有全局作用域。<br>拥有作用域的情况：</p>\n<ul>\n<li>程序最外层定义的函数或变量。</li>\n<li>所有未定义直接赋值的变量，相当于在window对象上创建属性。（不推荐）</li>\n<li>所有window对象的属性和方法。</li>\n</ul>\n<h3 id=\"局部作用域（函数作用域）\"><a href=\"#局部作用域（函数作用域）\" class=\"headerlink\" title=\"局部作用域（函数作用域）\"></a>局部作用域（函数作用域）</h3><p>局部作用域在函数内创建，在函数内可访问，函数外不可访问。</p>\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><p>js引擎解析js代码时，会先把变量和函数的声明提前进行预解析，然后再去执行其他代码。</p>\n<p>直接赋值不会引起变量提升，在执行期间创建，为window的属性，可删除。</p>\n<h3 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h3><ol>\n<li>function name(){}直接创建</li>\n<li>new Function构建函数创建</li>\n<li>给变量赋值匿名函数方法创建<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = function()&#123; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>后两者，在声明前访问，返回undefined。<br>函数名与变量名声明时相同，函数优先声明。</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><ul>\n<li>当代码在一个环境中执行时，一般情况下，会到当前执行环境中访问变量。</li>\n<li>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条（即这样逐层的作用域形成的链条）就叫做作用域链。</li>\n<li>作用域链是函数被创建的作用域中对象的集合。作用域链保证了对变量和函数的有序访问。</li>\n<li>每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。</li>\n</ul>\n<p>作用域链的前端，始终是当前执行代码所在环境的变量对象。如果当前环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含arguments对象（这个对象在全局环境中不存在）。</p>\n<p>全局执行环境的变量对象始终都是作用域链的最后一个对象。</p>\n<p>js每一个函数执行时，会先在自己创建的AO上找对应的属性值。若找不到，则往父函数的AO上找，直到找到全局作用域，这样就形成一条作用域链。</p>\n<p>VO（变量对象）：函数创建阶段，js解析引擎进行预解析时，所有变量和函数的声明组成VO。</p>\n<p>AO（活动对象）：函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，这些变量组成AO。</p>\n<p>执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>\n<h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p>在代码任何地方都能访问到的对象拥有全局作用域。<br>拥有作用域的情况：</p>\n<ul>\n<li>程序最外层定义的函数或变量。</li>\n<li>所有未定义直接赋值的变量，相当于在window对象上创建属性。（不推荐）</li>\n<li>所有window对象的属性和方法。</li>\n</ul>\n<h3 id=\"局部作用域（函数作用域）\"><a href=\"#局部作用域（函数作用域）\" class=\"headerlink\" title=\"局部作用域（函数作用域）\"></a>局部作用域（函数作用域）</h3><p>局部作用域在函数内创建，在函数内可访问，函数外不可访问。</p>\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><p>js引擎解析js代码时，会先把变量和函数的声明提前进行预解析，然后再去执行其他代码。</p>\n<p>直接赋值不会引起变量提升，在执行期间创建，为window的属性，可删除。</p>\n<h3 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h3><ol>\n<li>function name(){}直接创建</li>\n<li>new Function构建函数创建</li>\n<li>给变量赋值匿名函数方法创建<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = function()&#123; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>后两者，在声明前访问，返回undefined。<br>函数名与变量名声明时相同，函数优先声明。</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><ul>\n<li>当代码在一个环境中执行时，一般情况下，会到当前执行环境中访问变量。</li>\n<li>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条（即这样逐层的作用域形成的链条）就叫做作用域链。</li>\n<li>作用域链是函数被创建的作用域中对象的集合。作用域链保证了对变量和函数的有序访问。</li>\n<li>每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。</li>\n</ul>\n<p>作用域链的前端，始终是当前执行代码所在环境的变量对象。如果当前环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含arguments对象（这个对象在全局环境中不存在）。</p>\n<p>全局执行环境的变量对象始终都是作用域链的最后一个对象。</p>\n<p>js每一个函数执行时，会先在自己创建的AO上找对应的属性值。若找不到，则往父函数的AO上找，直到找到全局作用域，这样就形成一条作用域链。</p>\n<p>VO（变量对象）：函数创建阶段，js解析引擎进行预解析时，所有变量和函数的声明组成VO。</p>\n<p>AO（活动对象）：函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，这些变量组成AO。</p>\n<p>执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。</p>\n"},{"title":"js：关于闭包","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n## 闭包\n### 对闭包的理解\n1. 闭包是有权访问另一个函数作用域中的变量的一个函数。\n2. 简单来说就是定义在一个函数内部的函数。\n3. 闭包可以访问到父级函数的变量，且该变量不会销毁。\n\n### 闭包的原理\n利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条\n\n### 闭包的体现\n闭包只能取得包含函数中的任何变量的最后一个值\n```\nfunction person (){\n    var age = 18;\n    function cat(){\n        age ++;\n        console.log(age);\n    }\n    console.log(age)\n    return cat;\n}\nperson() // 18\nvar p = person(); // p相当于函数cat\n// 调用时会先在cat函数作用域内查找变量age，没有则顺着作用域链往上查找，找到person中的age\n// 经过首次调用后cat中存在age变量，这样每次调用都不经过age的初始值，就可以一直增加\np() // 19，p()即cat()\np() // 20\nperson() // 18，每次调用person函数，进入该作用域，age都会重新赋值为18\n```\n\n### 闭包的作用\n- 隐藏变量，避免全局污染\n- 可以读取函数内部的变量\n\n### 闭包的缺点\n- 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。\n- 闭包会导致局部变量能在函数作用域之外被访问，但是这不是变量不可被回收的充分条件，通常情况下是考虑局部变量是否被全局或者一个不可被回收的对象引用了。\n- 闭包被引用后始终在内存中，不会在调用结束后被垃圾回收机制回收，可能会造成内存消耗。\n```\n// 释放闭包引用\np = null;\n```\n### 闭包的应用场景\n#### 封装变量\n为避免全局污染，把变量封装到函数作用域中\n\n#### 循环绑定事件处理函数\n\n```\nvar lis = document.getElementsByTagName('li')\n\n// 每循环一次给lis添加一个function，最后lis是这样的 lis[function(){},function(){},function(){}]\n// 里面有3个function，在for里面声明了function，但还没有立即执行\n// 真正执行的时候是当点击li的时候才执行这个函数// 当执行的时候for循环已经结束，i已经变成最后一个取值了，所以每触发一次事件都访问的是等于最后一个取值的i\n\nfor(var i=0;i<lis.length;i++){\n  lis[i].onclick = function(){\n    console.log(i);\n  };      \n}\n\n// 立即执行函数要保护j这个索引值的变量不被污染\nfor(var i=0;i<lis.length;i++){\n  (function(j){\n      lis[j].onclick = function(){\n           console.log(j);\n      };\n  })(i);       //事件处理函数中闭包的写法\n} \n```\n#### 循环打印\n\n```\n// 定时器中的回调函数是一个在立即执行函数中的闭包，单独的立即执行函数能不能叫做闭包说法各有不同。\nfunction fn(){\n  for(var i = 1;i <= 5;i ++){\n\t(function(j){\n\t\tsetTimeout(function () {\n            console.log(j)\n        }, 1000)\n\t})(i);\n  }\n}\nfn() // 1 2 3 4 5\n```\n\n## 拓展\n### 垃圾回收机制\n#### 标记清除\n工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。\n\n工作流程：\n1. 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。\n2. 去掉环境中的变量以及被环境中的变量引用的变量的标记。\n3. 再被加上标记的会被视为准备删除的变量。\n4. 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。\n\n#### 引用计数\n工作原理：跟踪记录每个值被引用的次数。\n\n工作流程：\n1. 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。\n2. 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.\n3. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.\n4. 当引用次数变成0时，说明没办法访问这个值了。\n5. 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。\n\n### 引起内存泄漏\n1. 全局变量\n2. 闭包\n3. 原因：都是由于不能被回收","source":"_posts/js/js：关于闭包.md","raw":"---\ntitle: js：关于闭包\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n## 闭包\n### 对闭包的理解\n1. 闭包是有权访问另一个函数作用域中的变量的一个函数。\n2. 简单来说就是定义在一个函数内部的函数。\n3. 闭包可以访问到父级函数的变量，且该变量不会销毁。\n\n### 闭包的原理\n利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条\n\n### 闭包的体现\n闭包只能取得包含函数中的任何变量的最后一个值\n```\nfunction person (){\n    var age = 18;\n    function cat(){\n        age ++;\n        console.log(age);\n    }\n    console.log(age)\n    return cat;\n}\nperson() // 18\nvar p = person(); // p相当于函数cat\n// 调用时会先在cat函数作用域内查找变量age，没有则顺着作用域链往上查找，找到person中的age\n// 经过首次调用后cat中存在age变量，这样每次调用都不经过age的初始值，就可以一直增加\np() // 19，p()即cat()\np() // 20\nperson() // 18，每次调用person函数，进入该作用域，age都会重新赋值为18\n```\n\n### 闭包的作用\n- 隐藏变量，避免全局污染\n- 可以读取函数内部的变量\n\n### 闭包的缺点\n- 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。\n- 闭包会导致局部变量能在函数作用域之外被访问，但是这不是变量不可被回收的充分条件，通常情况下是考虑局部变量是否被全局或者一个不可被回收的对象引用了。\n- 闭包被引用后始终在内存中，不会在调用结束后被垃圾回收机制回收，可能会造成内存消耗。\n```\n// 释放闭包引用\np = null;\n```\n### 闭包的应用场景\n#### 封装变量\n为避免全局污染，把变量封装到函数作用域中\n\n#### 循环绑定事件处理函数\n\n```\nvar lis = document.getElementsByTagName('li')\n\n// 每循环一次给lis添加一个function，最后lis是这样的 lis[function(){},function(){},function(){}]\n// 里面有3个function，在for里面声明了function，但还没有立即执行\n// 真正执行的时候是当点击li的时候才执行这个函数// 当执行的时候for循环已经结束，i已经变成最后一个取值了，所以每触发一次事件都访问的是等于最后一个取值的i\n\nfor(var i=0;i<lis.length;i++){\n  lis[i].onclick = function(){\n    console.log(i);\n  };      \n}\n\n// 立即执行函数要保护j这个索引值的变量不被污染\nfor(var i=0;i<lis.length;i++){\n  (function(j){\n      lis[j].onclick = function(){\n           console.log(j);\n      };\n  })(i);       //事件处理函数中闭包的写法\n} \n```\n#### 循环打印\n\n```\n// 定时器中的回调函数是一个在立即执行函数中的闭包，单独的立即执行函数能不能叫做闭包说法各有不同。\nfunction fn(){\n  for(var i = 1;i <= 5;i ++){\n\t(function(j){\n\t\tsetTimeout(function () {\n            console.log(j)\n        }, 1000)\n\t})(i);\n  }\n}\nfn() // 1 2 3 4 5\n```\n\n## 拓展\n### 垃圾回收机制\n#### 标记清除\n工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。\n\n工作流程：\n1. 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。\n2. 去掉环境中的变量以及被环境中的变量引用的变量的标记。\n3. 再被加上标记的会被视为准备删除的变量。\n4. 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。\n\n#### 引用计数\n工作原理：跟踪记录每个值被引用的次数。\n\n工作流程：\n1. 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。\n2. 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.\n3. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.\n4. 当引用次数变成0时，说明没办法访问这个值了。\n5. 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。\n\n### 引起内存泄漏\n1. 全局变量\n2. 闭包\n3. 原因：都是由于不能被回收","slug":"js/js：关于闭包","published":1,"date":"2020-05-14T08:58:05.648Z","updated":"2020-05-14T09:05:29.342Z","layout":"post","photos":[],"link":"","_id":"cka6kws14002hrcu9lpta6z98","content":"<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h3 id=\"对闭包的理解\"><a href=\"#对闭包的理解\" class=\"headerlink\" title=\"对闭包的理解\"></a>对闭包的理解</h3><ol>\n<li>闭包是有权访问另一个函数作用域中的变量的一个函数。</li>\n<li>简单来说就是定义在一个函数内部的函数。</li>\n<li>闭包可以访问到父级函数的变量，且该变量不会销毁。</li>\n</ol>\n<h3 id=\"闭包的原理\"><a href=\"#闭包的原理\" class=\"headerlink\" title=\"闭包的原理\"></a>闭包的原理</h3><p>利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条</p>\n<h3 id=\"闭包的体现\"><a href=\"#闭包的体现\" class=\"headerlink\" title=\"闭包的体现\"></a>闭包的体现</h3><p>闭包只能取得包含函数中的任何变量的最后一个值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function person ()&#123;</span><br><span class=\"line\">    var age = 18;</span><br><span class=\"line\">    function cat()&#123;</span><br><span class=\"line\">        age ++;</span><br><span class=\"line\">        console.log(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(age)</span><br><span class=\"line\">    return cat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">person() // 18</span><br><span class=\"line\">var p = person(); // p相当于函数cat</span><br><span class=\"line\">// 调用时会先在cat函数作用域内查找变量age，没有则顺着作用域链往上查找，找到person中的age</span><br><span class=\"line\">// 经过首次调用后cat中存在age变量，这样每次调用都不经过age的初始值，就可以一直增加</span><br><span class=\"line\">p() // 19，p()即cat()</span><br><span class=\"line\">p() // 20</span><br><span class=\"line\">person() // 18，每次调用person函数，进入该作用域，age都会重新赋值为18</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h3><ul>\n<li>隐藏变量，避免全局污染</li>\n<li>可以读取函数内部的变量</li>\n</ul>\n<h3 id=\"闭包的缺点\"><a href=\"#闭包的缺点\" class=\"headerlink\" title=\"闭包的缺点\"></a>闭包的缺点</h3><ul>\n<li>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</li>\n<li>闭包会导致局部变量能在函数作用域之外被访问，但是这不是变量不可被回收的充分条件，通常情况下是考虑局部变量是否被全局或者一个不可被回收的对象引用了。</li>\n<li>闭包被引用后始终在内存中，不会在调用结束后被垃圾回收机制回收，可能会造成内存消耗。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 释放闭包引用</span><br><span class=\"line\">p = null;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"闭包的应用场景\"><a href=\"#闭包的应用场景\" class=\"headerlink\" title=\"闭包的应用场景\"></a>闭包的应用场景</h3><h4 id=\"封装变量\"><a href=\"#封装变量\" class=\"headerlink\" title=\"封装变量\"></a>封装变量</h4><p>为避免全局污染，把变量封装到函数作用域中</p>\n<h4 id=\"循环绑定事件处理函数\"><a href=\"#循环绑定事件处理函数\" class=\"headerlink\" title=\"循环绑定事件处理函数\"></a>循环绑定事件处理函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lis = document.getElementsByTagName(&apos;li&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 每循环一次给lis添加一个function，最后lis是这样的 lis[function()&#123;&#125;,function()&#123;&#125;,function()&#123;&#125;]</span><br><span class=\"line\">// 里面有3个function，在for里面声明了function，但还没有立即执行</span><br><span class=\"line\">// 真正执行的时候是当点击li的时候才执行这个函数// 当执行的时候for循环已经结束，i已经变成最后一个取值了，所以每触发一次事件都访问的是等于最后一个取值的i</span><br><span class=\"line\"></span><br><span class=\"line\">for(var i=0;i&lt;lis.length;i++)&#123;</span><br><span class=\"line\">  lis[i].onclick = function()&#123;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">  &#125;;      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 立即执行函数要保护j这个索引值的变量不被污染</span><br><span class=\"line\">for(var i=0;i&lt;lis.length;i++)&#123;</span><br><span class=\"line\">  (function(j)&#123;</span><br><span class=\"line\">      lis[j].onclick = function()&#123;</span><br><span class=\"line\">           console.log(j);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;)(i);       //事件处理函数中闭包的写法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"循环打印\"><a href=\"#循环打印\" class=\"headerlink\" title=\"循环打印\"></a>循环打印</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定时器中的回调函数是一个在立即执行函数中的闭包，单独的立即执行函数能不能叫做闭包说法各有不同。</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">  for(var i = 1;i &lt;= 5;i ++)&#123;</span><br><span class=\"line\">\t(function(j)&#123;</span><br><span class=\"line\">\t\tsetTimeout(function () &#123;</span><br><span class=\"line\">            console.log(j)</span><br><span class=\"line\">        &#125;, 1000)</span><br><span class=\"line\">\t&#125;)(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn() // 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><h4 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h4><p>工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>\n<p>工作流程：</p>\n<ol>\n<li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。</li>\n<li>去掉环境中的变量以及被环境中的变量引用的变量的标记。</li>\n<li>再被加上标记的会被视为准备删除的变量。</li>\n<li>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</li>\n</ol>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>工作原理：跟踪记录每个值被引用的次数。</p>\n<p>工作流程：</p>\n<ol>\n<li>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。</li>\n<li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.</li>\n<li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.</li>\n<li>当引用次数变成0时，说明没办法访问这个值了。</li>\n<li>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。</li>\n</ol>\n<h3 id=\"引起内存泄漏\"><a href=\"#引起内存泄漏\" class=\"headerlink\" title=\"引起内存泄漏\"></a>引起内存泄漏</h3><ol>\n<li>全局变量</li>\n<li>闭包</li>\n<li>原因：都是由于不能被回收</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h3 id=\"对闭包的理解\"><a href=\"#对闭包的理解\" class=\"headerlink\" title=\"对闭包的理解\"></a>对闭包的理解</h3><ol>\n<li>闭包是有权访问另一个函数作用域中的变量的一个函数。</li>\n<li>简单来说就是定义在一个函数内部的函数。</li>\n<li>闭包可以访问到父级函数的变量，且该变量不会销毁。</li>\n</ol>\n<h3 id=\"闭包的原理\"><a href=\"#闭包的原理\" class=\"headerlink\" title=\"闭包的原理\"></a>闭包的原理</h3><p>利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条</p>\n<h3 id=\"闭包的体现\"><a href=\"#闭包的体现\" class=\"headerlink\" title=\"闭包的体现\"></a>闭包的体现</h3><p>闭包只能取得包含函数中的任何变量的最后一个值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function person ()&#123;</span><br><span class=\"line\">    var age = 18;</span><br><span class=\"line\">    function cat()&#123;</span><br><span class=\"line\">        age ++;</span><br><span class=\"line\">        console.log(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(age)</span><br><span class=\"line\">    return cat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">person() // 18</span><br><span class=\"line\">var p = person(); // p相当于函数cat</span><br><span class=\"line\">// 调用时会先在cat函数作用域内查找变量age，没有则顺着作用域链往上查找，找到person中的age</span><br><span class=\"line\">// 经过首次调用后cat中存在age变量，这样每次调用都不经过age的初始值，就可以一直增加</span><br><span class=\"line\">p() // 19，p()即cat()</span><br><span class=\"line\">p() // 20</span><br><span class=\"line\">person() // 18，每次调用person函数，进入该作用域，age都会重新赋值为18</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h3><ul>\n<li>隐藏变量，避免全局污染</li>\n<li>可以读取函数内部的变量</li>\n</ul>\n<h3 id=\"闭包的缺点\"><a href=\"#闭包的缺点\" class=\"headerlink\" title=\"闭包的缺点\"></a>闭包的缺点</h3><ul>\n<li>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</li>\n<li>闭包会导致局部变量能在函数作用域之外被访问，但是这不是变量不可被回收的充分条件，通常情况下是考虑局部变量是否被全局或者一个不可被回收的对象引用了。</li>\n<li>闭包被引用后始终在内存中，不会在调用结束后被垃圾回收机制回收，可能会造成内存消耗。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 释放闭包引用</span><br><span class=\"line\">p = null;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"闭包的应用场景\"><a href=\"#闭包的应用场景\" class=\"headerlink\" title=\"闭包的应用场景\"></a>闭包的应用场景</h3><h4 id=\"封装变量\"><a href=\"#封装变量\" class=\"headerlink\" title=\"封装变量\"></a>封装变量</h4><p>为避免全局污染，把变量封装到函数作用域中</p>\n<h4 id=\"循环绑定事件处理函数\"><a href=\"#循环绑定事件处理函数\" class=\"headerlink\" title=\"循环绑定事件处理函数\"></a>循环绑定事件处理函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lis = document.getElementsByTagName(&apos;li&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 每循环一次给lis添加一个function，最后lis是这样的 lis[function()&#123;&#125;,function()&#123;&#125;,function()&#123;&#125;]</span><br><span class=\"line\">// 里面有3个function，在for里面声明了function，但还没有立即执行</span><br><span class=\"line\">// 真正执行的时候是当点击li的时候才执行这个函数// 当执行的时候for循环已经结束，i已经变成最后一个取值了，所以每触发一次事件都访问的是等于最后一个取值的i</span><br><span class=\"line\"></span><br><span class=\"line\">for(var i=0;i&lt;lis.length;i++)&#123;</span><br><span class=\"line\">  lis[i].onclick = function()&#123;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">  &#125;;      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 立即执行函数要保护j这个索引值的变量不被污染</span><br><span class=\"line\">for(var i=0;i&lt;lis.length;i++)&#123;</span><br><span class=\"line\">  (function(j)&#123;</span><br><span class=\"line\">      lis[j].onclick = function()&#123;</span><br><span class=\"line\">           console.log(j);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;)(i);       //事件处理函数中闭包的写法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"循环打印\"><a href=\"#循环打印\" class=\"headerlink\" title=\"循环打印\"></a>循环打印</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定时器中的回调函数是一个在立即执行函数中的闭包，单独的立即执行函数能不能叫做闭包说法各有不同。</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">  for(var i = 1;i &lt;= 5;i ++)&#123;</span><br><span class=\"line\">\t(function(j)&#123;</span><br><span class=\"line\">\t\tsetTimeout(function () &#123;</span><br><span class=\"line\">            console.log(j)</span><br><span class=\"line\">        &#125;, 1000)</span><br><span class=\"line\">\t&#125;)(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn() // 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><h4 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h4><p>工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>\n<p>工作流程：</p>\n<ol>\n<li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。</li>\n<li>去掉环境中的变量以及被环境中的变量引用的变量的标记。</li>\n<li>再被加上标记的会被视为准备删除的变量。</li>\n<li>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</li>\n</ol>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>工作原理：跟踪记录每个值被引用的次数。</p>\n<p>工作流程：</p>\n<ol>\n<li>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。</li>\n<li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.</li>\n<li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.</li>\n<li>当引用次数变成0时，说明没办法访问这个值了。</li>\n<li>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。</li>\n</ol>\n<h3 id=\"引起内存泄漏\"><a href=\"#引起内存泄漏\" class=\"headerlink\" title=\"引起内存泄漏\"></a>引起内存泄漏</h3><ol>\n<li>全局变量</li>\n<li>闭包</li>\n<li>原因：都是由于不能被回收</li>\n</ol>\n"},{"title":"js：内存泄漏","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 什么是内存泄露？\n\n应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。\n\n编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了，操作系统可以回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。\n\n### JavaScript 内存管理\n\nJavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可 达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。\n\n### JavaScript 内存泄露\n\n垃圾回收语言的内存泄露主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。\n\n\n\n\n","source":"_posts/js/js：内存泄漏.md","raw":"---\ntitle: js：内存泄漏\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### 什么是内存泄露？\n\n应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。\n\n编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了，操作系统可以回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。\n\n### JavaScript 内存管理\n\nJavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可 达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。\n\n### JavaScript 内存泄露\n\n垃圾回收语言的内存泄露主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。\n\n\n\n\n","slug":"js/js：内存泄漏","published":1,"date":"2020-05-14T08:56:55.460Z","updated":"2020-05-14T09:04:49.958Z","layout":"post","photos":[],"link":"","_id":"cka6kws19002krcu9ohfimjv4","content":"<h3 id=\"什么是内存泄露？\"><a href=\"#什么是内存泄露？\" class=\"headerlink\" title=\"什么是内存泄露？\"></a>什么是内存泄露？</h3><p>应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。</p>\n<p>编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了，操作系统可以回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。</p>\n<h3 id=\"JavaScript-内存管理\"><a href=\"#JavaScript-内存管理\" class=\"headerlink\" title=\"JavaScript 内存管理\"></a>JavaScript 内存管理</h3><p>JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可 达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。</p>\n<h3 id=\"JavaScript-内存泄露\"><a href=\"#JavaScript-内存泄露\" class=\"headerlink\" title=\"JavaScript 内存泄露\"></a>JavaScript 内存泄露</h3><p>垃圾回收语言的内存泄露主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是内存泄露？\"><a href=\"#什么是内存泄露？\" class=\"headerlink\" title=\"什么是内存泄露？\"></a>什么是内存泄露？</h3><p>应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。</p>\n<p>编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了，操作系统可以回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。</p>\n<h3 id=\"JavaScript-内存管理\"><a href=\"#JavaScript-内存管理\" class=\"headerlink\" title=\"JavaScript 内存管理\"></a>JavaScript 内存管理</h3><p>JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可 达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。</p>\n<h3 id=\"JavaScript-内存泄露\"><a href=\"#JavaScript-内存泄露\" class=\"headerlink\" title=\"JavaScript 内存泄露\"></a>JavaScript 内存泄露</h3><p>垃圾回收语言的内存泄露主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。</p>\n"},{"title":"js：判断一个空对象或空数组","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 判断一个空对象\n```\nfunction isEmptyObject(obj){\n    if(JSON.stringify(obj) == \"{}\"){\n        console.log(\"是空对象\");\n    }else{\n        console.log(\"不是空对象\");\n    }\n}\n```\n### 判断一个空数组\n\n```\nfunction isEmptyArray(arr){\n    if(JSON.stringify(srr) == \"[]\"){\n        console.log(\"是空数组\");\n    }else{\n        console.log(\"不是空数组\");\n    }\n}\n```\n\n```\nfunction isEmptyArray(arr){\n    if(arr == false){\n        console.log(\"是空数组\");\n    }else{\n        console.log(\"不是空数组\");\n    }\n}\n```\n```\nfunction isEmptyArray(arr){\n    if(arr.length == 0){\n        console.log(\"是空数组\");\n    }else{\n        console.log(\"不是空数组\");\n    }\n}\n```\n### 拓展：判断数组\n\n```\n1. Array.isArray(arr)\n2. arr instanceof Array\n3. object.prototype.toString.call(arr) === '[object Array]'\n4. arr.constructor === Array\n```\n","source":"_posts/js/js：判断一个空对象或空数组.md","raw":"---\ntitle: js：判断一个空对象或空数组\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 判断一个空对象\n```\nfunction isEmptyObject(obj){\n    if(JSON.stringify(obj) == \"{}\"){\n        console.log(\"是空对象\");\n    }else{\n        console.log(\"不是空对象\");\n    }\n}\n```\n### 判断一个空数组\n\n```\nfunction isEmptyArray(arr){\n    if(JSON.stringify(srr) == \"[]\"){\n        console.log(\"是空数组\");\n    }else{\n        console.log(\"不是空数组\");\n    }\n}\n```\n\n```\nfunction isEmptyArray(arr){\n    if(arr == false){\n        console.log(\"是空数组\");\n    }else{\n        console.log(\"不是空数组\");\n    }\n}\n```\n```\nfunction isEmptyArray(arr){\n    if(arr.length == 0){\n        console.log(\"是空数组\");\n    }else{\n        console.log(\"不是空数组\");\n    }\n}\n```\n### 拓展：判断数组\n\n```\n1. Array.isArray(arr)\n2. arr instanceof Array\n3. object.prototype.toString.call(arr) === '[object Array]'\n4. arr.constructor === Array\n```\n","slug":"js/js：判断一个空对象或空数组","published":1,"date":"2020-05-14T08:56:04.398Z","updated":"2020-05-14T09:03:31.237Z","layout":"post","photos":[],"link":"","_id":"cka6kws1k002nrcu9ui7uukie","content":"<h3 id=\"判断一个空对象\"><a href=\"#判断一个空对象\" class=\"headerlink\" title=\"判断一个空对象\"></a>判断一个空对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isEmptyObject(obj)&#123;</span><br><span class=\"line\">    if(JSON.stringify(obj) == &quot;&#123;&#125;&quot;)&#123;</span><br><span class=\"line\">        console.log(&quot;是空对象&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(&quot;不是空对象&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"判断一个空数组\"><a href=\"#判断一个空数组\" class=\"headerlink\" title=\"判断一个空数组\"></a>判断一个空数组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isEmptyArray(arr)&#123;</span><br><span class=\"line\">    if(JSON.stringify(srr) == &quot;[]&quot;)&#123;</span><br><span class=\"line\">        console.log(&quot;是空数组&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(&quot;不是空数组&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isEmptyArray(arr)&#123;</span><br><span class=\"line\">    if(arr == false)&#123;</span><br><span class=\"line\">        console.log(&quot;是空数组&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(&quot;不是空数组&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isEmptyArray(arr)&#123;</span><br><span class=\"line\">    if(arr.length == 0)&#123;</span><br><span class=\"line\">        console.log(&quot;是空数组&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(&quot;不是空数组&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拓展：判断数组\"><a href=\"#拓展：判断数组\" class=\"headerlink\" title=\"拓展：判断数组\"></a>拓展：判断数组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Array.isArray(arr)</span><br><span class=\"line\">2. arr instanceof Array</span><br><span class=\"line\">3. object.prototype.toString.call(arr) === &apos;[object Array]&apos;</span><br><span class=\"line\">4. arr.constructor === Array</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"判断一个空对象\"><a href=\"#判断一个空对象\" class=\"headerlink\" title=\"判断一个空对象\"></a>判断一个空对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isEmptyObject(obj)&#123;</span><br><span class=\"line\">    if(JSON.stringify(obj) == &quot;&#123;&#125;&quot;)&#123;</span><br><span class=\"line\">        console.log(&quot;是空对象&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(&quot;不是空对象&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"判断一个空数组\"><a href=\"#判断一个空数组\" class=\"headerlink\" title=\"判断一个空数组\"></a>判断一个空数组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isEmptyArray(arr)&#123;</span><br><span class=\"line\">    if(JSON.stringify(srr) == &quot;[]&quot;)&#123;</span><br><span class=\"line\">        console.log(&quot;是空数组&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(&quot;不是空数组&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isEmptyArray(arr)&#123;</span><br><span class=\"line\">    if(arr == false)&#123;</span><br><span class=\"line\">        console.log(&quot;是空数组&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(&quot;不是空数组&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isEmptyArray(arr)&#123;</span><br><span class=\"line\">    if(arr.length == 0)&#123;</span><br><span class=\"line\">        console.log(&quot;是空数组&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(&quot;不是空数组&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拓展：判断数组\"><a href=\"#拓展：判断数组\" class=\"headerlink\" title=\"拓展：判断数组\"></a>拓展：判断数组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Array.isArray(arr)</span><br><span class=\"line\">2. arr instanceof Array</span><br><span class=\"line\">3. object.prototype.toString.call(arr) === &apos;[object Array]&apos;</span><br><span class=\"line\">4. arr.constructor === Array</span><br></pre></td></tr></table></figure>\n"},{"title":"js：发布-订阅和观察者","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n![image](https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)\n\n## 观察者模式（自定义事件）\n目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。\n\n```\n// 观察者(订阅者)\nfunction Observer(name) {\n\tthis.name = name;\n}\nObserver.prototype = {\n\tupdate: function(context) {\n\t\tconsole.log(this.name + \"：\" + context);\n\t}\n}\n\n// 观察者(订阅者)列表\nfunction ObserverList() {\n\tthis.observerList = [];\n}\n\nObserverList.prototype = {\n\tadd: function(obj) {\n\t\treturn this.observerList.push(obj);\n\t},\n\tcount: function() {\n\t\treturn this.observerList.length;\n\t},\n\tget: function(index) {\n\t\tif (index > -1 && index < this.observerList.length) {\n\t\t\treturn this.observerList[index];\n\t\t}\n\t},\n\tremoveAt: function(index) {\n\t\tthis.observerList.splice(index, 1);\n\t}\n}\n\n\n// 目标(发布者)\nfunction Subject() {\n\tthis.observers = new ObserverList();\n}\n\nSubject.prototype = {\n\taddObsever: function(observer) {\n\t\tthis.observers.add(observer);\n\t},\n\n\tremoveObsever: function(observer) {\n\t\tthis.observers.removeAt(this.observers.indexOf(observer, 0));\n\t},\n\n\tnotify: function(context) {\n\t\tvar observerCount = this.observers.count();\n\t\tfor (var i = 0; i < observerCount; i++) {\n\t\t\tthis.observers.get(i).update(context);\n\t\t}\n\t}\n}\n\n\nvar mySubject = new Subject();\nmySubject.addObsever(new Observer(\"小明\"));\nmySubject.addObsever(new Observer(\"小红\"));\nmySubject.notify(\"hello world\");\n\t\n```\n\n\n## 发布-订阅\n### 理解\n发布-订阅模式，用个对象作为调度中心，绑定事件名为属性。订阅者把自己想订阅的事件注册到调度中心，发布者发布事件到调度中心时，即触发这个事件，由调度中心统一调度订阅者注册到调度中心的处理代码。\n\n### 优点\n- 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。\n- 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。\n\n### 缺点\n- 创建订阅者需要消耗一定的时间和内存。\n- 虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。\n\n\n### 一个简单的发布订阅\n\n```\nvar event = {\n  clientList: {},\n  listen: function( key, fn ){             //添加订阅对象\n      if( !this.clientList[ key ] ){\n         this.clientList[ key ] = [];\n      }\n      this.clientList[ key ].push( fn );\n  }, \n  trigger: function(){                     //绑定发布事件\n     var key = Array.prototype.shift.apply( arguments ),\n         fns = this.clientList[ key ];\n     for( var i = 0, fn; fn = fns[ i++]; ){\n        fn.apply( this, arguments );\n     }\n  },\n  remove: function( key, fn ){            //取消订阅的事件\n     var fns = this.clientList[ key ];\n     \n     if( !fns ){                          //如果key对应的消息没有被人订阅，则直接返回  \n        return false;\n     };\n     if( !fn ){                           //如果没有传入具体的回调函数，标示取消key对应消息的所有订阅 \n        fns = [];\n     }else{\n        for( var i = fns.length - 1; i >= 0 ; i-- ){  //取消key对应的订阅消息\n            if( fn === fns[ i ] ){\n               fns.splice( i, 1 );\n            }\n        }\n     }\n     \n  }\n};\n\nvar saleOffices = {};\n//给对象绑定一个调度中心\nvar installEvent = function( obj ){\n  for( i in event ){\n    obj[ i ] = event[ i ];\n  }\n};\n\ninstallEvent( saleOffices );\nsaleOffices.listen( \"squareMeter88\", fn1 = function( price ){\n   console.log( \"价格\" + price );\n} );\nsaleOffices.listen( \"squareMeter88\", function( price ){\n   console.log( \"价格\" + price );\n} );\nsaleOffices.remove( \"squareMeter88\", fn1 );\nsaleOffices.trigger( \"squareMeter88\", 200000 );\n\n```\n\n\n## 不同\n观察者模式的订阅者和发布者之间是存在依赖的，发布订阅模式的不会。\n","source":"_posts/js/js：发布-订阅和观察者.md","raw":"---\ntitle: js：发布-订阅和观察者\nDate: 2019-03-26\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n![image](https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)\n\n## 观察者模式（自定义事件）\n目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。\n\n```\n// 观察者(订阅者)\nfunction Observer(name) {\n\tthis.name = name;\n}\nObserver.prototype = {\n\tupdate: function(context) {\n\t\tconsole.log(this.name + \"：\" + context);\n\t}\n}\n\n// 观察者(订阅者)列表\nfunction ObserverList() {\n\tthis.observerList = [];\n}\n\nObserverList.prototype = {\n\tadd: function(obj) {\n\t\treturn this.observerList.push(obj);\n\t},\n\tcount: function() {\n\t\treturn this.observerList.length;\n\t},\n\tget: function(index) {\n\t\tif (index > -1 && index < this.observerList.length) {\n\t\t\treturn this.observerList[index];\n\t\t}\n\t},\n\tremoveAt: function(index) {\n\t\tthis.observerList.splice(index, 1);\n\t}\n}\n\n\n// 目标(发布者)\nfunction Subject() {\n\tthis.observers = new ObserverList();\n}\n\nSubject.prototype = {\n\taddObsever: function(observer) {\n\t\tthis.observers.add(observer);\n\t},\n\n\tremoveObsever: function(observer) {\n\t\tthis.observers.removeAt(this.observers.indexOf(observer, 0));\n\t},\n\n\tnotify: function(context) {\n\t\tvar observerCount = this.observers.count();\n\t\tfor (var i = 0; i < observerCount; i++) {\n\t\t\tthis.observers.get(i).update(context);\n\t\t}\n\t}\n}\n\n\nvar mySubject = new Subject();\nmySubject.addObsever(new Observer(\"小明\"));\nmySubject.addObsever(new Observer(\"小红\"));\nmySubject.notify(\"hello world\");\n\t\n```\n\n\n## 发布-订阅\n### 理解\n发布-订阅模式，用个对象作为调度中心，绑定事件名为属性。订阅者把自己想订阅的事件注册到调度中心，发布者发布事件到调度中心时，即触发这个事件，由调度中心统一调度订阅者注册到调度中心的处理代码。\n\n### 优点\n- 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。\n- 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。\n\n### 缺点\n- 创建订阅者需要消耗一定的时间和内存。\n- 虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。\n\n\n### 一个简单的发布订阅\n\n```\nvar event = {\n  clientList: {},\n  listen: function( key, fn ){             //添加订阅对象\n      if( !this.clientList[ key ] ){\n         this.clientList[ key ] = [];\n      }\n      this.clientList[ key ].push( fn );\n  }, \n  trigger: function(){                     //绑定发布事件\n     var key = Array.prototype.shift.apply( arguments ),\n         fns = this.clientList[ key ];\n     for( var i = 0, fn; fn = fns[ i++]; ){\n        fn.apply( this, arguments );\n     }\n  },\n  remove: function( key, fn ){            //取消订阅的事件\n     var fns = this.clientList[ key ];\n     \n     if( !fns ){                          //如果key对应的消息没有被人订阅，则直接返回  \n        return false;\n     };\n     if( !fn ){                           //如果没有传入具体的回调函数，标示取消key对应消息的所有订阅 \n        fns = [];\n     }else{\n        for( var i = fns.length - 1; i >= 0 ; i-- ){  //取消key对应的订阅消息\n            if( fn === fns[ i ] ){\n               fns.splice( i, 1 );\n            }\n        }\n     }\n     \n  }\n};\n\nvar saleOffices = {};\n//给对象绑定一个调度中心\nvar installEvent = function( obj ){\n  for( i in event ){\n    obj[ i ] = event[ i ];\n  }\n};\n\ninstallEvent( saleOffices );\nsaleOffices.listen( \"squareMeter88\", fn1 = function( price ){\n   console.log( \"价格\" + price );\n} );\nsaleOffices.listen( \"squareMeter88\", function( price ){\n   console.log( \"价格\" + price );\n} );\nsaleOffices.remove( \"squareMeter88\", fn1 );\nsaleOffices.trigger( \"squareMeter88\", 200000 );\n\n```\n\n\n## 不同\n观察者模式的订阅者和发布者之间是存在依赖的，发布订阅模式的不会。\n","slug":"js/js：发布-订阅和观察者","published":1,"date":"2019-03-26T07:49:12.352Z","updated":"2020-05-14T09:09:15.795Z","layout":"post","photos":[],"link":"","_id":"cka6kws1q002qrcu9mxx4rdnj","content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000\" alt=\"image\"></p>\n<h2 id=\"观察者模式（自定义事件）\"><a href=\"#观察者模式（自定义事件）\" class=\"headerlink\" title=\"观察者模式（自定义事件）\"></a>观察者模式（自定义事件）</h2><p>目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 观察者(订阅者)</span><br><span class=\"line\">function Observer(name) &#123;</span><br><span class=\"line\">\tthis.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Observer.prototype = &#123;</span><br><span class=\"line\">\tupdate: function(context) &#123;</span><br><span class=\"line\">\t\tconsole.log(this.name + &quot;：&quot; + context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 观察者(订阅者)列表</span><br><span class=\"line\">function ObserverList() &#123;</span><br><span class=\"line\">\tthis.observerList = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ObserverList.prototype = &#123;</span><br><span class=\"line\">\tadd: function(obj) &#123;</span><br><span class=\"line\">\t\treturn this.observerList.push(obj);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcount: function() &#123;</span><br><span class=\"line\">\t\treturn this.observerList.length;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tget: function(index) &#123;</span><br><span class=\"line\">\t\tif (index &gt; -1 &amp;&amp; index &lt; this.observerList.length) &#123;</span><br><span class=\"line\">\t\t\treturn this.observerList[index];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tremoveAt: function(index) &#123;</span><br><span class=\"line\">\t\tthis.observerList.splice(index, 1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 目标(发布者)</span><br><span class=\"line\">function Subject() &#123;</span><br><span class=\"line\">\tthis.observers = new ObserverList();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Subject.prototype = &#123;</span><br><span class=\"line\">\taddObsever: function(observer) &#123;</span><br><span class=\"line\">\t\tthis.observers.add(observer);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\tremoveObsever: function(observer) &#123;</span><br><span class=\"line\">\t\tthis.observers.removeAt(this.observers.indexOf(observer, 0));</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\tnotify: function(context) &#123;</span><br><span class=\"line\">\t\tvar observerCount = this.observers.count();</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; observerCount; i++) &#123;</span><br><span class=\"line\">\t\t\tthis.observers.get(i).update(context);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var mySubject = new Subject();</span><br><span class=\"line\">mySubject.addObsever(new Observer(&quot;小明&quot;));</span><br><span class=\"line\">mySubject.addObsever(new Observer(&quot;小红&quot;));</span><br><span class=\"line\">mySubject.notify(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"发布-订阅\"><a href=\"#发布-订阅\" class=\"headerlink\" title=\"发布-订阅\"></a>发布-订阅</h2><h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>发布-订阅模式，用个对象作为调度中心，绑定事件名为属性。订阅者把自己想订阅的事件注册到调度中心，发布者发布事件到调度中心时，即触发这个事件，由调度中心统一调度订阅者注册到调度中心的处理代码。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。</li>\n<li>发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>创建订阅者需要消耗一定的时间和内存。</li>\n<li>虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。</li>\n</ul>\n<h3 id=\"一个简单的发布订阅\"><a href=\"#一个简单的发布订阅\" class=\"headerlink\" title=\"一个简单的发布订阅\"></a>一个简单的发布订阅</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var event = &#123;</span><br><span class=\"line\">  clientList: &#123;&#125;,</span><br><span class=\"line\">  listen: function( key, fn )&#123;             //添加订阅对象</span><br><span class=\"line\">      if( !this.clientList[ key ] )&#123;</span><br><span class=\"line\">         this.clientList[ key ] = [];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.clientList[ key ].push( fn );</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">  trigger: function()&#123;                     //绑定发布事件</span><br><span class=\"line\">     var key = Array.prototype.shift.apply( arguments ),</span><br><span class=\"line\">         fns = this.clientList[ key ];</span><br><span class=\"line\">     for( var i = 0, fn; fn = fns[ i++]; )&#123;</span><br><span class=\"line\">        fn.apply( this, arguments );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  remove: function( key, fn )&#123;            //取消订阅的事件</span><br><span class=\"line\">     var fns = this.clientList[ key ];</span><br><span class=\"line\">     </span><br><span class=\"line\">     if( !fns )&#123;                          //如果key对应的消息没有被人订阅，则直接返回  </span><br><span class=\"line\">        return false;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">     if( !fn )&#123;                           //如果没有传入具体的回调函数，标示取消key对应消息的所有订阅 </span><br><span class=\"line\">        fns = [];</span><br><span class=\"line\">     &#125;else&#123;</span><br><span class=\"line\">        for( var i = fns.length - 1; i &gt;= 0 ; i-- )&#123;  //取消key对应的订阅消息</span><br><span class=\"line\">            if( fn === fns[ i ] )&#123;</span><br><span class=\"line\">               fns.splice( i, 1 );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var saleOffices = &#123;&#125;;</span><br><span class=\"line\">//给对象绑定一个调度中心</span><br><span class=\"line\">var installEvent = function( obj )&#123;</span><br><span class=\"line\">  for( i in event )&#123;</span><br><span class=\"line\">    obj[ i ] = event[ i ];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">installEvent( saleOffices );</span><br><span class=\"line\">saleOffices.listen( &quot;squareMeter88&quot;, fn1 = function( price )&#123;</span><br><span class=\"line\">   console.log( &quot;价格&quot; + price );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\">saleOffices.listen( &quot;squareMeter88&quot;, function( price )&#123;</span><br><span class=\"line\">   console.log( &quot;价格&quot; + price );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\">saleOffices.remove( &quot;squareMeter88&quot;, fn1 );</span><br><span class=\"line\">saleOffices.trigger( &quot;squareMeter88&quot;, 200000 );</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同\"><a href=\"#不同\" class=\"headerlink\" title=\"不同\"></a>不同</h2><p>观察者模式的订阅者和发布者之间是存在依赖的，发布订阅模式的不会。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000\" alt=\"image\"></p>\n<h2 id=\"观察者模式（自定义事件）\"><a href=\"#观察者模式（自定义事件）\" class=\"headerlink\" title=\"观察者模式（自定义事件）\"></a>观察者模式（自定义事件）</h2><p>目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 观察者(订阅者)</span><br><span class=\"line\">function Observer(name) &#123;</span><br><span class=\"line\">\tthis.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Observer.prototype = &#123;</span><br><span class=\"line\">\tupdate: function(context) &#123;</span><br><span class=\"line\">\t\tconsole.log(this.name + &quot;：&quot; + context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 观察者(订阅者)列表</span><br><span class=\"line\">function ObserverList() &#123;</span><br><span class=\"line\">\tthis.observerList = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ObserverList.prototype = &#123;</span><br><span class=\"line\">\tadd: function(obj) &#123;</span><br><span class=\"line\">\t\treturn this.observerList.push(obj);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcount: function() &#123;</span><br><span class=\"line\">\t\treturn this.observerList.length;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tget: function(index) &#123;</span><br><span class=\"line\">\t\tif (index &gt; -1 &amp;&amp; index &lt; this.observerList.length) &#123;</span><br><span class=\"line\">\t\t\treturn this.observerList[index];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tremoveAt: function(index) &#123;</span><br><span class=\"line\">\t\tthis.observerList.splice(index, 1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 目标(发布者)</span><br><span class=\"line\">function Subject() &#123;</span><br><span class=\"line\">\tthis.observers = new ObserverList();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Subject.prototype = &#123;</span><br><span class=\"line\">\taddObsever: function(observer) &#123;</span><br><span class=\"line\">\t\tthis.observers.add(observer);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\tremoveObsever: function(observer) &#123;</span><br><span class=\"line\">\t\tthis.observers.removeAt(this.observers.indexOf(observer, 0));</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\tnotify: function(context) &#123;</span><br><span class=\"line\">\t\tvar observerCount = this.observers.count();</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; observerCount; i++) &#123;</span><br><span class=\"line\">\t\t\tthis.observers.get(i).update(context);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var mySubject = new Subject();</span><br><span class=\"line\">mySubject.addObsever(new Observer(&quot;小明&quot;));</span><br><span class=\"line\">mySubject.addObsever(new Observer(&quot;小红&quot;));</span><br><span class=\"line\">mySubject.notify(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"发布-订阅\"><a href=\"#发布-订阅\" class=\"headerlink\" title=\"发布-订阅\"></a>发布-订阅</h2><h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>发布-订阅模式，用个对象作为调度中心，绑定事件名为属性。订阅者把自己想订阅的事件注册到调度中心，发布者发布事件到调度中心时，即触发这个事件，由调度中心统一调度订阅者注册到调度中心的处理代码。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。</li>\n<li>发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>创建订阅者需要消耗一定的时间和内存。</li>\n<li>虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。</li>\n</ul>\n<h3 id=\"一个简单的发布订阅\"><a href=\"#一个简单的发布订阅\" class=\"headerlink\" title=\"一个简单的发布订阅\"></a>一个简单的发布订阅</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var event = &#123;</span><br><span class=\"line\">  clientList: &#123;&#125;,</span><br><span class=\"line\">  listen: function( key, fn )&#123;             //添加订阅对象</span><br><span class=\"line\">      if( !this.clientList[ key ] )&#123;</span><br><span class=\"line\">         this.clientList[ key ] = [];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.clientList[ key ].push( fn );</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">  trigger: function()&#123;                     //绑定发布事件</span><br><span class=\"line\">     var key = Array.prototype.shift.apply( arguments ),</span><br><span class=\"line\">         fns = this.clientList[ key ];</span><br><span class=\"line\">     for( var i = 0, fn; fn = fns[ i++]; )&#123;</span><br><span class=\"line\">        fn.apply( this, arguments );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  remove: function( key, fn )&#123;            //取消订阅的事件</span><br><span class=\"line\">     var fns = this.clientList[ key ];</span><br><span class=\"line\">     </span><br><span class=\"line\">     if( !fns )&#123;                          //如果key对应的消息没有被人订阅，则直接返回  </span><br><span class=\"line\">        return false;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">     if( !fn )&#123;                           //如果没有传入具体的回调函数，标示取消key对应消息的所有订阅 </span><br><span class=\"line\">        fns = [];</span><br><span class=\"line\">     &#125;else&#123;</span><br><span class=\"line\">        for( var i = fns.length - 1; i &gt;= 0 ; i-- )&#123;  //取消key对应的订阅消息</span><br><span class=\"line\">            if( fn === fns[ i ] )&#123;</span><br><span class=\"line\">               fns.splice( i, 1 );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var saleOffices = &#123;&#125;;</span><br><span class=\"line\">//给对象绑定一个调度中心</span><br><span class=\"line\">var installEvent = function( obj )&#123;</span><br><span class=\"line\">  for( i in event )&#123;</span><br><span class=\"line\">    obj[ i ] = event[ i ];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">installEvent( saleOffices );</span><br><span class=\"line\">saleOffices.listen( &quot;squareMeter88&quot;, fn1 = function( price )&#123;</span><br><span class=\"line\">   console.log( &quot;价格&quot; + price );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\">saleOffices.listen( &quot;squareMeter88&quot;, function( price )&#123;</span><br><span class=\"line\">   console.log( &quot;价格&quot; + price );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\">saleOffices.remove( &quot;squareMeter88&quot;, fn1 );</span><br><span class=\"line\">saleOffices.trigger( &quot;squareMeter88&quot;, 200000 );</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同\"><a href=\"#不同\" class=\"headerlink\" title=\"不同\"></a>不同</h2><p>观察者模式的订阅者和发布者之间是存在依赖的，发布订阅模式的不会。</p>\n"},{"title":"js：基础类型和引用类型","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 基础类型\n- undefined，null，boolean，string，number\n- 在内存中是栈存储，自动分配内存，自动释放\n\n### 引用类型\n- array，object，function，date，regExp，特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)\n- 在内存中是堆存储，动态分配内存，大小不定，不会自动释放","source":"_posts/js/js：基础类型和引用类型.md","raw":"---\ntitle: js：基础类型和引用类型\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### 基础类型\n- undefined，null，boolean，string，number\n- 在内存中是栈存储，自动分配内存，自动释放\n\n### 引用类型\n- array，object，function，date，regExp，特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)\n- 在内存中是堆存储，动态分配内存，大小不定，不会自动释放","slug":"js/js：基础类型和引用类型","published":1,"date":"2020-05-14T08:57:27.255Z","updated":"2020-05-14T09:04:22.735Z","layout":"post","photos":[],"link":"","_id":"cka6kws1v002trcu9dvu2yd0d","content":"<h3 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h3><ul>\n<li>undefined，null，boolean，string，number</li>\n<li>在内存中是栈存储，自动分配内存，自动释放</li>\n</ul>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><ul>\n<li>array，object，function，date，regExp，特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)</li>\n<li>在内存中是堆存储，动态分配内存，大小不定，不会自动释放</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h3><ul>\n<li>undefined，null，boolean，string，number</li>\n<li>在内存中是栈存储，自动分配内存，自动释放</li>\n</ul>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><ul>\n<li>array，object，function，date，regExp，特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)</li>\n<li>在内存中是堆存储，动态分配内存，大小不定，不会自动释放</li>\n</ul>\n"},{"title":"js：字符串常用的方法","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n- charAt(index) \n```\n返回指定索引的字符。\n```\n- charCodeAt(index)\n```\n返回指定索引的unicode字符.\n```\n- indexOf(char)\n```\n判断一个字符第一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。对大小写敏感。\n```\n- lastIndexOf(char)\n```\n判断一个字符最后一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。\n```\n- concat()   (返回一个新字符串)\n```\n拼接2个字符串，返回一个新字符串，对原有字符串没有任何改变。\nvar str='qwe';\nvar str1='abc';\nvar str2=str.concat(str1);\n\nconsole.log(str2);//\"qweabc\"\n```\n- substr(start,number)  (不修改原字符串)\n```\n从索引start开始，截取number个字符，将截取的字符返回。start可正可负。\n```\n- substring(start,end)  (不修改原字符串)\n```\n从索引start开始，截取到索引end,不包括end.将截取的字符返回。start,end正值。\n```\n- slice(start,end)  (不修改原字符串)\n```\n从索引start开始，截取到索引end,不包括end。将截取的字符返回。start,end可正可负。\n```\n- split(\"分割符\"[,limit]) (返回数组，不修改原字符串)\n```\n用指定字符分割字符串，返回一个数组。默认每个字符都分割。\n```\n- replace(reg,new) (不修改原字符串)\n```\n替换指定字符，返回替换后新的字符串，不会对原有字符串有改变。\nvar str='aaaaee';\nvar reg=/a/g;\nstr.replace(reg,1);   //\"1111ee\"\nconsole.log(str);     //\"aaaaee\"\n```\n- match(reg) (返回一个数组)\n```\n可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。把符合正则表达式的字符放在数组里，返回一个数组。\n```\n- search(reg) \n```\n方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配字符串的第一个字符的位置。没有匹配的则返回-1。\n\n```\n","source":"_posts/js/js：字符串常用的方法.md","raw":"---\ntitle: js：字符串常用的方法\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n- charAt(index) \n```\n返回指定索引的字符。\n```\n- charCodeAt(index)\n```\n返回指定索引的unicode字符.\n```\n- indexOf(char)\n```\n判断一个字符第一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。对大小写敏感。\n```\n- lastIndexOf(char)\n```\n判断一个字符最后一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。\n```\n- concat()   (返回一个新字符串)\n```\n拼接2个字符串，返回一个新字符串，对原有字符串没有任何改变。\nvar str='qwe';\nvar str1='abc';\nvar str2=str.concat(str1);\n\nconsole.log(str2);//\"qweabc\"\n```\n- substr(start,number)  (不修改原字符串)\n```\n从索引start开始，截取number个字符，将截取的字符返回。start可正可负。\n```\n- substring(start,end)  (不修改原字符串)\n```\n从索引start开始，截取到索引end,不包括end.将截取的字符返回。start,end正值。\n```\n- slice(start,end)  (不修改原字符串)\n```\n从索引start开始，截取到索引end,不包括end。将截取的字符返回。start,end可正可负。\n```\n- split(\"分割符\"[,limit]) (返回数组，不修改原字符串)\n```\n用指定字符分割字符串，返回一个数组。默认每个字符都分割。\n```\n- replace(reg,new) (不修改原字符串)\n```\n替换指定字符，返回替换后新的字符串，不会对原有字符串有改变。\nvar str='aaaaee';\nvar reg=/a/g;\nstr.replace(reg,1);   //\"1111ee\"\nconsole.log(str);     //\"aaaaee\"\n```\n- match(reg) (返回一个数组)\n```\n可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。把符合正则表达式的字符放在数组里，返回一个数组。\n```\n- search(reg) \n```\n方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配字符串的第一个字符的位置。没有匹配的则返回-1。\n\n```\n","slug":"js/js：字符串常用的方法","published":1,"date":"2020-05-14T08:56:43.531Z","updated":"2020-05-14T09:02:13.112Z","layout":"post","photos":[],"link":"","_id":"cka6kws21002wrcu9ho090rff","content":"<ul>\n<li><p>charAt(index) </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回指定索引的字符。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>charCodeAt(index)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回指定索引的unicode字符.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>indexOf(char)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断一个字符第一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。对大小写敏感。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lastIndexOf(char)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断一个字符最后一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>concat()   (返回一个新字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">拼接2个字符串，返回一个新字符串，对原有字符串没有任何改变。</span><br><span class=\"line\">var str=&apos;qwe&apos;;</span><br><span class=\"line\">var str1=&apos;abc&apos;;</span><br><span class=\"line\">var str2=str.concat(str1);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str2);//&quot;qweabc&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>substr(start,number)  (不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从索引start开始，截取number个字符，将截取的字符返回。start可正可负。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>substring(start,end)  (不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从索引start开始，截取到索引end,不包括end.将截取的字符返回。start,end正值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>slice(start,end)  (不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从索引start开始，截取到索引end,不包括end。将截取的字符返回。start,end可正可负。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>split(“分割符”[,limit]) (返回数组，不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用指定字符分割字符串，返回一个数组。默认每个字符都分割。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>replace(reg,new) (不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">替换指定字符，返回替换后新的字符串，不会对原有字符串有改变。</span><br><span class=\"line\">var str=&apos;aaaaee&apos;;</span><br><span class=\"line\">var reg=/a/g;</span><br><span class=\"line\">str.replace(reg,1);   //&quot;1111ee&quot;</span><br><span class=\"line\">console.log(str);     //&quot;aaaaee&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>match(reg) (返回一个数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。把符合正则表达式的字符放在数组里，返回一个数组。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>search(reg) </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配字符串的第一个字符的位置。没有匹配的则返回-1。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>charAt(index) </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回指定索引的字符。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>charCodeAt(index)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回指定索引的unicode字符.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>indexOf(char)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断一个字符第一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。对大小写敏感。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lastIndexOf(char)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断一个字符最后一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>concat()   (返回一个新字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">拼接2个字符串，返回一个新字符串，对原有字符串没有任何改变。</span><br><span class=\"line\">var str=&apos;qwe&apos;;</span><br><span class=\"line\">var str1=&apos;abc&apos;;</span><br><span class=\"line\">var str2=str.concat(str1);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str2);//&quot;qweabc&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>substr(start,number)  (不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从索引start开始，截取number个字符，将截取的字符返回。start可正可负。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>substring(start,end)  (不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从索引start开始，截取到索引end,不包括end.将截取的字符返回。start,end正值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>slice(start,end)  (不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从索引start开始，截取到索引end,不包括end。将截取的字符返回。start,end可正可负。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>split(“分割符”[,limit]) (返回数组，不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用指定字符分割字符串，返回一个数组。默认每个字符都分割。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>replace(reg,new) (不修改原字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">替换指定字符，返回替换后新的字符串，不会对原有字符串有改变。</span><br><span class=\"line\">var str=&apos;aaaaee&apos;;</span><br><span class=\"line\">var reg=/a/g;</span><br><span class=\"line\">str.replace(reg,1);   //&quot;1111ee&quot;</span><br><span class=\"line\">console.log(str);     //&quot;aaaaee&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>match(reg) (返回一个数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。把符合正则表达式的字符放在数组里，返回一个数组。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>search(reg) </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配字符串的第一个字符的位置。没有匹配的则返回-1。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"js：实现给数字添加千分位符的方法","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n### toLocaleString方法\n\n```\nconst num = 12345678;\nnum.toLocaleString();\n```\n\ntoLacalString：返回这个数字在特定语言环境下的表示字符串。\n\n在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串。\n\n### 正则表达式\n\n```\nconst num = 12345678;\nvar reg=/\\d{1,3}(?=(\\d{3})+$)/g;\nnum.replace(reg,\"$&,\");\n\n1. 正则表达式 \\d{1,3}(?=(\\d{3})+$)  表示前面有1~3个数字，后面的至少由一组3个数字结尾。\n2. ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。\n3. $& 表示与正则表达式相匹配的内容。\n```\n","source":"_posts/js/js：实现给数字添加千分位符的方法.md","raw":"---\ntitle: js：实现给数字添加千分位符的方法\nDate: 2019-03-26\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### toLocaleString方法\n\n```\nconst num = 12345678;\nnum.toLocaleString();\n```\n\ntoLacalString：返回这个数字在特定语言环境下的表示字符串。\n\n在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串。\n\n### 正则表达式\n\n```\nconst num = 12345678;\nvar reg=/\\d{1,3}(?=(\\d{3})+$)/g;\nnum.replace(reg,\"$&,\");\n\n1. 正则表达式 \\d{1,3}(?=(\\d{3})+$)  表示前面有1~3个数字，后面的至少由一组3个数字结尾。\n2. ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。\n3. $& 表示与正则表达式相匹配的内容。\n```\n","slug":"js/js：实现给数字添加千分位符的方法","published":1,"date":"2019-03-26T07:49:30.873Z","updated":"2020-05-14T09:10:39.651Z","layout":"post","photos":[],"link":"","_id":"cka6kws27002zrcu9guflfcsy","content":"<h3 id=\"toLocaleString方法\"><a href=\"#toLocaleString方法\" class=\"headerlink\" title=\"toLocaleString方法\"></a>toLocaleString方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const num = 12345678;</span><br><span class=\"line\">num.toLocaleString();</span><br></pre></td></tr></table></figure>\n<p>toLacalString：返回这个数字在特定语言环境下的表示字符串。</p>\n<p>在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串。</p>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const num = 12345678;</span><br><span class=\"line\">var reg=/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g;</span><br><span class=\"line\">num.replace(reg,&quot;$&amp;,&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">1. 正则表达式 \\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)  表示前面有1~3个数字，后面的至少由一组3个数字结尾。</span><br><span class=\"line\">2. ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。</span><br><span class=\"line\">3. $&amp; 表示与正则表达式相匹配的内容。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"toLocaleString方法\"><a href=\"#toLocaleString方法\" class=\"headerlink\" title=\"toLocaleString方法\"></a>toLocaleString方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const num = 12345678;</span><br><span class=\"line\">num.toLocaleString();</span><br></pre></td></tr></table></figure>\n<p>toLacalString：返回这个数字在特定语言环境下的表示字符串。</p>\n<p>在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串。</p>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const num = 12345678;</span><br><span class=\"line\">var reg=/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g;</span><br><span class=\"line\">num.replace(reg,&quot;$&amp;,&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">1. 正则表达式 \\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)  表示前面有1~3个数字，后面的至少由一组3个数字结尾。</span><br><span class=\"line\">2. ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。</span><br><span class=\"line\">3. $&amp; 表示与正则表达式相匹配的内容。</span><br></pre></td></tr></table></figure>\n"},{"title":"js：数组去重","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\nES5\n\n```\nfunction unique(arr){\n    var temp = [];\n    for(var i = 0;i<arr.length;i++){\n        if(temp.indexOf(arr[i]==-1){\n            temp.push(arr[i);\n        }\n    }\n    return temp;\n}\n```\n双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length\n\n将重复值中右侧的值去除，并将指针重新指向该位置\n\n```\nfunction unique(arr){\n  for(var i=0;i<arr.length-1;i++){\n    for(var j=i+1;j<arr.length;j++){\n      if(arr[i]==arr[j]){\n        arr.splice(j,1);\n        j--;\n      }\n    }\n  }\n  return arr;\n}\n```\n\n\nES6\n\n```\nfunction unique(arr){\n    var temp = [...new Set(arr)];\n    return temp;\n}\n```\n","source":"_posts/js/js：数组去重.md","raw":"---\ntitle: js：数组去重\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\nES5\n\n```\nfunction unique(arr){\n    var temp = [];\n    for(var i = 0;i<arr.length;i++){\n        if(temp.indexOf(arr[i]==-1){\n            temp.push(arr[i);\n        }\n    }\n    return temp;\n}\n```\n双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length\n\n将重复值中右侧的值去除，并将指针重新指向该位置\n\n```\nfunction unique(arr){\n  for(var i=0;i<arr.length-1;i++){\n    for(var j=i+1;j<arr.length;j++){\n      if(arr[i]==arr[j]){\n        arr.splice(j,1);\n        j--;\n      }\n    }\n  }\n  return arr;\n}\n```\n\n\nES6\n\n```\nfunction unique(arr){\n    var temp = [...new Set(arr)];\n    return temp;\n}\n```\n","slug":"js/js：数组去重","published":1,"date":"2020-05-14T08:55:23.703Z","updated":"2020-05-14T09:00:22.266Z","layout":"post","photos":[],"link":"","_id":"cka6kws2d0032rcu9g0zn65lk","content":"<p>ES5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr)&#123;</span><br><span class=\"line\">    var temp = [];</span><br><span class=\"line\">    for(var i = 0;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        if(temp.indexOf(arr[i]==-1)&#123;</span><br><span class=\"line\">            temp.push(arr[i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length</p>\n<p>将重复值中右侧的值去除，并将指针重新指向该位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr)&#123;</span><br><span class=\"line\">  for(var i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class=\"line\">    for(var j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class=\"line\">      if(arr[i]==arr[j])&#123;</span><br><span class=\"line\">        arr.splice(j,1);</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr)&#123;</span><br><span class=\"line\">    var temp = [...new Set(arr)];</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>ES5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr)&#123;</span><br><span class=\"line\">    var temp = [];</span><br><span class=\"line\">    for(var i = 0;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        if(temp.indexOf(arr[i]==-1)&#123;</span><br><span class=\"line\">            temp.push(arr[i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length</p>\n<p>将重复值中右侧的值去除，并将指针重新指向该位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr)&#123;</span><br><span class=\"line\">  for(var i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class=\"line\">    for(var j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class=\"line\">      if(arr[i]==arr[j])&#123;</span><br><span class=\"line\">        arr.splice(j,1);</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr)&#123;</span><br><span class=\"line\">    var temp = [...new Set(arr)];</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"js：图片预加载和懒加载","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 页面加载过程\n如果页面不是第一次访问，那么可能会出现浏览器缓存现象，在本地调试代码的时候也会遇到这种问题，所以在实在想不通页面为什么没有变化的时候，可以清除一下浏览器的缓存。\n\n如果页面是第一次访问，浏览器向服务器http请求后，服务器返回html文件，在整个页面加载过程中，总的来说是按顺序从上到下执行，这是基于js的单线程机制（浏览器为多进程），但是html和css是并行加载的。\n1. 根据 HTML 结构生成 DOM Tree\n2. 根据 CSS 生成 CSSOM\n3. 将 DOM 和 CSSOM 整合形成 RenderTree\n4. 根据 RenderTree 开始渲染和展示\n5. 遇到script标签时，会执行并阻塞渲染，因为 Javascript 代码有权利改变DOM树\n6. 在浏览器解析页面内容的时候，若页面引用了未加载的图片，就会发送请求获取资源。此时图片还没下载完全，在页面上并不会留下图片的位置，而html不会堵塞，将会继续执行下去。等到有图片请求下载完成，html又会重新渲染页面，将图片显示出来。\n\n为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。\n\n### 预加载\n\n- 图片等静态资源在使用前提前请求。\n- 资源后续使用可以直接从缓存中加载，提升用户体验。\n- 预加载不是为了减少页面加载时间。\n- 预加载只是提前加载除首轮加载的图片之外以后要用到的图片，比如通过点击等事件才会用到的图片。\n\ncss\n\n```\n#preload-01 { background: url(img1.png); }\n#preload-02 { background: url(img2.png); }\n#preload-03 { background: url(img3.png); }\n```\n\n像上面那样写，预加载和页面上其他内容一起加载，还会加长页面的加载时间，用户在点进页面时，等待时间加长，并没有达到我们提高用户体验的目的，我们可以封装一个函数，推迟预加载时间，等页面加载完成后再预加载。\n```\nfunction preload(){ \n    if(document.getElementById){ \n        document.getElementById(\"preload-01\").style.background = \"url(img1.png)\"; \n        document.getElementById(\"preload-02\").style.background = \"url(img2.png)\"; \n        document.getElementById(\"preload-03\").style.background = \"url(img3.png)\";\n    } \n} \nfunction addLoadEvent(func){ \n    var oldonload = window.onload; \n    if(type window.onload != \"function\"){ \n        window.onload = func; \n    }else{ \n        window.onload = function(){ \n            if(oldonload){ \n                oldonload(); \n            } \n            func(); \n        } \n    } \n} \naddLoadEvent(preload);\n\n```\n\n\n### 懒加载\n\n- 仅显示可视区的图片资源，不可见区域的资源暂不请求。\n- 使用懒加载可以减少页面的加载时间。\n- 使用于需要大量图片的页面。\n\n实现要点:将图片的src设为空，或者也可以将所有图片的src设一个底图，当图片还没加载完时，用这张底图来占图片的位置，防止页面结构混乱。再给一个自定义的data-url属性，用来存放图片的真实路径。lazyload属性用来标明哪些图片是需要懒加载。监听滚动事件，只在图片出现在可视区时，才动态地将图片的真实地址赋予图片的src属性。\n\n```\n<img src=\"\" lazyload=\"true\" data-url=\"1.jpg\"/>\n\nvar viewHeight = document.documentElement.clientHeight;//可视区域的高度\nfunction lazyload(){\n    var eles = document.querySelectorAll('img[data-url][lazyload]');\n    Array.prototype.forEach.call(eles,function(item,index){\n        var rect;\n        if(item.dataset.url === ''){//html5 data 钩子的写法\n            return;\n        }\n        rect = item.getBoundingClientRect();//getBoundingClientRect()返回一个矩形对象.\n        if(rect.bottom >= 0 && rect.top < viewHeight){\n            !function(){//感叹号表明这是一个函数表达式\n                var img = new Image();\n                img.src = item.dataset.url;\n                img.onload = function(){\n                    item.src = img.src;\n                }\n                item.removeAttribute('data-url');\n                item.removeAttribute('lazyload');\n            }()\n        }\n    })\n}\nlazyload();//首屏调用\ndocument.addEventListener('scroll',lazyload);\n\n```\n","source":"_posts/js/js：图片预加载和懒加载.md","raw":"---\ntitle: js：图片预加载和懒加载\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 页面加载过程\n如果页面不是第一次访问，那么可能会出现浏览器缓存现象，在本地调试代码的时候也会遇到这种问题，所以在实在想不通页面为什么没有变化的时候，可以清除一下浏览器的缓存。\n\n如果页面是第一次访问，浏览器向服务器http请求后，服务器返回html文件，在整个页面加载过程中，总的来说是按顺序从上到下执行，这是基于js的单线程机制（浏览器为多进程），但是html和css是并行加载的。\n1. 根据 HTML 结构生成 DOM Tree\n2. 根据 CSS 生成 CSSOM\n3. 将 DOM 和 CSSOM 整合形成 RenderTree\n4. 根据 RenderTree 开始渲染和展示\n5. 遇到script标签时，会执行并阻塞渲染，因为 Javascript 代码有权利改变DOM树\n6. 在浏览器解析页面内容的时候，若页面引用了未加载的图片，就会发送请求获取资源。此时图片还没下载完全，在页面上并不会留下图片的位置，而html不会堵塞，将会继续执行下去。等到有图片请求下载完成，html又会重新渲染页面，将图片显示出来。\n\n为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。\n\n### 预加载\n\n- 图片等静态资源在使用前提前请求。\n- 资源后续使用可以直接从缓存中加载，提升用户体验。\n- 预加载不是为了减少页面加载时间。\n- 预加载只是提前加载除首轮加载的图片之外以后要用到的图片，比如通过点击等事件才会用到的图片。\n\ncss\n\n```\n#preload-01 { background: url(img1.png); }\n#preload-02 { background: url(img2.png); }\n#preload-03 { background: url(img3.png); }\n```\n\n像上面那样写，预加载和页面上其他内容一起加载，还会加长页面的加载时间，用户在点进页面时，等待时间加长，并没有达到我们提高用户体验的目的，我们可以封装一个函数，推迟预加载时间，等页面加载完成后再预加载。\n```\nfunction preload(){ \n    if(document.getElementById){ \n        document.getElementById(\"preload-01\").style.background = \"url(img1.png)\"; \n        document.getElementById(\"preload-02\").style.background = \"url(img2.png)\"; \n        document.getElementById(\"preload-03\").style.background = \"url(img3.png)\";\n    } \n} \nfunction addLoadEvent(func){ \n    var oldonload = window.onload; \n    if(type window.onload != \"function\"){ \n        window.onload = func; \n    }else{ \n        window.onload = function(){ \n            if(oldonload){ \n                oldonload(); \n            } \n            func(); \n        } \n    } \n} \naddLoadEvent(preload);\n\n```\n\n\n### 懒加载\n\n- 仅显示可视区的图片资源，不可见区域的资源暂不请求。\n- 使用懒加载可以减少页面的加载时间。\n- 使用于需要大量图片的页面。\n\n实现要点:将图片的src设为空，或者也可以将所有图片的src设一个底图，当图片还没加载完时，用这张底图来占图片的位置，防止页面结构混乱。再给一个自定义的data-url属性，用来存放图片的真实路径。lazyload属性用来标明哪些图片是需要懒加载。监听滚动事件，只在图片出现在可视区时，才动态地将图片的真实地址赋予图片的src属性。\n\n```\n<img src=\"\" lazyload=\"true\" data-url=\"1.jpg\"/>\n\nvar viewHeight = document.documentElement.clientHeight;//可视区域的高度\nfunction lazyload(){\n    var eles = document.querySelectorAll('img[data-url][lazyload]');\n    Array.prototype.forEach.call(eles,function(item,index){\n        var rect;\n        if(item.dataset.url === ''){//html5 data 钩子的写法\n            return;\n        }\n        rect = item.getBoundingClientRect();//getBoundingClientRect()返回一个矩形对象.\n        if(rect.bottom >= 0 && rect.top < viewHeight){\n            !function(){//感叹号表明这是一个函数表达式\n                var img = new Image();\n                img.src = item.dataset.url;\n                img.onload = function(){\n                    item.src = img.src;\n                }\n                item.removeAttribute('data-url');\n                item.removeAttribute('lazyload');\n            }()\n        }\n    })\n}\nlazyload();//首屏调用\ndocument.addEventListener('scroll',lazyload);\n\n```\n","slug":"js/js：图片预加载和懒加载","published":1,"date":"2020-05-14T08:55:05.077Z","updated":"2020-05-14T09:00:03.512Z","layout":"post","photos":[],"link":"","_id":"cka6kws2i0035rcu9ad44lkyt","content":"<h3 id=\"页面加载过程\"><a href=\"#页面加载过程\" class=\"headerlink\" title=\"页面加载过程\"></a>页面加载过程</h3><p>如果页面不是第一次访问，那么可能会出现浏览器缓存现象，在本地调试代码的时候也会遇到这种问题，所以在实在想不通页面为什么没有变化的时候，可以清除一下浏览器的缓存。</p>\n<p>如果页面是第一次访问，浏览器向服务器http请求后，服务器返回html文件，在整个页面加载过程中，总的来说是按顺序从上到下执行，这是基于js的单线程机制（浏览器为多进程），但是html和css是并行加载的。</p>\n<ol>\n<li>根据 HTML 结构生成 DOM Tree</li>\n<li>根据 CSS 生成 CSSOM</li>\n<li>将 DOM 和 CSSOM 整合形成 RenderTree</li>\n<li>根据 RenderTree 开始渲染和展示</li>\n<li>遇到script标签时，会执行并阻塞渲染，因为 Javascript 代码有权利改变DOM树</li>\n<li>在浏览器解析页面内容的时候，若页面引用了未加载的图片，就会发送请求获取资源。此时图片还没下载完全，在页面上并不会留下图片的位置，而html不会堵塞，将会继续执行下去。等到有图片请求下载完成，html又会重新渲染页面，将图片显示出来。</li>\n</ol>\n<p>为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n<h3 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h3><ul>\n<li>图片等静态资源在使用前提前请求。</li>\n<li>资源后续使用可以直接从缓存中加载，提升用户体验。</li>\n<li>预加载不是为了减少页面加载时间。</li>\n<li>预加载只是提前加载除首轮加载的图片之外以后要用到的图片，比如通过点击等事件才会用到的图片。</li>\n</ul>\n<p>css</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#preload-01 &#123; background: url(img1.png); &#125;</span><br><span class=\"line\">#preload-02 &#123; background: url(img2.png); &#125;</span><br><span class=\"line\">#preload-03 &#123; background: url(img3.png); &#125;</span><br></pre></td></tr></table></figure>\n<p>像上面那样写，预加载和页面上其他内容一起加载，还会加长页面的加载时间，用户在点进页面时，等待时间加长，并没有达到我们提高用户体验的目的，我们可以封装一个函数，推迟预加载时间，等页面加载完成后再预加载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function preload()&#123; </span><br><span class=\"line\">    if(document.getElementById)&#123; </span><br><span class=\"line\">        document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(img1.png)&quot;; </span><br><span class=\"line\">        document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(img2.png)&quot;; </span><br><span class=\"line\">        document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(img3.png)&quot;;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">function addLoadEvent(func)&#123; </span><br><span class=\"line\">    var oldonload = window.onload; </span><br><span class=\"line\">    if(type window.onload != &quot;function&quot;)&#123; </span><br><span class=\"line\">        window.onload = func; </span><br><span class=\"line\">    &#125;else&#123; </span><br><span class=\"line\">        window.onload = function()&#123; </span><br><span class=\"line\">            if(oldonload)&#123; </span><br><span class=\"line\">                oldonload(); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            func(); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">addLoadEvent(preload);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><ul>\n<li>仅显示可视区的图片资源，不可见区域的资源暂不请求。</li>\n<li>使用懒加载可以减少页面的加载时间。</li>\n<li>使用于需要大量图片的页面。</li>\n</ul>\n<p>实现要点:将图片的src设为空，或者也可以将所有图片的src设一个底图，当图片还没加载完时，用这张底图来占图片的位置，防止页面结构混乱。再给一个自定义的data-url属性，用来存放图片的真实路径。lazyload属性用来标明哪些图片是需要懒加载。监听滚动事件，只在图片出现在可视区时，才动态地将图片的真实地址赋予图片的src属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;&quot; lazyload=&quot;true&quot; data-url=&quot;1.jpg&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var viewHeight = document.documentElement.clientHeight;//可视区域的高度</span><br><span class=\"line\">function lazyload()&#123;</span><br><span class=\"line\">    var eles = document.querySelectorAll(&apos;img[data-url][lazyload]&apos;);</span><br><span class=\"line\">    Array.prototype.forEach.call(eles,function(item,index)&#123;</span><br><span class=\"line\">        var rect;</span><br><span class=\"line\">        if(item.dataset.url === &apos;&apos;)&#123;//html5 data 钩子的写法</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rect = item.getBoundingClientRect();//getBoundingClientRect()返回一个矩形对象.</span><br><span class=\"line\">        if(rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight)&#123;</span><br><span class=\"line\">            !function()&#123;//感叹号表明这是一个函数表达式</span><br><span class=\"line\">                var img = new Image();</span><br><span class=\"line\">                img.src = item.dataset.url;</span><br><span class=\"line\">                img.onload = function()&#123;</span><br><span class=\"line\">                    item.src = img.src;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                item.removeAttribute(&apos;data-url&apos;);</span><br><span class=\"line\">                item.removeAttribute(&apos;lazyload&apos;);</span><br><span class=\"line\">            &#125;()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">lazyload();//首屏调用</span><br><span class=\"line\">document.addEventListener(&apos;scroll&apos;,lazyload);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"页面加载过程\"><a href=\"#页面加载过程\" class=\"headerlink\" title=\"页面加载过程\"></a>页面加载过程</h3><p>如果页面不是第一次访问，那么可能会出现浏览器缓存现象，在本地调试代码的时候也会遇到这种问题，所以在实在想不通页面为什么没有变化的时候，可以清除一下浏览器的缓存。</p>\n<p>如果页面是第一次访问，浏览器向服务器http请求后，服务器返回html文件，在整个页面加载过程中，总的来说是按顺序从上到下执行，这是基于js的单线程机制（浏览器为多进程），但是html和css是并行加载的。</p>\n<ol>\n<li>根据 HTML 结构生成 DOM Tree</li>\n<li>根据 CSS 生成 CSSOM</li>\n<li>将 DOM 和 CSSOM 整合形成 RenderTree</li>\n<li>根据 RenderTree 开始渲染和展示</li>\n<li>遇到script标签时，会执行并阻塞渲染，因为 Javascript 代码有权利改变DOM树</li>\n<li>在浏览器解析页面内容的时候，若页面引用了未加载的图片，就会发送请求获取资源。此时图片还没下载完全，在页面上并不会留下图片的位置，而html不会堵塞，将会继续执行下去。等到有图片请求下载完成，html又会重新渲染页面，将图片显示出来。</li>\n</ol>\n<p>为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n<h3 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h3><ul>\n<li>图片等静态资源在使用前提前请求。</li>\n<li>资源后续使用可以直接从缓存中加载，提升用户体验。</li>\n<li>预加载不是为了减少页面加载时间。</li>\n<li>预加载只是提前加载除首轮加载的图片之外以后要用到的图片，比如通过点击等事件才会用到的图片。</li>\n</ul>\n<p>css</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#preload-01 &#123; background: url(img1.png); &#125;</span><br><span class=\"line\">#preload-02 &#123; background: url(img2.png); &#125;</span><br><span class=\"line\">#preload-03 &#123; background: url(img3.png); &#125;</span><br></pre></td></tr></table></figure>\n<p>像上面那样写，预加载和页面上其他内容一起加载，还会加长页面的加载时间，用户在点进页面时，等待时间加长，并没有达到我们提高用户体验的目的，我们可以封装一个函数，推迟预加载时间，等页面加载完成后再预加载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function preload()&#123; </span><br><span class=\"line\">    if(document.getElementById)&#123; </span><br><span class=\"line\">        document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(img1.png)&quot;; </span><br><span class=\"line\">        document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(img2.png)&quot;; </span><br><span class=\"line\">        document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(img3.png)&quot;;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">function addLoadEvent(func)&#123; </span><br><span class=\"line\">    var oldonload = window.onload; </span><br><span class=\"line\">    if(type window.onload != &quot;function&quot;)&#123; </span><br><span class=\"line\">        window.onload = func; </span><br><span class=\"line\">    &#125;else&#123; </span><br><span class=\"line\">        window.onload = function()&#123; </span><br><span class=\"line\">            if(oldonload)&#123; </span><br><span class=\"line\">                oldonload(); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            func(); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">addLoadEvent(preload);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><ul>\n<li>仅显示可视区的图片资源，不可见区域的资源暂不请求。</li>\n<li>使用懒加载可以减少页面的加载时间。</li>\n<li>使用于需要大量图片的页面。</li>\n</ul>\n<p>实现要点:将图片的src设为空，或者也可以将所有图片的src设一个底图，当图片还没加载完时，用这张底图来占图片的位置，防止页面结构混乱。再给一个自定义的data-url属性，用来存放图片的真实路径。lazyload属性用来标明哪些图片是需要懒加载。监听滚动事件，只在图片出现在可视区时，才动态地将图片的真实地址赋予图片的src属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;&quot; lazyload=&quot;true&quot; data-url=&quot;1.jpg&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var viewHeight = document.documentElement.clientHeight;//可视区域的高度</span><br><span class=\"line\">function lazyload()&#123;</span><br><span class=\"line\">    var eles = document.querySelectorAll(&apos;img[data-url][lazyload]&apos;);</span><br><span class=\"line\">    Array.prototype.forEach.call(eles,function(item,index)&#123;</span><br><span class=\"line\">        var rect;</span><br><span class=\"line\">        if(item.dataset.url === &apos;&apos;)&#123;//html5 data 钩子的写法</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rect = item.getBoundingClientRect();//getBoundingClientRect()返回一个矩形对象.</span><br><span class=\"line\">        if(rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight)&#123;</span><br><span class=\"line\">            !function()&#123;//感叹号表明这是一个函数表达式</span><br><span class=\"line\">                var img = new Image();</span><br><span class=\"line\">                img.src = item.dataset.url;</span><br><span class=\"line\">                img.onload = function()&#123;</span><br><span class=\"line\">                    item.src = img.src;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                item.removeAttribute(&apos;data-url&apos;);</span><br><span class=\"line\">                item.removeAttribute(&apos;lazyload&apos;);</span><br><span class=\"line\">            &#125;()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">lazyload();//首屏调用</span><br><span class=\"line\">document.addEventListener(&apos;scroll&apos;,lazyload);</span><br></pre></td></tr></table></figure>\n"},{"title":"js：数组和链表","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 物理地址存储的连续性\n- 数组的元素在内存中是连续存放的。\n- 链表的元素在内存中不一定是连续存放的，通常是不连续的。\n\n### 访问速度\n- 数组的访问速度很快，因为数组可以根据数组可以根据下标进行快速定位。\n- 链表的访问速度较慢，因为链表访问元素需要移动指针。\n\n### 添加、删减元素速度\n- 数组的元素增删速度较慢，因为需要移动大量的元素。\n- 链表的元素增删速度较快，因为只需要修改指针即可。","source":"_posts/js/js：数组和链表.md","raw":"---\ntitle: js：数组和链表\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### 物理地址存储的连续性\n- 数组的元素在内存中是连续存放的。\n- 链表的元素在内存中不一定是连续存放的，通常是不连续的。\n\n### 访问速度\n- 数组的访问速度很快，因为数组可以根据数组可以根据下标进行快速定位。\n- 链表的访问速度较慢，因为链表访问元素需要移动指针。\n\n### 添加、删减元素速度\n- 数组的元素增删速度较慢，因为需要移动大量的元素。\n- 链表的元素增删速度较快，因为只需要修改指针即可。","slug":"js/js：数组和链表","published":1,"date":"2020-05-14T08:57:23.196Z","updated":"2020-05-14T09:04:33.375Z","layout":"post","photos":[],"link":"","_id":"cka6kws2o0038rcu90w41kh3q","content":"<h3 id=\"物理地址存储的连续性\"><a href=\"#物理地址存储的连续性\" class=\"headerlink\" title=\"物理地址存储的连续性\"></a>物理地址存储的连续性</h3><ul>\n<li>数组的元素在内存中是连续存放的。</li>\n<li>链表的元素在内存中不一定是连续存放的，通常是不连续的。</li>\n</ul>\n<h3 id=\"访问速度\"><a href=\"#访问速度\" class=\"headerlink\" title=\"访问速度\"></a>访问速度</h3><ul>\n<li>数组的访问速度很快，因为数组可以根据数组可以根据下标进行快速定位。</li>\n<li>链表的访问速度较慢，因为链表访问元素需要移动指针。</li>\n</ul>\n<h3 id=\"添加、删减元素速度\"><a href=\"#添加、删减元素速度\" class=\"headerlink\" title=\"添加、删减元素速度\"></a>添加、删减元素速度</h3><ul>\n<li>数组的元素增删速度较慢，因为需要移动大量的元素。</li>\n<li>链表的元素增删速度较快，因为只需要修改指针即可。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"物理地址存储的连续性\"><a href=\"#物理地址存储的连续性\" class=\"headerlink\" title=\"物理地址存储的连续性\"></a>物理地址存储的连续性</h3><ul>\n<li>数组的元素在内存中是连续存放的。</li>\n<li>链表的元素在内存中不一定是连续存放的，通常是不连续的。</li>\n</ul>\n<h3 id=\"访问速度\"><a href=\"#访问速度\" class=\"headerlink\" title=\"访问速度\"></a>访问速度</h3><ul>\n<li>数组的访问速度很快，因为数组可以根据数组可以根据下标进行快速定位。</li>\n<li>链表的访问速度较慢，因为链表访问元素需要移动指针。</li>\n</ul>\n<h3 id=\"添加、删减元素速度\"><a href=\"#添加、删减元素速度\" class=\"headerlink\" title=\"添加、删减元素速度\"></a>添加、删减元素速度</h3><ul>\n<li>数组的元素增删速度较慢，因为需要移动大量的元素。</li>\n<li>链表的元素增删速度较快，因为只需要修改指针即可。</li>\n</ul>\n"},{"title":"js：数组的常用方法","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n- join(\"分隔符\")\n```\n将数组的元素放入一个字符串，默认用逗号为分隔符。\n```\n- push()\n```\n把参数逐个添加到数组末尾，返回修改后数组长度。\n```\n- pop()\n```\n从数组末尾移除最后一项，返回移除的项。\n```\n- shift()\n```\n移除数组中的第一个项并返回该项。\n```\n- unshift()\n```\n在数组前面添加任意个项，返回数组长度。\n```\n- reverse()  （会修改原数组）\n```\n反转数组的顺序，返回经过排序后的数组，会修改原数组。\n```\n- sort([function])  （会修改原数组）\n```\n参数必须是函数，若无参数则默认按照字母编码（字符编码）的顺序进行排序。会修改原数组。\n//数字从小到大排序\narr.sort(function(a,b){\n    return a-b;\n});\n//数字从大到小排序\narr.sort(function(a,b){\n    return b-a;\n});\n```\n- concat()  (不修改原数组)\n```\n连接两个或多个数组。\n参数可以为具体的值，也可以为数组对象，可以有任意多个。\n返回当前数组的一个浅拷贝。\n```\n- slice(start,end)  (不修改原数组)\n```\n基于当前数组的一个或多个项创建一个新数组。\n左闭右开，返回新数组，不影响原数组。\n没有参数则原数组的浅拷贝。\n```\n- splice(start,number,new) (会修改原数组)\n```\n删除原数组的一部份成员，并可以在被删除的位置添加入新的数组成员，会修改原数组。返回一个数组，里面包含被删除的项目。\n```\n- indexOf(search,start)\n```\n返回search首次出现的位置，没有则返回-1。默认从第0位开始。\n```\n- lastIndexOf(search,start)\n```\n从右往左找，返回search首次出现的位置，没有则返回-1。\n```\n- includes(value)\n```\n判断一个数组是否包含一个指定的值。\n```\n- forEach(callback(value,index,array){}[,this]) (不修改原数组)\n```\n对数组进行遍历循环，对数组中的每一项运行给定函数。\n这个方法没有返回值。\n参数都是function类型，默认有传参，参数分别为：遍历的数组内容，对应的数组索引，数组本身。\n```\n- map(callback(value,index,array){}[,this]) (不修改原数组)\n```\n对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n```\n- filter(callback(value,index,array){}[,this]) (不修改原数组)\n```\n“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。\n```\n- some(callback(value,index,array){}[,this]) (不修改原数组)\n```\n判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。\n```\n- every(callback(value,index,array){}[,this]) (不修改原数组)\n```\n判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。\n```\n- find(callback(value,index,array){}[,this]) (不修改原数组)\n```\n返回数组中满足提供的测试函数的第一个元素的值。\n```\n- findIndex(callback(value,index,array){}[,this]) (不修改原数组)\n```\n返回数组中满足提供的测试函数的第一个元素的索引。\n```\n- reduce(function(prev, cur, index, array){}[,初始值])和reduceRight(function(prev, cur, index, array){}[,初始值]) (不修改原数组)\n```\n实现迭代数组的所有项，然后构建一个最终返回的值。\n前者从第一项开始，后者从最后一项开始。\n这个函数返回的任何值都会作为第一个参数自动传给下一项。\n```\n","source":"_posts/js/js：数组的常用方法.md","raw":"---\ntitle: js：数组的常用方法\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n- join(\"分隔符\")\n```\n将数组的元素放入一个字符串，默认用逗号为分隔符。\n```\n- push()\n```\n把参数逐个添加到数组末尾，返回修改后数组长度。\n```\n- pop()\n```\n从数组末尾移除最后一项，返回移除的项。\n```\n- shift()\n```\n移除数组中的第一个项并返回该项。\n```\n- unshift()\n```\n在数组前面添加任意个项，返回数组长度。\n```\n- reverse()  （会修改原数组）\n```\n反转数组的顺序，返回经过排序后的数组，会修改原数组。\n```\n- sort([function])  （会修改原数组）\n```\n参数必须是函数，若无参数则默认按照字母编码（字符编码）的顺序进行排序。会修改原数组。\n//数字从小到大排序\narr.sort(function(a,b){\n    return a-b;\n});\n//数字从大到小排序\narr.sort(function(a,b){\n    return b-a;\n});\n```\n- concat()  (不修改原数组)\n```\n连接两个或多个数组。\n参数可以为具体的值，也可以为数组对象，可以有任意多个。\n返回当前数组的一个浅拷贝。\n```\n- slice(start,end)  (不修改原数组)\n```\n基于当前数组的一个或多个项创建一个新数组。\n左闭右开，返回新数组，不影响原数组。\n没有参数则原数组的浅拷贝。\n```\n- splice(start,number,new) (会修改原数组)\n```\n删除原数组的一部份成员，并可以在被删除的位置添加入新的数组成员，会修改原数组。返回一个数组，里面包含被删除的项目。\n```\n- indexOf(search,start)\n```\n返回search首次出现的位置，没有则返回-1。默认从第0位开始。\n```\n- lastIndexOf(search,start)\n```\n从右往左找，返回search首次出现的位置，没有则返回-1。\n```\n- includes(value)\n```\n判断一个数组是否包含一个指定的值。\n```\n- forEach(callback(value,index,array){}[,this]) (不修改原数组)\n```\n对数组进行遍历循环，对数组中的每一项运行给定函数。\n这个方法没有返回值。\n参数都是function类型，默认有传参，参数分别为：遍历的数组内容，对应的数组索引，数组本身。\n```\n- map(callback(value,index,array){}[,this]) (不修改原数组)\n```\n对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n```\n- filter(callback(value,index,array){}[,this]) (不修改原数组)\n```\n“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。\n```\n- some(callback(value,index,array){}[,this]) (不修改原数组)\n```\n判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。\n```\n- every(callback(value,index,array){}[,this]) (不修改原数组)\n```\n判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。\n```\n- find(callback(value,index,array){}[,this]) (不修改原数组)\n```\n返回数组中满足提供的测试函数的第一个元素的值。\n```\n- findIndex(callback(value,index,array){}[,this]) (不修改原数组)\n```\n返回数组中满足提供的测试函数的第一个元素的索引。\n```\n- reduce(function(prev, cur, index, array){}[,初始值])和reduceRight(function(prev, cur, index, array){}[,初始值]) (不修改原数组)\n```\n实现迭代数组的所有项，然后构建一个最终返回的值。\n前者从第一项开始，后者从最后一项开始。\n这个函数返回的任何值都会作为第一个参数自动传给下一项。\n```\n","slug":"js/js：数组的常用方法","published":1,"date":"2020-05-14T08:54:42.865Z","updated":"2020-05-14T09:05:20.565Z","layout":"post","photos":[],"link":"","_id":"cka6kws2t003brcu9qh0u6m40","content":"<ul>\n<li><p>join(“分隔符”)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将数组的元素放入一个字符串，默认用逗号为分隔符。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>push()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把参数逐个添加到数组末尾，返回修改后数组长度。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pop()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从数组末尾移除最后一项，返回移除的项。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>shift()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移除数组中的第一个项并返回该项。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>unshift()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在数组前面添加任意个项，返回数组长度。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reverse()  （会修改原数组）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">反转数组的顺序，返回经过排序后的数组，会修改原数组。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>sort([function])  （会修改原数组）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数必须是函数，若无参数则默认按照字母编码（字符编码）的顺序进行排序。会修改原数组。</span><br><span class=\"line\">//数字从小到大排序</span><br><span class=\"line\">arr.sort(function(a,b)&#123;</span><br><span class=\"line\">    return a-b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//数字从大到小排序</span><br><span class=\"line\">arr.sort(function(a,b)&#123;</span><br><span class=\"line\">    return b-a;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>concat()  (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">连接两个或多个数组。</span><br><span class=\"line\">参数可以为具体的值，也可以为数组对象，可以有任意多个。</span><br><span class=\"line\">返回当前数组的一个浅拷贝。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>slice(start,end)  (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基于当前数组的一个或多个项创建一个新数组。</span><br><span class=\"line\">左闭右开，返回新数组，不影响原数组。</span><br><span class=\"line\">没有参数则原数组的浅拷贝。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>splice(start,number,new) (会修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">删除原数组的一部份成员，并可以在被删除的位置添加入新的数组成员，会修改原数组。返回一个数组，里面包含被删除的项目。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>indexOf(search,start)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回search首次出现的位置，没有则返回-1。默认从第0位开始。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lastIndexOf(search,start)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从右往左找，返回search首次出现的位置，没有则返回-1。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>includes(value)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断一个数组是否包含一个指定的值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>forEach(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对数组进行遍历循环，对数组中的每一项运行给定函数。</span><br><span class=\"line\">这个方法没有返回值。</span><br><span class=\"line\">参数都是function类型，默认有传参，参数分别为：遍历的数组内容，对应的数组索引，数组本身。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>map(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>filter(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>some(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>every(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>find(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回数组中满足提供的测试函数的第一个元素的值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>findIndex(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回数组中满足提供的测试函数的第一个元素的索引。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reduce(function(prev, cur, index, array){}[,初始值])和reduceRight(function(prev, cur, index, array){}[,初始值]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">实现迭代数组的所有项，然后构建一个最终返回的值。</span><br><span class=\"line\">前者从第一项开始，后者从最后一项开始。</span><br><span class=\"line\">这个函数返回的任何值都会作为第一个参数自动传给下一项。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>join(“分隔符”)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将数组的元素放入一个字符串，默认用逗号为分隔符。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>push()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把参数逐个添加到数组末尾，返回修改后数组长度。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pop()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从数组末尾移除最后一项，返回移除的项。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>shift()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移除数组中的第一个项并返回该项。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>unshift()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在数组前面添加任意个项，返回数组长度。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reverse()  （会修改原数组）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">反转数组的顺序，返回经过排序后的数组，会修改原数组。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>sort([function])  （会修改原数组）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数必须是函数，若无参数则默认按照字母编码（字符编码）的顺序进行排序。会修改原数组。</span><br><span class=\"line\">//数字从小到大排序</span><br><span class=\"line\">arr.sort(function(a,b)&#123;</span><br><span class=\"line\">    return a-b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//数字从大到小排序</span><br><span class=\"line\">arr.sort(function(a,b)&#123;</span><br><span class=\"line\">    return b-a;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>concat()  (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">连接两个或多个数组。</span><br><span class=\"line\">参数可以为具体的值，也可以为数组对象，可以有任意多个。</span><br><span class=\"line\">返回当前数组的一个浅拷贝。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>slice(start,end)  (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基于当前数组的一个或多个项创建一个新数组。</span><br><span class=\"line\">左闭右开，返回新数组，不影响原数组。</span><br><span class=\"line\">没有参数则原数组的浅拷贝。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>splice(start,number,new) (会修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">删除原数组的一部份成员，并可以在被删除的位置添加入新的数组成员，会修改原数组。返回一个数组，里面包含被删除的项目。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>indexOf(search,start)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回search首次出现的位置，没有则返回-1。默认从第0位开始。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lastIndexOf(search,start)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从右往左找，返回search首次出现的位置，没有则返回-1。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>includes(value)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断一个数组是否包含一个指定的值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>forEach(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对数组进行遍历循环，对数组中的每一项运行给定函数。</span><br><span class=\"line\">这个方法没有返回值。</span><br><span class=\"line\">参数都是function类型，默认有传参，参数分别为：遍历的数组内容，对应的数组索引，数组本身。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>map(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>filter(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>some(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>every(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>find(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回数组中满足提供的测试函数的第一个元素的值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>findIndex(callback(value,index,array){}[,this]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回数组中满足提供的测试函数的第一个元素的索引。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reduce(function(prev, cur, index, array){}[,初始值])和reduceRight(function(prev, cur, index, array){}[,初始值]) (不修改原数组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">实现迭代数组的所有项，然后构建一个最终返回的值。</span><br><span class=\"line\">前者从第一项开始，后者从最后一项开始。</span><br><span class=\"line\">这个函数返回的任何值都会作为第一个参数自动传给下一项。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"js：文件上传","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 获取文件内容\n\n```\n<input type=\"file\" id=\"fileUpload\"/>\n\ndocument.getElementById('fileUpload').onchange = function (e) {\n                var e = e || window.event;\n                // files 为选择的所有文件\n                var files = e.target.files;\n            }\n\n```\nfiles 为FileList，每一个元素为一个对象，里面包含：\n- lastModified\n- lastModifiedDate\n- name\n- size\n- type\n- webkitRelativePath\n\n![image](https://img-blog.csdn.net/20180614110140438)\n\n### 获取文件上传进度\n\n```\nvar xhrOnProgress=function(fun) {\n    xhrOnProgress.onprogress = fun; //绑定监听\n    //使用闭包实现监听绑\n    return function() {\n        //通过$.ajaxSettings.xhr();获得XMLHttpRequest对象\n        var xhr = $.ajaxSettings.xhr();\n        //判断监听函数是否为函数\n        if (typeof xhrOnProgress.onprogress !== 'function')\n          return xhr;\n        //如果有监听函数并且xhr对象支持绑定时就把监听函数绑定上去\n        if (xhrOnProgress.onprogress && xhr.upload) {\n          xhr.upload.onprogress = xhrOnProgress.onprogress;\n        }\n        return xhr;\n    }\n}\n\nfunction Submit(){\n    var fileObj = document.getElementById(\"FileUpload\").files[0]; // js 获取文件对象\n    var formFile = new FormData();\n    formFile.append(\"file\", fileObj); //加入文件对象\n    var data = formFile;\n    $.ajax({\n        url: \"http://up.qiniu.com/\",\n        data: data,\n        type: \"Post\",\n        dataType: \"json\",\n        cache: false,//上传文件无需缓存\n        processData: false,//用于对data参数进行序列化处理 这里必须false\n        contentType: false, //必须\n        xhr:xhrOnProgress(function(e){\n            var percent=e.loaded/e.total;\n            console.log(percent);\n        }),\n        success: function (result) {\n             console.log(result);\n        },\n    })\n}\n```\n### 断点续传\n指的是在上传/下载时，将任务（一个文件或压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。\n\n它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range\n\n- Range\n```\n用于请求头中，指定第一个字节的位置和最后一个字节的位置。\n```\n- Content-Range\n```\n用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。\n```\n在响应完成后，返回的响应头内容也不同，根据返回的状态码判断是否使用断点续传\n- 200 Ok（不使用断点续传方式）\n- 206 Partial Content（使用断点续传方式）\n","source":"_posts/js/js：文件上传.md","raw":"---\ntitle: js：文件上传\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### 获取文件内容\n\n```\n<input type=\"file\" id=\"fileUpload\"/>\n\ndocument.getElementById('fileUpload').onchange = function (e) {\n                var e = e || window.event;\n                // files 为选择的所有文件\n                var files = e.target.files;\n            }\n\n```\nfiles 为FileList，每一个元素为一个对象，里面包含：\n- lastModified\n- lastModifiedDate\n- name\n- size\n- type\n- webkitRelativePath\n\n![image](https://img-blog.csdn.net/20180614110140438)\n\n### 获取文件上传进度\n\n```\nvar xhrOnProgress=function(fun) {\n    xhrOnProgress.onprogress = fun; //绑定监听\n    //使用闭包实现监听绑\n    return function() {\n        //通过$.ajaxSettings.xhr();获得XMLHttpRequest对象\n        var xhr = $.ajaxSettings.xhr();\n        //判断监听函数是否为函数\n        if (typeof xhrOnProgress.onprogress !== 'function')\n          return xhr;\n        //如果有监听函数并且xhr对象支持绑定时就把监听函数绑定上去\n        if (xhrOnProgress.onprogress && xhr.upload) {\n          xhr.upload.onprogress = xhrOnProgress.onprogress;\n        }\n        return xhr;\n    }\n}\n\nfunction Submit(){\n    var fileObj = document.getElementById(\"FileUpload\").files[0]; // js 获取文件对象\n    var formFile = new FormData();\n    formFile.append(\"file\", fileObj); //加入文件对象\n    var data = formFile;\n    $.ajax({\n        url: \"http://up.qiniu.com/\",\n        data: data,\n        type: \"Post\",\n        dataType: \"json\",\n        cache: false,//上传文件无需缓存\n        processData: false,//用于对data参数进行序列化处理 这里必须false\n        contentType: false, //必须\n        xhr:xhrOnProgress(function(e){\n            var percent=e.loaded/e.total;\n            console.log(percent);\n        }),\n        success: function (result) {\n             console.log(result);\n        },\n    })\n}\n```\n### 断点续传\n指的是在上传/下载时，将任务（一个文件或压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。\n\n它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range\n\n- Range\n```\n用于请求头中，指定第一个字节的位置和最后一个字节的位置。\n```\n- Content-Range\n```\n用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。\n```\n在响应完成后，返回的响应头内容也不同，根据返回的状态码判断是否使用断点续传\n- 200 Ok（不使用断点续传方式）\n- 206 Partial Content（使用断点续传方式）\n","slug":"js/js：文件上传","published":1,"date":"2020-05-14T08:57:48.763Z","updated":"2020-05-14T09:04:04.724Z","layout":"post","photos":[],"link":"","_id":"cka6kws2y003ercu97b25wgou","content":"<h3 id=\"获取文件内容\"><a href=\"#获取文件内容\" class=\"headerlink\" title=\"获取文件内容\"></a>获取文件内容</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;fileUpload&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&apos;fileUpload&apos;).onchange = function (e) &#123;</span><br><span class=\"line\">                var e = e || window.event;</span><br><span class=\"line\">                // files 为选择的所有文件</span><br><span class=\"line\">                var files = e.target.files;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>files 为FileList，每一个元素为一个对象，里面包含：</p>\n<ul>\n<li>lastModified</li>\n<li>lastModifiedDate</li>\n<li>name</li>\n<li>size</li>\n<li>type</li>\n<li>webkitRelativePath</li>\n</ul>\n<p><img src=\"https://img-blog.csdn.net/20180614110140438\" alt=\"image\"></p>\n<h3 id=\"获取文件上传进度\"><a href=\"#获取文件上传进度\" class=\"headerlink\" title=\"获取文件上传进度\"></a>获取文件上传进度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhrOnProgress=function(fun) &#123;</span><br><span class=\"line\">    xhrOnProgress.onprogress = fun; //绑定监听</span><br><span class=\"line\">    //使用闭包实现监听绑</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        //通过$.ajaxSettings.xhr();获得XMLHttpRequest对象</span><br><span class=\"line\">        var xhr = $.ajaxSettings.xhr();</span><br><span class=\"line\">        //判断监听函数是否为函数</span><br><span class=\"line\">        if (typeof xhrOnProgress.onprogress !== &apos;function&apos;)</span><br><span class=\"line\">          return xhr;</span><br><span class=\"line\">        //如果有监听函数并且xhr对象支持绑定时就把监听函数绑定上去</span><br><span class=\"line\">        if (xhrOnProgress.onprogress &amp;&amp; xhr.upload) &#123;</span><br><span class=\"line\">          xhr.upload.onprogress = xhrOnProgress.onprogress;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return xhr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Submit()&#123;</span><br><span class=\"line\">    var fileObj = document.getElementById(&quot;FileUpload&quot;).files[0]; // js 获取文件对象</span><br><span class=\"line\">    var formFile = new FormData();</span><br><span class=\"line\">    formFile.append(&quot;file&quot;, fileObj); //加入文件对象</span><br><span class=\"line\">    var data = formFile;</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: &quot;http://up.qiniu.com/&quot;,</span><br><span class=\"line\">        data: data,</span><br><span class=\"line\">        type: &quot;Post&quot;,</span><br><span class=\"line\">        dataType: &quot;json&quot;,</span><br><span class=\"line\">        cache: false,//上传文件无需缓存</span><br><span class=\"line\">        processData: false,//用于对data参数进行序列化处理 这里必须false</span><br><span class=\"line\">        contentType: false, //必须</span><br><span class=\"line\">        xhr:xhrOnProgress(function(e)&#123;</span><br><span class=\"line\">            var percent=e.loaded/e.total;</span><br><span class=\"line\">            console.log(percent);</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        success: function (result) &#123;</span><br><span class=\"line\">             console.log(result);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"断点续传\"><a href=\"#断点续传\" class=\"headerlink\" title=\"断点续传\"></a>断点续传</h3><p>指的是在上传/下载时，将任务（一个文件或压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。</p>\n<p>它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range</p>\n<ul>\n<li><p>Range</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用于请求头中，指定第一个字节的位置和最后一个字节的位置。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Content-Range</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在响应完成后，返回的响应头内容也不同，根据返回的状态码判断是否使用断点续传</p>\n<ul>\n<li>200 Ok（不使用断点续传方式）</li>\n<li>206 Partial Content（使用断点续传方式）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"获取文件内容\"><a href=\"#获取文件内容\" class=\"headerlink\" title=\"获取文件内容\"></a>获取文件内容</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;fileUpload&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&apos;fileUpload&apos;).onchange = function (e) &#123;</span><br><span class=\"line\">                var e = e || window.event;</span><br><span class=\"line\">                // files 为选择的所有文件</span><br><span class=\"line\">                var files = e.target.files;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>files 为FileList，每一个元素为一个对象，里面包含：</p>\n<ul>\n<li>lastModified</li>\n<li>lastModifiedDate</li>\n<li>name</li>\n<li>size</li>\n<li>type</li>\n<li>webkitRelativePath</li>\n</ul>\n<p><img src=\"https://img-blog.csdn.net/20180614110140438\" alt=\"image\"></p>\n<h3 id=\"获取文件上传进度\"><a href=\"#获取文件上传进度\" class=\"headerlink\" title=\"获取文件上传进度\"></a>获取文件上传进度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhrOnProgress=function(fun) &#123;</span><br><span class=\"line\">    xhrOnProgress.onprogress = fun; //绑定监听</span><br><span class=\"line\">    //使用闭包实现监听绑</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        //通过$.ajaxSettings.xhr();获得XMLHttpRequest对象</span><br><span class=\"line\">        var xhr = $.ajaxSettings.xhr();</span><br><span class=\"line\">        //判断监听函数是否为函数</span><br><span class=\"line\">        if (typeof xhrOnProgress.onprogress !== &apos;function&apos;)</span><br><span class=\"line\">          return xhr;</span><br><span class=\"line\">        //如果有监听函数并且xhr对象支持绑定时就把监听函数绑定上去</span><br><span class=\"line\">        if (xhrOnProgress.onprogress &amp;&amp; xhr.upload) &#123;</span><br><span class=\"line\">          xhr.upload.onprogress = xhrOnProgress.onprogress;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return xhr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Submit()&#123;</span><br><span class=\"line\">    var fileObj = document.getElementById(&quot;FileUpload&quot;).files[0]; // js 获取文件对象</span><br><span class=\"line\">    var formFile = new FormData();</span><br><span class=\"line\">    formFile.append(&quot;file&quot;, fileObj); //加入文件对象</span><br><span class=\"line\">    var data = formFile;</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: &quot;http://up.qiniu.com/&quot;,</span><br><span class=\"line\">        data: data,</span><br><span class=\"line\">        type: &quot;Post&quot;,</span><br><span class=\"line\">        dataType: &quot;json&quot;,</span><br><span class=\"line\">        cache: false,//上传文件无需缓存</span><br><span class=\"line\">        processData: false,//用于对data参数进行序列化处理 这里必须false</span><br><span class=\"line\">        contentType: false, //必须</span><br><span class=\"line\">        xhr:xhrOnProgress(function(e)&#123;</span><br><span class=\"line\">            var percent=e.loaded/e.total;</span><br><span class=\"line\">            console.log(percent);</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        success: function (result) &#123;</span><br><span class=\"line\">             console.log(result);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"断点续传\"><a href=\"#断点续传\" class=\"headerlink\" title=\"断点续传\"></a>断点续传</h3><p>指的是在上传/下载时，将任务（一个文件或压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。</p>\n<p>它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range</p>\n<ul>\n<li><p>Range</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用于请求头中，指定第一个字节的位置和最后一个字节的位置。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Content-Range</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在响应完成后，返回的响应头内容也不同，根据返回的状态码判断是否使用断点续传</p>\n<ul>\n<li>200 Ok（不使用断点续传方式）</li>\n<li>206 Partial Content（使用断点续传方式）</li>\n</ul>\n"},{"title":"js：时间复杂度","Date":"2019-04-22T16:00:00.000Z","comments":1,"_content":"\n### 时间复杂度\n#### 原则\n- 如果运行时间是常数量级，用常数1表示；\n- 只保留时间函数中的最高阶项；\n- 如果最高阶项存在，则省去最高阶项前面的系数。\n\n#### 场景一\n给小灰一条长n寸的面包，小灰每3天吃掉1寸，那么吃掉整个面包需要几天？\n\n```\n//T（n） = 3n，执行次数是线性的。\nvoid eat1(int n){\n    for(int i=0; i<n; i++){;\n        System.out.println(\"等待一天\");\n        System.out.println(\"等待一天\");\n        System.out.println(\"吃一寸面包\");\n    }\n}\n```\n时间复杂度为：T（n） =  O（n）\n\n#### 场景二\n给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸......那么小灰把面包吃得只剩下1寸，需要多少天呢？\n\n这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为log16。  \n因此，把面包吃得只剩下1寸，需要 5 X log16 = 5 X 4 = 20 天。\n\n如果面包的长度是 N 寸呢？    \n需要 5 X logn = 5logn天，记作 T（n） = 5logn。\n```\n//T（n） = 5logn，执行次数是对数的。\nvoid eat2(int n){\n   for(int i=1; i<n; i*=2){\n       System.out.println(\"等待一天\");\n       System.out.println(\"等待一天\");\n       System.out.println(\"等待一天\");\n       System.out.println(\"等待一天\");\n       System.out.println(\"吃一半面包\");\n   }\n}\n```\n时间复杂度为：T（n） =  O（logn）\n\n#### 场景三\n给小灰一条长10寸的面包和一个鸡腿，小灰每2天吃掉一个鸡腿。那么小灰吃掉整个鸡腿需要多少天呢？\n\n```\n//T（n） = 2，执行次数是常量的。\nvoid eat3(int n){\n   System.out.println(\"等待一天\");\n   System.out.println(\"吃一个鸡腿\");\n}\n```\n时间复杂度为：T（n） =  O（1）\n\n### 场景四\n给小灰一条长10寸的面包，小灰吃掉第一个一寸需要1天时间，吃掉第二个一寸需要2天时间，吃掉第三个一寸需要3天时间.....每多吃一寸，所花的时间也多一天。那么小灰吃掉整个面包需要多少天呢？\n\n答案是从1累加到10的总和，也就是55天。\n\n如果面包的长度是 N 寸呢？    \n此时吃掉整个面包，需要 1+2+3+......+ n-1 + n = (1+n)*n/2 = 0.5n^2 + 0.5n。\n```\n//T（n） = 0.5n^2 + 0.5n，执行次数是一个多项式。\nvoid eat4(int n){\n   for(int i=0; i<n; i++){\n       for(int j=0; j<i; j++){\n           System.out.println(\"等待一天\");\n       }\n       System.out.println(\"吃一寸面包\");\n   }\n}\n```\n时间复杂度为：T（n） =  O（n^2）\n\n#### 总结\n四种时间复杂度究竟谁用时更长，谁节省时间呢？\n\n```\nO（1）< O（logn）< O（n）< O（n^2）\n```\n\n除了上述的四个场景，还有许多不同形式的时间复杂度，比如：\n\n```\nO（nlogn）, O（n^3）, O（m*n），O（2^n），O（n！）\n```","source":"_posts/js/js：时间复杂度.md","raw":"---\ntitle: js：时间复杂度\nDate: 2019-04-23\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 时间复杂度\n#### 原则\n- 如果运行时间是常数量级，用常数1表示；\n- 只保留时间函数中的最高阶项；\n- 如果最高阶项存在，则省去最高阶项前面的系数。\n\n#### 场景一\n给小灰一条长n寸的面包，小灰每3天吃掉1寸，那么吃掉整个面包需要几天？\n\n```\n//T（n） = 3n，执行次数是线性的。\nvoid eat1(int n){\n    for(int i=0; i<n; i++){;\n        System.out.println(\"等待一天\");\n        System.out.println(\"等待一天\");\n        System.out.println(\"吃一寸面包\");\n    }\n}\n```\n时间复杂度为：T（n） =  O（n）\n\n#### 场景二\n给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸......那么小灰把面包吃得只剩下1寸，需要多少天呢？\n\n这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为log16。  \n因此，把面包吃得只剩下1寸，需要 5 X log16 = 5 X 4 = 20 天。\n\n如果面包的长度是 N 寸呢？    \n需要 5 X logn = 5logn天，记作 T（n） = 5logn。\n```\n//T（n） = 5logn，执行次数是对数的。\nvoid eat2(int n){\n   for(int i=1; i<n; i*=2){\n       System.out.println(\"等待一天\");\n       System.out.println(\"等待一天\");\n       System.out.println(\"等待一天\");\n       System.out.println(\"等待一天\");\n       System.out.println(\"吃一半面包\");\n   }\n}\n```\n时间复杂度为：T（n） =  O（logn）\n\n#### 场景三\n给小灰一条长10寸的面包和一个鸡腿，小灰每2天吃掉一个鸡腿。那么小灰吃掉整个鸡腿需要多少天呢？\n\n```\n//T（n） = 2，执行次数是常量的。\nvoid eat3(int n){\n   System.out.println(\"等待一天\");\n   System.out.println(\"吃一个鸡腿\");\n}\n```\n时间复杂度为：T（n） =  O（1）\n\n### 场景四\n给小灰一条长10寸的面包，小灰吃掉第一个一寸需要1天时间，吃掉第二个一寸需要2天时间，吃掉第三个一寸需要3天时间.....每多吃一寸，所花的时间也多一天。那么小灰吃掉整个面包需要多少天呢？\n\n答案是从1累加到10的总和，也就是55天。\n\n如果面包的长度是 N 寸呢？    \n此时吃掉整个面包，需要 1+2+3+......+ n-1 + n = (1+n)*n/2 = 0.5n^2 + 0.5n。\n```\n//T（n） = 0.5n^2 + 0.5n，执行次数是一个多项式。\nvoid eat4(int n){\n   for(int i=0; i<n; i++){\n       for(int j=0; j<i; j++){\n           System.out.println(\"等待一天\");\n       }\n       System.out.println(\"吃一寸面包\");\n   }\n}\n```\n时间复杂度为：T（n） =  O（n^2）\n\n#### 总结\n四种时间复杂度究竟谁用时更长，谁节省时间呢？\n\n```\nO（1）< O（logn）< O（n）< O（n^2）\n```\n\n除了上述的四个场景，还有许多不同形式的时间复杂度，比如：\n\n```\nO（nlogn）, O（n^3）, O（m*n），O（2^n），O（n！）\n```","slug":"js/js：时间复杂度","published":1,"date":"2019-04-23T14:18:49.296Z","updated":"2020-05-14T09:10:31.725Z","layout":"post","photos":[],"link":"","_id":"cka6kws33003hrcu9f1h74kj8","content":"<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><h4 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h4><ul>\n<li>如果运行时间是常数量级，用常数1表示；</li>\n<li>只保留时间函数中的最高阶项；</li>\n<li>如果最高阶项存在，则省去最高阶项前面的系数。</li>\n</ul>\n<h4 id=\"场景一\"><a href=\"#场景一\" class=\"headerlink\" title=\"场景一\"></a>场景一</h4><p>给小灰一条长n寸的面包，小灰每3天吃掉1寸，那么吃掉整个面包需要几天？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//T（n） = 3n，执行次数是线性的。</span><br><span class=\"line\">void eat1(int n)&#123;</span><br><span class=\"line\">    for(int i=0; i&lt;n; i++)&#123;;</span><br><span class=\"line\">        System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">        System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">        System.out.println(&quot;吃一寸面包&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为：T（n） =  O（n）</p>\n<h4 id=\"场景二\"><a href=\"#场景二\" class=\"headerlink\" title=\"场景二\"></a>场景二</h4><p>给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸……那么小灰把面包吃得只剩下1寸，需要多少天呢？</p>\n<p>这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为log16。<br>因此，把面包吃得只剩下1寸，需要 5 X log16 = 5 X 4 = 20 天。</p>\n<p>如果面包的长度是 N 寸呢？<br>需要 5 X logn = 5logn天，记作 T（n） = 5logn。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//T（n） = 5logn，执行次数是对数的。</span><br><span class=\"line\">void eat2(int n)&#123;</span><br><span class=\"line\">   for(int i=1; i&lt;n; i*=2)&#123;</span><br><span class=\"line\">       System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       System.out.println(&quot;吃一半面包&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时间复杂度为：T（n） =  O（logn）</p>\n<h4 id=\"场景三\"><a href=\"#场景三\" class=\"headerlink\" title=\"场景三\"></a>场景三</h4><p>给小灰一条长10寸的面包和一个鸡腿，小灰每2天吃掉一个鸡腿。那么小灰吃掉整个鸡腿需要多少天呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//T（n） = 2，执行次数是常量的。</span><br><span class=\"line\">void eat3(int n)&#123;</span><br><span class=\"line\">   System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">   System.out.println(&quot;吃一个鸡腿&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为：T（n） =  O（1）</p>\n<h3 id=\"场景四\"><a href=\"#场景四\" class=\"headerlink\" title=\"场景四\"></a>场景四</h3><p>给小灰一条长10寸的面包，小灰吃掉第一个一寸需要1天时间，吃掉第二个一寸需要2天时间，吃掉第三个一寸需要3天时间…..每多吃一寸，所花的时间也多一天。那么小灰吃掉整个面包需要多少天呢？</p>\n<p>答案是从1累加到10的总和，也就是55天。</p>\n<p>如果面包的长度是 N 寸呢？<br>此时吃掉整个面包，需要 1+2+3+……+ n-1 + n = (1+n)*n/2 = 0.5n^2 + 0.5n。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//T（n） = 0.5n^2 + 0.5n，执行次数是一个多项式。</span><br><span class=\"line\">void eat4(int n)&#123;</span><br><span class=\"line\">   for(int i=0; i&lt;n; i++)&#123;</span><br><span class=\"line\">       for(int j=0; j&lt;i; j++)&#123;</span><br><span class=\"line\">           System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(&quot;吃一寸面包&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时间复杂度为：T（n） =  O（n^2）</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>四种时间复杂度究竟谁用时更长，谁节省时间呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">O（1）&lt; O（logn）&lt; O（n）&lt; O（n^2）</span><br></pre></td></tr></table></figure>\n<p>除了上述的四个场景，还有许多不同形式的时间复杂度，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">O（nlogn）, O（n^3）, O（m*n），O（2^n），O（n！）</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><h4 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h4><ul>\n<li>如果运行时间是常数量级，用常数1表示；</li>\n<li>只保留时间函数中的最高阶项；</li>\n<li>如果最高阶项存在，则省去最高阶项前面的系数。</li>\n</ul>\n<h4 id=\"场景一\"><a href=\"#场景一\" class=\"headerlink\" title=\"场景一\"></a>场景一</h4><p>给小灰一条长n寸的面包，小灰每3天吃掉1寸，那么吃掉整个面包需要几天？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//T（n） = 3n，执行次数是线性的。</span><br><span class=\"line\">void eat1(int n)&#123;</span><br><span class=\"line\">    for(int i=0; i&lt;n; i++)&#123;;</span><br><span class=\"line\">        System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">        System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">        System.out.println(&quot;吃一寸面包&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为：T（n） =  O（n）</p>\n<h4 id=\"场景二\"><a href=\"#场景二\" class=\"headerlink\" title=\"场景二\"></a>场景二</h4><p>给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸……那么小灰把面包吃得只剩下1寸，需要多少天呢？</p>\n<p>这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为log16。<br>因此，把面包吃得只剩下1寸，需要 5 X log16 = 5 X 4 = 20 天。</p>\n<p>如果面包的长度是 N 寸呢？<br>需要 5 X logn = 5logn天，记作 T（n） = 5logn。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//T（n） = 5logn，执行次数是对数的。</span><br><span class=\"line\">void eat2(int n)&#123;</span><br><span class=\"line\">   for(int i=1; i&lt;n; i*=2)&#123;</span><br><span class=\"line\">       System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       System.out.println(&quot;吃一半面包&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时间复杂度为：T（n） =  O（logn）</p>\n<h4 id=\"场景三\"><a href=\"#场景三\" class=\"headerlink\" title=\"场景三\"></a>场景三</h4><p>给小灰一条长10寸的面包和一个鸡腿，小灰每2天吃掉一个鸡腿。那么小灰吃掉整个鸡腿需要多少天呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//T（n） = 2，执行次数是常量的。</span><br><span class=\"line\">void eat3(int n)&#123;</span><br><span class=\"line\">   System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">   System.out.println(&quot;吃一个鸡腿&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为：T（n） =  O（1）</p>\n<h3 id=\"场景四\"><a href=\"#场景四\" class=\"headerlink\" title=\"场景四\"></a>场景四</h3><p>给小灰一条长10寸的面包，小灰吃掉第一个一寸需要1天时间，吃掉第二个一寸需要2天时间，吃掉第三个一寸需要3天时间…..每多吃一寸，所花的时间也多一天。那么小灰吃掉整个面包需要多少天呢？</p>\n<p>答案是从1累加到10的总和，也就是55天。</p>\n<p>如果面包的长度是 N 寸呢？<br>此时吃掉整个面包，需要 1+2+3+……+ n-1 + n = (1+n)*n/2 = 0.5n^2 + 0.5n。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//T（n） = 0.5n^2 + 0.5n，执行次数是一个多项式。</span><br><span class=\"line\">void eat4(int n)&#123;</span><br><span class=\"line\">   for(int i=0; i&lt;n; i++)&#123;</span><br><span class=\"line\">       for(int j=0; j&lt;i; j++)&#123;</span><br><span class=\"line\">           System.out.println(&quot;等待一天&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(&quot;吃一寸面包&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时间复杂度为：T（n） =  O（n^2）</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>四种时间复杂度究竟谁用时更长，谁节省时间呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">O（1）&lt; O（logn）&lt; O（n）&lt; O（n^2）</span><br></pre></td></tr></table></figure>\n<p>除了上述的四个场景，还有许多不同形式的时间复杂度，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">O（nlogn）, O（n^3）, O（m*n），O（2^n），O（n！）</span><br></pre></td></tr></table></figure>"},{"title":"js：正则表达式","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 正则的三种属性\n- g：全局匹配\n- i：忽略大小写（默认区分大小写）\n- m：多行模式\n\n### 常用方法\n\n```\nlet str = 'abc';\nlet reg = /a/gi;\n```\n#### test()\n在字符串中查找符合正则的内容，若找到返回true，否则false\n\n```\n// 用法：正则.test(字符串)\nreg.test(str)\n```\n\n#### search()\n在字符串中搜索符合正则的内容，返回出现的位置，从0开始。若匹配不止一个字符，则返回第一个字符的位置。搜索失败返回-1。\n\n```\n// 用法：字符串.test(正则)\nstr.test(reg)\n```\n\n#### match()\n在字符串中搜索符合正则的内容，返回一个数组，里面包含相匹配的内容，失败返回null\n\n```\n// 用法：字符串.test(正则)\nstr.test(reg)\n```\n\n### 常用字符\n#### 非打印字符\n\n字符 | 描述\n---|---\n\\cx |\t匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。\n\\f |\t匹配一个换页符。等价于 \\x0c 和 \\cL。\n\\n |\t匹配一个换行符。等价于 \\x0a 和 \\cJ。\n\\r |\t匹配一个回车符。等价于 \\x0d 和 \\cM。\n\\d |    匹配0-9之间的任意一个数字。等价于[0-9]\n\\D |    匹配所有非数字。等价于[\\^0-9]，[]中的^代表非、除了\n\\w |    匹配数字、字母、下划线。等价于[0-9a-zA-Z_]\n\\W |    匹配所有非数字、字母、下划线。等价于[\\^0-9a-zA-Z_]\n\\s |\t匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。\n\\S |\t匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\t |\t匹配一个制表符。等价于 \\x09 和 \\cI。\n\\v |\t匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\n\n#### 特殊字符\n\n字符 | 描述\n---|---\n$ |\t匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。\n( ) |\t标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。\n* |\t匹配前面的子表达式零次到多次。要匹配 * 字符，请使用 \\*。\n+ |\t匹配前面的子表达式一次到多次。要匹配 + 字符，请使用 \\+。\n. |\t匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。\n[ |\t标记一个中括号表达式的开始。要匹配 [，请使用 \\[。\n? |\t匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。\n\\ |\t将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\' 匹配 \"\\\"，而 '\\(' 则匹配 \"(\"。\n^ |\t匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。\n{ |\t标记限定符表达式的开始。要匹配 {，请使用 \\{。\n| |\t指明两项之间的一个选择。要匹配 |，请使用 \\|。\n\n\n#### 限定符\n\n字符 | 描述\n---|---\n* |\t匹配前面的子表达式零次到多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。\n+ |\t匹配前面的子表达式一次到多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。\n? |\t匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。\n{n} |\tn 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。\n{n,} |\tn 是一个非负整数。匹配n 次到多次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。\n{n,m} |\tm 和 n 均为非负整数，匹配n次到m次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。\n\n#### 定位符\n\n字符 | 描述\n---|---\n^ |\t匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。\n$ |\t匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。\n\\b |\t匹配一个单词边界，即字与空格间的位置。\n\\B |\t非单词边界匹配。\n\n","source":"_posts/js/js：正则表达式.md","raw":"---\ntitle: js：正则表达式\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### 正则的三种属性\n- g：全局匹配\n- i：忽略大小写（默认区分大小写）\n- m：多行模式\n\n### 常用方法\n\n```\nlet str = 'abc';\nlet reg = /a/gi;\n```\n#### test()\n在字符串中查找符合正则的内容，若找到返回true，否则false\n\n```\n// 用法：正则.test(字符串)\nreg.test(str)\n```\n\n#### search()\n在字符串中搜索符合正则的内容，返回出现的位置，从0开始。若匹配不止一个字符，则返回第一个字符的位置。搜索失败返回-1。\n\n```\n// 用法：字符串.test(正则)\nstr.test(reg)\n```\n\n#### match()\n在字符串中搜索符合正则的内容，返回一个数组，里面包含相匹配的内容，失败返回null\n\n```\n// 用法：字符串.test(正则)\nstr.test(reg)\n```\n\n### 常用字符\n#### 非打印字符\n\n字符 | 描述\n---|---\n\\cx |\t匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。\n\\f |\t匹配一个换页符。等价于 \\x0c 和 \\cL。\n\\n |\t匹配一个换行符。等价于 \\x0a 和 \\cJ。\n\\r |\t匹配一个回车符。等价于 \\x0d 和 \\cM。\n\\d |    匹配0-9之间的任意一个数字。等价于[0-9]\n\\D |    匹配所有非数字。等价于[\\^0-9]，[]中的^代表非、除了\n\\w |    匹配数字、字母、下划线。等价于[0-9a-zA-Z_]\n\\W |    匹配所有非数字、字母、下划线。等价于[\\^0-9a-zA-Z_]\n\\s |\t匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。\n\\S |\t匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\t |\t匹配一个制表符。等价于 \\x09 和 \\cI。\n\\v |\t匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\n\n#### 特殊字符\n\n字符 | 描述\n---|---\n$ |\t匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。\n( ) |\t标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。\n* |\t匹配前面的子表达式零次到多次。要匹配 * 字符，请使用 \\*。\n+ |\t匹配前面的子表达式一次到多次。要匹配 + 字符，请使用 \\+。\n. |\t匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。\n[ |\t标记一个中括号表达式的开始。要匹配 [，请使用 \\[。\n? |\t匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。\n\\ |\t将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\' 匹配 \"\\\"，而 '\\(' 则匹配 \"(\"。\n^ |\t匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。\n{ |\t标记限定符表达式的开始。要匹配 {，请使用 \\{。\n| |\t指明两项之间的一个选择。要匹配 |，请使用 \\|。\n\n\n#### 限定符\n\n字符 | 描述\n---|---\n* |\t匹配前面的子表达式零次到多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。\n+ |\t匹配前面的子表达式一次到多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。\n? |\t匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。\n{n} |\tn 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。\n{n,} |\tn 是一个非负整数。匹配n 次到多次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。\n{n,m} |\tm 和 n 均为非负整数，匹配n次到m次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。\n\n#### 定位符\n\n字符 | 描述\n---|---\n^ |\t匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。\n$ |\t匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。\n\\b |\t匹配一个单词边界，即字与空格间的位置。\n\\B |\t非单词边界匹配。\n\n","slug":"js/js：正则表达式","published":1,"date":"2020-05-14T08:57:18.210Z","updated":"2020-05-14T09:06:30.322Z","layout":"post","photos":[],"link":"","_id":"cka6kws37003krcu907xb9oy3","content":"<h3 id=\"正则的三种属性\"><a href=\"#正则的三种属性\" class=\"headerlink\" title=\"正则的三种属性\"></a>正则的三种属性</h3><ul>\n<li>g：全局匹配</li>\n<li>i：忽略大小写（默认区分大小写）</li>\n<li>m：多行模式</li>\n</ul>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str = &apos;abc&apos;;</span><br><span class=\"line\">let reg = /a/gi;</span><br></pre></td></tr></table></figure>\n<h4 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h4><p>在字符串中查找符合正则的内容，若找到返回true，否则false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用法：正则.test(字符串)</span><br><span class=\"line\">reg.test(str)</span><br></pre></td></tr></table></figure>\n<h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a>search()</h4><p>在字符串中搜索符合正则的内容，返回出现的位置，从0开始。若匹配不止一个字符，则返回第一个字符的位置。搜索失败返回-1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用法：字符串.test(正则)</span><br><span class=\"line\">str.test(reg)</span><br></pre></td></tr></table></figure>\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match()\"></a>match()</h4><p>在字符串中搜索符合正则的内容，返回一个数组，里面包含相匹配的内容，失败返回null</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用法：字符串.test(正则)</span><br><span class=\"line\">str.test(reg)</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用字符\"><a href=\"#常用字符\" class=\"headerlink\" title=\"常用字符\"></a>常用字符</h3><h4 id=\"非打印字符\"><a href=\"#非打印字符\" class=\"headerlink\" title=\"非打印字符\"></a>非打印字符</h4><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\cx</td>\n<td>匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符。等价于 \\x0c 和 \\cL。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符。等价于 \\x0a 和 \\cJ。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符。等价于 \\x0d 和 \\cM。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配0-9之间的任意一个数字。等价于[0-9]</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配所有非数字。等价于[\\^0-9]，[]中的^代表非、除了</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配数字、字母、下划线。等价于[0-9a-zA-Z_]</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配所有非数字、字母、下划线。等价于[\\^0-9a-zA-Z_]</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个制表符。等价于 \\x09 和 \\cI。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h4><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$</td>\n<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。</td>\n</tr>\n<tr>\n<td>( )</td>\n<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前面的子表达式零次到多次。要匹配 <em> 字符，请使用 \\</em>。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面的子表达式一次到多次。要匹配 + 字符，请使用 +。</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。</td>\n</tr>\n<tr>\n<td>[</td>\n<td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘(‘ 则匹配 “(“。</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。</td>\n</tr>\n<tr>\n<td>{</td>\n<td>标记限定符表达式的开始。要匹配 {，请使用 {。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>指明两项之间的一个选择。要匹配</td>\n<td>，请使用 \\</td>\n<td>。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h4><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>匹配前面的子表达式零次到多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面的子表达式一次到多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>n 是一个非负整数。匹配n 次到多次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>m 和 n 均为非负整数，匹配n次到m次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"定位符\"><a href=\"#定位符\" class=\"headerlink\" title=\"定位符\"></a>定位符</h4><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，即字与空格间的位置。</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>非单词边界匹配。</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"正则的三种属性\"><a href=\"#正则的三种属性\" class=\"headerlink\" title=\"正则的三种属性\"></a>正则的三种属性</h3><ul>\n<li>g：全局匹配</li>\n<li>i：忽略大小写（默认区分大小写）</li>\n<li>m：多行模式</li>\n</ul>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str = &apos;abc&apos;;</span><br><span class=\"line\">let reg = /a/gi;</span><br></pre></td></tr></table></figure>\n<h4 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h4><p>在字符串中查找符合正则的内容，若找到返回true，否则false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用法：正则.test(字符串)</span><br><span class=\"line\">reg.test(str)</span><br></pre></td></tr></table></figure>\n<h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a>search()</h4><p>在字符串中搜索符合正则的内容，返回出现的位置，从0开始。若匹配不止一个字符，则返回第一个字符的位置。搜索失败返回-1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用法：字符串.test(正则)</span><br><span class=\"line\">str.test(reg)</span><br></pre></td></tr></table></figure>\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match()\"></a>match()</h4><p>在字符串中搜索符合正则的内容，返回一个数组，里面包含相匹配的内容，失败返回null</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用法：字符串.test(正则)</span><br><span class=\"line\">str.test(reg)</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用字符\"><a href=\"#常用字符\" class=\"headerlink\" title=\"常用字符\"></a>常用字符</h3><h4 id=\"非打印字符\"><a href=\"#非打印字符\" class=\"headerlink\" title=\"非打印字符\"></a>非打印字符</h4><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\cx</td>\n<td>匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符。等价于 \\x0c 和 \\cL。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符。等价于 \\x0a 和 \\cJ。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符。等价于 \\x0d 和 \\cM。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配0-9之间的任意一个数字。等价于[0-9]</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配所有非数字。等价于[\\^0-9]，[]中的^代表非、除了</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配数字、字母、下划线。等价于[0-9a-zA-Z_]</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配所有非数字、字母、下划线。等价于[\\^0-9a-zA-Z_]</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个制表符。等价于 \\x09 和 \\cI。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h4><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$</td>\n<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。</td>\n</tr>\n<tr>\n<td>( )</td>\n<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前面的子表达式零次到多次。要匹配 <em> 字符，请使用 \\</em>。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面的子表达式一次到多次。要匹配 + 字符，请使用 +。</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。</td>\n</tr>\n<tr>\n<td>[</td>\n<td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘(‘ 则匹配 “(“。</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。</td>\n</tr>\n<tr>\n<td>{</td>\n<td>标记限定符表达式的开始。要匹配 {，请使用 {。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>指明两项之间的一个选择。要匹配</td>\n<td>，请使用 \\</td>\n<td>。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h4><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>匹配前面的子表达式零次到多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面的子表达式一次到多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>n 是一个非负整数。匹配n 次到多次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>m 和 n 均为非负整数，匹配n次到m次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"定位符\"><a href=\"#定位符\" class=\"headerlink\" title=\"定位符\"></a>定位符</h4><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，即字与空格间的位置。</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>非单词边界匹配。</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"js：浅拷贝与深拷贝","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 浅拷贝\n拷贝对象的内存地址，新旧对象共享同一块内存，修改新对象会导致旧对象也改变。\n\n```\nvar obj = { a: {a:\"kobe\",b:39} };\nvar arr = [\"a\",\"b\",{name:\"kobe\"}];\n//第一种\nvar obj1 = obj;\n//第二种\nvar obj2 = Object.assign({},obj);//当object只有一层时为深拷贝\n//第三种\nvar arr1 = arr.concat();\n//第四种\nvar arr2 = arr.slice();\n```\n\n\n\n### 深拷贝\n创造一个一模一样的对象，，新旧对象不共享同一块内存，修改新对象不会导致旧对象改变。\n#### 递归实现深拷贝\n\n```\nfunction clone(target) {\n\tvar temp;\n\tif (target instanceof Array) {\n\t\ttemp = [];\n\t} else if (target instanceof Object) {\n\t\ttemp = {};\n\t} else {\n\t\treturn target;\n\t}\n\n\tfor (var i in target) {\n\t\ttemp[i] = clone(target[i]);\n\t}\n\treturn temp;\n}\n\nconsole.log(clone([\"111\", \"222\", {\n\t\ta: \"1\"\n\t},\n\t[1, 1]\n]));\nconsole.log(clone({\n\ta: [1, 1],\n\tb: {\n\t\ta: \"1\",\n\t\tb: \"11\"\n\t},\n\tc: \"11\"\n}));\nconsole.log(clone(\"111\"));\n```\n\n#### JSON.parse(JSON.stringify())\n\n```\nfunction clone(target){\n    return JSON.parse(JSON.stringify(target));\n}\n```\n原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。\n\n> 这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。","source":"_posts/js/js：浅拷贝与深拷贝.md","raw":"---\ntitle: js：浅拷贝与深拷贝\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### 浅拷贝\n拷贝对象的内存地址，新旧对象共享同一块内存，修改新对象会导致旧对象也改变。\n\n```\nvar obj = { a: {a:\"kobe\",b:39} };\nvar arr = [\"a\",\"b\",{name:\"kobe\"}];\n//第一种\nvar obj1 = obj;\n//第二种\nvar obj2 = Object.assign({},obj);//当object只有一层时为深拷贝\n//第三种\nvar arr1 = arr.concat();\n//第四种\nvar arr2 = arr.slice();\n```\n\n\n\n### 深拷贝\n创造一个一模一样的对象，，新旧对象不共享同一块内存，修改新对象不会导致旧对象改变。\n#### 递归实现深拷贝\n\n```\nfunction clone(target) {\n\tvar temp;\n\tif (target instanceof Array) {\n\t\ttemp = [];\n\t} else if (target instanceof Object) {\n\t\ttemp = {};\n\t} else {\n\t\treturn target;\n\t}\n\n\tfor (var i in target) {\n\t\ttemp[i] = clone(target[i]);\n\t}\n\treturn temp;\n}\n\nconsole.log(clone([\"111\", \"222\", {\n\t\ta: \"1\"\n\t},\n\t[1, 1]\n]));\nconsole.log(clone({\n\ta: [1, 1],\n\tb: {\n\t\ta: \"1\",\n\t\tb: \"11\"\n\t},\n\tc: \"11\"\n}));\nconsole.log(clone(\"111\"));\n```\n\n#### JSON.parse(JSON.stringify())\n\n```\nfunction clone(target){\n    return JSON.parse(JSON.stringify(target));\n}\n```\n原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。\n\n> 这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。","slug":"js/js：浅拷贝与深拷贝","published":1,"date":"2020-05-14T08:57:55.442Z","updated":"2020-05-14T09:03:56.810Z","layout":"post","photos":[],"link":"","_id":"cka6kws3b003nrcu9td4zqufo","content":"<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>拷贝对象的内存地址，新旧对象共享同一块内存，修改新对象会导致旧对象也改变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123; a: &#123;a:&quot;kobe&quot;,b:39&#125; &#125;;</span><br><span class=\"line\">var arr = [&quot;a&quot;,&quot;b&quot;,&#123;name:&quot;kobe&quot;&#125;];</span><br><span class=\"line\">//第一种</span><br><span class=\"line\">var obj1 = obj;</span><br><span class=\"line\">//第二种</span><br><span class=\"line\">var obj2 = Object.assign(&#123;&#125;,obj);//当object只有一层时为深拷贝</span><br><span class=\"line\">//第三种</span><br><span class=\"line\">var arr1 = arr.concat();</span><br><span class=\"line\">//第四种</span><br><span class=\"line\">var arr2 = arr.slice();</span><br></pre></td></tr></table></figure>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>创造一个一模一样的对象，，新旧对象不共享同一块内存，修改新对象不会导致旧对象改变。</p>\n<h4 id=\"递归实现深拷贝\"><a href=\"#递归实现深拷贝\" class=\"headerlink\" title=\"递归实现深拷贝\"></a>递归实现深拷贝</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function clone(target) &#123;</span><br><span class=\"line\">\tvar temp;</span><br><span class=\"line\">\tif (target instanceof Array) &#123;</span><br><span class=\"line\">\t\ttemp = [];</span><br><span class=\"line\">\t&#125; else if (target instanceof Object) &#123;</span><br><span class=\"line\">\t\ttemp = &#123;&#125;;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\treturn target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (var i in target) &#123;</span><br><span class=\"line\">\t\ttemp[i] = clone(target[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(clone([&quot;111&quot;, &quot;222&quot;, &#123;</span><br><span class=\"line\">\t\ta: &quot;1&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t[1, 1]</span><br><span class=\"line\">]));</span><br><span class=\"line\">console.log(clone(&#123;</span><br><span class=\"line\">\ta: [1, 1],</span><br><span class=\"line\">\tb: &#123;</span><br><span class=\"line\">\t\ta: &quot;1&quot;,</span><br><span class=\"line\">\t\tb: &quot;11&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tc: &quot;11&quot;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">console.log(clone(&quot;111&quot;));</span><br></pre></td></tr></table></figure>\n<h4 id=\"JSON-parse-JSON-stringify\"><a href=\"#JSON-parse-JSON-stringify\" class=\"headerlink\" title=\"JSON.parse(JSON.stringify())\"></a>JSON.parse(JSON.stringify())</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function clone(target)&#123;</span><br><span class=\"line\">    return JSON.parse(JSON.stringify(target));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p>\n<blockquote>\n<p>这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>拷贝对象的内存地址，新旧对象共享同一块内存，修改新对象会导致旧对象也改变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123; a: &#123;a:&quot;kobe&quot;,b:39&#125; &#125;;</span><br><span class=\"line\">var arr = [&quot;a&quot;,&quot;b&quot;,&#123;name:&quot;kobe&quot;&#125;];</span><br><span class=\"line\">//第一种</span><br><span class=\"line\">var obj1 = obj;</span><br><span class=\"line\">//第二种</span><br><span class=\"line\">var obj2 = Object.assign(&#123;&#125;,obj);//当object只有一层时为深拷贝</span><br><span class=\"line\">//第三种</span><br><span class=\"line\">var arr1 = arr.concat();</span><br><span class=\"line\">//第四种</span><br><span class=\"line\">var arr2 = arr.slice();</span><br></pre></td></tr></table></figure>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>创造一个一模一样的对象，，新旧对象不共享同一块内存，修改新对象不会导致旧对象改变。</p>\n<h4 id=\"递归实现深拷贝\"><a href=\"#递归实现深拷贝\" class=\"headerlink\" title=\"递归实现深拷贝\"></a>递归实现深拷贝</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function clone(target) &#123;</span><br><span class=\"line\">\tvar temp;</span><br><span class=\"line\">\tif (target instanceof Array) &#123;</span><br><span class=\"line\">\t\ttemp = [];</span><br><span class=\"line\">\t&#125; else if (target instanceof Object) &#123;</span><br><span class=\"line\">\t\ttemp = &#123;&#125;;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\treturn target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (var i in target) &#123;</span><br><span class=\"line\">\t\ttemp[i] = clone(target[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(clone([&quot;111&quot;, &quot;222&quot;, &#123;</span><br><span class=\"line\">\t\ta: &quot;1&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t[1, 1]</span><br><span class=\"line\">]));</span><br><span class=\"line\">console.log(clone(&#123;</span><br><span class=\"line\">\ta: [1, 1],</span><br><span class=\"line\">\tb: &#123;</span><br><span class=\"line\">\t\ta: &quot;1&quot;,</span><br><span class=\"line\">\t\tb: &quot;11&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tc: &quot;11&quot;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">console.log(clone(&quot;111&quot;));</span><br></pre></td></tr></table></figure>\n<h4 id=\"JSON-parse-JSON-stringify\"><a href=\"#JSON-parse-JSON-stringify\" class=\"headerlink\" title=\"JSON.parse(JSON.stringify())\"></a>JSON.parse(JSON.stringify())</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function clone(target)&#123;</span><br><span class=\"line\">    return JSON.parse(JSON.stringify(target));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p>\n<blockquote>\n<p>这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。</p>\n</blockquote>\n"},{"title":"js：瀑布流布局","Date":"2019-03-26T16:00:00.000Z","comments":1,"_content":"\n1. 瀑布流布局的要求要进行布置的元素等宽； 然后计算元素的宽度， 与浏览器宽度之比，得到需要布置的列数；\n2. 创建一个数组，长度为列数， 里面的值为以已布置元素的总高度（最开始为0）；\n3. 然后将未布置的元素的依次布置到高度最小的那一列， 就得到了瀑布流布局；\n4. 滚动加载，scroll事件得到scrollTop， 与最后盒子的offsetTop对比， 符合条件就不断滚动加载。","source":"_posts/js/js：瀑布流布局.md","raw":"---\ntitle: js：瀑布流布局\nDate: 2019-03-27\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n1. 瀑布流布局的要求要进行布置的元素等宽； 然后计算元素的宽度， 与浏览器宽度之比，得到需要布置的列数；\n2. 创建一个数组，长度为列数， 里面的值为以已布置元素的总高度（最开始为0）；\n3. 然后将未布置的元素的依次布置到高度最小的那一列， 就得到了瀑布流布局；\n4. 滚动加载，scroll事件得到scrollTop， 与最后盒子的offsetTop对比， 符合条件就不断滚动加载。","slug":"js/js：瀑布流布局","published":1,"date":"2019-03-27T07:31:08.518Z","updated":"2020-05-14T09:10:20.315Z","layout":"post","photos":[],"link":"","_id":"cka6kws3i003qrcu93m2mvy56","content":"<ol>\n<li>瀑布流布局的要求要进行布置的元素等宽； 然后计算元素的宽度， 与浏览器宽度之比，得到需要布置的列数；</li>\n<li>创建一个数组，长度为列数， 里面的值为以已布置元素的总高度（最开始为0）；</li>\n<li>然后将未布置的元素的依次布置到高度最小的那一列， 就得到了瀑布流布局；</li>\n<li>滚动加载，scroll事件得到scrollTop， 与最后盒子的offsetTop对比， 符合条件就不断滚动加载。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>瀑布流布局的要求要进行布置的元素等宽； 然后计算元素的宽度， 与浏览器宽度之比，得到需要布置的列数；</li>\n<li>创建一个数组，长度为列数， 里面的值为以已布置元素的总高度（最开始为0）；</li>\n<li>然后将未布置的元素的依次布置到高度最小的那一列， 就得到了瀑布流布局；</li>\n<li>滚动加载，scroll事件得到scrollTop， 与最后盒子的offsetTop对比， 符合条件就不断滚动加载。</li>\n</ol>\n"},{"title":"js：立即执行函数","Date":"2019-04-22T16:00:00.000Z","comments":1,"_content":"\n### 立即执行函数\n\n```\n//一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号\n( function(){…} )()  \n//等价于\n( function (){…} () )\n//一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中\n```\n注意：\n- 函数体后面要有小括号()，函数体必须是函数表达式而不能是函数声明。\n- （）运算符将匿名函数或函数声明转换为函数表达式。\n\n### 好处\n通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。\n\n此时若是想访问全局对象，将全局对象以参数形式传进去即可\n\n```\n(function(window){\n    ...\n})(window);\n```\n\n### 拓展\n\n```\nfor(var i = 0; i<10; i++){\n    setTimeout(function(){\n        console.log(i)\n    });\n}\n改写：使打印 0-10\n//第一种：let\nfor(let i = 0; i<10; i++){\n    setTimeout(function(){\n        console.log(i)\n    });\n}\n//第二种：闭包 + 立即执行函数\nfor(var i = 0; i<10; i++){\n    (function(a){\n        setTimeout(function(){\n            console.log(a)\n        });\n    })(i);\n}\n上面的代码即可实现依次打印出0,1,2,3...\n此处利用闭包每次将i的值传入进去，里面使用参数a接受传过来的值\n然后setTimeout异步调用，进入异步队列，循环代码很快执行完\n然后从异步队列里返回执行后的结果，依次打印出0，1,2,3...\n\n//实现隔1秒依次打印一个结果\nfor(var i = 0; i<10; i++){\n    (function(a){\n        setTimeout(function(){\n            console.log(a)\n        });\n    },1000*a)(i);\n}\n上面代码在延迟执行时间那块加了一个参数a\na的值每次都会增加1，使时间每次扩大比上次大一倍\n从而实现了每隔一秒就打印出一个结果\n```\n> 异步调用：异步代码执行完后结果存放在队列中，等同步代码执行完，再输出结果","source":"_posts/js/js：立即执行函数.md","raw":"---\ntitle: js：立即执行函数\nDate: 2019-04-23\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 立即执行函数\n\n```\n//一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号\n( function(){…} )()  \n//等价于\n( function (){…} () )\n//一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中\n```\n注意：\n- 函数体后面要有小括号()，函数体必须是函数表达式而不能是函数声明。\n- （）运算符将匿名函数或函数声明转换为函数表达式。\n\n### 好处\n通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。\n\n此时若是想访问全局对象，将全局对象以参数形式传进去即可\n\n```\n(function(window){\n    ...\n})(window);\n```\n\n### 拓展\n\n```\nfor(var i = 0; i<10; i++){\n    setTimeout(function(){\n        console.log(i)\n    });\n}\n改写：使打印 0-10\n//第一种：let\nfor(let i = 0; i<10; i++){\n    setTimeout(function(){\n        console.log(i)\n    });\n}\n//第二种：闭包 + 立即执行函数\nfor(var i = 0; i<10; i++){\n    (function(a){\n        setTimeout(function(){\n            console.log(a)\n        });\n    })(i);\n}\n上面的代码即可实现依次打印出0,1,2,3...\n此处利用闭包每次将i的值传入进去，里面使用参数a接受传过来的值\n然后setTimeout异步调用，进入异步队列，循环代码很快执行完\n然后从异步队列里返回执行后的结果，依次打印出0，1,2,3...\n\n//实现隔1秒依次打印一个结果\nfor(var i = 0; i<10; i++){\n    (function(a){\n        setTimeout(function(){\n            console.log(a)\n        });\n    },1000*a)(i);\n}\n上面代码在延迟执行时间那块加了一个参数a\na的值每次都会增加1，使时间每次扩大比上次大一倍\n从而实现了每隔一秒就打印出一个结果\n```\n> 异步调用：异步代码执行完后结果存放在队列中，等同步代码执行完，再输出结果","slug":"js/js：立即执行函数","published":1,"date":"2019-04-23T14:24:21.702Z","updated":"2020-05-14T09:10:07.368Z","layout":"post","photos":[],"link":"","_id":"cka6kws3n003trcu9leszlppo","content":"<h3 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号</span><br><span class=\"line\">( function()&#123;…&#125; )()  </span><br><span class=\"line\">//等价于</span><br><span class=\"line\">( function ()&#123;…&#125; () )</span><br><span class=\"line\">//一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<ul>\n<li>函数体后面要有小括号()，函数体必须是函数表达式而不能是函数声明。</li>\n<li>（）运算符将匿名函数或函数声明转换为函数表达式。</li>\n</ul>\n<h3 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h3><p>通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。</p>\n<p>此时若是想访问全局对象，将全局对象以参数形式传进去即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(window)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)(window);</span><br></pre></td></tr></table></figure>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        console.log(i)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">改写：使打印 0-10</span><br><span class=\"line\">//第一种：let</span><br><span class=\"line\">for(let i = 0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        console.log(i)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//第二种：闭包 + 立即执行函数</span><br><span class=\"line\">for(var i = 0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    (function(a)&#123;</span><br><span class=\"line\">        setTimeout(function()&#123;</span><br><span class=\"line\">            console.log(a)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">上面的代码即可实现依次打印出0,1,2,3...</span><br><span class=\"line\">此处利用闭包每次将i的值传入进去，里面使用参数a接受传过来的值</span><br><span class=\"line\">然后setTimeout异步调用，进入异步队列，循环代码很快执行完</span><br><span class=\"line\">然后从异步队列里返回执行后的结果，依次打印出0，1,2,3...</span><br><span class=\"line\"></span><br><span class=\"line\">//实现隔1秒依次打印一个结果</span><br><span class=\"line\">for(var i = 0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    (function(a)&#123;</span><br><span class=\"line\">        setTimeout(function()&#123;</span><br><span class=\"line\">            console.log(a)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,1000*a)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">上面代码在延迟执行时间那块加了一个参数a</span><br><span class=\"line\">a的值每次都会增加1，使时间每次扩大比上次大一倍</span><br><span class=\"line\">从而实现了每隔一秒就打印出一个结果</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>异步调用：异步代码执行完后结果存放在队列中，等同步代码执行完，再输出结果</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号</span><br><span class=\"line\">( function()&#123;…&#125; )()  </span><br><span class=\"line\">//等价于</span><br><span class=\"line\">( function ()&#123;…&#125; () )</span><br><span class=\"line\">//一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<ul>\n<li>函数体后面要有小括号()，函数体必须是函数表达式而不能是函数声明。</li>\n<li>（）运算符将匿名函数或函数声明转换为函数表达式。</li>\n</ul>\n<h3 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h3><p>通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。</p>\n<p>此时若是想访问全局对象，将全局对象以参数形式传进去即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(window)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)(window);</span><br></pre></td></tr></table></figure>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        console.log(i)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">改写：使打印 0-10</span><br><span class=\"line\">//第一种：let</span><br><span class=\"line\">for(let i = 0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        console.log(i)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//第二种：闭包 + 立即执行函数</span><br><span class=\"line\">for(var i = 0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    (function(a)&#123;</span><br><span class=\"line\">        setTimeout(function()&#123;</span><br><span class=\"line\">            console.log(a)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">上面的代码即可实现依次打印出0,1,2,3...</span><br><span class=\"line\">此处利用闭包每次将i的值传入进去，里面使用参数a接受传过来的值</span><br><span class=\"line\">然后setTimeout异步调用，进入异步队列，循环代码很快执行完</span><br><span class=\"line\">然后从异步队列里返回执行后的结果，依次打印出0，1,2,3...</span><br><span class=\"line\"></span><br><span class=\"line\">//实现隔1秒依次打印一个结果</span><br><span class=\"line\">for(var i = 0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    (function(a)&#123;</span><br><span class=\"line\">        setTimeout(function()&#123;</span><br><span class=\"line\">            console.log(a)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,1000*a)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">上面代码在延迟执行时间那块加了一个参数a</span><br><span class=\"line\">a的值每次都会增加1，使时间每次扩大比上次大一倍</span><br><span class=\"line\">从而实现了每隔一秒就打印出一个结果</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>异步调用：异步代码执行完后结果存放在队列中，等同步代码执行完，再输出结果</p>\n</blockquote>\n"},{"title":"js：简化运算","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n\n### 三元运算\n\n```\nlet type;\nif(type === 'a') {\n    type = 'typeA';\n} else if (type === 'b') {\n    type = 'typeB'\n}\n// 简化\nlet type = type === 'a' ? 'typeA' : 'typeB'\n```\n### 四元运算\n\n```\nlet type;\nif(type === 'a') {\n    type = 'typeA';\n} else if (type === 'b') {\n    type = 'typeB'\n} else if (type === 'c') {\n    type = 'typeC'\n}\n// 简化\nlet type = type === 'a' ? 'typeA' : (type === 'b' ? 'typeB' : 'typeC')\n```\n","source":"_posts/js/js：简化运算.md","raw":"---\ntitle: js：简化运算\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n\n### 三元运算\n\n```\nlet type;\nif(type === 'a') {\n    type = 'typeA';\n} else if (type === 'b') {\n    type = 'typeB'\n}\n// 简化\nlet type = type === 'a' ? 'typeA' : 'typeB'\n```\n### 四元运算\n\n```\nlet type;\nif(type === 'a') {\n    type = 'typeA';\n} else if (type === 'b') {\n    type = 'typeB'\n} else if (type === 'c') {\n    type = 'typeC'\n}\n// 简化\nlet type = type === 'a' ? 'typeA' : (type === 'b' ? 'typeB' : 'typeC')\n```\n","slug":"js/js：简化运算","published":1,"date":"2020-05-14T08:57:12.889Z","updated":"2020-05-14T09:06:37.730Z","layout":"post","photos":[],"link":"","_id":"cka6kws3s003wrcu9cz7lf2dx","content":"<h3 id=\"三元运算\"><a href=\"#三元运算\" class=\"headerlink\" title=\"三元运算\"></a>三元运算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type;</span><br><span class=\"line\">if(type === &apos;a&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeA&apos;;</span><br><span class=\"line\">&#125; else if (type === &apos;b&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeB&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 简化</span><br><span class=\"line\">let type = type === &apos;a&apos; ? &apos;typeA&apos; : &apos;typeB&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四元运算\"><a href=\"#四元运算\" class=\"headerlink\" title=\"四元运算\"></a>四元运算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type;</span><br><span class=\"line\">if(type === &apos;a&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeA&apos;;</span><br><span class=\"line\">&#125; else if (type === &apos;b&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeB&apos;</span><br><span class=\"line\">&#125; else if (type === &apos;c&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeC&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 简化</span><br><span class=\"line\">let type = type === &apos;a&apos; ? &apos;typeA&apos; : (type === &apos;b&apos; ? &apos;typeB&apos; : &apos;typeC&apos;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"三元运算\"><a href=\"#三元运算\" class=\"headerlink\" title=\"三元运算\"></a>三元运算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type;</span><br><span class=\"line\">if(type === &apos;a&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeA&apos;;</span><br><span class=\"line\">&#125; else if (type === &apos;b&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeB&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 简化</span><br><span class=\"line\">let type = type === &apos;a&apos; ? &apos;typeA&apos; : &apos;typeB&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四元运算\"><a href=\"#四元运算\" class=\"headerlink\" title=\"四元运算\"></a>四元运算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type;</span><br><span class=\"line\">if(type === &apos;a&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeA&apos;;</span><br><span class=\"line\">&#125; else if (type === &apos;b&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeB&apos;</span><br><span class=\"line\">&#125; else if (type === &apos;c&apos;) &#123;</span><br><span class=\"line\">    type = &apos;typeC&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 简化</span><br><span class=\"line\">let type = type === &apos;a&apos; ? &apos;typeA&apos; : (type === &apos;b&apos; ? &apos;typeB&apos; : &apos;typeC&apos;)</span><br></pre></td></tr></table></figure>\n"},{"title":"js：类数组对象","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 类数组对象\n只包含使用从零开始，且自然递增的整数做键名，并且定义了length表示元素个数的对象。\n\n```\nvar arr = [1,2,3];\nvar obj = {0: 1, 1: 2, 2: 3, length: 3};\nconsole.log(arr[0], obj[0])//1, 1\nconsole.log(arr['length'], obj['length'])//3，3\n```\n我们可以使用对象来模拟数组，只要我们定义的对象的每个元素的键名都使用数字并且让其保持递增，且动态的定义一个length属性来表示元素个数，那么从效果上来说，基本就和数组相同了。\n\n### arguments\narguments就是一个典型的类数组对象，为一个参数集\n\n```\n// 数组\nfunction printArr () {\n    return ['ming',18];\n}\nprintArr()\n// 打印结果\n(2) [\"ming\", 18]\n    0: \"ming\"\n    1: 18\n    length: 2\n    __proto__: Array(0)\n    \n    \n// arguments\nfunction printArg (name,age) {\n    return arguments;\n}\nprintArg('ming',18)\n// 打印结果\nArguments(2) [\"ming\", 18, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n    0: \"ming\"\n    1: 18\n    callee: ƒ fn(name,age)\n    length: 2\n    Symbol(Symbol.iterator): ƒ values()\n    __proto__: Object\n\n\n```\n#### arguments转换为数组\n```\nfunction toArr(){\n    var arr = [];\n    for（var i in arguments）{\n        arr.push(arguments[i]);\n    }\n    return arr;\n}\n```\n\n```\nfunction toArr(){\n    var arr = [];\n    arr = Array.prototype.slice.call(arguments);\n    return arr;\n}\n```","source":"_posts/js/js：类数组对象.md","raw":"---\ntitle: js：类数组对象\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 类数组对象\n只包含使用从零开始，且自然递增的整数做键名，并且定义了length表示元素个数的对象。\n\n```\nvar arr = [1,2,3];\nvar obj = {0: 1, 1: 2, 2: 3, length: 3};\nconsole.log(arr[0], obj[0])//1, 1\nconsole.log(arr['length'], obj['length'])//3，3\n```\n我们可以使用对象来模拟数组，只要我们定义的对象的每个元素的键名都使用数字并且让其保持递增，且动态的定义一个length属性来表示元素个数，那么从效果上来说，基本就和数组相同了。\n\n### arguments\narguments就是一个典型的类数组对象，为一个参数集\n\n```\n// 数组\nfunction printArr () {\n    return ['ming',18];\n}\nprintArr()\n// 打印结果\n(2) [\"ming\", 18]\n    0: \"ming\"\n    1: 18\n    length: 2\n    __proto__: Array(0)\n    \n    \n// arguments\nfunction printArg (name,age) {\n    return arguments;\n}\nprintArg('ming',18)\n// 打印结果\nArguments(2) [\"ming\", 18, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n    0: \"ming\"\n    1: 18\n    callee: ƒ fn(name,age)\n    length: 2\n    Symbol(Symbol.iterator): ƒ values()\n    __proto__: Object\n\n\n```\n#### arguments转换为数组\n```\nfunction toArr(){\n    var arr = [];\n    for（var i in arguments）{\n        arr.push(arguments[i]);\n    }\n    return arr;\n}\n```\n\n```\nfunction toArr(){\n    var arr = [];\n    arr = Array.prototype.slice.call(arguments);\n    return arr;\n}\n```","slug":"js/js：类数组对象","published":1,"date":"2020-05-14T09:23:03.761Z","updated":"2020-05-14T09:23:30.433Z","layout":"post","photos":[],"link":"","_id":"cka6kws3y003zrcu9fw0qexyc","content":"<h3 id=\"类数组对象\"><a href=\"#类数组对象\" class=\"headerlink\" title=\"类数组对象\"></a>类数组对象</h3><p>只包含使用从零开始，且自然递增的整数做键名，并且定义了length表示元素个数的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3];</span><br><span class=\"line\">var obj = &#123;0: 1, 1: 2, 2: 3, length: 3&#125;;</span><br><span class=\"line\">console.log(arr[0], obj[0])//1, 1</span><br><span class=\"line\">console.log(arr[&apos;length&apos;], obj[&apos;length&apos;])//3，3</span><br></pre></td></tr></table></figure>\n<p>我们可以使用对象来模拟数组，只要我们定义的对象的每个元素的键名都使用数字并且让其保持递增，且动态的定义一个length属性来表示元素个数，那么从效果上来说，基本就和数组相同了。</p>\n<h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h3><p>arguments就是一个典型的类数组对象，为一个参数集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 数组</span><br><span class=\"line\">function printArr () &#123;</span><br><span class=\"line\">    return [&apos;ming&apos;,18];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printArr()</span><br><span class=\"line\">// 打印结果</span><br><span class=\"line\">(2) [&quot;ming&quot;, 18]</span><br><span class=\"line\">    0: &quot;ming&quot;</span><br><span class=\"line\">    1: 18</span><br><span class=\"line\">    length: 2</span><br><span class=\"line\">    __proto__: Array(0)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">// arguments</span><br><span class=\"line\">function printArg (name,age) &#123;</span><br><span class=\"line\">    return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printArg(&apos;ming&apos;,18)</span><br><span class=\"line\">// 打印结果</span><br><span class=\"line\">Arguments(2) [&quot;ming&quot;, 18, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class=\"line\">    0: &quot;ming&quot;</span><br><span class=\"line\">    1: 18</span><br><span class=\"line\">    callee: ƒ fn(name,age)</span><br><span class=\"line\">    length: 2</span><br><span class=\"line\">    Symbol(Symbol.iterator): ƒ values()</span><br><span class=\"line\">    __proto__: Object</span><br></pre></td></tr></table></figure>\n<h4 id=\"arguments转换为数组\"><a href=\"#arguments转换为数组\" class=\"headerlink\" title=\"arguments转换为数组\"></a>arguments转换为数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toArr()&#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for（var i in arguments）&#123;</span><br><span class=\"line\">        arr.push(arguments[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toArr()&#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    arr = Array.prototype.slice.call(arguments);</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"类数组对象\"><a href=\"#类数组对象\" class=\"headerlink\" title=\"类数组对象\"></a>类数组对象</h3><p>只包含使用从零开始，且自然递增的整数做键名，并且定义了length表示元素个数的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3];</span><br><span class=\"line\">var obj = &#123;0: 1, 1: 2, 2: 3, length: 3&#125;;</span><br><span class=\"line\">console.log(arr[0], obj[0])//1, 1</span><br><span class=\"line\">console.log(arr[&apos;length&apos;], obj[&apos;length&apos;])//3，3</span><br></pre></td></tr></table></figure>\n<p>我们可以使用对象来模拟数组，只要我们定义的对象的每个元素的键名都使用数字并且让其保持递增，且动态的定义一个length属性来表示元素个数，那么从效果上来说，基本就和数组相同了。</p>\n<h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h3><p>arguments就是一个典型的类数组对象，为一个参数集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 数组</span><br><span class=\"line\">function printArr () &#123;</span><br><span class=\"line\">    return [&apos;ming&apos;,18];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printArr()</span><br><span class=\"line\">// 打印结果</span><br><span class=\"line\">(2) [&quot;ming&quot;, 18]</span><br><span class=\"line\">    0: &quot;ming&quot;</span><br><span class=\"line\">    1: 18</span><br><span class=\"line\">    length: 2</span><br><span class=\"line\">    __proto__: Array(0)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">// arguments</span><br><span class=\"line\">function printArg (name,age) &#123;</span><br><span class=\"line\">    return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printArg(&apos;ming&apos;,18)</span><br><span class=\"line\">// 打印结果</span><br><span class=\"line\">Arguments(2) [&quot;ming&quot;, 18, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class=\"line\">    0: &quot;ming&quot;</span><br><span class=\"line\">    1: 18</span><br><span class=\"line\">    callee: ƒ fn(name,age)</span><br><span class=\"line\">    length: 2</span><br><span class=\"line\">    Symbol(Symbol.iterator): ƒ values()</span><br><span class=\"line\">    __proto__: Object</span><br></pre></td></tr></table></figure>\n<h4 id=\"arguments转换为数组\"><a href=\"#arguments转换为数组\" class=\"headerlink\" title=\"arguments转换为数组\"></a>arguments转换为数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toArr()&#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for（var i in arguments）&#123;</span><br><span class=\"line\">        arr.push(arguments[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toArr()&#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    arr = Array.prototype.slice.call(arguments);</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"js：递归和非递归实现中序遍历","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### 二叉树结构\n\n\n```\nvar TreeNode = {\n    val: 1,\n    left: {\n        val: 2,\n        left: {\n          val: 4,\n        },\n        right: {\n            val: 5\n        }\n    },\n    right: {\n        val: 3,\n        left: {\n            val: 6,\n        },\n        right: {\n            val: 7\n        }\n    }\n};\n// 中序遍历，左根右\n// [4, 2, 5, 1, 6, 3, 7]\n```\n### 递归\n\n```\nfunction inOrderRecur (root，list=[]) {\n    if(root !== undefined) {\n        inOrderRecur(root.left,list);\n        list.push(root.val);\n        inOrderRecur(root.right,list);\n    }\n    return list;\n}\n```\n\n### 非递归\n\n```\nfunction inOrderUnRecur (root){\n    var stack = [];\n    var list = [];\n    var head = root;\n    while(stack.length !== 0 || head !== undefined){\n        while(head !== undefined){\n            stack.push(head);\n            head = head.left;\n        }\n\n        if(stack.length !== 0){\n            head = stack.pop();\n            list.push(head.val);\n            head = head.right;\n        }\n    }\n    return list;\n};\n```\n","source":"_posts/js/js：递归和非递归实现中序遍历.md","raw":"---\ntitle: js：递归和非递归实现中序遍历\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n### 二叉树结构\n\n\n```\nvar TreeNode = {\n    val: 1,\n    left: {\n        val: 2,\n        left: {\n          val: 4,\n        },\n        right: {\n            val: 5\n        }\n    },\n    right: {\n        val: 3,\n        left: {\n            val: 6,\n        },\n        right: {\n            val: 7\n        }\n    }\n};\n// 中序遍历，左根右\n// [4, 2, 5, 1, 6, 3, 7]\n```\n### 递归\n\n```\nfunction inOrderRecur (root，list=[]) {\n    if(root !== undefined) {\n        inOrderRecur(root.left,list);\n        list.push(root.val);\n        inOrderRecur(root.right,list);\n    }\n    return list;\n}\n```\n\n### 非递归\n\n```\nfunction inOrderUnRecur (root){\n    var stack = [];\n    var list = [];\n    var head = root;\n    while(stack.length !== 0 || head !== undefined){\n        while(head !== undefined){\n            stack.push(head);\n            head = head.left;\n        }\n\n        if(stack.length !== 0){\n            head = stack.pop();\n            list.push(head.val);\n            head = head.right;\n        }\n    }\n    return list;\n};\n```\n","slug":"js/js：递归和非递归实现中序遍历","published":1,"date":"2020-05-14T08:56:37.614Z","updated":"2020-05-14T09:02:29.299Z","layout":"post","photos":[],"link":"","_id":"cka6kws430042rcu9m5z0akyi","content":"<h3 id=\"二叉树结构\"><a href=\"#二叉树结构\" class=\"headerlink\" title=\"二叉树结构\"></a>二叉树结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var TreeNode = &#123;</span><br><span class=\"line\">    val: 1,</span><br><span class=\"line\">    left: &#123;</span><br><span class=\"line\">        val: 2,</span><br><span class=\"line\">        left: &#123;</span><br><span class=\"line\">          val: 4,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        right: &#123;</span><br><span class=\"line\">            val: 5</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    right: &#123;</span><br><span class=\"line\">        val: 3,</span><br><span class=\"line\">        left: &#123;</span><br><span class=\"line\">            val: 6,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        right: &#123;</span><br><span class=\"line\">            val: 7</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 中序遍历，左根右</span><br><span class=\"line\">// [4, 2, 5, 1, 6, 3, 7]</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inOrderRecur (root，list=[]) &#123;</span><br><span class=\"line\">    if(root !== undefined) &#123;</span><br><span class=\"line\">        inOrderRecur(root.left,list);</span><br><span class=\"line\">        list.push(root.val);</span><br><span class=\"line\">        inOrderRecur(root.right,list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inOrderUnRecur (root)&#123;</span><br><span class=\"line\">    var stack = [];</span><br><span class=\"line\">    var list = [];</span><br><span class=\"line\">    var head = root;</span><br><span class=\"line\">    while(stack.length !== 0 || head !== undefined)&#123;</span><br><span class=\"line\">        while(head !== undefined)&#123;</span><br><span class=\"line\">            stack.push(head);</span><br><span class=\"line\">            head = head.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if(stack.length !== 0)&#123;</span><br><span class=\"line\">            head = stack.pop();</span><br><span class=\"line\">            list.push(head.val);</span><br><span class=\"line\">            head = head.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return list;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"二叉树结构\"><a href=\"#二叉树结构\" class=\"headerlink\" title=\"二叉树结构\"></a>二叉树结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var TreeNode = &#123;</span><br><span class=\"line\">    val: 1,</span><br><span class=\"line\">    left: &#123;</span><br><span class=\"line\">        val: 2,</span><br><span class=\"line\">        left: &#123;</span><br><span class=\"line\">          val: 4,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        right: &#123;</span><br><span class=\"line\">            val: 5</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    right: &#123;</span><br><span class=\"line\">        val: 3,</span><br><span class=\"line\">        left: &#123;</span><br><span class=\"line\">            val: 6,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        right: &#123;</span><br><span class=\"line\">            val: 7</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 中序遍历，左根右</span><br><span class=\"line\">// [4, 2, 5, 1, 6, 3, 7]</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inOrderRecur (root，list=[]) &#123;</span><br><span class=\"line\">    if(root !== undefined) &#123;</span><br><span class=\"line\">        inOrderRecur(root.left,list);</span><br><span class=\"line\">        list.push(root.val);</span><br><span class=\"line\">        inOrderRecur(root.right,list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inOrderUnRecur (root)&#123;</span><br><span class=\"line\">    var stack = [];</span><br><span class=\"line\">    var list = [];</span><br><span class=\"line\">    var head = root;</span><br><span class=\"line\">    while(stack.length !== 0 || head !== undefined)&#123;</span><br><span class=\"line\">        while(head !== undefined)&#123;</span><br><span class=\"line\">            stack.push(head);</span><br><span class=\"line\">            head = head.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if(stack.length !== 0)&#123;</span><br><span class=\"line\">            head = stack.pop();</span><br><span class=\"line\">            list.push(head.val);</span><br><span class=\"line\">            head = head.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return list;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"js：防抖和节流","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n优化高频率执行js代码\n### 防抖\n在事件被触发后的某个时间限制内，事件处理函数只执行一次。\n\n在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n\n应用场景：搜索框搜索输入，最后一次输入完再发送请求；手机号、邮箱验证输入检测。\n\n```\nfunction debounce(fn,delay){\n    var timer;\n    return function(){\n        var _this = this; //取debounce执行作用域的this\n        var args = arguments;//获取传入闭包函数中的参数\n        //以上两句为了debounce函数最终返回的函数this指向不变（否则指向全局）和依然可以获取参数。\n        //因为fn有可能需要传参\n        if(timer){ \n        //当前正在一个计时过程中，又触发相同事件，所以取消计时，重新计时\n            clearTimeout(timer);\n        }\n        timer = setTimeout(function(){\n            fn.apply(_this,args); //把回调函数应用在这些对象上\n        },delay);\n    };\n}\n```\n> 缺点：若不断触发同一事件会导致回调函数无法执行\n\n\n### 节流\n每隔一段时间，只执行一次函数\n\n如果短时间内大量触发同一事件，那么函数在执行一次后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。\n\n与防抖相比，多了防止不断触发同一事件而导致不执行回调函数的情况。\n\n应用场景：滚动加载，加载更多或滚到底部监听\n\n```\n//第一种：定时器\nfunction throttle(fn,delay){\n    var timer;\n    return function(){\n        var _this = this;\n        var args = arguments;\n        if(timer){\n           return;\n        }\n        timer = setTimeout(function(){\n            fn.apply(_this,args);\n            timer = null;  //在delay后执行完fn后把timer清空\n        },delay);\n    };\n}\n\n//第二种：时间戳\nfunction throttle(fn,delay){\n    var previous = 0;\n    return function(){\n        var _this = this;\n        var args = arguments;\n        var now = new Date();\n        //若时间差大于间隔时间，就执行回调函数，并更新上一次执行时间\n        if(now - previous > delay){\n            fn.apply(_this,args);\n            previous = now;\n        }\n    }\n}\n```\n\n### 相同点\n- 都可以使用setTimeout实现\n- 目的都是降低回调执行频率，节省计算资源\n\n### 不同点\n- 防抖，在一段连续操作结束后，处理回调函数。\n- 节流，在一段连续操作中，每隔一段时间只执行一次回调函数。\n","source":"_posts/js/js：防抖和节流.md","raw":"---\ntitle: js：防抖和节流\nDate: 2020-05-14\ntags: [JS]\ncategories: JS\ncomments: true\n---\n\n优化高频率执行js代码\n### 防抖\n在事件被触发后的某个时间限制内，事件处理函数只执行一次。\n\n在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n\n应用场景：搜索框搜索输入，最后一次输入完再发送请求；手机号、邮箱验证输入检测。\n\n```\nfunction debounce(fn,delay){\n    var timer;\n    return function(){\n        var _this = this; //取debounce执行作用域的this\n        var args = arguments;//获取传入闭包函数中的参数\n        //以上两句为了debounce函数最终返回的函数this指向不变（否则指向全局）和依然可以获取参数。\n        //因为fn有可能需要传参\n        if(timer){ \n        //当前正在一个计时过程中，又触发相同事件，所以取消计时，重新计时\n            clearTimeout(timer);\n        }\n        timer = setTimeout(function(){\n            fn.apply(_this,args); //把回调函数应用在这些对象上\n        },delay);\n    };\n}\n```\n> 缺点：若不断触发同一事件会导致回调函数无法执行\n\n\n### 节流\n每隔一段时间，只执行一次函数\n\n如果短时间内大量触发同一事件，那么函数在执行一次后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。\n\n与防抖相比，多了防止不断触发同一事件而导致不执行回调函数的情况。\n\n应用场景：滚动加载，加载更多或滚到底部监听\n\n```\n//第一种：定时器\nfunction throttle(fn,delay){\n    var timer;\n    return function(){\n        var _this = this;\n        var args = arguments;\n        if(timer){\n           return;\n        }\n        timer = setTimeout(function(){\n            fn.apply(_this,args);\n            timer = null;  //在delay后执行完fn后把timer清空\n        },delay);\n    };\n}\n\n//第二种：时间戳\nfunction throttle(fn,delay){\n    var previous = 0;\n    return function(){\n        var _this = this;\n        var args = arguments;\n        var now = new Date();\n        //若时间差大于间隔时间，就执行回调函数，并更新上一次执行时间\n        if(now - previous > delay){\n            fn.apply(_this,args);\n            previous = now;\n        }\n    }\n}\n```\n\n### 相同点\n- 都可以使用setTimeout实现\n- 目的都是降低回调执行频率，节省计算资源\n\n### 不同点\n- 防抖，在一段连续操作结束后，处理回调函数。\n- 节流，在一段连续操作中，每隔一段时间只执行一次回调函数。\n","slug":"js/js：防抖和节流","published":1,"date":"2020-05-14T08:56:20.397Z","updated":"2020-05-14T09:03:16.070Z","layout":"post","photos":[],"link":"","_id":"cka6kws470045rcu93azdmpf3","content":"<p>优化高频率执行js代码</p>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>在事件被触发后的某个时间限制内，事件处理函数只执行一次。</p>\n<p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>\n<p>应用场景：搜索框搜索输入，最后一次输入完再发送请求；手机号、邮箱验证输入检测。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn,delay)&#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        var _this = this; //取debounce执行作用域的this</span><br><span class=\"line\">        var args = arguments;//获取传入闭包函数中的参数</span><br><span class=\"line\">        //以上两句为了debounce函数最终返回的函数this指向不变（否则指向全局）和依然可以获取参数。</span><br><span class=\"line\">        //因为fn有可能需要传参</span><br><span class=\"line\">        if(timer)&#123; </span><br><span class=\"line\">        //当前正在一个计时过程中，又触发相同事件，所以取消计时，重新计时</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = setTimeout(function()&#123;</span><br><span class=\"line\">            fn.apply(_this,args); //把回调函数应用在这些对象上</span><br><span class=\"line\">        &#125;,delay);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>缺点：若不断触发同一事件会导致回调函数无法执行</p>\n</blockquote>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>每隔一段时间，只执行一次函数</p>\n<p>如果短时间内大量触发同一事件，那么函数在执行一次后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</p>\n<p>与防抖相比，多了防止不断触发同一事件而导致不执行回调函数的情况。</p>\n<p>应用场景：滚动加载，加载更多或滚到底部监听</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第一种：定时器</span><br><span class=\"line\">function throttle(fn,delay)&#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        if(timer)&#123;</span><br><span class=\"line\">           return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = setTimeout(function()&#123;</span><br><span class=\"line\">            fn.apply(_this,args);</span><br><span class=\"line\">            timer = null;  //在delay后执行完fn后把timer清空</span><br><span class=\"line\">        &#125;,delay);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//第二种：时间戳</span><br><span class=\"line\">function throttle(fn,delay)&#123;</span><br><span class=\"line\">    var previous = 0;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        var now = new Date();</span><br><span class=\"line\">        //若时间差大于间隔时间，就执行回调函数，并更新上一次执行时间</span><br><span class=\"line\">        if(now - previous &gt; delay)&#123;</span><br><span class=\"line\">            fn.apply(_this,args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><ul>\n<li>都可以使用setTimeout实现</li>\n<li>目的都是降低回调执行频率，节省计算资源</li>\n</ul>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><ul>\n<li>防抖，在一段连续操作结束后，处理回调函数。</li>\n<li>节流，在一段连续操作中，每隔一段时间只执行一次回调函数。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>优化高频率执行js代码</p>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>在事件被触发后的某个时间限制内，事件处理函数只执行一次。</p>\n<p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>\n<p>应用场景：搜索框搜索输入，最后一次输入完再发送请求；手机号、邮箱验证输入检测。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn,delay)&#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        var _this = this; //取debounce执行作用域的this</span><br><span class=\"line\">        var args = arguments;//获取传入闭包函数中的参数</span><br><span class=\"line\">        //以上两句为了debounce函数最终返回的函数this指向不变（否则指向全局）和依然可以获取参数。</span><br><span class=\"line\">        //因为fn有可能需要传参</span><br><span class=\"line\">        if(timer)&#123; </span><br><span class=\"line\">        //当前正在一个计时过程中，又触发相同事件，所以取消计时，重新计时</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = setTimeout(function()&#123;</span><br><span class=\"line\">            fn.apply(_this,args); //把回调函数应用在这些对象上</span><br><span class=\"line\">        &#125;,delay);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>缺点：若不断触发同一事件会导致回调函数无法执行</p>\n</blockquote>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>每隔一段时间，只执行一次函数</p>\n<p>如果短时间内大量触发同一事件，那么函数在执行一次后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</p>\n<p>与防抖相比，多了防止不断触发同一事件而导致不执行回调函数的情况。</p>\n<p>应用场景：滚动加载，加载更多或滚到底部监听</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第一种：定时器</span><br><span class=\"line\">function throttle(fn,delay)&#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        if(timer)&#123;</span><br><span class=\"line\">           return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = setTimeout(function()&#123;</span><br><span class=\"line\">            fn.apply(_this,args);</span><br><span class=\"line\">            timer = null;  //在delay后执行完fn后把timer清空</span><br><span class=\"line\">        &#125;,delay);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//第二种：时间戳</span><br><span class=\"line\">function throttle(fn,delay)&#123;</span><br><span class=\"line\">    var previous = 0;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        var now = new Date();</span><br><span class=\"line\">        //若时间差大于间隔时间，就执行回调函数，并更新上一次执行时间</span><br><span class=\"line\">        if(now - previous &gt; delay)&#123;</span><br><span class=\"line\">            fn.apply(_this,args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><ul>\n<li>都可以使用setTimeout实现</li>\n<li>目的都是降低回调执行频率，节省计算资源</li>\n</ul>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><ul>\n<li>防抖，在一段连续操作结束后，处理回调函数。</li>\n<li>节流，在一段连续操作中，每隔一段时间只执行一次回调函数。</li>\n</ul>\n"},{"title":"CSS：position","Date":"2019-03-25T16:00:00.000Z","comments":1,"_content":"\n### position:static\n没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。\n\n### position:fixed\n相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。\n\n### position:relative\n1. 相对于元素自身正常位置定位，元素在正常的文档流中占位。\n2. 当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。\n\n### position:absolute\n1. 元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。\n2. 必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，但是不占位。\n3. 绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会\n4. 绝对定位对象头部超过可视区域会被裁掉。\n\n### position:inherit\n规定应该从父元素继承 position 属性的值。\n\n### z-index\n1. 如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。\n2. 需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。","source":"_posts/css/css：positon.md","raw":"---\ntitle: CSS：position\nDate: 2019-03-26\ntags: [CSS]\ncategories: CSS\ncomments: true\n---\n\n### position:static\n没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。\n\n### position:fixed\n相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。\n\n### position:relative\n1. 相对于元素自身正常位置定位，元素在正常的文档流中占位。\n2. 当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。\n\n### position:absolute\n1. 元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。\n2. 必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，但是不占位。\n3. 绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会\n4. 绝对定位对象头部超过可视区域会被裁掉。\n\n### position:inherit\n规定应该从父元素继承 position 属性的值。\n\n### z-index\n1. 如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。\n2. 需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。","slug":"css/css：positon","published":1,"date":"2019-03-26T03:46:23.311Z","updated":"2019-03-26T03:43:57.303Z","layout":"post","photos":[],"link":"","_id":"cka6kws4b0048rcu9hnpxwd77","content":"<h3 id=\"position-static\"><a href=\"#position-static\" class=\"headerlink\" title=\"position:static\"></a>position:static</h3><p>没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。</p>\n<h3 id=\"position-fixed\"><a href=\"#position-fixed\" class=\"headerlink\" title=\"position:fixed\"></a>position:fixed</h3><p>相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。</p>\n<h3 id=\"position-relative\"><a href=\"#position-relative\" class=\"headerlink\" title=\"position:relative\"></a>position:relative</h3><ol>\n<li>相对于元素自身正常位置定位，元素在正常的文档流中占位。</li>\n<li>当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。</li>\n</ol>\n<h3 id=\"position-absolute\"><a href=\"#position-absolute\" class=\"headerlink\" title=\"position:absolute\"></a>position:absolute</h3><ol>\n<li>元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。</li>\n<li>必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，但是不占位。</li>\n<li>绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会</li>\n<li>绝对定位对象头部超过可视区域会被裁掉。</li>\n</ol>\n<h3 id=\"position-inherit\"><a href=\"#position-inherit\" class=\"headerlink\" title=\"position:inherit\"></a>position:inherit</h3><p>规定应该从父元素继承 position 属性的值。</p>\n<h3 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h3><ol>\n<li>如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。</li>\n<li>需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"position-static\"><a href=\"#position-static\" class=\"headerlink\" title=\"position:static\"></a>position:static</h3><p>没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。</p>\n<h3 id=\"position-fixed\"><a href=\"#position-fixed\" class=\"headerlink\" title=\"position:fixed\"></a>position:fixed</h3><p>相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。</p>\n<h3 id=\"position-relative\"><a href=\"#position-relative\" class=\"headerlink\" title=\"position:relative\"></a>position:relative</h3><ol>\n<li>相对于元素自身正常位置定位，元素在正常的文档流中占位。</li>\n<li>当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。</li>\n</ol>\n<h3 id=\"position-absolute\"><a href=\"#position-absolute\" class=\"headerlink\" title=\"position:absolute\"></a>position:absolute</h3><ol>\n<li>元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。</li>\n<li>必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，但是不占位。</li>\n<li>绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会</li>\n<li>绝对定位对象头部超过可视区域会被裁掉。</li>\n</ol>\n<h3 id=\"position-inherit\"><a href=\"#position-inherit\" class=\"headerlink\" title=\"position:inherit\"></a>position:inherit</h3><p>规定应该从父元素继承 position 属性的值。</p>\n<h3 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h3><ol>\n<li>如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。</li>\n<li>需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。</li>\n</ol>\n"},{"title":"Hexo+Github 搭建属于自己的博客（基础）","Date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"\n# 搭建环境准备\n### Node.js 的安装和准备\n\n```\n$ node -v\n$ npm -v\n```\n###  git的安装和准备\n\n```\n$ git --version\n```\n\n### github账户的配置\n\n- github账户注册\n- 创建新仓库\n\n![image](http://ww4.sinaimg.cn/large/9fe4afa0gw1faljv7hoqhj20p40fz0vo.jpg)\n\n注意：仓库名称一定为  github用户名.github.io\n\n- 仓库设置\n\n![image](http://ww1.sinaimg.cn/large/9fe4afa0gw1falk4end8ij20kg0cbtbl.jpg)\n\n接下来开启github pages功能 ，点击界面右侧的 Settings，你将会打开这个库的settings页面，向下拖动，直到看见GitHub Pages\n\n![image](http://ww3.sinaimg.cn/large/9fe4afa0gw1falk1s5xq7j20q204kq3o.jpg)\n\n\n\n![image](http://upload-images.jianshu.io/upload_images/1244124-5e0f79282ae8140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n\n\n# 安装hexo \n在任意一个地方创建文件夹hexo，进入到该目录输入：\n\n```\n$ npm install hexo-cli -g\n```\n然后可能会看到一个WARN，并不会影响操作，继续输入：\n\n```\n$ npm install hexo --save\n```\n\n```\n$ hexo -v\n```\n### hexo的相关配置\n\n- 初始化hexo\n\n```\n$ hexo init <新文件夹> \n$ cd <新文件夹>\n```\n\n- 首次体验hexo\n\n```\n$ hexo g\n$ hexo s  //若一直无法跳转，则是端口被占用\n$ hexo server -p 5000 //改变端口号\n```\n\n### 配置Git个人信息\n如果之前已经配置好git个人信息，请跳过这一个步骤\n- 设置Git的user name和email\n\n```\n$ git config --global user.name \"yourusername\"\n$ git config --global user.email \"youremail\"\n```\n- 生成密钥\n\n\n```\n$  ssh-keygen -t rsa -C \"youremail\"\n```\n\n### 配置Deployment\n\n在_config.yml文件中，找到Deployment，然后按照如下修改：\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/yourname/yourname.github.io.git\n  branch: master\n  \n```\n\n# 写博客、发布新文章\n\n- 新建一篇博客\n\n```\n$ hexo new post \"article title\"\n```\n用MarDown编辑器打开就可以编辑文章了\n\n- 生成、部署\n\n```\n$ hexo g   // 生成\n$ hexo d   // 部署\n```\n\n```\n$ hexo d -g //在部署前先生成\n```\n\n- 踩坑提醒\n\n注意需要提前安装一个扩展\n\n```\nnpm install hexo-deployer-git --save\n```\n> 如果没有执行这行命令，将会提醒\n\n    deloyer not found:git\n\n","source":"_posts/其他/Hexo+Github 搭建属于自己的博客（基础）.md","raw":"---\ntitle: Hexo+Github 搭建属于自己的博客（基础）\nDate: 2018-05-03\ntags: [博客搭建]\ncategories: 博客搭建\ncomments: true\n---\n\n# 搭建环境准备\n### Node.js 的安装和准备\n\n```\n$ node -v\n$ npm -v\n```\n###  git的安装和准备\n\n```\n$ git --version\n```\n\n### github账户的配置\n\n- github账户注册\n- 创建新仓库\n\n![image](http://ww4.sinaimg.cn/large/9fe4afa0gw1faljv7hoqhj20p40fz0vo.jpg)\n\n注意：仓库名称一定为  github用户名.github.io\n\n- 仓库设置\n\n![image](http://ww1.sinaimg.cn/large/9fe4afa0gw1falk4end8ij20kg0cbtbl.jpg)\n\n接下来开启github pages功能 ，点击界面右侧的 Settings，你将会打开这个库的settings页面，向下拖动，直到看见GitHub Pages\n\n![image](http://ww3.sinaimg.cn/large/9fe4afa0gw1falk1s5xq7j20q204kq3o.jpg)\n\n\n\n![image](http://upload-images.jianshu.io/upload_images/1244124-5e0f79282ae8140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n\n\n# 安装hexo \n在任意一个地方创建文件夹hexo，进入到该目录输入：\n\n```\n$ npm install hexo-cli -g\n```\n然后可能会看到一个WARN，并不会影响操作，继续输入：\n\n```\n$ npm install hexo --save\n```\n\n```\n$ hexo -v\n```\n### hexo的相关配置\n\n- 初始化hexo\n\n```\n$ hexo init <新文件夹> \n$ cd <新文件夹>\n```\n\n- 首次体验hexo\n\n```\n$ hexo g\n$ hexo s  //若一直无法跳转，则是端口被占用\n$ hexo server -p 5000 //改变端口号\n```\n\n### 配置Git个人信息\n如果之前已经配置好git个人信息，请跳过这一个步骤\n- 设置Git的user name和email\n\n```\n$ git config --global user.name \"yourusername\"\n$ git config --global user.email \"youremail\"\n```\n- 生成密钥\n\n\n```\n$  ssh-keygen -t rsa -C \"youremail\"\n```\n\n### 配置Deployment\n\n在_config.yml文件中，找到Deployment，然后按照如下修改：\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/yourname/yourname.github.io.git\n  branch: master\n  \n```\n\n# 写博客、发布新文章\n\n- 新建一篇博客\n\n```\n$ hexo new post \"article title\"\n```\n用MarDown编辑器打开就可以编辑文章了\n\n- 生成、部署\n\n```\n$ hexo g   // 生成\n$ hexo d   // 部署\n```\n\n```\n$ hexo d -g //在部署前先生成\n```\n\n- 踩坑提醒\n\n注意需要提前安装一个扩展\n\n```\nnpm install hexo-deployer-git --save\n```\n> 如果没有执行这行命令，将会提醒\n\n    deloyer not found:git\n\n","slug":"其他/Hexo+Github 搭建属于自己的博客（基础）","published":1,"date":"2018-05-03T14:27:08.897Z","updated":"2018-05-04T14:57:24.269Z","layout":"post","photos":[],"link":"","_id":"cka6l2e2n0000c0u9pf87lrpm","content":"<h1 id=\"搭建环境准备\"><a href=\"#搭建环境准备\" class=\"headerlink\" title=\"搭建环境准备\"></a>搭建环境准备</h1><h3 id=\"Node-js-的安装和准备\"><a href=\"#Node-js-的安装和准备\" class=\"headerlink\" title=\"Node.js 的安装和准备\"></a>Node.js 的安装和准备</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">$ npm -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"git的安装和准备\"><a href=\"#git的安装和准备\" class=\"headerlink\" title=\"git的安装和准备\"></a>git的安装和准备</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git --version</span><br></pre></td></tr></table></figure>\n<h3 id=\"github账户的配置\"><a href=\"#github账户的配置\" class=\"headerlink\" title=\"github账户的配置\"></a>github账户的配置</h3><ul>\n<li>github账户注册</li>\n<li>创建新仓库</li>\n</ul>\n<p><img src=\"http://ww4.sinaimg.cn/large/9fe4afa0gw1faljv7hoqhj20p40fz0vo.jpg\" alt=\"image\"></p>\n<p>注意：仓库名称一定为  github用户名.github.io</p>\n<ul>\n<li>仓库设置</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/9fe4afa0gw1falk4end8ij20kg0cbtbl.jpg\" alt=\"image\"></p>\n<p>接下来开启github pages功能 ，点击界面右侧的 Settings，你将会打开这个库的settings页面，向下拖动，直到看见GitHub Pages</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/9fe4afa0gw1falk1s5xq7j20q204kq3o.jpg\" alt=\"image\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1244124-5e0f79282ae8140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"image\"></p>\n<h1 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h1><p>在任意一个地方创建文件夹hexo，进入到该目录输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<p>然后可能会看到一个WARN，并不会影响操作，继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo --save</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"hexo的相关配置\"><a href=\"#hexo的相关配置\" class=\"headerlink\" title=\"hexo的相关配置\"></a>hexo的相关配置</h3><ul>\n<li>初始化hexo</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;新文件夹&gt; </span><br><span class=\"line\">$ cd &lt;新文件夹&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首次体验hexo</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo s  //若一直无法跳转，则是端口被占用</span><br><span class=\"line\">$ hexo server -p 5000 //改变端口号</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置Git个人信息\"><a href=\"#配置Git个人信息\" class=\"headerlink\" title=\"配置Git个人信息\"></a>配置Git个人信息</h3><p>如果之前已经配置好git个人信息，请跳过这一个步骤</p>\n<ul>\n<li>设置Git的user name和email</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;yourusername&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成密钥</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置Deployment\"><a href=\"#配置Deployment\" class=\"headerlink\" title=\"配置Deployment\"></a>配置Deployment</h3><p>在_config.yml文件中，找到Deployment，然后按照如下修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/yourname/yourname.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<h1 id=\"写博客、发布新文章\"><a href=\"#写博客、发布新文章\" class=\"headerlink\" title=\"写博客、发布新文章\"></a>写博客、发布新文章</h1><ul>\n<li>新建一篇博客</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure>\n<p>用MarDown编辑器打开就可以编辑文章了</p>\n<ul>\n<li>生成、部署</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g   // 生成</span><br><span class=\"line\">$ hexo d   // 部署</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d -g //在部署前先生成</span><br></pre></td></tr></table></figure>\n<ul>\n<li>踩坑提醒</li>\n</ul>\n<p>注意需要提前安装一个扩展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果没有执行这行命令，将会提醒</p>\n</blockquote>\n<pre><code>deloyer not found:git\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"搭建环境准备\"><a href=\"#搭建环境准备\" class=\"headerlink\" title=\"搭建环境准备\"></a>搭建环境准备</h1><h3 id=\"Node-js-的安装和准备\"><a href=\"#Node-js-的安装和准备\" class=\"headerlink\" title=\"Node.js 的安装和准备\"></a>Node.js 的安装和准备</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">$ npm -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"git的安装和准备\"><a href=\"#git的安装和准备\" class=\"headerlink\" title=\"git的安装和准备\"></a>git的安装和准备</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git --version</span><br></pre></td></tr></table></figure>\n<h3 id=\"github账户的配置\"><a href=\"#github账户的配置\" class=\"headerlink\" title=\"github账户的配置\"></a>github账户的配置</h3><ul>\n<li>github账户注册</li>\n<li>创建新仓库</li>\n</ul>\n<p><img src=\"http://ww4.sinaimg.cn/large/9fe4afa0gw1faljv7hoqhj20p40fz0vo.jpg\" alt=\"image\"></p>\n<p>注意：仓库名称一定为  github用户名.github.io</p>\n<ul>\n<li>仓库设置</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/9fe4afa0gw1falk4end8ij20kg0cbtbl.jpg\" alt=\"image\"></p>\n<p>接下来开启github pages功能 ，点击界面右侧的 Settings，你将会打开这个库的settings页面，向下拖动，直到看见GitHub Pages</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/9fe4afa0gw1falk1s5xq7j20q204kq3o.jpg\" alt=\"image\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1244124-5e0f79282ae8140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"image\"></p>\n<h1 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h1><p>在任意一个地方创建文件夹hexo，进入到该目录输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<p>然后可能会看到一个WARN，并不会影响操作，继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo --save</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"hexo的相关配置\"><a href=\"#hexo的相关配置\" class=\"headerlink\" title=\"hexo的相关配置\"></a>hexo的相关配置</h3><ul>\n<li>初始化hexo</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;新文件夹&gt; </span><br><span class=\"line\">$ cd &lt;新文件夹&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首次体验hexo</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo s  //若一直无法跳转，则是端口被占用</span><br><span class=\"line\">$ hexo server -p 5000 //改变端口号</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置Git个人信息\"><a href=\"#配置Git个人信息\" class=\"headerlink\" title=\"配置Git个人信息\"></a>配置Git个人信息</h3><p>如果之前已经配置好git个人信息，请跳过这一个步骤</p>\n<ul>\n<li>设置Git的user name和email</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;yourusername&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成密钥</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置Deployment\"><a href=\"#配置Deployment\" class=\"headerlink\" title=\"配置Deployment\"></a>配置Deployment</h3><p>在_config.yml文件中，找到Deployment，然后按照如下修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/yourname/yourname.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<h1 id=\"写博客、发布新文章\"><a href=\"#写博客、发布新文章\" class=\"headerlink\" title=\"写博客、发布新文章\"></a>写博客、发布新文章</h1><ul>\n<li>新建一篇博客</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure>\n<p>用MarDown编辑器打开就可以编辑文章了</p>\n<ul>\n<li>生成、部署</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g   // 生成</span><br><span class=\"line\">$ hexo d   // 部署</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d -g //在部署前先生成</span><br></pre></td></tr></table></figure>\n<ul>\n<li>踩坑提醒</li>\n</ul>\n<p>注意需要提前安装一个扩展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果没有执行这行命令，将会提醒</p>\n</blockquote>\n<pre><code>deloyer not found:git\n</code></pre>"},{"title":"Electron：从零到完成一个桌面应用","Date":"2019-02-25T16:00:00.000Z","comments":1,"_content":"\nElectron\n## 开发环境\n- 安装node\n- 安装cnpm（或者npm）\n- 安装electron\n- 安装打包工具\n\n```\nnpm install -g electron-packager\n```\n\n## 经典例子\n### electron-quick-start\n一个简约的记事本\n```\n//克隆这仓库\n git clone https://github.com/electron/electron-quick-start\n//进入仓库\n cd electron-quick-start\n//安装依赖库\n cnpm install\n//运行应用，也可以用： cnpm run start\n cnpm start \n```\n### electron-api-demos\n介绍了主要的一些功能及实现代码\n\n```\n git clone https://github.com/electron/electron-api-demos\n cd electron-api-demos\n cnpm install\n cnpm start\n```\n## 开始开发\n### 安装electron\n推荐的安装方法是把electron作为您 app 中的开发依赖项，使您可以在不同的 app 中使用不同的 Electron 版本   \n\n在根目录下运行\n\n```\nnpm install --save-dev electron\n```\n当然，也可以在 $PATH 中全局安装\n```\nnpm install electron -g\n```\n\n### 创建Electron简单文件结构  \n在根目录下创建package.json文件，内容如下\n\n```\n{\n\t\"name\": \"test\",\n\t\"version\": \"0.1.0\",\n\t\"main\": \"main.js\",\n\t\"scripts\": {\n\t\t\"start\": \"electron .\"\n\t},\n\t\"devDependencies\": {\n\t\t\"electron\": \"^3.0.4\"\n\t}\n}\n```\n在根目录下创建main.js，内容如下\n\n```\nconst { app, BrowserWindow } = require('electron')\n  \n  // Keep a global reference of the window object, if you don't, the window will\n  // be closed automatically when the JavaScript object is garbage collected.\n  let win\n  \n  function createWindow () {\n    // 创建浏览器窗口。\n    win = new BrowserWindow({ width: 800, height: 600 })\n  \n    // 然后加载应用的 index.html。\n    win.loadFile('index.html')\n  \n    // 打开开发者工具\n    win.webContents.openDevTools()\n  \n    // 当 window 被关闭，这个事件会被触发。\n    win.on('closed', () => {\n      // 取消引用 window 对象，如果你的应用支持多窗口的话，\n      // 通常会把多个 window 对象存放在一个数组里面，\n      // 与此同时，你应该删除相应的元素。\n      win = null\n    })\n  }\n  \n  // Electron 会在初始化后并准备\n  // 创建浏览器窗口时，调用这个函数。\n  // 部分 API 在 ready 事件触发后才能使用。\n  app.on('ready', createWindow)\n  \n  // 当全部窗口关闭时退出。\n  app.on('window-all-closed', () => {\n    // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，\n    // 否则绝大部分应用及其菜单栏会保持激活。\n    if (process.platform !== 'darwin') {\n      app.quit()\n    }\n  })\n  \n  app.on('activate', () => {\n    // 在macOS上，当单击dock图标并且没有其他窗口打开时，\n    // 通常在应用程序中重新创建一个窗口。\n    if (win === null) {\n      createWindow()\n    }\n  })\n  \n  // 在这个文件中，你可以续写应用剩下主进程代码。\n  // 也可以拆分成几个文件，然后用 require 导入。\n```\n然后创建index.html文件，内容如下\n\n```\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"utf-8\" /> \n    <title>TEST</title>\n</head>\n<body>\n    <span style=\"color:#fff;\">Hello World</span>\n</body>\n</html>\n```\n\n### 启动app\n\n```\nnpm start\n```\n或者在package.json中配置\n```\n\"scripts\": {\"start\": \"electron .\"}\n```\n则可以输入一下命令启动\n```\nelectron .\n```\n## 打包\n全局安装electron-packager\n\n\n","source":"_posts/其他/Electron：从零到完成一个桌面应用.md","raw":"---\ntitle: Electron：从零到完成一个桌面应用\nDate: 2019-02-26\ntags: [Electron]\ncategories: Electron\ncomments: true\n---\n\nElectron\n## 开发环境\n- 安装node\n- 安装cnpm（或者npm）\n- 安装electron\n- 安装打包工具\n\n```\nnpm install -g electron-packager\n```\n\n## 经典例子\n### electron-quick-start\n一个简约的记事本\n```\n//克隆这仓库\n git clone https://github.com/electron/electron-quick-start\n//进入仓库\n cd electron-quick-start\n//安装依赖库\n cnpm install\n//运行应用，也可以用： cnpm run start\n cnpm start \n```\n### electron-api-demos\n介绍了主要的一些功能及实现代码\n\n```\n git clone https://github.com/electron/electron-api-demos\n cd electron-api-demos\n cnpm install\n cnpm start\n```\n## 开始开发\n### 安装electron\n推荐的安装方法是把electron作为您 app 中的开发依赖项，使您可以在不同的 app 中使用不同的 Electron 版本   \n\n在根目录下运行\n\n```\nnpm install --save-dev electron\n```\n当然，也可以在 $PATH 中全局安装\n```\nnpm install electron -g\n```\n\n### 创建Electron简单文件结构  \n在根目录下创建package.json文件，内容如下\n\n```\n{\n\t\"name\": \"test\",\n\t\"version\": \"0.1.0\",\n\t\"main\": \"main.js\",\n\t\"scripts\": {\n\t\t\"start\": \"electron .\"\n\t},\n\t\"devDependencies\": {\n\t\t\"electron\": \"^3.0.4\"\n\t}\n}\n```\n在根目录下创建main.js，内容如下\n\n```\nconst { app, BrowserWindow } = require('electron')\n  \n  // Keep a global reference of the window object, if you don't, the window will\n  // be closed automatically when the JavaScript object is garbage collected.\n  let win\n  \n  function createWindow () {\n    // 创建浏览器窗口。\n    win = new BrowserWindow({ width: 800, height: 600 })\n  \n    // 然后加载应用的 index.html。\n    win.loadFile('index.html')\n  \n    // 打开开发者工具\n    win.webContents.openDevTools()\n  \n    // 当 window 被关闭，这个事件会被触发。\n    win.on('closed', () => {\n      // 取消引用 window 对象，如果你的应用支持多窗口的话，\n      // 通常会把多个 window 对象存放在一个数组里面，\n      // 与此同时，你应该删除相应的元素。\n      win = null\n    })\n  }\n  \n  // Electron 会在初始化后并准备\n  // 创建浏览器窗口时，调用这个函数。\n  // 部分 API 在 ready 事件触发后才能使用。\n  app.on('ready', createWindow)\n  \n  // 当全部窗口关闭时退出。\n  app.on('window-all-closed', () => {\n    // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，\n    // 否则绝大部分应用及其菜单栏会保持激活。\n    if (process.platform !== 'darwin') {\n      app.quit()\n    }\n  })\n  \n  app.on('activate', () => {\n    // 在macOS上，当单击dock图标并且没有其他窗口打开时，\n    // 通常在应用程序中重新创建一个窗口。\n    if (win === null) {\n      createWindow()\n    }\n  })\n  \n  // 在这个文件中，你可以续写应用剩下主进程代码。\n  // 也可以拆分成几个文件，然后用 require 导入。\n```\n然后创建index.html文件，内容如下\n\n```\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"utf-8\" /> \n    <title>TEST</title>\n</head>\n<body>\n    <span style=\"color:#fff;\">Hello World</span>\n</body>\n</html>\n```\n\n### 启动app\n\n```\nnpm start\n```\n或者在package.json中配置\n```\n\"scripts\": {\"start\": \"electron .\"}\n```\n则可以输入一下命令启动\n```\nelectron .\n```\n## 打包\n全局安装electron-packager\n\n\n","slug":"其他/Electron：从零到完成一个桌面应用","published":1,"date":"2019-02-26T08:38:52.872Z","updated":"2019-02-26T08:57:45.811Z","layout":"post","photos":[],"link":"","_id":"cka6l2e320001c0u90c7eqrg9","content":"<p>Electron</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><ul>\n<li>安装node</li>\n<li>安装cnpm（或者npm）</li>\n<li>安装electron</li>\n<li>安装打包工具</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g electron-packager</span><br></pre></td></tr></table></figure>\n<h2 id=\"经典例子\"><a href=\"#经典例子\" class=\"headerlink\" title=\"经典例子\"></a>经典例子</h2><h3 id=\"electron-quick-start\"><a href=\"#electron-quick-start\" class=\"headerlink\" title=\"electron-quick-start\"></a>electron-quick-start</h3><p>一个简约的记事本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//克隆这仓库</span><br><span class=\"line\"> git clone https://github.com/electron/electron-quick-start</span><br><span class=\"line\">//进入仓库</span><br><span class=\"line\"> cd electron-quick-start</span><br><span class=\"line\">//安装依赖库</span><br><span class=\"line\"> cnpm install</span><br><span class=\"line\">//运行应用，也可以用： cnpm run start</span><br><span class=\"line\"> cnpm start</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"electron-api-demos\"><a href=\"#electron-api-demos\" class=\"headerlink\" title=\"electron-api-demos\"></a>electron-api-demos</h3><p>介绍了主要的一些功能及实现代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/electron/electron-api-demos</span><br><span class=\"line\">cd electron-api-demos</span><br><span class=\"line\">cnpm install</span><br><span class=\"line\">cnpm start</span><br></pre></td></tr></table></figure>\n<h2 id=\"开始开发\"><a href=\"#开始开发\" class=\"headerlink\" title=\"开始开发\"></a>开始开发</h2><h3 id=\"安装electron\"><a href=\"#安装electron\" class=\"headerlink\" title=\"安装electron\"></a>安装electron</h3><p>推荐的安装方法是把electron作为您 app 中的开发依赖项，使您可以在不同的 app 中使用不同的 Electron 版本   </p>\n<p>在根目录下运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev electron</span><br></pre></td></tr></table></figure>\n<p>当然，也可以在 $PATH 中全局安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install electron -g</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建Electron简单文件结构\"><a href=\"#创建Electron简单文件结构\" class=\"headerlink\" title=\"创建Electron简单文件结构\"></a>创建Electron简单文件结构</h3><p>在根目录下创建package.json文件，内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;test&quot;,</span><br><span class=\"line\">\t&quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\">\t&quot;main&quot;: &quot;main.js&quot;,</span><br><span class=\"line\">\t&quot;scripts&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;start&quot;: &quot;electron .&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;electron&quot;: &quot;^3.0.4&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在根目录下创建main.js，内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; app, BrowserWindow &#125; = require(&apos;electron&apos;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // Keep a global reference of the window object, if you don&apos;t, the window will</span><br><span class=\"line\">  // be closed automatically when the JavaScript object is garbage collected.</span><br><span class=\"line\">  let win</span><br><span class=\"line\">  </span><br><span class=\"line\">  function createWindow () &#123;</span><br><span class=\"line\">    // 创建浏览器窗口。</span><br><span class=\"line\">    win = new BrowserWindow(&#123; width: 800, height: 600 &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 然后加载应用的 index.html。</span><br><span class=\"line\">    win.loadFile(&apos;index.html&apos;)</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 打开开发者工具</span><br><span class=\"line\">    win.webContents.openDevTools()</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 当 window 被关闭，这个事件会被触发。</span><br><span class=\"line\">    win.on(&apos;closed&apos;, () =&gt; &#123;</span><br><span class=\"line\">      // 取消引用 window 对象，如果你的应用支持多窗口的话，</span><br><span class=\"line\">      // 通常会把多个 window 对象存放在一个数组里面，</span><br><span class=\"line\">      // 与此同时，你应该删除相应的元素。</span><br><span class=\"line\">      win = null</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // Electron 会在初始化后并准备</span><br><span class=\"line\">  // 创建浏览器窗口时，调用这个函数。</span><br><span class=\"line\">  // 部分 API 在 ready 事件触发后才能使用。</span><br><span class=\"line\">  app.on(&apos;ready&apos;, createWindow)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 当全部窗口关闭时退出。</span><br><span class=\"line\">  app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</span><br><span class=\"line\">    // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span><br><span class=\"line\">    // 否则绝大部分应用及其菜单栏会保持激活。</span><br><span class=\"line\">    if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class=\"line\">      app.quit()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  app.on(&apos;activate&apos;, () =&gt; &#123;</span><br><span class=\"line\">    // 在macOS上，当单击dock图标并且没有其他窗口打开时，</span><br><span class=\"line\">    // 通常在应用程序中重新创建一个窗口。</span><br><span class=\"line\">    if (win === null) &#123;</span><br><span class=\"line\">      createWindow()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 在这个文件中，你可以续写应用剩下主进程代码。</span><br><span class=\"line\">  // 也可以拆分成几个文件，然后用 require 导入。</span><br></pre></td></tr></table></figure>\n<p>然后创建index.html文件，内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot; /&gt; </span><br><span class=\"line\">    &lt;title&gt;TEST&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;span style=&quot;color:#fff;&quot;&gt;Hello World&lt;/span&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动app\"><a href=\"#启动app\" class=\"headerlink\" title=\"启动app\"></a>启动app</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>或者在package.json中配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;electron .&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>则可以输入一下命令启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">electron .</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>全局安装electron-packager</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Electron</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><ul>\n<li>安装node</li>\n<li>安装cnpm（或者npm）</li>\n<li>安装electron</li>\n<li>安装打包工具</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g electron-packager</span><br></pre></td></tr></table></figure>\n<h2 id=\"经典例子\"><a href=\"#经典例子\" class=\"headerlink\" title=\"经典例子\"></a>经典例子</h2><h3 id=\"electron-quick-start\"><a href=\"#electron-quick-start\" class=\"headerlink\" title=\"electron-quick-start\"></a>electron-quick-start</h3><p>一个简约的记事本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//克隆这仓库</span><br><span class=\"line\"> git clone https://github.com/electron/electron-quick-start</span><br><span class=\"line\">//进入仓库</span><br><span class=\"line\"> cd electron-quick-start</span><br><span class=\"line\">//安装依赖库</span><br><span class=\"line\"> cnpm install</span><br><span class=\"line\">//运行应用，也可以用： cnpm run start</span><br><span class=\"line\"> cnpm start</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"electron-api-demos\"><a href=\"#electron-api-demos\" class=\"headerlink\" title=\"electron-api-demos\"></a>electron-api-demos</h3><p>介绍了主要的一些功能及实现代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/electron/electron-api-demos</span><br><span class=\"line\">cd electron-api-demos</span><br><span class=\"line\">cnpm install</span><br><span class=\"line\">cnpm start</span><br></pre></td></tr></table></figure>\n<h2 id=\"开始开发\"><a href=\"#开始开发\" class=\"headerlink\" title=\"开始开发\"></a>开始开发</h2><h3 id=\"安装electron\"><a href=\"#安装electron\" class=\"headerlink\" title=\"安装electron\"></a>安装electron</h3><p>推荐的安装方法是把electron作为您 app 中的开发依赖项，使您可以在不同的 app 中使用不同的 Electron 版本   </p>\n<p>在根目录下运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev electron</span><br></pre></td></tr></table></figure>\n<p>当然，也可以在 $PATH 中全局安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install electron -g</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建Electron简单文件结构\"><a href=\"#创建Electron简单文件结构\" class=\"headerlink\" title=\"创建Electron简单文件结构\"></a>创建Electron简单文件结构</h3><p>在根目录下创建package.json文件，内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;test&quot;,</span><br><span class=\"line\">\t&quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\">\t&quot;main&quot;: &quot;main.js&quot;,</span><br><span class=\"line\">\t&quot;scripts&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;start&quot;: &quot;electron .&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;electron&quot;: &quot;^3.0.4&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在根目录下创建main.js，内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; app, BrowserWindow &#125; = require(&apos;electron&apos;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // Keep a global reference of the window object, if you don&apos;t, the window will</span><br><span class=\"line\">  // be closed automatically when the JavaScript object is garbage collected.</span><br><span class=\"line\">  let win</span><br><span class=\"line\">  </span><br><span class=\"line\">  function createWindow () &#123;</span><br><span class=\"line\">    // 创建浏览器窗口。</span><br><span class=\"line\">    win = new BrowserWindow(&#123; width: 800, height: 600 &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 然后加载应用的 index.html。</span><br><span class=\"line\">    win.loadFile(&apos;index.html&apos;)</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 打开开发者工具</span><br><span class=\"line\">    win.webContents.openDevTools()</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 当 window 被关闭，这个事件会被触发。</span><br><span class=\"line\">    win.on(&apos;closed&apos;, () =&gt; &#123;</span><br><span class=\"line\">      // 取消引用 window 对象，如果你的应用支持多窗口的话，</span><br><span class=\"line\">      // 通常会把多个 window 对象存放在一个数组里面，</span><br><span class=\"line\">      // 与此同时，你应该删除相应的元素。</span><br><span class=\"line\">      win = null</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // Electron 会在初始化后并准备</span><br><span class=\"line\">  // 创建浏览器窗口时，调用这个函数。</span><br><span class=\"line\">  // 部分 API 在 ready 事件触发后才能使用。</span><br><span class=\"line\">  app.on(&apos;ready&apos;, createWindow)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 当全部窗口关闭时退出。</span><br><span class=\"line\">  app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</span><br><span class=\"line\">    // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span><br><span class=\"line\">    // 否则绝大部分应用及其菜单栏会保持激活。</span><br><span class=\"line\">    if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class=\"line\">      app.quit()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  app.on(&apos;activate&apos;, () =&gt; &#123;</span><br><span class=\"line\">    // 在macOS上，当单击dock图标并且没有其他窗口打开时，</span><br><span class=\"line\">    // 通常在应用程序中重新创建一个窗口。</span><br><span class=\"line\">    if (win === null) &#123;</span><br><span class=\"line\">      createWindow()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 在这个文件中，你可以续写应用剩下主进程代码。</span><br><span class=\"line\">  // 也可以拆分成几个文件，然后用 require 导入。</span><br></pre></td></tr></table></figure>\n<p>然后创建index.html文件，内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot; /&gt; </span><br><span class=\"line\">    &lt;title&gt;TEST&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;span style=&quot;color:#fff;&quot;&gt;Hello World&lt;/span&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动app\"><a href=\"#启动app\" class=\"headerlink\" title=\"启动app\"></a>启动app</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>或者在package.json中配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;electron .&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>则可以输入一下命令启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">electron .</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>全局安装electron-packager</p>\n"},{"title":"Electron进阶：打开新窗口","Date":"2019-02-25T16:00:00.000Z","comments":1,"_content":"\n## 标签实现新窗口打开\n- 增加 target=\"_blank\"属性\n- router-link标签只有tag=”a”模式下 target=”_blank” 属性才会生效（vue2）\n\n## 编程式导航\n\n```\nlet routeData = this.$router.resolve({ \nname: \"searchGoods\", \nquery: params, \nparams:{catId:params.catId} \n}); \nwindow.open(routeData.href, '_blank');\n```\n\n","source":"_posts/其他/Electron进阶：打开新窗口.md","raw":"---\ntitle: Electron进阶：打开新窗口\nDate: 2019-02-26\ntags: [Electron]\ncategories: Electron\ncomments: true\n---\n\n## 标签实现新窗口打开\n- 增加 target=\"_blank\"属性\n- router-link标签只有tag=”a”模式下 target=”_blank” 属性才会生效（vue2）\n\n## 编程式导航\n\n```\nlet routeData = this.$router.resolve({ \nname: \"searchGoods\", \nquery: params, \nparams:{catId:params.catId} \n}); \nwindow.open(routeData.href, '_blank');\n```\n\n","slug":"其他/Electron进阶：打开新窗口","published":1,"date":"2019-02-26T08:39:46.004Z","updated":"2019-02-26T08:58:44.371Z","layout":"post","photos":[],"link":"","_id":"cka6l2e3b0003c0u9ox8n2twx","content":"<h2 id=\"标签实现新窗口打开\"><a href=\"#标签实现新窗口打开\" class=\"headerlink\" title=\"标签实现新窗口打开\"></a>标签实现新窗口打开</h2><ul>\n<li>增加 target=”_blank”属性</li>\n<li>router-link标签只有tag=”a”模式下 target=”_blank” 属性才会生效（vue2）</li>\n</ul>\n<h2 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let routeData = this.$router.resolve(&#123; </span><br><span class=\"line\">name: &quot;searchGoods&quot;, </span><br><span class=\"line\">query: params, </span><br><span class=\"line\">params:&#123;catId:params.catId&#125; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">window.open(routeData.href, &apos;_blank&apos;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"标签实现新窗口打开\"><a href=\"#标签实现新窗口打开\" class=\"headerlink\" title=\"标签实现新窗口打开\"></a>标签实现新窗口打开</h2><ul>\n<li>增加 target=”_blank”属性</li>\n<li>router-link标签只有tag=”a”模式下 target=”_blank” 属性才会生效（vue2）</li>\n</ul>\n<h2 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let routeData = this.$router.resolve(&#123; </span><br><span class=\"line\">name: &quot;searchGoods&quot;, </span><br><span class=\"line\">query: params, </span><br><span class=\"line\">params:&#123;catId:params.catId&#125; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">window.open(routeData.href, &apos;_blank&apos;);</span><br></pre></td></tr></table></figure>\n"},{"title":"Hexo+Github 搭建属于自己的博客（进阶）NexT主题","Date":"2018-05-03T16:00:00.000Z","comments":1,"_content":"\n# 主题安装\n### 安装NexT\n在站点目录下（hexo），输入命令：\n\n```\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n### 启用主题\n在站点目录中（blog），打开配置文件_config.yml，修改\n```\ntheme：next\n```\n### 验证主题\n\n```\n$ hexo s\n```\n# 主题设定\n以下所有设置注意格式\n### NexT主题设定\n可以在next主题目录下的_config.yml文件中修改\n\n```\n# Schemes\nscheme: Muse\n#scheme: Mist\n#scheme: Pisces\n#scheme: Gemini\n```\n### 基础设置\n在站点目录下的配置文件_cofig.yml中修改\n\n```\n# Site\ntitle: your blog title\nsubtitle:\ndescription: describe yourself\nkeywords:\nauthor: yourname\nlanguage: zh-Hans //简体中文\ntimezone:\n```\n### 修改菜单项\n在主题目录下修改配置文件_cofig.yml中的menu\n\n```\nmenu:\n  home: / || home\n  about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n  #schedule: /schedule/ || calendar\n  #sitemap: /sitemap.xml || sitemap\n  #commonweal: /404/ || heartbeat\n```\n这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联\n\n```\nmenu:\n  home: 首页\n  archives: 归档\n  categories: 分类\n  tags: 标签\n  about: 关于\n  search: 搜索\n  schedule: 日程表\n  sitemap: 站点地图\n  commonweal: 公益404\n```\n### 限定主页文章高度\n修改主题目录下的值\n\n```\nauto_excerpt:\n  enable: true\n  length: 150\n```\n### 设置头像\n\n修改主题目录下Sidebar Avatar的avatar值\n```\n# Sidebar Avatar\n# in theme directory(source/images): /images/avatar.gif\n# in site  directory(source/uploads): /uploads/avatar.gif\navatar: /images/avatar.jpg\n```\n\n\n地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）\n\n### 添加标签页面\n点击标签，跳转的页面会显示page not found\n\n此时需要在站点目录的source文件夹里新建tags文件夹，并新建index.md，添加：\n\n```\n---\ntitle: tags\ndate: \ntype: \"tags\"\n---\n```\n当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可\n\n### 实现点击出现桃心效果\n将代码copy到/themes/next/source/js/src里面新建的love.js中\n\n```\n! function(e, t, a) {\n    function n() {\n        c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r()\n    }\n\n    function r() {\n        for (var e = 0; e < d.length; e++) d[e].alpha <= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = \"left:\" + d[e].x + \"px;top:\" + d[e].y + \"px;opacity:\" + d[e].alpha + \";transform:scale(\" + d[e].scale + \",\" + d[e].scale + \") rotate(45deg);background:\" + d[e].color + \";z-index:99999\");\n        requestAnimationFrame(r)\n    }\n\n    function o() {\n        var t = \"function\" == typeof e.onclick && e.onclick;\n        e.onclick = function(e) {\n            t && t(), i(e)\n        }\n    }\n\n    function i(e) {\n        var a = t.createElement(\"div\");\n        a.className = \"heart\", d.push({\n            el: a,\n            x: e.clientX - 5,\n            y: e.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: s()\n        }), t.body.appendChild(a)\n    }\n\n    function c(e) {\n        var a = t.createElement(\"style\");\n        a.type = \"text/css\";\n        try {\n            a.appendChild(t.createTextNode(e))\n        } catch (t) {\n            a.styleSheet.cssText = e\n        }\n        t.getElementsByTagName(\"head\")[0].appendChild(a)\n    }\n\n    function s() {\n        return \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\"\n    }\n    var d = [];\n    e.requestAnimationFrame = function() {\n        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) {\n            setTimeout(e, 1e3 / 60)\n        }\n    }(), n()\n}(window, document);\n```\n打开\\themes\\next\\layout\\_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js\n\n```\n<script src=\"/js/src/love.js\" type=\"text/javascript\"></script>\n```\n\n### 添加动态背景\n打开\\themes\\next\\layout\\_layout.swig文件，\n在 </body>之前添加代码(注意不要放在< /head>的后面)\n\n```\n{% if theme.canvas_nest %}\n<script type=\"text/javascript\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"></script>\n{% endif %}\n```\n打开开\\themes\\next\\_config.yml,在里面修改为如下代码\n\n```\ncanvas_nest: true\n```\n\n\n### 在网站底部加上访问量\n打开\\themes\\next\\layout\\_partials\\footer.swig文件,在类copyright前加上这段代码：\n\n```\n<script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n然后在合适的位置添加显示统计的代码：\n\n```\n<div class=\"powered-by\">\n<i class=\"fa fa-user-md\"></i><span id=\"busuanzi_container_site_uv\">\n  本站访客数:<span id=\"busuanzi_value_site_uv\"></span>\n</span>\n</div>\n```\n\n### 在每篇文章末尾添加“本文结束”标记\n在路径 \\themes\\next\\layout\\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容\n\n```\n<div>\n    {% if not is_index %}\n        <div style=\"text-align:center;color: #ccc;font-size:14px;\">-------------本文结束<i class=\"fa fa-paw\"></i>感谢您的阅读-------------</div>\n    {% endif %}\n</div>\n```\n接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下代码\n\n```\n<div>\n  {% if not is_index %}\n    {% include 'passage-end-tag.swig' %}\n  {% endif %}\n</div>\n```\n打开主题配置文件,在末尾添加\n\n```\n# 文章末尾添加“本文结束”标记\npassage_end_tag:\n  enabled: true\n```\n\n### 侧边栏社交链接\n在主题配置文件中修改：\n\n```\n# Social links\nsocial:\n  GitHub: https://github.com/your-user-name\n  Twitter: https://twitter.com/your-user-name\n  微博: http://weibo.com/your-user-name\n\n# Social Icons\nsocial_icons:\n  enable: true\n  # Icon Mappings\n  GitHub: github\n  Twitter: twitter\n  微博: weibo\n```\n###  添加小图标\n在主题配置文件中修改：\n\n```\nfavicon:\n  #small: /images/favicon.ico\n  medium: /images/favicon.ico\n```\n\n\n> [NexT主题美化](http://theme-next.iissnan.com/getting-started.html#avatar-setting)\n\n除了NexT还有很多其他好看的主题，百度会有很多方法的","source":"_posts/其他/Hexo+Github 搭建属于自己的博客（进阶）NexT主题.md","raw":"---\ntitle: Hexo+Github 搭建属于自己的博客（进阶）NexT主题\nDate: 2018-05-04\ntags: [博客搭建]\ncategories: 博客搭建\ncomments: true\n---\n\n# 主题安装\n### 安装NexT\n在站点目录下（hexo），输入命令：\n\n```\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n### 启用主题\n在站点目录中（blog），打开配置文件_config.yml，修改\n```\ntheme：next\n```\n### 验证主题\n\n```\n$ hexo s\n```\n# 主题设定\n以下所有设置注意格式\n### NexT主题设定\n可以在next主题目录下的_config.yml文件中修改\n\n```\n# Schemes\nscheme: Muse\n#scheme: Mist\n#scheme: Pisces\n#scheme: Gemini\n```\n### 基础设置\n在站点目录下的配置文件_cofig.yml中修改\n\n```\n# Site\ntitle: your blog title\nsubtitle:\ndescription: describe yourself\nkeywords:\nauthor: yourname\nlanguage: zh-Hans //简体中文\ntimezone:\n```\n### 修改菜单项\n在主题目录下修改配置文件_cofig.yml中的menu\n\n```\nmenu:\n  home: / || home\n  about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n  #schedule: /schedule/ || calendar\n  #sitemap: /sitemap.xml || sitemap\n  #commonweal: /404/ || heartbeat\n```\n这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联\n\n```\nmenu:\n  home: 首页\n  archives: 归档\n  categories: 分类\n  tags: 标签\n  about: 关于\n  search: 搜索\n  schedule: 日程表\n  sitemap: 站点地图\n  commonweal: 公益404\n```\n### 限定主页文章高度\n修改主题目录下的值\n\n```\nauto_excerpt:\n  enable: true\n  length: 150\n```\n### 设置头像\n\n修改主题目录下Sidebar Avatar的avatar值\n```\n# Sidebar Avatar\n# in theme directory(source/images): /images/avatar.gif\n# in site  directory(source/uploads): /uploads/avatar.gif\navatar: /images/avatar.jpg\n```\n\n\n地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）\n\n### 添加标签页面\n点击标签，跳转的页面会显示page not found\n\n此时需要在站点目录的source文件夹里新建tags文件夹，并新建index.md，添加：\n\n```\n---\ntitle: tags\ndate: \ntype: \"tags\"\n---\n```\n当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可\n\n### 实现点击出现桃心效果\n将代码copy到/themes/next/source/js/src里面新建的love.js中\n\n```\n! function(e, t, a) {\n    function n() {\n        c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r()\n    }\n\n    function r() {\n        for (var e = 0; e < d.length; e++) d[e].alpha <= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = \"left:\" + d[e].x + \"px;top:\" + d[e].y + \"px;opacity:\" + d[e].alpha + \";transform:scale(\" + d[e].scale + \",\" + d[e].scale + \") rotate(45deg);background:\" + d[e].color + \";z-index:99999\");\n        requestAnimationFrame(r)\n    }\n\n    function o() {\n        var t = \"function\" == typeof e.onclick && e.onclick;\n        e.onclick = function(e) {\n            t && t(), i(e)\n        }\n    }\n\n    function i(e) {\n        var a = t.createElement(\"div\");\n        a.className = \"heart\", d.push({\n            el: a,\n            x: e.clientX - 5,\n            y: e.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: s()\n        }), t.body.appendChild(a)\n    }\n\n    function c(e) {\n        var a = t.createElement(\"style\");\n        a.type = \"text/css\";\n        try {\n            a.appendChild(t.createTextNode(e))\n        } catch (t) {\n            a.styleSheet.cssText = e\n        }\n        t.getElementsByTagName(\"head\")[0].appendChild(a)\n    }\n\n    function s() {\n        return \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\"\n    }\n    var d = [];\n    e.requestAnimationFrame = function() {\n        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) {\n            setTimeout(e, 1e3 / 60)\n        }\n    }(), n()\n}(window, document);\n```\n打开\\themes\\next\\layout\\_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js\n\n```\n<script src=\"/js/src/love.js\" type=\"text/javascript\"></script>\n```\n\n### 添加动态背景\n打开\\themes\\next\\layout\\_layout.swig文件，\n在 </body>之前添加代码(注意不要放在< /head>的后面)\n\n```\n{% if theme.canvas_nest %}\n<script type=\"text/javascript\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"></script>\n{% endif %}\n```\n打开开\\themes\\next\\_config.yml,在里面修改为如下代码\n\n```\ncanvas_nest: true\n```\n\n\n### 在网站底部加上访问量\n打开\\themes\\next\\layout\\_partials\\footer.swig文件,在类copyright前加上这段代码：\n\n```\n<script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n然后在合适的位置添加显示统计的代码：\n\n```\n<div class=\"powered-by\">\n<i class=\"fa fa-user-md\"></i><span id=\"busuanzi_container_site_uv\">\n  本站访客数:<span id=\"busuanzi_value_site_uv\"></span>\n</span>\n</div>\n```\n\n### 在每篇文章末尾添加“本文结束”标记\n在路径 \\themes\\next\\layout\\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容\n\n```\n<div>\n    {% if not is_index %}\n        <div style=\"text-align:center;color: #ccc;font-size:14px;\">-------------本文结束<i class=\"fa fa-paw\"></i>感谢您的阅读-------------</div>\n    {% endif %}\n</div>\n```\n接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下代码\n\n```\n<div>\n  {% if not is_index %}\n    {% include 'passage-end-tag.swig' %}\n  {% endif %}\n</div>\n```\n打开主题配置文件,在末尾添加\n\n```\n# 文章末尾添加“本文结束”标记\npassage_end_tag:\n  enabled: true\n```\n\n### 侧边栏社交链接\n在主题配置文件中修改：\n\n```\n# Social links\nsocial:\n  GitHub: https://github.com/your-user-name\n  Twitter: https://twitter.com/your-user-name\n  微博: http://weibo.com/your-user-name\n\n# Social Icons\nsocial_icons:\n  enable: true\n  # Icon Mappings\n  GitHub: github\n  Twitter: twitter\n  微博: weibo\n```\n###  添加小图标\n在主题配置文件中修改：\n\n```\nfavicon:\n  #small: /images/favicon.ico\n  medium: /images/favicon.ico\n```\n\n\n> [NexT主题美化](http://theme-next.iissnan.com/getting-started.html#avatar-setting)\n\n除了NexT还有很多其他好看的主题，百度会有很多方法的","slug":"其他/Hexo+Github 搭建属于自己的博客（进阶）NexT主题","published":1,"date":"2018-05-04T13:46:25.664Z","updated":"2018-05-04T13:47:10.007Z","layout":"post","photos":[],"link":"","_id":"cka6l2e3j0005c0u9mw3m0r8x","content":"<h1 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a>主题安装</h1><h3 id=\"安装NexT\"><a href=\"#安装NexT\" class=\"headerlink\" title=\"安装NexT\"></a>安装NexT</h3><p>在站点目录下（hexo），输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<h3 id=\"启用主题\"><a href=\"#启用主题\" class=\"headerlink\" title=\"启用主题\"></a>启用主题</h3><p>在站点目录中（blog），打开配置文件_config.yml，修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme：next</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"验证主题\"><a href=\"#验证主题\" class=\"headerlink\" title=\"验证主题\"></a>验证主题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n<h1 id=\"主题设定\"><a href=\"#主题设定\" class=\"headerlink\" title=\"主题设定\"></a>主题设定</h1><p>以下所有设置注意格式</p>\n<h3 id=\"NexT主题设定\"><a href=\"#NexT主题设定\" class=\"headerlink\" title=\"NexT主题设定\"></a>NexT主题设定</h3><p>可以在next主题目录下的_config.yml文件中修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">#scheme: Gemini</span><br></pre></td></tr></table></figure>\n<h3 id=\"基础设置\"><a href=\"#基础设置\" class=\"headerlink\" title=\"基础设置\"></a>基础设置</h3><p>在站点目录下的配置文件_cofig.yml中修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: your blog title</span><br><span class=\"line\">subtitle:</span><br><span class=\"line\">description: describe yourself</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: yourname</span><br><span class=\"line\">language: zh-Hans //简体中文</span><br><span class=\"line\">timezone:</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改菜单项\"><a href=\"#修改菜单项\" class=\"headerlink\" title=\"修改菜单项\"></a>修改菜单项</h3><p>在主题目录下修改配置文件_cofig.yml中的menu</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: / || home</span><br><span class=\"line\">  about: /about/ || user</span><br><span class=\"line\">  tags: /tags/ || tags</span><br><span class=\"line\">  categories: /categories/ || th</span><br><span class=\"line\">  archives: /archives/ || archive</span><br><span class=\"line\">  #schedule: /schedule/ || calendar</span><br><span class=\"line\">  #sitemap: /sitemap.xml || sitemap</span><br><span class=\"line\">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>\n<p>这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: 首页</span><br><span class=\"line\">  archives: 归档</span><br><span class=\"line\">  categories: 分类</span><br><span class=\"line\">  tags: 标签</span><br><span class=\"line\">  about: 关于</span><br><span class=\"line\">  search: 搜索</span><br><span class=\"line\">  schedule: 日程表</span><br><span class=\"line\">  sitemap: 站点地图</span><br><span class=\"line\">  commonweal: 公益404</span><br></pre></td></tr></table></figure>\n<h3 id=\"限定主页文章高度\"><a href=\"#限定主页文章高度\" class=\"headerlink\" title=\"限定主页文章高度\"></a>限定主页文章高度</h3><p>修改主题目录下的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_excerpt:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  length: 150</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置头像\"><a href=\"#设置头像\" class=\"headerlink\" title=\"设置头像\"></a>设置头像</h3><p>修改主题目录下Sidebar Avatar的avatar值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Sidebar Avatar</span><br><span class=\"line\"># in theme directory(source/images): /images/avatar.gif</span><br><span class=\"line\"># in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class=\"line\">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure></p>\n<p>地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）</p>\n<h3 id=\"添加标签页面\"><a href=\"#添加标签页面\" class=\"headerlink\" title=\"添加标签页面\"></a>添加标签页面</h3><p>点击标签，跳转的页面会显示page not found</p>\n<p>此时需要在站点目录的source文件夹里新建tags文件夹，并新建index.md，添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: </span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可</p>\n<h3 id=\"实现点击出现桃心效果\"><a href=\"#实现点击出现桃心效果\" class=\"headerlink\" title=\"实现点击出现桃心效果\"></a>实现点击出现桃心效果</h3><p>将代码copy到/themes/next/source/js/src里面新建的love.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function(e, t, a) &#123;</span><br><span class=\"line\">    function n() &#123;</span><br><span class=\"line\">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function r() &#123;</span><br><span class=\"line\">        for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class=\"line\">        requestAnimationFrame(r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function o() &#123;</span><br><span class=\"line\">        var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;</span><br><span class=\"line\">        e.onclick = function(e) &#123;</span><br><span class=\"line\">            t &amp;&amp; t(), i(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function i(e) &#123;</span><br><span class=\"line\">        var a = t.createElement(&quot;div&quot;);</span><br><span class=\"line\">        a.className = &quot;heart&quot;, d.push(&#123;</span><br><span class=\"line\">            el: a,</span><br><span class=\"line\">            x: e.clientX - 5,</span><br><span class=\"line\">            y: e.clientY - 5,</span><br><span class=\"line\">            scale: 1,</span><br><span class=\"line\">            alpha: 1,</span><br><span class=\"line\">            color: s()</span><br><span class=\"line\">        &#125;), t.body.appendChild(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function c(e) &#123;</span><br><span class=\"line\">        var a = t.createElement(&quot;style&quot;);</span><br><span class=\"line\">        a.type = &quot;text/css&quot;;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            a.appendChild(t.createTextNode(e))</span><br><span class=\"line\">        &#125; catch (t) &#123;</span><br><span class=\"line\">            a.styleSheet.cssText = e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function s() &#123;</span><br><span class=\"line\">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var d = [];</span><br><span class=\"line\">    e.requestAnimationFrame = function() &#123;</span><br><span class=\"line\">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123;</span><br><span class=\"line\">            setTimeout(e, 1e3 / 60)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;(), n()</span><br><span class=\"line\">&#125;(window, document);</span><br></pre></td></tr></table></figure>\n<p>打开\\themes\\next\\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;/js/src/love.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加动态背景\"><a href=\"#添加动态背景\" class=\"headerlink\" title=\"添加动态背景\"></a>添加动态背景</h3><p>打开\\themes\\next\\layout_layout.swig文件，<br>在 之前添加代码(注意不要放在&lt; /head&gt;的后面)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if theme.canvas_nest %&#125;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<p>打开开\\themes\\next_config.yml,在里面修改为如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas_nest: true</span><br></pre></td></tr></table></figure>\n<h3 id=\"在网站底部加上访问量\"><a href=\"#在网站底部加上访问量\" class=\"headerlink\" title=\"在网站底部加上访问量\"></a>在网站底部加上访问量</h3><p>打开\\themes\\next\\layout_partials\\footer.swig文件,在类copyright前加上这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在合适的位置添加显示统计的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;powered-by&quot;&gt;</span><br><span class=\"line\">&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class=\"line\">  本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在每篇文章末尾添加“本文结束”标记\"><a href=\"#在每篇文章末尾添加“本文结束”标记\" class=\"headerlink\" title=\"在每篇文章末尾添加“本文结束”标记\"></a>在每篇文章末尾添加“本文结束”标记</h3><p>在路径 \\themes\\next\\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &#123;% if not is_index %&#125;</span><br><span class=\"line\">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>接着打开\\themes\\next\\layout_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &#123;% if not is_index %&#125;</span><br><span class=\"line\">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>打开主题配置文件,在末尾添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文章末尾添加“本文结束”标记</span><br><span class=\"line\">passage_end_tag:</span><br><span class=\"line\">  enabled: true</span><br></pre></td></tr></table></figure>\n<h3 id=\"侧边栏社交链接\"><a href=\"#侧边栏社交链接\" class=\"headerlink\" title=\"侧边栏社交链接\"></a>侧边栏社交链接</h3><p>在主题配置文件中修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Social links</span><br><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https://github.com/your-user-name</span><br><span class=\"line\">  Twitter: https://twitter.com/your-user-name</span><br><span class=\"line\">  微博: http://weibo.com/your-user-name</span><br><span class=\"line\"></span><br><span class=\"line\"># Social Icons</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Icon Mappings</span><br><span class=\"line\">  GitHub: github</span><br><span class=\"line\">  Twitter: twitter</span><br><span class=\"line\">  微博: weibo</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加小图标\"><a href=\"#添加小图标\" class=\"headerlink\" title=\"添加小图标\"></a>添加小图标</h3><p>在主题配置文件中修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">favicon:</span><br><span class=\"line\">  #small: /images/favicon.ico</span><br><span class=\"line\">  medium: /images/favicon.ico</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"http://theme-next.iissnan.com/getting-started.html#avatar-setting\" target=\"_blank\" rel=\"noopener\">NexT主题美化</a></p>\n</blockquote>\n<p>除了NexT还有很多其他好看的主题，百度会有很多方法的</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a>主题安装</h1><h3 id=\"安装NexT\"><a href=\"#安装NexT\" class=\"headerlink\" title=\"安装NexT\"></a>安装NexT</h3><p>在站点目录下（hexo），输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<h3 id=\"启用主题\"><a href=\"#启用主题\" class=\"headerlink\" title=\"启用主题\"></a>启用主题</h3><p>在站点目录中（blog），打开配置文件_config.yml，修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme：next</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"验证主题\"><a href=\"#验证主题\" class=\"headerlink\" title=\"验证主题\"></a>验证主题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n<h1 id=\"主题设定\"><a href=\"#主题设定\" class=\"headerlink\" title=\"主题设定\"></a>主题设定</h1><p>以下所有设置注意格式</p>\n<h3 id=\"NexT主题设定\"><a href=\"#NexT主题设定\" class=\"headerlink\" title=\"NexT主题设定\"></a>NexT主题设定</h3><p>可以在next主题目录下的_config.yml文件中修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">#scheme: Gemini</span><br></pre></td></tr></table></figure>\n<h3 id=\"基础设置\"><a href=\"#基础设置\" class=\"headerlink\" title=\"基础设置\"></a>基础设置</h3><p>在站点目录下的配置文件_cofig.yml中修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: your blog title</span><br><span class=\"line\">subtitle:</span><br><span class=\"line\">description: describe yourself</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: yourname</span><br><span class=\"line\">language: zh-Hans //简体中文</span><br><span class=\"line\">timezone:</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改菜单项\"><a href=\"#修改菜单项\" class=\"headerlink\" title=\"修改菜单项\"></a>修改菜单项</h3><p>在主题目录下修改配置文件_cofig.yml中的menu</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: / || home</span><br><span class=\"line\">  about: /about/ || user</span><br><span class=\"line\">  tags: /tags/ || tags</span><br><span class=\"line\">  categories: /categories/ || th</span><br><span class=\"line\">  archives: /archives/ || archive</span><br><span class=\"line\">  #schedule: /schedule/ || calendar</span><br><span class=\"line\">  #sitemap: /sitemap.xml || sitemap</span><br><span class=\"line\">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>\n<p>这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: 首页</span><br><span class=\"line\">  archives: 归档</span><br><span class=\"line\">  categories: 分类</span><br><span class=\"line\">  tags: 标签</span><br><span class=\"line\">  about: 关于</span><br><span class=\"line\">  search: 搜索</span><br><span class=\"line\">  schedule: 日程表</span><br><span class=\"line\">  sitemap: 站点地图</span><br><span class=\"line\">  commonweal: 公益404</span><br></pre></td></tr></table></figure>\n<h3 id=\"限定主页文章高度\"><a href=\"#限定主页文章高度\" class=\"headerlink\" title=\"限定主页文章高度\"></a>限定主页文章高度</h3><p>修改主题目录下的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_excerpt:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  length: 150</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置头像\"><a href=\"#设置头像\" class=\"headerlink\" title=\"设置头像\"></a>设置头像</h3><p>修改主题目录下Sidebar Avatar的avatar值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Sidebar Avatar</span><br><span class=\"line\"># in theme directory(source/images): /images/avatar.gif</span><br><span class=\"line\"># in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class=\"line\">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure></p>\n<p>地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）</p>\n<h3 id=\"添加标签页面\"><a href=\"#添加标签页面\" class=\"headerlink\" title=\"添加标签页面\"></a>添加标签页面</h3><p>点击标签，跳转的页面会显示page not found</p>\n<p>此时需要在站点目录的source文件夹里新建tags文件夹，并新建index.md，添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: </span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可</p>\n<h3 id=\"实现点击出现桃心效果\"><a href=\"#实现点击出现桃心效果\" class=\"headerlink\" title=\"实现点击出现桃心效果\"></a>实现点击出现桃心效果</h3><p>将代码copy到/themes/next/source/js/src里面新建的love.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function(e, t, a) &#123;</span><br><span class=\"line\">    function n() &#123;</span><br><span class=\"line\">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function r() &#123;</span><br><span class=\"line\">        for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class=\"line\">        requestAnimationFrame(r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function o() &#123;</span><br><span class=\"line\">        var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;</span><br><span class=\"line\">        e.onclick = function(e) &#123;</span><br><span class=\"line\">            t &amp;&amp; t(), i(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function i(e) &#123;</span><br><span class=\"line\">        var a = t.createElement(&quot;div&quot;);</span><br><span class=\"line\">        a.className = &quot;heart&quot;, d.push(&#123;</span><br><span class=\"line\">            el: a,</span><br><span class=\"line\">            x: e.clientX - 5,</span><br><span class=\"line\">            y: e.clientY - 5,</span><br><span class=\"line\">            scale: 1,</span><br><span class=\"line\">            alpha: 1,</span><br><span class=\"line\">            color: s()</span><br><span class=\"line\">        &#125;), t.body.appendChild(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function c(e) &#123;</span><br><span class=\"line\">        var a = t.createElement(&quot;style&quot;);</span><br><span class=\"line\">        a.type = &quot;text/css&quot;;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            a.appendChild(t.createTextNode(e))</span><br><span class=\"line\">        &#125; catch (t) &#123;</span><br><span class=\"line\">            a.styleSheet.cssText = e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function s() &#123;</span><br><span class=\"line\">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var d = [];</span><br><span class=\"line\">    e.requestAnimationFrame = function() &#123;</span><br><span class=\"line\">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123;</span><br><span class=\"line\">            setTimeout(e, 1e3 / 60)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;(), n()</span><br><span class=\"line\">&#125;(window, document);</span><br></pre></td></tr></table></figure>\n<p>打开\\themes\\next\\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;/js/src/love.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加动态背景\"><a href=\"#添加动态背景\" class=\"headerlink\" title=\"添加动态背景\"></a>添加动态背景</h3><p>打开\\themes\\next\\layout_layout.swig文件，<br>在 之前添加代码(注意不要放在&lt; /head&gt;的后面)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if theme.canvas_nest %&#125;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<p>打开开\\themes\\next_config.yml,在里面修改为如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas_nest: true</span><br></pre></td></tr></table></figure>\n<h3 id=\"在网站底部加上访问量\"><a href=\"#在网站底部加上访问量\" class=\"headerlink\" title=\"在网站底部加上访问量\"></a>在网站底部加上访问量</h3><p>打开\\themes\\next\\layout_partials\\footer.swig文件,在类copyright前加上这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在合适的位置添加显示统计的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;powered-by&quot;&gt;</span><br><span class=\"line\">&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class=\"line\">  本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在每篇文章末尾添加“本文结束”标记\"><a href=\"#在每篇文章末尾添加“本文结束”标记\" class=\"headerlink\" title=\"在每篇文章末尾添加“本文结束”标记\"></a>在每篇文章末尾添加“本文结束”标记</h3><p>在路径 \\themes\\next\\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &#123;% if not is_index %&#125;</span><br><span class=\"line\">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>接着打开\\themes\\next\\layout_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &#123;% if not is_index %&#125;</span><br><span class=\"line\">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>打开主题配置文件,在末尾添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文章末尾添加“本文结束”标记</span><br><span class=\"line\">passage_end_tag:</span><br><span class=\"line\">  enabled: true</span><br></pre></td></tr></table></figure>\n<h3 id=\"侧边栏社交链接\"><a href=\"#侧边栏社交链接\" class=\"headerlink\" title=\"侧边栏社交链接\"></a>侧边栏社交链接</h3><p>在主题配置文件中修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Social links</span><br><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https://github.com/your-user-name</span><br><span class=\"line\">  Twitter: https://twitter.com/your-user-name</span><br><span class=\"line\">  微博: http://weibo.com/your-user-name</span><br><span class=\"line\"></span><br><span class=\"line\"># Social Icons</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Icon Mappings</span><br><span class=\"line\">  GitHub: github</span><br><span class=\"line\">  Twitter: twitter</span><br><span class=\"line\">  微博: weibo</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加小图标\"><a href=\"#添加小图标\" class=\"headerlink\" title=\"添加小图标\"></a>添加小图标</h3><p>在主题配置文件中修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">favicon:</span><br><span class=\"line\">  #small: /images/favicon.ico</span><br><span class=\"line\">  medium: /images/favicon.ico</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"http://theme-next.iissnan.com/getting-started.html#avatar-setting\" target=\"_blank\" rel=\"noopener\">NexT主题美化</a></p>\n</blockquote>\n<p>除了NexT还有很多其他好看的主题，百度会有很多方法的</p>\n"},{"title":"Hello World","Date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/其他/hello-world.md","raw":"---\ntitle: Hello World\nDate: 2018-05-03\ntags: [demo]\ncategories: demo\ncomments: true\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"其他/hello-world","published":1,"date":"2018-04-27T08:32:23.495Z","updated":"2018-05-03T14:58:35.712Z","layout":"post","photos":[],"link":"","_id":"cka6l2e3p0008c0u9dcjfk1sz","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"操作系统：进程、线程、程序","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n- 程序只是一组指令的有序集合。\n- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是资源分配的最小单位。\n- 线程是程序执行的最小单位。\n- 一个程序至少一个进程，一个进程至少一个线程。\n- 一个线程只能属于一个进程，但是一个进程可以拥有多个线程\n- 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。\n- 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。\n- 多线程处理就是允许一个进程中在同一时刻执行多个任务。\n- 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。","source":"_posts/其他/操作系统：进程、线程、程序.md","raw":"---\ntitle: 操作系统：进程、线程、程序\nDate: 2020-05-14\ntags: [操作系统]\ncategories: 操作系统\ncomments: true\n---\n\n- 程序只是一组指令的有序集合。\n- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是资源分配的最小单位。\n- 线程是程序执行的最小单位。\n- 一个程序至少一个进程，一个进程至少一个线程。\n- 一个线程只能属于一个进程，但是一个进程可以拥有多个线程\n- 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。\n- 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。\n- 多线程处理就是允许一个进程中在同一时刻执行多个任务。\n- 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。","slug":"其他/操作系统：进程、线程、程序","published":1,"date":"2020-05-14T08:43:35.817Z","updated":"2020-05-14T08:45:41.669Z","layout":"post","photos":[],"link":"","_id":"cka6l2e3w000bc0u9s8vcoqmr","content":"<ul>\n<li>程序只是一组指令的有序集合。</li>\n<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是资源分配的最小单位。</li>\n<li>线程是程序执行的最小单位。</li>\n<li>一个程序至少一个进程，一个进程至少一个线程。</li>\n<li>一个线程只能属于一个进程，但是一个进程可以拥有多个线程</li>\n<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。</li>\n<li>而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li>\n<li>多线程处理就是允许一个进程中在同一时刻执行多个任务。</li>\n<li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>程序只是一组指令的有序集合。</li>\n<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是资源分配的最小单位。</li>\n<li>线程是程序执行的最小单位。</li>\n<li>一个程序至少一个进程，一个进程至少一个线程。</li>\n<li>一个线程只能属于一个进程，但是一个进程可以拥有多个线程</li>\n<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。</li>\n<li>而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li>\n<li>多线程处理就是允许一个进程中在同一时刻执行多个任务。</li>\n<li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li>\n</ul>\n"},{"title":"数据类型：json和xml","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n### json\n- json是一种轻量级的数据交换格式。\n- 兼容性高。\n- 格式简单，易读写。\n- 易于解析。\n\n### xml\n- xml是一种扩展标记语言。\n- 可用来标记数据，定义数据类型。\n- 格式统一。\n- 文件庞大，格式复杂。\n- 客户端和服务器端都需要大量代码来解析，导致代码复杂难以维护。","source":"_posts/其他/数据类型：json和xml.md","raw":"---\ntitle: 数据类型：json和xml\nDate: 2020-05-14\ntags: [数据类型]\ncategories: 数据类型\ncomments: true\n---\n\n### json\n- json是一种轻量级的数据交换格式。\n- 兼容性高。\n- 格式简单，易读写。\n- 易于解析。\n\n### xml\n- xml是一种扩展标记语言。\n- 可用来标记数据，定义数据类型。\n- 格式统一。\n- 文件庞大，格式复杂。\n- 客户端和服务器端都需要大量代码来解析，导致代码复杂难以维护。","slug":"其他/数据类型：json和xml","published":1,"date":"2020-05-14T08:43:30.894Z","updated":"2020-05-14T08:46:00.396Z","layout":"post","photos":[],"link":"","_id":"cka6l2e47000ec0u9l6bq50qq","content":"<h3 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json\"></a>json</h3><ul>\n<li>json是一种轻量级的数据交换格式。</li>\n<li>兼容性高。</li>\n<li>格式简单，易读写。</li>\n<li>易于解析。</li>\n</ul>\n<h3 id=\"xml\"><a href=\"#xml\" class=\"headerlink\" title=\"xml\"></a>xml</h3><ul>\n<li>xml是一种扩展标记语言。</li>\n<li>可用来标记数据，定义数据类型。</li>\n<li>格式统一。</li>\n<li>文件庞大，格式复杂。</li>\n<li>客户端和服务器端都需要大量代码来解析，导致代码复杂难以维护。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json\"></a>json</h3><ul>\n<li>json是一种轻量级的数据交换格式。</li>\n<li>兼容性高。</li>\n<li>格式简单，易读写。</li>\n<li>易于解析。</li>\n</ul>\n<h3 id=\"xml\"><a href=\"#xml\" class=\"headerlink\" title=\"xml\"></a>xml</h3><ul>\n<li>xml是一种扩展标记语言。</li>\n<li>可用来标记数据，定义数据类型。</li>\n<li>格式统一。</li>\n<li>文件庞大，格式复杂。</li>\n<li>客户端和服务器端都需要大量代码来解析，导致代码复杂难以维护。</li>\n</ul>\n"},{"title":"数据结构：树的深度遍历和广度遍历","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n## 普通树\n### 深度遍历\n先访问根结点，然后遍历左子树接着是遍历右子树。利用堆栈的先进后出。\n\n### 广度遍历\n从根开始访问,按照根节点左右顺序访问.每次把同层节点左右孩子访问完毕.再访问下一层，所以用队列的先进先出实现。\n\n## 二叉树\n### 前序遍历\n根 左 右\n### 中序遍历\n左 根 右\n### 后序遍历\n左 右 根\n","source":"_posts/其他/数据结构：树的深度遍历和广度遍历.md","raw":"---\ntitle: 数据结构：树的深度遍历和广度遍历\nDate: 2020-05-14\ntags: [数据结构]\ncategories: 数据结构\ncomments: true\n---\n\n## 普通树\n### 深度遍历\n先访问根结点，然后遍历左子树接着是遍历右子树。利用堆栈的先进后出。\n\n### 广度遍历\n从根开始访问,按照根节点左右顺序访问.每次把同层节点左右孩子访问完毕.再访问下一层，所以用队列的先进先出实现。\n\n## 二叉树\n### 前序遍历\n根 左 右\n### 中序遍历\n左 根 右\n### 后序遍历\n左 右 根\n","slug":"其他/数据结构：树的深度遍历和广度遍历","published":1,"date":"2020-05-14T08:43:45.700Z","updated":"2020-05-14T08:46:22.226Z","layout":"post","photos":[],"link":"","_id":"cka6l2e4d000hc0u9z6yl0brq","content":"<h2 id=\"普通树\"><a href=\"#普通树\" class=\"headerlink\" title=\"普通树\"></a>普通树</h2><h3 id=\"深度遍历\"><a href=\"#深度遍历\" class=\"headerlink\" title=\"深度遍历\"></a>深度遍历</h3><p>先访问根结点，然后遍历左子树接着是遍历右子树。利用堆栈的先进后出。</p>\n<h3 id=\"广度遍历\"><a href=\"#广度遍历\" class=\"headerlink\" title=\"广度遍历\"></a>广度遍历</h3><p>从根开始访问,按照根节点左右顺序访问.每次把同层节点左右孩子访问完毕.再访问下一层，所以用队列的先进先出实现。</p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h3 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h3><p>根 左 右</p>\n<h3 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h3><p>左 根 右</p>\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><p>左 右 根</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"普通树\"><a href=\"#普通树\" class=\"headerlink\" title=\"普通树\"></a>普通树</h2><h3 id=\"深度遍历\"><a href=\"#深度遍历\" class=\"headerlink\" title=\"深度遍历\"></a>深度遍历</h3><p>先访问根结点，然后遍历左子树接着是遍历右子树。利用堆栈的先进后出。</p>\n<h3 id=\"广度遍历\"><a href=\"#广度遍历\" class=\"headerlink\" title=\"广度遍历\"></a>广度遍历</h3><p>从根开始访问,按照根节点左右顺序访问.每次把同层节点左右孩子访问完毕.再访问下一层，所以用队列的先进先出实现。</p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h3 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h3><p>根 左 右</p>\n<h3 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h3><p>左 根 右</p>\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><p>左 右 根</p>\n"},{"title":"Electron：结合vue创建桌面应用","Date":"2019-02-25T16:00:00.000Z","comments":1,"_content":"\n## 首先\n创建项目并安装好依赖\n```\nvue init webpack test-electron\ncd test-electron\nnpm install\nnpm install electron --save-dev\nnpm install electron-packager --save-dev\n```\n## 其次\n将零基础中的main.js拷贝到新建项目的build目录下，并更名为electron.js\n\n按照实际项目路径更改electron.js中的路径\n\n```\n mainWindow.loadURL(url.format({\n    pathname: path.join(__dirname, '../dist/index.html'),\n    protocol: 'file:',\n    slashes: true\n  }))\n```\n## 最后\n在新建项目package.json文件中增加一条指令\n\n```\n \"scripts\": \n { ... \n \"lint\": \"eslint --ext .js,.vue src test/unit/specs test/e2e/specs\", \n \"build\": \"node build/build.js\", \n  //增加这条,JSON文件不支持注释，引用时请清除 \n \"electron_dev\": \"npm run build && electron build/electron.js\" \n },\n```\n## 启动\n\n```\nnpm run build //生成dist目录\nnpm run electron_dev //启动electron\n```\n\n> PS 打包前：更改config/index.js中生产模式下（build）的assetsPublicPth, 原本为 /, 改为 ./ 。","source":"_posts/其他/Electron：结合vue创建桌面应用.md","raw":"---\ntitle: Electron：结合vue创建桌面应用\nDate: 2019-02-26\ntags: [Electron]\ncategories: Electron\ncomments: true\n---\n\n## 首先\n创建项目并安装好依赖\n```\nvue init webpack test-electron\ncd test-electron\nnpm install\nnpm install electron --save-dev\nnpm install electron-packager --save-dev\n```\n## 其次\n将零基础中的main.js拷贝到新建项目的build目录下，并更名为electron.js\n\n按照实际项目路径更改electron.js中的路径\n\n```\n mainWindow.loadURL(url.format({\n    pathname: path.join(__dirname, '../dist/index.html'),\n    protocol: 'file:',\n    slashes: true\n  }))\n```\n## 最后\n在新建项目package.json文件中增加一条指令\n\n```\n \"scripts\": \n { ... \n \"lint\": \"eslint --ext .js,.vue src test/unit/specs test/e2e/specs\", \n \"build\": \"node build/build.js\", \n  //增加这条,JSON文件不支持注释，引用时请清除 \n \"electron_dev\": \"npm run build && electron build/electron.js\" \n },\n```\n## 启动\n\n```\nnpm run build //生成dist目录\nnpm run electron_dev //启动electron\n```\n\n> PS 打包前：更改config/index.js中生产模式下（build）的assetsPublicPth, 原本为 /, 改为 ./ 。","slug":"其他/Electron：结合vue创建桌面应用","published":1,"date":"2019-02-26T08:39:37.502Z","updated":"2019-02-26T08:58:20.061Z","layout":"post","photos":[],"link":"","_id":"cka6l2e4m000nc0u9yicnqqp5","content":"<h2 id=\"首先\"><a href=\"#首先\" class=\"headerlink\" title=\"首先\"></a>首先</h2><p>创建项目并安装好依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack test-electron</span><br><span class=\"line\">cd test-electron</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm install electron --save-dev</span><br><span class=\"line\">npm install electron-packager --save-dev</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其次\"><a href=\"#其次\" class=\"headerlink\" title=\"其次\"></a>其次</h2><p>将零基础中的main.js拷贝到新建项目的build目录下，并更名为electron.js</p>\n<p>按照实际项目路径更改electron.js中的路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainWindow.loadURL(url.format(&#123;</span><br><span class=\"line\">   pathname: path.join(__dirname, &apos;../dist/index.html&apos;),</span><br><span class=\"line\">   protocol: &apos;file:&apos;,</span><br><span class=\"line\">   slashes: true</span><br><span class=\"line\"> &#125;))</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>在新建项目package.json文件中增加一条指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: </span><br><span class=\"line\">&#123; ... </span><br><span class=\"line\">&quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;, </span><br><span class=\"line\">&quot;build&quot;: &quot;node build/build.js&quot;, </span><br><span class=\"line\"> //增加这条,JSON文件不支持注释，引用时请清除 </span><br><span class=\"line\">&quot;electron_dev&quot;: &quot;npm run build &amp;&amp; electron build/electron.js&quot; </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build //生成dist目录</span><br><span class=\"line\">npm run electron_dev //启动electron</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS 打包前：更改config/index.js中生产模式下（build）的assetsPublicPth, 原本为 /, 改为 ./ 。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"首先\"><a href=\"#首先\" class=\"headerlink\" title=\"首先\"></a>首先</h2><p>创建项目并安装好依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack test-electron</span><br><span class=\"line\">cd test-electron</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm install electron --save-dev</span><br><span class=\"line\">npm install electron-packager --save-dev</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其次\"><a href=\"#其次\" class=\"headerlink\" title=\"其次\"></a>其次</h2><p>将零基础中的main.js拷贝到新建项目的build目录下，并更名为electron.js</p>\n<p>按照实际项目路径更改electron.js中的路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainWindow.loadURL(url.format(&#123;</span><br><span class=\"line\">   pathname: path.join(__dirname, &apos;../dist/index.html&apos;),</span><br><span class=\"line\">   protocol: &apos;file:&apos;,</span><br><span class=\"line\">   slashes: true</span><br><span class=\"line\"> &#125;))</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>在新建项目package.json文件中增加一条指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: </span><br><span class=\"line\">&#123; ... </span><br><span class=\"line\">&quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;, </span><br><span class=\"line\">&quot;build&quot;: &quot;node build/build.js&quot;, </span><br><span class=\"line\"> //增加这条,JSON文件不支持注释，引用时请清除 </span><br><span class=\"line\">&quot;electron_dev&quot;: &quot;npm run build &amp;&amp; electron build/electron.js&quot; </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build //生成dist目录</span><br><span class=\"line\">npm run electron_dev //启动electron</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS 打包前：更改config/index.js中生产模式下（build）的assetsPublicPth, 原本为 /, 改为 ./ 。</p>\n</blockquote>\n"},{"title":"安全：cookie和session","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n## 前言\n- 会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。\n- Cookie通过在客户端记录信息确定用户身份。\n- Session通过在服务器端记录信息确定用户身份。\n\n## cookie\n在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。\n\nWeb应用程序是使用HTTP协议传输数据的。==HTTP协议是无状态的协议==。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。\n### 什么是cookie\ncookie其实是存储在浏览器中的纯文本，是服务器发送出来存储在浏览器上的一组组键值对，浏览器的安装目录下会专门有一个cookie文件夹来存放各个域下设置的cookie。\n\n### cookie怎么工作\n- 存储cookie是浏览器提供的功能。\n- 若客户端首次请求服务器，浏览器会添加请求头中的 cookie字段为{}，把请求的网址连同该Cookie一同提交给服务器。如果服务器需要记录该用户状态，就向客户端浏览器返回Cookie，客户端浏览器会把Cookie保存起来。\n- 当网页要再次发http请求时，浏览器会先检查是否有相应的 cookie，有则自动把所有这个服务器Cookie添加在 request header中的 cookie字段中，把请求的网址连同该Cookie一同提交给服务器。这些是浏览器自动帮我们做的，而且每一次 http请求浏览器都会自动帮我们做。\n- 服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容\n- cookie的存放有大小限制，不可以超过4kb, 每一个域名下的cookie数量最多是20个\n\n### 获取cookie\ndocument.cookie，只能获取非HttpOnly类型的cookie。\n\n打印出的结果是一个字符串类型，因为 cookie本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value构成，键值对之间由一个 分号和一个 空格隔开。\n\n```\nkey=value; key=value\n```\n\n### Cookie的不可跨域名性\n\n受同源策略限制，跨域的ajax请求默认不携带cookie，那为什么还会有csrf攻击呢？\n\n```\n由于script、img、iframe的src都不受同源策略影响，可以利用此来实现跨域请求，来实施攻击。\n浏览器会依据加载的域名附带上对应域名的cookie\n```\n例如，a.com是一个银行网站，用户在此网站登录且生成了授权的cookie，此时浏览器保存了这个cookie。随后访问 b.com，在这个网站中伪造一个请求a网站的请求，如转账、删除操作等，利用script、img、iframe来加载a网站的地址，浏览器就会携带上a网站此登陆用户的授权cookie信息，这样就构成了csrf攻击。\n\n![image](https://upload-images.jianshu.io/upload_images/3635292-906033c13ee628a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800)\n\n### cookie的属性\n\n属性名 | 数据类型 | 描述\n---|---|---\nname | String | 该Cookie的名称。Cookie一旦创建，名称便不可更改\nvalue | Object | 该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码\nmaxAge | int | 该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1\nsecure | boolean | 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false\npath | String | 该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”\ndomain | String | 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”\ncomment | String | 该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明\nversion | int |  该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范\n\n### cookie的修改和删除\n- 服务器可以对cookie进行操作，浏览器只能对非HttpOnly类型的cookie进行操作（为了预防xss攻击）。\n- Cookie并不提供修改、删除操作。\n- 如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。\n- 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。\n\n注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。\n\n## session\n除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。\n\nsession是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。\n\n### 什么是session\n\n- 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。\n- 客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。\n- session对象是在客户端第一次请求服务器的时候创建的。session也是一种key-value的属性对\n\n如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。\n\n### session的生命周期\n\nsession保存在服务器端。为了获得更高的存取速度，服务器一般把session放在内存里。每个用户都会有一个独立的session。如果session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，session里的信息应该尽量精简。\n\nsession在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建session，只访问HTML、IMAGE等静态资源并不会创建session。如果尚未生成session，也可以使用request.getSession(true)强制生成session。\n\n- session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。用户每访问服务器一次，无论是否读写session，服务器都认为该用户的Session“活跃（active）”了一次。\n- 为防止内存溢出，服务器会把长时间内没有活跃的session从内存删除。这个时间就是session的超时时间。如果超过了超时时间没访问过服务器，session就自动失效了。tomcat默认失效时间为20分钟。\n\n### session对浏览器的要求\n虽然session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为session需要使用Cookie作为识别标志。HTTP协议是无状态的，session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该session的id（也就是HttpSession.getId()的返回值）。session依据该Cookie来识别是否为同一用户。\n\n如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。\n\n### URL地址重写\n\nURL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户session的id信息重写到URL地址中。服务器能够解析重写后的URL获取session的id。这样即使客户端不支持Cookie，也可以使用session来记录用户状态。\n\n## 两者区别\n- cookie数据存放在客户的浏览器上，session数据放在服务器上的，但名为JSESSIONID的Cookie（值为该Session的id）是放在客户端的。\n- cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。\n- 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。\n- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。\n- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)\n- 两者最大的区别在于生存周期，session是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，cookie是预先设置的生存周期，或永久的保存于本地的文件。","source":"_posts/其他/安全：cookie和session.md","raw":"---\ntitle: 安全：cookie和session\nDate: 2020-05-14\ntags: [安全]\ncategories: 安全\ncomments: true\n---\n\n## 前言\n- 会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。\n- Cookie通过在客户端记录信息确定用户身份。\n- Session通过在服务器端记录信息确定用户身份。\n\n## cookie\n在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。\n\nWeb应用程序是使用HTTP协议传输数据的。==HTTP协议是无状态的协议==。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。\n### 什么是cookie\ncookie其实是存储在浏览器中的纯文本，是服务器发送出来存储在浏览器上的一组组键值对，浏览器的安装目录下会专门有一个cookie文件夹来存放各个域下设置的cookie。\n\n### cookie怎么工作\n- 存储cookie是浏览器提供的功能。\n- 若客户端首次请求服务器，浏览器会添加请求头中的 cookie字段为{}，把请求的网址连同该Cookie一同提交给服务器。如果服务器需要记录该用户状态，就向客户端浏览器返回Cookie，客户端浏览器会把Cookie保存起来。\n- 当网页要再次发http请求时，浏览器会先检查是否有相应的 cookie，有则自动把所有这个服务器Cookie添加在 request header中的 cookie字段中，把请求的网址连同该Cookie一同提交给服务器。这些是浏览器自动帮我们做的，而且每一次 http请求浏览器都会自动帮我们做。\n- 服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容\n- cookie的存放有大小限制，不可以超过4kb, 每一个域名下的cookie数量最多是20个\n\n### 获取cookie\ndocument.cookie，只能获取非HttpOnly类型的cookie。\n\n打印出的结果是一个字符串类型，因为 cookie本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value构成，键值对之间由一个 分号和一个 空格隔开。\n\n```\nkey=value; key=value\n```\n\n### Cookie的不可跨域名性\n\n受同源策略限制，跨域的ajax请求默认不携带cookie，那为什么还会有csrf攻击呢？\n\n```\n由于script、img、iframe的src都不受同源策略影响，可以利用此来实现跨域请求，来实施攻击。\n浏览器会依据加载的域名附带上对应域名的cookie\n```\n例如，a.com是一个银行网站，用户在此网站登录且生成了授权的cookie，此时浏览器保存了这个cookie。随后访问 b.com，在这个网站中伪造一个请求a网站的请求，如转账、删除操作等，利用script、img、iframe来加载a网站的地址，浏览器就会携带上a网站此登陆用户的授权cookie信息，这样就构成了csrf攻击。\n\n![image](https://upload-images.jianshu.io/upload_images/3635292-906033c13ee628a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800)\n\n### cookie的属性\n\n属性名 | 数据类型 | 描述\n---|---|---\nname | String | 该Cookie的名称。Cookie一旦创建，名称便不可更改\nvalue | Object | 该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码\nmaxAge | int | 该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1\nsecure | boolean | 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false\npath | String | 该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”\ndomain | String | 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”\ncomment | String | 该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明\nversion | int |  该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范\n\n### cookie的修改和删除\n- 服务器可以对cookie进行操作，浏览器只能对非HttpOnly类型的cookie进行操作（为了预防xss攻击）。\n- Cookie并不提供修改、删除操作。\n- 如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。\n- 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。\n\n注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。\n\n## session\n除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。\n\nsession是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。\n\n### 什么是session\n\n- 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。\n- 客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。\n- session对象是在客户端第一次请求服务器的时候创建的。session也是一种key-value的属性对\n\n如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。\n\n### session的生命周期\n\nsession保存在服务器端。为了获得更高的存取速度，服务器一般把session放在内存里。每个用户都会有一个独立的session。如果session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，session里的信息应该尽量精简。\n\nsession在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建session，只访问HTML、IMAGE等静态资源并不会创建session。如果尚未生成session，也可以使用request.getSession(true)强制生成session。\n\n- session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。用户每访问服务器一次，无论是否读写session，服务器都认为该用户的Session“活跃（active）”了一次。\n- 为防止内存溢出，服务器会把长时间内没有活跃的session从内存删除。这个时间就是session的超时时间。如果超过了超时时间没访问过服务器，session就自动失效了。tomcat默认失效时间为20分钟。\n\n### session对浏览器的要求\n虽然session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为session需要使用Cookie作为识别标志。HTTP协议是无状态的，session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该session的id（也就是HttpSession.getId()的返回值）。session依据该Cookie来识别是否为同一用户。\n\n如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。\n\n### URL地址重写\n\nURL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户session的id信息重写到URL地址中。服务器能够解析重写后的URL获取session的id。这样即使客户端不支持Cookie，也可以使用session来记录用户状态。\n\n## 两者区别\n- cookie数据存放在客户的浏览器上，session数据放在服务器上的，但名为JSESSIONID的Cookie（值为该Session的id）是放在客户端的。\n- cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。\n- 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。\n- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。\n- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)\n- 两者最大的区别在于生存周期，session是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，cookie是预先设置的生存周期，或永久的保存于本地的文件。","slug":"其他/安全：cookie和session","published":1,"date":"2020-05-14T09:46:19.727Z","updated":"2020-05-14T09:45:18.896Z","layout":"post","photos":[],"link":"","_id":"cka6l90240000v8u9yvx19qbh","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。</li>\n<li>Cookie通过在客户端记录信息确定用户身份。</li>\n<li>Session通过在服务器端记录信息确定用户身份。</li>\n</ul>\n<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。</p>\n<p>Web应用程序是使用HTTP协议传输数据的。==HTTP协议是无状态的协议==。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</p>\n<h3 id=\"什么是cookie\"><a href=\"#什么是cookie\" class=\"headerlink\" title=\"什么是cookie\"></a>什么是cookie</h3><p>cookie其实是存储在浏览器中的纯文本，是服务器发送出来存储在浏览器上的一组组键值对，浏览器的安装目录下会专门有一个cookie文件夹来存放各个域下设置的cookie。</p>\n<h3 id=\"cookie怎么工作\"><a href=\"#cookie怎么工作\" class=\"headerlink\" title=\"cookie怎么工作\"></a>cookie怎么工作</h3><ul>\n<li>存储cookie是浏览器提供的功能。</li>\n<li>若客户端首次请求服务器，浏览器会添加请求头中的 cookie字段为{}，把请求的网址连同该Cookie一同提交给服务器。如果服务器需要记录该用户状态，就向客户端浏览器返回Cookie，客户端浏览器会把Cookie保存起来。</li>\n<li>当网页要再次发http请求时，浏览器会先检查是否有相应的 cookie，有则自动把所有这个服务器Cookie添加在 request header中的 cookie字段中，把请求的网址连同该Cookie一同提交给服务器。这些是浏览器自动帮我们做的，而且每一次 http请求浏览器都会自动帮我们做。</li>\n<li>服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容</li>\n<li>cookie的存放有大小限制，不可以超过4kb, 每一个域名下的cookie数量最多是20个</li>\n</ul>\n<h3 id=\"获取cookie\"><a href=\"#获取cookie\" class=\"headerlink\" title=\"获取cookie\"></a>获取cookie</h3><p>document.cookie，只能获取非HttpOnly类型的cookie。</p>\n<p>打印出的结果是一个字符串类型，因为 cookie本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value构成，键值对之间由一个 分号和一个 空格隔开。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key=value; key=value</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cookie的不可跨域名性\"><a href=\"#Cookie的不可跨域名性\" class=\"headerlink\" title=\"Cookie的不可跨域名性\"></a>Cookie的不可跨域名性</h3><p>受同源策略限制，跨域的ajax请求默认不携带cookie，那为什么还会有csrf攻击呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于script、img、iframe的src都不受同源策略影响，可以利用此来实现跨域请求，来实施攻击。</span><br><span class=\"line\">浏览器会依据加载的域名附带上对应域名的cookie</span><br></pre></td></tr></table></figure>\n<p>例如，a.com是一个银行网站，用户在此网站登录且生成了授权的cookie，此时浏览器保存了这个cookie。随后访问 b.com，在这个网站中伪造一个请求a网站的请求，如转账、删除操作等，利用script、img、iframe来加载a网站的地址，浏览器就会携带上a网站此登陆用户的授权cookie信息，这样就构成了csrf攻击。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3635292-906033c13ee628a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800\" alt=\"image\"></p>\n<h3 id=\"cookie的属性\"><a href=\"#cookie的属性\" class=\"headerlink\" title=\"cookie的属性\"></a>cookie的属性</h3><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>数据类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>String</td>\n<td>该Cookie的名称。Cookie一旦创建，名称便不可更改</td>\n</tr>\n<tr>\n<td>value</td>\n<td>Object</td>\n<td>该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码</td>\n</tr>\n<tr>\n<td>maxAge</td>\n<td>int</td>\n<td>该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1</td>\n</tr>\n<tr>\n<td>secure</td>\n<td>boolean</td>\n<td>该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false</td>\n</tr>\n<tr>\n<td>path</td>\n<td>String</td>\n<td>该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”</td>\n</tr>\n<tr>\n<td>domain</td>\n<td>String</td>\n<td>可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”</td>\n</tr>\n<tr>\n<td>comment</td>\n<td>String</td>\n<td>该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</td>\n</tr>\n<tr>\n<td>version</td>\n<td>int</td>\n<td>该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"cookie的修改和删除\"><a href=\"#cookie的修改和删除\" class=\"headerlink\" title=\"cookie的修改和删除\"></a>cookie的修改和删除</h3><ul>\n<li>服务器可以对cookie进行操作，浏览器只能对非HttpOnly类型的cookie进行操作（为了预防xss攻击）。</li>\n<li>Cookie并不提供修改、删除操作。</li>\n<li>如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。</li>\n<li>如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。</li>\n</ul>\n<p>注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。</p>\n<h2 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h2><p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p>\n<p>session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。</p>\n<h3 id=\"什么是session\"><a href=\"#什么是session\" class=\"headerlink\" title=\"什么是session\"></a>什么是session</h3><ul>\n<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。</li>\n<li>客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。</li>\n<li>session对象是在客户端第一次请求服务器的时候创建的。session也是一种key-value的属性对</li>\n</ul>\n<p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>\n<h3 id=\"session的生命周期\"><a href=\"#session的生命周期\" class=\"headerlink\" title=\"session的生命周期\"></a>session的生命周期</h3><p>session保存在服务器端。为了获得更高的存取速度，服务器一般把session放在内存里。每个用户都会有一个独立的session。如果session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，session里的信息应该尽量精简。</p>\n<p>session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建session，只访问HTML、IMAGE等静态资源并不会创建session。如果尚未生成session，也可以使用request.getSession(true)强制生成session。</p>\n<ul>\n<li>session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。用户每访问服务器一次，无论是否读写session，服务器都认为该用户的Session“活跃（active）”了一次。</li>\n<li>为防止内存溢出，服务器会把长时间内没有活跃的session从内存删除。这个时间就是session的超时时间。如果超过了超时时间没访问过服务器，session就自动失效了。tomcat默认失效时间为20分钟。</li>\n</ul>\n<h3 id=\"session对浏览器的要求\"><a href=\"#session对浏览器的要求\" class=\"headerlink\" title=\"session对浏览器的要求\"></a>session对浏览器的要求</h3><p>虽然session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为session需要使用Cookie作为识别标志。HTTP协议是无状态的，session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该session的id（也就是HttpSession.getId()的返回值）。session依据该Cookie来识别是否为同一用户。</p>\n<p>如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。</p>\n<h3 id=\"URL地址重写\"><a href=\"#URL地址重写\" class=\"headerlink\" title=\"URL地址重写\"></a>URL地址重写</h3><p>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户session的id信息重写到URL地址中。服务器能够解析重写后的URL获取session的id。这样即使客户端不支持Cookie，也可以使用session来记录用户状态。</p>\n<h2 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h2><ul>\n<li>cookie数据存放在客户的浏览器上，session数据放在服务器上的，但名为JSESSIONID的Cookie（值为该Session的id）是放在客户端的。</li>\n<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</li>\n<li>设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。</li>\n<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</li>\n<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</li>\n<li>两者最大的区别在于生存周期，session是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，cookie是预先设置的生存周期，或永久的保存于本地的文件。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。</li>\n<li>Cookie通过在客户端记录信息确定用户身份。</li>\n<li>Session通过在服务器端记录信息确定用户身份。</li>\n</ul>\n<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。</p>\n<p>Web应用程序是使用HTTP协议传输数据的。==HTTP协议是无状态的协议==。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</p>\n<h3 id=\"什么是cookie\"><a href=\"#什么是cookie\" class=\"headerlink\" title=\"什么是cookie\"></a>什么是cookie</h3><p>cookie其实是存储在浏览器中的纯文本，是服务器发送出来存储在浏览器上的一组组键值对，浏览器的安装目录下会专门有一个cookie文件夹来存放各个域下设置的cookie。</p>\n<h3 id=\"cookie怎么工作\"><a href=\"#cookie怎么工作\" class=\"headerlink\" title=\"cookie怎么工作\"></a>cookie怎么工作</h3><ul>\n<li>存储cookie是浏览器提供的功能。</li>\n<li>若客户端首次请求服务器，浏览器会添加请求头中的 cookie字段为{}，把请求的网址连同该Cookie一同提交给服务器。如果服务器需要记录该用户状态，就向客户端浏览器返回Cookie，客户端浏览器会把Cookie保存起来。</li>\n<li>当网页要再次发http请求时，浏览器会先检查是否有相应的 cookie，有则自动把所有这个服务器Cookie添加在 request header中的 cookie字段中，把请求的网址连同该Cookie一同提交给服务器。这些是浏览器自动帮我们做的，而且每一次 http请求浏览器都会自动帮我们做。</li>\n<li>服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容</li>\n<li>cookie的存放有大小限制，不可以超过4kb, 每一个域名下的cookie数量最多是20个</li>\n</ul>\n<h3 id=\"获取cookie\"><a href=\"#获取cookie\" class=\"headerlink\" title=\"获取cookie\"></a>获取cookie</h3><p>document.cookie，只能获取非HttpOnly类型的cookie。</p>\n<p>打印出的结果是一个字符串类型，因为 cookie本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value构成，键值对之间由一个 分号和一个 空格隔开。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key=value; key=value</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cookie的不可跨域名性\"><a href=\"#Cookie的不可跨域名性\" class=\"headerlink\" title=\"Cookie的不可跨域名性\"></a>Cookie的不可跨域名性</h3><p>受同源策略限制，跨域的ajax请求默认不携带cookie，那为什么还会有csrf攻击呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于script、img、iframe的src都不受同源策略影响，可以利用此来实现跨域请求，来实施攻击。</span><br><span class=\"line\">浏览器会依据加载的域名附带上对应域名的cookie</span><br></pre></td></tr></table></figure>\n<p>例如，a.com是一个银行网站，用户在此网站登录且生成了授权的cookie，此时浏览器保存了这个cookie。随后访问 b.com，在这个网站中伪造一个请求a网站的请求，如转账、删除操作等，利用script、img、iframe来加载a网站的地址，浏览器就会携带上a网站此登陆用户的授权cookie信息，这样就构成了csrf攻击。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3635292-906033c13ee628a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800\" alt=\"image\"></p>\n<h3 id=\"cookie的属性\"><a href=\"#cookie的属性\" class=\"headerlink\" title=\"cookie的属性\"></a>cookie的属性</h3><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>数据类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>String</td>\n<td>该Cookie的名称。Cookie一旦创建，名称便不可更改</td>\n</tr>\n<tr>\n<td>value</td>\n<td>Object</td>\n<td>该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码</td>\n</tr>\n<tr>\n<td>maxAge</td>\n<td>int</td>\n<td>该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1</td>\n</tr>\n<tr>\n<td>secure</td>\n<td>boolean</td>\n<td>该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false</td>\n</tr>\n<tr>\n<td>path</td>\n<td>String</td>\n<td>该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”</td>\n</tr>\n<tr>\n<td>domain</td>\n<td>String</td>\n<td>可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”</td>\n</tr>\n<tr>\n<td>comment</td>\n<td>String</td>\n<td>该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</td>\n</tr>\n<tr>\n<td>version</td>\n<td>int</td>\n<td>该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"cookie的修改和删除\"><a href=\"#cookie的修改和删除\" class=\"headerlink\" title=\"cookie的修改和删除\"></a>cookie的修改和删除</h3><ul>\n<li>服务器可以对cookie进行操作，浏览器只能对非HttpOnly类型的cookie进行操作（为了预防xss攻击）。</li>\n<li>Cookie并不提供修改、删除操作。</li>\n<li>如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。</li>\n<li>如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。</li>\n</ul>\n<p>注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。</p>\n<h2 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h2><p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p>\n<p>session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。</p>\n<h3 id=\"什么是session\"><a href=\"#什么是session\" class=\"headerlink\" title=\"什么是session\"></a>什么是session</h3><ul>\n<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。</li>\n<li>客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。</li>\n<li>session对象是在客户端第一次请求服务器的时候创建的。session也是一种key-value的属性对</li>\n</ul>\n<p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>\n<h3 id=\"session的生命周期\"><a href=\"#session的生命周期\" class=\"headerlink\" title=\"session的生命周期\"></a>session的生命周期</h3><p>session保存在服务器端。为了获得更高的存取速度，服务器一般把session放在内存里。每个用户都会有一个独立的session。如果session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，session里的信息应该尽量精简。</p>\n<p>session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建session，只访问HTML、IMAGE等静态资源并不会创建session。如果尚未生成session，也可以使用request.getSession(true)强制生成session。</p>\n<ul>\n<li>session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。用户每访问服务器一次，无论是否读写session，服务器都认为该用户的Session“活跃（active）”了一次。</li>\n<li>为防止内存溢出，服务器会把长时间内没有活跃的session从内存删除。这个时间就是session的超时时间。如果超过了超时时间没访问过服务器，session就自动失效了。tomcat默认失效时间为20分钟。</li>\n</ul>\n<h3 id=\"session对浏览器的要求\"><a href=\"#session对浏览器的要求\" class=\"headerlink\" title=\"session对浏览器的要求\"></a>session对浏览器的要求</h3><p>虽然session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为session需要使用Cookie作为识别标志。HTTP协议是无状态的，session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该session的id（也就是HttpSession.getId()的返回值）。session依据该Cookie来识别是否为同一用户。</p>\n<p>如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。</p>\n<h3 id=\"URL地址重写\"><a href=\"#URL地址重写\" class=\"headerlink\" title=\"URL地址重写\"></a>URL地址重写</h3><p>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户session的id信息重写到URL地址中。服务器能够解析重写后的URL获取session的id。这样即使客户端不支持Cookie，也可以使用session来记录用户状态。</p>\n<h2 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h2><ul>\n<li>cookie数据存放在客户的浏览器上，session数据放在服务器上的，但名为JSESSIONID的Cookie（值为该Session的id）是放在客户端的。</li>\n<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</li>\n<li>设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。</li>\n<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</li>\n<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</li>\n<li>两者最大的区别在于生存周期，session是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，cookie是预先设置的生存周期，或永久的保存于本地的文件。</li>\n</ul>\n"},{"title":"安全：XSS和CSRF","Date":"2020-05-13T16:00:00.000Z","comments":1,"_content":"\n## XSS攻击（跨站脚本攻击）\n### 原理\n恶意攻击者往web页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中web里面的脚本代码会被执行，从而达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。\n### 分类\n- 存储型XSS   \n恶意代码存储在数据库中\n- 反射型XSS   \n恶意代码存储在url中\n- DOM型XSS   \n取出和执行恶意代码都是浏览器端完成\n### 防御\n#### 开启CSP\n建立白名单，明确告诉浏览器哪些外部资源可以加载和执行。\n- 设置http header中的Content-Security-Policy\n- 设置meta标签\n```\n<meta http-equiv=\"Content-Security-Policy\">\n```\n\n#### 输入输出过滤\n前端负责，后端也要做相同的过滤检查，因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。\n#### 转义字符\n转义输入输出的内容，对于引号、尖括号、斜杠进行转义。\n\n#### cookie\nweb应用程序在设置cookie时，将其属性设为HttpOnly，这样设置的cookie，js就无法进行读写，就可以预防XSS攻击窃取用户cookie，保护用户cookie信息。\n\n## CSRF攻击（跨站请求伪造）\n### 原理\n攻击者通过一些技术手段欺骗用户的浏览器去訪问一个自己以前认证过的站点并运行一些操作。\n\n利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以这么理解：攻击者盗用了你的身份，以你的名义发送恶意请求。\n\n一般发起攻击的是第三方网站。是利用用户的登录凭证，冒用用户信息，不能获取用户的数据。    \n\nCSRF攻击是源于WEB的隐式身份验证机制。WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。\n\n\n\n### 分类\n- get类型  \n可以将get请求嵌入img标签，打开页面自动发送请求。\n- post类型  \n可以利用自动提交的form表单，访问页面就会自动提交。\n- 链接型  \n需要用户点击链接才会触发。\n### 防御\n#### post\n尽量使用post请求，避免get请求。\n\n#### cookie\n对cookie设置SameSite属性。该属性表示cookie不随跨域请求发送，可以很大程度减少csrf攻击。\n\n#### token\n\n1. 用户访问某个表单页面。\n2. 服务端生成一个Token，放在用户的Session或者浏览器的Cookie中。\n3. 在页面表单附带上Token参数。\n4. 用户发送请求时以参数的形式带上本次页面中生成的token，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。\n> 仅仅用来防御csrf攻击，当加上xss攻击时，无用\n\n#### 验证码\n\n### xss和csrf\n- 通常来说csrf是由xss引起的\n- xss是代码注入问题，csrf是http问题\n\n### 同源策略\n同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。\n\n不受同源策略限制的：\n- 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。\n- 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script标签的src属性、img标签、link标签、iframe标签等。\n- 通过标签的方式发起的请求不受同源策略的限制。且发送请求时浏览器会携带对应的cookie。\n\n## SQL注入\n### 原理\n通过传入一些特殊字符，从而达到欺骗服务器执行恶意的SQL命令的目的。\n\n如输入特殊的用户名\n\n```\n//理想中的输入：admin  password\nSELECT * FROM user WHERE username='admin' AND psw='password'\n\n//特殊用户名：admin' --\nSELECT * FROM user WHERE username='admin' --' AND psw='xxxx'\n//在SQL中，--是注释后面的内容的意思\n```\n\n### 防御\n- 严格限制web应用的数据库的操作权限。\n- 后端代码检查输入的数据是否符合预期。\n- 对特殊字符进行转义处理。","source":"_posts/其他/安全：XSS和CSRF.md","raw":"---\ntitle: 安全：XSS和CSRF\nDate: 2020-05-14\ntags: [安全]\ncategories: 安全\ncomments: true\n---\n\n## XSS攻击（跨站脚本攻击）\n### 原理\n恶意攻击者往web页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中web里面的脚本代码会被执行，从而达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。\n### 分类\n- 存储型XSS   \n恶意代码存储在数据库中\n- 反射型XSS   \n恶意代码存储在url中\n- DOM型XSS   \n取出和执行恶意代码都是浏览器端完成\n### 防御\n#### 开启CSP\n建立白名单，明确告诉浏览器哪些外部资源可以加载和执行。\n- 设置http header中的Content-Security-Policy\n- 设置meta标签\n```\n<meta http-equiv=\"Content-Security-Policy\">\n```\n\n#### 输入输出过滤\n前端负责，后端也要做相同的过滤检查，因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。\n#### 转义字符\n转义输入输出的内容，对于引号、尖括号、斜杠进行转义。\n\n#### cookie\nweb应用程序在设置cookie时，将其属性设为HttpOnly，这样设置的cookie，js就无法进行读写，就可以预防XSS攻击窃取用户cookie，保护用户cookie信息。\n\n## CSRF攻击（跨站请求伪造）\n### 原理\n攻击者通过一些技术手段欺骗用户的浏览器去訪问一个自己以前认证过的站点并运行一些操作。\n\n利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以这么理解：攻击者盗用了你的身份，以你的名义发送恶意请求。\n\n一般发起攻击的是第三方网站。是利用用户的登录凭证，冒用用户信息，不能获取用户的数据。    \n\nCSRF攻击是源于WEB的隐式身份验证机制。WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。\n\n\n\n### 分类\n- get类型  \n可以将get请求嵌入img标签，打开页面自动发送请求。\n- post类型  \n可以利用自动提交的form表单，访问页面就会自动提交。\n- 链接型  \n需要用户点击链接才会触发。\n### 防御\n#### post\n尽量使用post请求，避免get请求。\n\n#### cookie\n对cookie设置SameSite属性。该属性表示cookie不随跨域请求发送，可以很大程度减少csrf攻击。\n\n#### token\n\n1. 用户访问某个表单页面。\n2. 服务端生成一个Token，放在用户的Session或者浏览器的Cookie中。\n3. 在页面表单附带上Token参数。\n4. 用户发送请求时以参数的形式带上本次页面中生成的token，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。\n> 仅仅用来防御csrf攻击，当加上xss攻击时，无用\n\n#### 验证码\n\n### xss和csrf\n- 通常来说csrf是由xss引起的\n- xss是代码注入问题，csrf是http问题\n\n### 同源策略\n同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。\n\n不受同源策略限制的：\n- 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。\n- 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script标签的src属性、img标签、link标签、iframe标签等。\n- 通过标签的方式发起的请求不受同源策略的限制。且发送请求时浏览器会携带对应的cookie。\n\n## SQL注入\n### 原理\n通过传入一些特殊字符，从而达到欺骗服务器执行恶意的SQL命令的目的。\n\n如输入特殊的用户名\n\n```\n//理想中的输入：admin  password\nSELECT * FROM user WHERE username='admin' AND psw='password'\n\n//特殊用户名：admin' --\nSELECT * FROM user WHERE username='admin' --' AND psw='xxxx'\n//在SQL中，--是注释后面的内容的意思\n```\n\n### 防御\n- 严格限制web应用的数据库的操作权限。\n- 后端代码检查输入的数据是否符合预期。\n- 对特殊字符进行转义处理。","slug":"其他/安全：XSS和CSRF","published":1,"date":"2020-05-14T08:43:40.496Z","updated":"2020-05-14T09:48:39.240Z","layout":"post","photos":[],"link":"","_id":"cka6lc4vg0000aou9smbxcg7f","content":"<h2 id=\"XSS攻击（跨站脚本攻击）\"><a href=\"#XSS攻击（跨站脚本攻击）\" class=\"headerlink\" title=\"XSS攻击（跨站脚本攻击）\"></a>XSS攻击（跨站脚本攻击）</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>恶意攻击者往web页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中web里面的脚本代码会被执行，从而达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>存储型XSS<br>恶意代码存储在数据库中</li>\n<li>反射型XSS<br>恶意代码存储在url中</li>\n<li>DOM型XSS<br>取出和执行恶意代码都是浏览器端完成<h3 id=\"防御\"><a href=\"#防御\" class=\"headerlink\" title=\"防御\"></a>防御</h3><h4 id=\"开启CSP\"><a href=\"#开启CSP\" class=\"headerlink\" title=\"开启CSP\"></a>开启CSP</h4>建立白名单，明确告诉浏览器哪些外部资源可以加载和执行。</li>\n<li>设置http header中的Content-Security-Policy</li>\n<li>设置meta标签<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"输入输出过滤\"><a href=\"#输入输出过滤\" class=\"headerlink\" title=\"输入输出过滤\"></a>输入输出过滤</h4><p>前端负责，后端也要做相同的过滤检查，因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</p>\n<h4 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h4><p>转义输入输出的内容，对于引号、尖括号、斜杠进行转义。</p>\n<h4 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h4><p>web应用程序在设置cookie时，将其属性设为HttpOnly，这样设置的cookie，js就无法进行读写，就可以预防XSS攻击窃取用户cookie，保护用户cookie信息。</p>\n<h2 id=\"CSRF攻击（跨站请求伪造）\"><a href=\"#CSRF攻击（跨站请求伪造）\" class=\"headerlink\" title=\"CSRF攻击（跨站请求伪造）\"></a>CSRF攻击（跨站请求伪造）</h2><h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>攻击者通过一些技术手段欺骗用户的浏览器去訪问一个自己以前认证过的站点并运行一些操作。</p>\n<p>利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以这么理解：攻击者盗用了你的身份，以你的名义发送恶意请求。</p>\n<p>一般发起攻击的是第三方网站。是利用用户的登录凭证，冒用用户信息，不能获取用户的数据。    </p>\n<p>CSRF攻击是源于WEB的隐式身份验证机制。WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。</p>\n<h3 id=\"分类-1\"><a href=\"#分类-1\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>get类型<br>可以将get请求嵌入img标签，打开页面自动发送请求。</li>\n<li>post类型<br>可以利用自动提交的form表单，访问页面就会自动提交。</li>\n<li>链接型<br>需要用户点击链接才会触发。<h3 id=\"防御-1\"><a href=\"#防御-1\" class=\"headerlink\" title=\"防御\"></a>防御</h3><h4 id=\"post\"><a href=\"#post\" class=\"headerlink\" title=\"post\"></a>post</h4>尽量使用post请求，避免get请求。</li>\n</ul>\n<h4 id=\"cookie-1\"><a href=\"#cookie-1\" class=\"headerlink\" title=\"cookie\"></a>cookie</h4><p>对cookie设置SameSite属性。该属性表示cookie不随跨域请求发送，可以很大程度减少csrf攻击。</p>\n<h4 id=\"token\"><a href=\"#token\" class=\"headerlink\" title=\"token\"></a>token</h4><ol>\n<li>用户访问某个表单页面。</li>\n<li>服务端生成一个Token，放在用户的Session或者浏览器的Cookie中。</li>\n<li>在页面表单附带上Token参数。</li>\n<li>用户发送请求时以参数的形式带上本次页面中生成的token，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。<blockquote>\n<p>仅仅用来防御csrf攻击，当加上xss攻击时，无用</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h4><h3 id=\"xss和csrf\"><a href=\"#xss和csrf\" class=\"headerlink\" title=\"xss和csrf\"></a>xss和csrf</h3><ul>\n<li>通常来说csrf是由xss引起的</li>\n<li>xss是代码注入问题，csrf是http问题</li>\n</ul>\n<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。</p>\n<p>不受同源策略限制的：</p>\n<ul>\n<li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的。</li>\n<li>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script标签的src属性、img标签、link标签、iframe标签等。</li>\n<li>通过标签的方式发起的请求不受同源策略的限制。且发送请求时浏览器会携带对应的cookie。</li>\n</ul>\n<h2 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h2><h3 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>通过传入一些特殊字符，从而达到欺骗服务器执行恶意的SQL命令的目的。</p>\n<p>如输入特殊的用户名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//理想中的输入：admin  password</span><br><span class=\"line\">SELECT * FROM user WHERE username=&apos;admin&apos; AND psw=&apos;password&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">//特殊用户名：admin&apos; --</span><br><span class=\"line\">SELECT * FROM user WHERE username=&apos;admin&apos; --&apos; AND psw=&apos;xxxx&apos;</span><br><span class=\"line\">//在SQL中，--是注释后面的内容的意思</span><br></pre></td></tr></table></figure>\n<h3 id=\"防御-2\"><a href=\"#防御-2\" class=\"headerlink\" title=\"防御\"></a>防御</h3><ul>\n<li>严格限制web应用的数据库的操作权限。</li>\n<li>后端代码检查输入的数据是否符合预期。</li>\n<li>对特殊字符进行转义处理。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"XSS攻击（跨站脚本攻击）\"><a href=\"#XSS攻击（跨站脚本攻击）\" class=\"headerlink\" title=\"XSS攻击（跨站脚本攻击）\"></a>XSS攻击（跨站脚本攻击）</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>恶意攻击者往web页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中web里面的脚本代码会被执行，从而达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>存储型XSS<br>恶意代码存储在数据库中</li>\n<li>反射型XSS<br>恶意代码存储在url中</li>\n<li>DOM型XSS<br>取出和执行恶意代码都是浏览器端完成<h3 id=\"防御\"><a href=\"#防御\" class=\"headerlink\" title=\"防御\"></a>防御</h3><h4 id=\"开启CSP\"><a href=\"#开启CSP\" class=\"headerlink\" title=\"开启CSP\"></a>开启CSP</h4>建立白名单，明确告诉浏览器哪些外部资源可以加载和执行。</li>\n<li>设置http header中的Content-Security-Policy</li>\n<li>设置meta标签<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"输入输出过滤\"><a href=\"#输入输出过滤\" class=\"headerlink\" title=\"输入输出过滤\"></a>输入输出过滤</h4><p>前端负责，后端也要做相同的过滤检查，因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</p>\n<h4 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h4><p>转义输入输出的内容，对于引号、尖括号、斜杠进行转义。</p>\n<h4 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h4><p>web应用程序在设置cookie时，将其属性设为HttpOnly，这样设置的cookie，js就无法进行读写，就可以预防XSS攻击窃取用户cookie，保护用户cookie信息。</p>\n<h2 id=\"CSRF攻击（跨站请求伪造）\"><a href=\"#CSRF攻击（跨站请求伪造）\" class=\"headerlink\" title=\"CSRF攻击（跨站请求伪造）\"></a>CSRF攻击（跨站请求伪造）</h2><h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>攻击者通过一些技术手段欺骗用户的浏览器去訪问一个自己以前认证过的站点并运行一些操作。</p>\n<p>利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以这么理解：攻击者盗用了你的身份，以你的名义发送恶意请求。</p>\n<p>一般发起攻击的是第三方网站。是利用用户的登录凭证，冒用用户信息，不能获取用户的数据。    </p>\n<p>CSRF攻击是源于WEB的隐式身份验证机制。WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。</p>\n<h3 id=\"分类-1\"><a href=\"#分类-1\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>get类型<br>可以将get请求嵌入img标签，打开页面自动发送请求。</li>\n<li>post类型<br>可以利用自动提交的form表单，访问页面就会自动提交。</li>\n<li>链接型<br>需要用户点击链接才会触发。<h3 id=\"防御-1\"><a href=\"#防御-1\" class=\"headerlink\" title=\"防御\"></a>防御</h3><h4 id=\"post\"><a href=\"#post\" class=\"headerlink\" title=\"post\"></a>post</h4>尽量使用post请求，避免get请求。</li>\n</ul>\n<h4 id=\"cookie-1\"><a href=\"#cookie-1\" class=\"headerlink\" title=\"cookie\"></a>cookie</h4><p>对cookie设置SameSite属性。该属性表示cookie不随跨域请求发送，可以很大程度减少csrf攻击。</p>\n<h4 id=\"token\"><a href=\"#token\" class=\"headerlink\" title=\"token\"></a>token</h4><ol>\n<li>用户访问某个表单页面。</li>\n<li>服务端生成一个Token，放在用户的Session或者浏览器的Cookie中。</li>\n<li>在页面表单附带上Token参数。</li>\n<li>用户发送请求时以参数的形式带上本次页面中生成的token，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。<blockquote>\n<p>仅仅用来防御csrf攻击，当加上xss攻击时，无用</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h4><h3 id=\"xss和csrf\"><a href=\"#xss和csrf\" class=\"headerlink\" title=\"xss和csrf\"></a>xss和csrf</h3><ul>\n<li>通常来说csrf是由xss引起的</li>\n<li>xss是代码注入问题，csrf是http问题</li>\n</ul>\n<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。</p>\n<p>不受同源策略限制的：</p>\n<ul>\n<li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的。</li>\n<li>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script标签的src属性、img标签、link标签、iframe标签等。</li>\n<li>通过标签的方式发起的请求不受同源策略的限制。且发送请求时浏览器会携带对应的cookie。</li>\n</ul>\n<h2 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h2><h3 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>通过传入一些特殊字符，从而达到欺骗服务器执行恶意的SQL命令的目的。</p>\n<p>如输入特殊的用户名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//理想中的输入：admin  password</span><br><span class=\"line\">SELECT * FROM user WHERE username=&apos;admin&apos; AND psw=&apos;password&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">//特殊用户名：admin&apos; --</span><br><span class=\"line\">SELECT * FROM user WHERE username=&apos;admin&apos; --&apos; AND psw=&apos;xxxx&apos;</span><br><span class=\"line\">//在SQL中，--是注释后面的内容的意思</span><br></pre></td></tr></table></figure>\n<h3 id=\"防御-2\"><a href=\"#防御-2\" class=\"headerlink\" title=\"防御\"></a>防御</h3><ul>\n<li>严格限制web应用的数据库的操作权限。</li>\n<li>后端代码检查输入的数据是否符合预期。</li>\n<li>对特殊字符进行转义处理。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cka6kimwx0008qgu9x5hi91c1","category_id":"cka6kimwn0005qgu9w9j1zmty","_id":"cka6kimxr000gqgu9zhcuf2cm"},{"post_id":"cka6kimw30003qgu91eyuks3u","category_id":"cka6kimwn0005qgu9w9j1zmty","_id":"cka6kimy1000lqgu9rcfx5im1"},{"post_id":"cka6kimwd0004qgu9ha1lp1vh","category_id":"cka6kimwn0005qgu9w9j1zmty","_id":"cka6kimyb000oqgu99n0rb7mm"},{"post_id":"cka6kimwx0007qgu90x9i04jq","category_id":"cka6kimwn0005qgu9w9j1zmty","_id":"cka6kimyl000tqgu9ek8jxq9o"},{"post_id":"cka6kin1d0027qgu9jqw0ow2w","category_id":"cka6kin130021qgu98qmw1jl0","_id":"cka6kin27002tqgu9xe3hpny7"},{"post_id":"cka6kin0t001wqgu9wd1xpye8","category_id":"cka6kin130021qgu98qmw1jl0","_id":"cka6kin2h002wqgu9bcg4gwjk"},{"post_id":"cka6kin1d002aqgu9mqwkausn","category_id":"cka6kin130021qgu98qmw1jl0","_id":"cka6kin2r002zqgu92vneurba"},{"post_id":"cka6kin0t001zqgu9834fiinh","category_id":"cka6kin130021qgu98qmw1jl0","_id":"cka6kin2r0034qgu988zqxloq"},{"post_id":"cka6kin130024qgu9899r15rb","category_id":"cka6kin130021qgu98qmw1jl0","_id":"cka6kin310037qgu9zm6mh4c6"},{"post_id":"cka6kin1n002fqgu984mee98y","category_id":"cka6kin27002rqgu9rau830xe","_id":"cka6kin31003cqgu9eq7fyx79"},{"post_id":"cka6kin1n002iqgu9mk4ly2et","category_id":"cka6kin27002rqgu9rau830xe","_id":"cka6kin3b003eqgu9upf8as6o"},{"post_id":"cka6kin1x002nqgu9a4j9m651","category_id":"cka6kin310038qgu9mawsunca","_id":"cka6kin3l003lqgu9zdnqbqgp"},{"post_id":"cka6kin27002qqgu9w4aglbod","category_id":"cka6kin310038qgu9mawsunca","_id":"cka6kin3v003rqgu9vfqb2ehn"},{"post_id":"cka6kin27002vqgu9xyz252fk","category_id":"cka6kin310038qgu9mawsunca","_id":"cka6kin45003xqgu98vt5oi3q"},{"post_id":"cka6kin2h002yqgu9uv15gu9f","category_id":"cka6kin310038qgu9mawsunca","_id":"cka6kin4f0042qgu98q5e6k67"},{"post_id":"cka6kin2r0033qgu9tzwsmzvz","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin4z0049qgu9vyr9ujus"},{"post_id":"cka6kin310036qgu96rdir78u","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin59004fqgu99mikqb40"},{"post_id":"cka6kin31003aqgu9t512cwh9","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin5j004lqgu9xx84xj5u"},{"post_id":"cka6kin3b003dqgu9gx4pf8ht","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin5t004rqgu9znc1bmak"},{"post_id":"cka6kin3b003hqgu96gfhm3x2","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin63004xqgu9szmcdz4z"},{"post_id":"cka6kin3l003jqgu9m6efo7lk","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin6n0053qgu9sb28m3f3"},{"post_id":"cka6kin3l003nqgu9k51v12u9","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin6x0059qgu9xhzchpek"},{"post_id":"cka6kin3v003pqgu9kovnfter","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin77005fqgu9s9hbuy5k"},{"post_id":"cka6kin3v003tqgu9uwh91egm","category_id":"cka6kin45003wqgu94v49vmur","_id":"cka6kin7h005kqgu9u2620e75"},{"post_id":"cka6kinb3007lqgu9ocyej3k7","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinjq00cbqgu9s1roq838"},{"post_id":"cka6kinbd007oqgu9mu1klvxb","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinjw00cfqgu9glbzhobg"},{"post_id":"cka6kinbn007tqgu90anit00c","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kink000cjqgu9m8zrkvu1"},{"post_id":"cka6kinbn007wqgu9j5fvok95","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kink400cnqgu9agjnoysf"},{"post_id":"cka6kinbx0081qgu94ymcmb5g","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kink900crqgu9r2lbfpi0"},{"post_id":"cka6kinc70084qgu9x3zw1mlq","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinkf00cvqgu924dy807d"},{"post_id":"cka6kinch0088qgu9al82lcll","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinkn00czqgu9hbu4y4di"},{"post_id":"cka6kinch008bqgu95s187h9b","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinks00d3qgu9e582dqqf"},{"post_id":"cka6kincr008fqgu9zmxg9gpq","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinky00d7qgu9ta5jdbm9"},{"post_id":"cka6kincr008hqgu9g54116d7","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinl400dbqgu9fog9gmxs"},{"post_id":"cka6kindb008lqgu9do7gq2jr","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinl800dfqgu973a6r54c"},{"post_id":"cka6kindb008nqgu9bdgeolrh","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinld00djqgu9rfc2bhns"},{"post_id":"cka6kindl008rqgu9hxfrv7jm","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinlh00dnqgu980rrnllq"},{"post_id":"cka6kindl008tqgu9aphe7lst","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinll00drqgu9umvcud24"},{"post_id":"cka6kindv008xqgu91kjzyuaf","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinlq00dvqgu9jn1tl1hj"},{"post_id":"cka6kindv008zqgu96v7g2y34","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinls00dyqgu9pqvehykb"},{"post_id":"cka6kine50093qgu9tght9bwi","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinlx00e3qgu99ufvalfu"},{"post_id":"cka6kine50095qgu9qp2ayzpu","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinm200e7qgu99870rz2r"},{"post_id":"cka6kinef0099qgu9nun9p5cl","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinm700ebqgu9s9bwezqw"},{"post_id":"cka6kinef009bqgu93lvwxt9t","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinmb00efqgu93of49wia"},{"post_id":"cka6kines009fqgu9bh9gadmh","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinmi00ejqgu9flfmfjio"},{"post_id":"cka6kinex009hqgu9cp365ewb","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinmo00enqgu9rpqb5bw9"},{"post_id":"cka6kinf4009lqgu9527rzd70","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinmu00erqgu98tsq07wc"},{"post_id":"cka6kinfa009nqgu99ou97fqf","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinmz00evqgu9m1veri66"},{"post_id":"cka6kinfh009rqgu9b6j7delb","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinn300ezqgu9bprirxwc"},{"post_id":"cka6kinfo009tqgu9ytdqn7v3","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinn800f3qgu9pl29ojqv"},{"post_id":"cka6kinfv009xqgu917ykgk69","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinnd00f7qgu9lw6hkmyt"},{"post_id":"cka6king1009zqgu9juxmw86r","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinni00fbqgu948rbap1a"},{"post_id":"cka6kingc00a3qgu91skbs184","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinnn00ffqgu9bmyu8eps"},{"post_id":"cka6kingj00a5qgu9r9uub0bl","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinns00fjqgu94vth08nw"},{"post_id":"cka6kingq00a9qgu9kn50g6nw","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinnu00fmqgu9q8xuf7ig"},{"post_id":"cka6kinh700afqgu9q9yxnf6s","category_id":"cka6kinnr00fiqgu9lp1mza8n","_id":"cka6kino000frqgu9ljb3f9wp"},{"post_id":"cka6kinhe00ahqgu92nwxhpsq","category_id":"cka6kinnr00fiqgu9lp1mza8n","_id":"cka6kino400fvqgu9xojopkc1"},{"post_id":"cka6kinhk00alqgu9unavh6g1","category_id":"cka6kinnr00fiqgu9lp1mza8n","_id":"cka6kinoa00fzqgu9ynvj4ige"},{"post_id":"cka6kinhp00anqgu9p1dkzbph","category_id":"cka6kinnr00fiqgu9lp1mza8n","_id":"cka6kinof00g3qgu9dld73j06"},{"post_id":"cka6kinhu00arqgu9qpsc5fgg","category_id":"cka6kinnr00fiqgu9lp1mza8n","_id":"cka6kinok00g7qgu9u7iu3ef0"},{"post_id":"cka6kinhy00atqgu9c5m67xz8","category_id":"cka6kinnr00fiqgu9lp1mza8n","_id":"cka6kinon00gaqgu9vwugfq1f"},{"post_id":"cka6kini300axqgu9o8oanl30","category_id":"cka6kinlp00duqgu94t80ui9k","_id":"cka6kinop00gcqgu9y3rmmqwe"},{"post_id":"cka6kint700gdqgu9i5q4jh2j","category_id":"cka6kin310038qgu9mawsunca","_id":"cka6kints00gjqgu9zizdb56r"},{"post_id":"cka6kintj00geqgu94skhk41g","category_id":"cka6kin310038qgu9mawsunca","_id":"cka6kints00glqgu948rnsrkh"},{"post_id":"cka6kints00giqgu96qgzu3ni","category_id":"cka6kinjg00c2qgu9dlre4cqm","_id":"cka6kinu200goqgu9xf88cjaq"},{"post_id":"cka6kinum00gpqgu9op48q2b5","category_id":"cka6kin130021qgu98qmw1jl0","_id":"cka6kinuw00grqgu9v13yxzxd"},{"post_id":"cka6kwrv90000rcu9hf3j45ld","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrwi0006rcu9xtzt4a1q"},{"post_id":"cka6kwrvt0001rcu9h09hdvay","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrwo0009rcu9e2mte9bu"},{"post_id":"cka6kwrw30003rcu9kudp9l4z","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrwv000crcu9fqwou9uh"},{"post_id":"cka6kwrwf0005rcu9rjpulhzz","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrwz000frcu9wpld5q0n"},{"post_id":"cka6kwrwl0008rcu9vepujkpy","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrx7000ircu9be9bj6hi"},{"post_id":"cka6kwrws000brcu9vaknvw7y","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrxd000lrcu90d19gkir"},{"post_id":"cka6kwrwx000ercu968d0wm3x","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrxj000orcu9owvlpv6s"},{"post_id":"cka6kwrx4000hrcu9skvmwdhp","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrxq000rrcu9vlxu6oiq"},{"post_id":"cka6kwrx9000krcu9s9laxdgg","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrxw000urcu94cjtf87v"},{"post_id":"cka6kwrxf000nrcu9p09lv1tj","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwry1000xrcu97ha3glkr"},{"post_id":"cka6kwrxn000qrcu9kqyqx9cg","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwry60010rcu9finx97k8"},{"post_id":"cka6kwrxt000trcu95mcy43fn","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwryb0013rcu94l6ac6gx"},{"post_id":"cka6kwrxy000wrcu9glxtuzoe","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwryf0016rcu92vjtlcaz"},{"post_id":"cka6kwry3000zrcu9jc7z4lpo","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwryk0019rcu9n91vnydg"},{"post_id":"cka6kwry80012rcu92zp7xnu5","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwryt001crcu92fckv1qm"},{"post_id":"cka6kwryd0015rcu9bphv7cim","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrz4001frcu95m0479yr"},{"post_id":"cka6kwryh0018rcu9rpfjw3cl","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kwrzb001ircu9b5fetgvt"},{"post_id":"cka6kwryn001brcu9ztcjkumw","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kwrzi001lrcu9egjiho28"},{"post_id":"cka6kwryw001ercu9thdzy3u4","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kwrzo001orcu9i9tabv51"},{"post_id":"cka6kwrz8001hrcu9t1e3ulqt","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kwrzu001rrcu96nmzsemj"},{"post_id":"cka6kwrze001krcu98w3wbfma","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws00001urcu9hacsd4mq"},{"post_id":"cka6kwrzl001nrcu95omam0eh","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws05001xrcu9k3bv286g"},{"post_id":"cka6kwrzr001qrcu9ms5pfjrn","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws0c0020rcu9sr9re4bi"},{"post_id":"cka6kwrzx001trcu9fe8evzax","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws0i0023rcu9uale0tw6"},{"post_id":"cka6kws03001wrcu97qxqpv18","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws0m0026rcu9yr9mq4rh"},{"post_id":"cka6kws09001zrcu9p0ui6t8z","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws0r0029rcu93ku9k65d"},{"post_id":"cka6kws0f0022rcu9brhk4y9l","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws0w002crcu95mvqkksn"},{"post_id":"cka6kws0k0025rcu9qs7rb0kc","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws11002frcu96f3yfxzr"},{"post_id":"cka6kws0o0028rcu92xbebtg8","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws16002ircu9jya24ce0"},{"post_id":"cka6kws0t002brcu9y7p4kp76","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws1h002lrcu9ouwstbhu"},{"post_id":"cka6kws0y002ercu9dmfo774y","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws1n002orcu9zcfzhblc"},{"post_id":"cka6kws14002hrcu9lpta6z98","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws1t002rrcu93hwcom4m"},{"post_id":"cka6kws19002krcu9ohfimjv4","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws1y002urcu9ql3h23uk"},{"post_id":"cka6kws1k002nrcu9ui7uukie","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws25002xrcu9qyke2vri"},{"post_id":"cka6kws1q002qrcu9mxx4rdnj","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws2b0030rcu9odspdtnr"},{"post_id":"cka6kws1v002trcu9dvu2yd0d","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws2g0033rcu9nqy8d33s"},{"post_id":"cka6kws21002wrcu9ho090rff","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws2l0036rcu9wm3f62k6"},{"post_id":"cka6kws27002zrcu9guflfcsy","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws2q0039rcu9rpcox6pr"},{"post_id":"cka6kws2d0032rcu9g0zn65lk","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws2w003crcu9eo04zki9"},{"post_id":"cka6kws2i0035rcu9ad44lkyt","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws31003frcu99djtmksi"},{"post_id":"cka6kws2o0038rcu90w41kh3q","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws35003ircu9fftr2uyz"},{"post_id":"cka6kws2t003brcu9qh0u6m40","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws39003lrcu9jblzxk97"},{"post_id":"cka6kws2y003ercu97b25wgou","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws3d003orcu9sira2w1q"},{"post_id":"cka6kws33003hrcu9f1h74kj8","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws3l003rrcu99pr3j3ej"},{"post_id":"cka6kws37003krcu907xb9oy3","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws3q003urcu9cntl9raj"},{"post_id":"cka6kws3b003nrcu9td4zqufo","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws3w003xrcu90xryg5dq"},{"post_id":"cka6kws3i003qrcu93m2mvy56","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws410040rcu9hrkyjtl3"},{"post_id":"cka6kws3n003trcu9leszlppo","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws450043rcu9tys8mb7f"},{"post_id":"cka6kws3s003wrcu9cz7lf2dx","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws490046rcu9k6673xhs"},{"post_id":"cka6kws3y003zrcu9fw0qexyc","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws4e0049rcu9ti4enzpo"},{"post_id":"cka6kws430042rcu9m5z0akyi","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws4g004brcu9syr9sa27"},{"post_id":"cka6kws470045rcu93azdmpf3","category_id":"cka6kinaj0075qgu9eb32y32k","_id":"cka6kws4i004drcu9b3tarf8t"},{"post_id":"cka6kws4b0048rcu9hnpxwd77","category_id":"cka6kimyb000nqgu96kf3ebw5","_id":"cka6kws4j004ercu9q10acg4c"},{"post_id":"cka6l2e2n0000c0u9pf87lrpm","category_id":"cka6kin8b005xqgu9fpj1m5sv","_id":"cka6l2e3n0006c0u9s6nw0bhi"},{"post_id":"cka6l2e320001c0u90c7eqrg9","category_id":"cka6kin77005eqgu92rregwei","_id":"cka6l2e3t0009c0u9i6miff37"},{"post_id":"cka6l2e3b0003c0u9ox8n2twx","category_id":"cka6kin77005eqgu92rregwei","_id":"cka6l2e41000cc0u9kwq4b9er"},{"post_id":"cka6l2e3j0005c0u9mw3m0r8x","category_id":"cka6kin8b005xqgu9fpj1m5sv","_id":"cka6l2e4a000fc0u99adp9fr7"},{"post_id":"cka6l2e3p0008c0u9dcjfk1sz","category_id":"cka6kin8v0069qgu9d207njy7","_id":"cka6l2e4f000ic0u94es1e93j"},{"post_id":"cka6l2e3w000bc0u9s8vcoqmr","category_id":"cka6kin9f006mqgu9jake6g4v","_id":"cka6l2e4k000lc0u9f9rgo54h"},{"post_id":"cka6l2e47000ec0u9l6bq50qq","category_id":"cka6kina9006zqgu9ghhapyeb","_id":"cka6l2e4p000oc0u92ox5q7bb"},{"post_id":"cka6l2e4d000hc0u9z6yl0brq","category_id":"cka6kin9z006tqgu9p2r2thtr","_id":"cka6l2e4s000qc0u913r680j1"},{"post_id":"cka6l2e4m000nc0u9yicnqqp5","category_id":"cka6kin77005eqgu92rregwei","_id":"cka6l2e4u000tc0u9effug92z"},{"post_id":"cka6l90240000v8u9yvx19qbh","category_id":"cka6kin95006gqgu9utkiruqn","_id":"cka6l902y0002v8u9flj92tev"},{"post_id":"cka6lc4vg0000aou9smbxcg7f","category_id":"cka6kin95006gqgu9utkiruqn","_id":"cka6lc4w10002aou9gc0iuk8t"}],"PostTag":[{"post_id":"cka6kimwx0008qgu9x5hi91c1","tag_id":"cka6kimwx0006qgu9imsc34k5","_id":"cka6kimxh000cqgu9ptem1i4b"},{"post_id":"cka6kimw30003qgu91eyuks3u","tag_id":"cka6kimwx0006qgu9imsc34k5","_id":"cka6kimxr000eqgu98flk5mty"},{"post_id":"cka6kimwd0004qgu9ha1lp1vh","tag_id":"cka6kimwx0006qgu9imsc34k5","_id":"cka6kimy1000jqgu9l3ewwg06"},{"post_id":"cka6kimwx0007qgu90x9i04jq","tag_id":"cka6kimwx0006qgu9imsc34k5","_id":"cka6kimyb000qqgu9ctzh9beh"},{"post_id":"cka6kin1d0027qgu9jqw0ow2w","tag_id":"cka6kin130022qgu9nbyabwv3","_id":"cka6kin1x002mqgu9jy1dntn6"},{"post_id":"cka6kin0t001wqgu9wd1xpye8","tag_id":"cka6kin130022qgu9nbyabwv3","_id":"cka6kin27002pqgu9ztavfqux"},{"post_id":"cka6kin1d002aqgu9mqwkausn","tag_id":"cka6kin130022qgu9nbyabwv3","_id":"cka6kin27002uqgu9pirf6rbc"},{"post_id":"cka6kin0t001zqgu9834fiinh","tag_id":"cka6kin130022qgu9nbyabwv3","_id":"cka6kin2h002xqgu9z85ucst3"},{"post_id":"cka6kin130024qgu9899r15rb","tag_id":"cka6kin130022qgu9nbyabwv3","_id":"cka6kin2r0032qgu9bxrqkqef"},{"post_id":"cka6kin1n002fqgu984mee98y","tag_id":"cka6kin27002sqgu9jybavlud","_id":"cka6kin2r0035qgu9ecw4nq2j"},{"post_id":"cka6kin1n002iqgu9mk4ly2et","tag_id":"cka6kin27002sqgu9jybavlud","_id":"cka6kin31003bqgu95rduw3xa"},{"post_id":"cka6kin1x002nqgu9a4j9m651","tag_id":"cka6kin310039qgu9ecrwl45q","_id":"cka6kin3b003iqgu9oe1xcv6i"},{"post_id":"cka6kin27002qqgu9w4aglbod","tag_id":"cka6kin310039qgu9ecrwl45q","_id":"cka6kin3v003oqgu9q6xx5kdo"},{"post_id":"cka6kin27002vqgu9xyz252fk","tag_id":"cka6kin310039qgu9ecrwl45q","_id":"cka6kin45003uqgu93p976vm8"},{"post_id":"cka6kin2h002yqgu9uv15gu9f","tag_id":"cka6kin310039qgu9ecrwl45q","_id":"cka6kin4f0040qgu9g580i0qn"},{"post_id":"cka6kin2r0033qgu9tzwsmzvz","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin4p0046qgu9uhc0eicy"},{"post_id":"cka6kin310036qgu96rdir78u","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin4z004cqgu92llex66q"},{"post_id":"cka6kin31003aqgu9t512cwh9","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin5j004iqgu90gb0sdrr"},{"post_id":"cka6kin3b003dqgu9gx4pf8ht","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin5t004oqgu9dnil62w5"},{"post_id":"cka6kin3b003hqgu96gfhm3x2","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin63004uqgu96b68eiic"},{"post_id":"cka6kin3l003jqgu9m6efo7lk","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin6d0050qgu9alxig5zh"},{"post_id":"cka6kin3l003nqgu9k51v12u9","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin6n0056qgu9xeq7ojq0"},{"post_id":"cka6kin3v003pqgu9kovnfter","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin77005cqgu995erflkc"},{"post_id":"cka6kin3v003tqgu9uwh91egm","tag_id":"cka6kin45003yqgu9gbzdpn7b","_id":"cka6kin7h005iqgu94r25m87d"},{"post_id":"cka6kinb3007lqgu9ocyej3k7","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinjo00c9qgu9bko6bhil"},{"post_id":"cka6kinbd007oqgu9mu1klvxb","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinjt00cdqgu93txxx6mo"},{"post_id":"cka6kinbn007tqgu90anit00c","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinjy00chqgu93w3kywgn"},{"post_id":"cka6kinbn007wqgu9j5fvok95","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kink200clqgu9vzdptri9"},{"post_id":"cka6kinbx0081qgu94ymcmb5g","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kink700cpqgu9u2rd6cfs"},{"post_id":"cka6kinc70084qgu9x3zw1mlq","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinkb00ctqgu9p4hzd17f"},{"post_id":"cka6kinch0088qgu9al82lcll","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinki00cxqgu9rzpkws1e"},{"post_id":"cka6kinch008bqgu95s187h9b","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinkq00d1qgu94e36xt5u"},{"post_id":"cka6kincr008fqgu9zmxg9gpq","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinkw00d5qgu9ad60c5wu"},{"post_id":"cka6kincr008hqgu9g54116d7","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinl100d9qgu940ka78qc"},{"post_id":"cka6kindb008lqgu9do7gq2jr","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinl600ddqgu970nfbfye"},{"post_id":"cka6kindb008nqgu9bdgeolrh","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinlb00dhqgu9dciebjho"},{"post_id":"cka6kindl008rqgu9hxfrv7jm","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinlf00dlqgu9wpkl1m4k"},{"post_id":"cka6kindl008tqgu9aphe7lst","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinlk00dpqgu9nkwqqj3w"},{"post_id":"cka6kindv008xqgu91kjzyuaf","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinlo00dtqgu99ozw6b06"},{"post_id":"cka6kindv008zqgu96v7g2y34","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kinls00dxqgu9vzbgkhi7"},{"post_id":"cka6kine50093qgu9tght9bwi","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinlv00e1qgu929t7po8d"},{"post_id":"cka6kine50095qgu9qp2ayzpu","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinm000e5qgu9sr0pi3gc"},{"post_id":"cka6kinef0099qgu9nun9p5cl","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinm400e9qgu9ue8j1w4b"},{"post_id":"cka6kinef009bqgu93lvwxt9t","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinm900edqgu9oenbw0tn"},{"post_id":"cka6kines009fqgu9bh9gadmh","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinmg00ehqgu98d6lg63b"},{"post_id":"cka6kinex009hqgu9cp365ewb","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinml00elqgu92k25dpsh"},{"post_id":"cka6kinf4009lqgu9527rzd70","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinmr00epqgu9zxl1nf2g"},{"post_id":"cka6kinfa009nqgu99ou97fqf","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinmx00etqgu9vsduqd1o"},{"post_id":"cka6kinfh009rqgu9b6j7delb","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinn100exqgu94vjas6jc"},{"post_id":"cka6kinfo009tqgu9ytdqn7v3","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinn600f1qgu9v283sb5x"},{"post_id":"cka6kinfv009xqgu917ykgk69","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinnb00f5qgu9jj916ni9"},{"post_id":"cka6king1009zqgu9juxmw86r","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinng00f9qgu98kyqcjzp"},{"post_id":"cka6kingc00a3qgu91skbs184","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinnk00fdqgu9gstqo1qn"},{"post_id":"cka6kingj00a5qgu9r9uub0bl","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinnq00fhqgu9v0xszqh8"},{"post_id":"cka6kingq00a9qgu9kn50g6nw","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinnt00flqgu9thcb94f6"},{"post_id":"cka6kinh700afqgu9q9yxnf6s","tag_id":"cka6kinns00fkqgu9srrb5emv","_id":"cka6kinny00fpqgu9wnt8yjmf"},{"post_id":"cka6kinhe00ahqgu92nwxhpsq","tag_id":"cka6kinns00fkqgu9srrb5emv","_id":"cka6kino200ftqgu98gtlw9xr"},{"post_id":"cka6kinhk00alqgu9unavh6g1","tag_id":"cka6kinns00fkqgu9srrb5emv","_id":"cka6kino800fxqgu9px9rka5b"},{"post_id":"cka6kinhp00anqgu9p1dkzbph","tag_id":"cka6kinns00fkqgu9srrb5emv","_id":"cka6kinod00g1qgu9zmulv1mv"},{"post_id":"cka6kinhu00arqgu9qpsc5fgg","tag_id":"cka6kinns00fkqgu9srrb5emv","_id":"cka6kinoi00g5qgu9b7whyrqz"},{"post_id":"cka6kinhy00atqgu9c5m67xz8","tag_id":"cka6kinns00fkqgu9srrb5emv","_id":"cka6kinom00g9qgu918o812c1"},{"post_id":"cka6kini300axqgu9o8oanl30","tag_id":"cka6kinlr00dwqgu9tz6cot88","_id":"cka6kinoo00gbqgu9hicllbi6"},{"post_id":"cka6kint700gdqgu9i5q4jh2j","tag_id":"cka6kin310039qgu9ecrwl45q","_id":"cka6kintp00gfqgu9b5ht06qm"},{"post_id":"cka6kintj00geqgu94skhk41g","tag_id":"cka6kin310039qgu9ecrwl45q","_id":"cka6kints00ghqgu9x6je3kxg"},{"post_id":"cka6kints00giqgu96qgzu3ni","tag_id":"cka6kinjh00c4qgu9xkk39p8s","_id":"cka6kints00gmqgu9puexth9m"},{"post_id":"cka6kinum00gpqgu9op48q2b5","tag_id":"cka6kin130022qgu9nbyabwv3","_id":"cka6kinuw00gqqgu922cxdadz"},{"post_id":"cka6kwrv90000rcu9hf3j45ld","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrw30002rcu9grvsg7m4"},{"post_id":"cka6kwrvt0001rcu9h09hdvay","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrw30004rcu9nucd3kh9"},{"post_id":"cka6kwrw30003rcu9kudp9l4z","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrwk0007rcu9axs5wwkc"},{"post_id":"cka6kwrwf0005rcu9rjpulhzz","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrwq000arcu9jio8vkx1"},{"post_id":"cka6kwrwl0008rcu9vepujkpy","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrww000drcu90rgx4q5y"},{"post_id":"cka6kwrws000brcu9vaknvw7y","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrx3000grcu9r2phty3l"},{"post_id":"cka6kwrwx000ercu968d0wm3x","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrx8000jrcu97gbo0ldb"},{"post_id":"cka6kwrx4000hrcu9skvmwdhp","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrxe000mrcu96rzip5gv"},{"post_id":"cka6kwrx9000krcu9s9laxdgg","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrxm000prcu90rb80ulb"},{"post_id":"cka6kwrxf000nrcu9p09lv1tj","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrxs000srcu9lhqplf35"},{"post_id":"cka6kwrxn000qrcu9kqyqx9cg","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrxx000vrcu94pcwznha"},{"post_id":"cka6kwrxt000trcu95mcy43fn","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwry2000yrcu9fdfw36xl"},{"post_id":"cka6kwrxy000wrcu9glxtuzoe","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwry80011rcu9hjinzgpb"},{"post_id":"cka6kwry3000zrcu9jc7z4lpo","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwryc0014rcu93xumzj1a"},{"post_id":"cka6kwry80012rcu92zp7xnu5","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwryh0017rcu9r5az1glz"},{"post_id":"cka6kwryd0015rcu9bphv7cim","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwrym001arcu9hanfua2d"},{"post_id":"cka6kwryh0018rcu9rpfjw3cl","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kwryu001drcu9ljm03bsc"},{"post_id":"cka6kwryn001brcu9ztcjkumw","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kwrz6001grcu9pun9nxkm"},{"post_id":"cka6kwryw001ercu9thdzy3u4","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kwrzd001jrcu9sq5oubey"},{"post_id":"cka6kwrz8001hrcu9t1e3ulqt","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kwrzk001mrcu92q22qool"},{"post_id":"cka6kwrze001krcu98w3wbfma","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kwrzq001prcu933cum96r"},{"post_id":"cka6kwrzl001nrcu95omam0eh","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kwrzw001srcu923xo4uep"},{"post_id":"cka6kwrzr001qrcu9ms5pfjrn","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws02001vrcu9gy8xpftx"},{"post_id":"cka6kwrzx001trcu9fe8evzax","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws08001yrcu9y8topv21"},{"post_id":"cka6kws03001wrcu97qxqpv18","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws0e0021rcu9k9fcyoxo"},{"post_id":"cka6kws09001zrcu9p0ui6t8z","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws0j0024rcu9x8r84dea"},{"post_id":"cka6kws0f0022rcu9brhk4y9l","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws0n0027rcu9c6tdt86t"},{"post_id":"cka6kws0k0025rcu9qs7rb0kc","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws0t002arcu9nroo4azn"},{"post_id":"cka6kws0o0028rcu92xbebtg8","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws0x002drcu9j0vp2qnp"},{"post_id":"cka6kws0t002brcu9y7p4kp76","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws13002grcu9x7etjpvk"},{"post_id":"cka6kws0y002ercu9dmfo774y","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws18002jrcu9pd05m6ac"},{"post_id":"cka6kws14002hrcu9lpta6z98","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws1j002mrcu9xctitiau"},{"post_id":"cka6kws19002krcu9ohfimjv4","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws1p002prcu9pnpf8m2y"},{"post_id":"cka6kws1k002nrcu9ui7uukie","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws1v002srcu9kg4t3tdq"},{"post_id":"cka6kws1q002qrcu9mxx4rdnj","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws20002vrcu92cafy4a9"},{"post_id":"cka6kws1v002trcu9dvu2yd0d","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws27002yrcu94cg0xurk"},{"post_id":"cka6kws21002wrcu9ho090rff","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws2c0031rcu9y8l2kbyf"},{"post_id":"cka6kws27002zrcu9guflfcsy","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws2i0034rcu9zo4ej26q"},{"post_id":"cka6kws2d0032rcu9g0zn65lk","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws2n0037rcu9u5wgc0t5"},{"post_id":"cka6kws2i0035rcu9ad44lkyt","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws2s003arcu9tum7axq9"},{"post_id":"cka6kws2o0038rcu90w41kh3q","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws2x003drcu9hcnobj6w"},{"post_id":"cka6kws2t003brcu9qh0u6m40","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws32003grcu9nnvbvksq"},{"post_id":"cka6kws2y003ercu97b25wgou","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws36003jrcu9bq0wlkdl"},{"post_id":"cka6kws33003hrcu9f1h74kj8","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws3a003mrcu9y0sbg9oa"},{"post_id":"cka6kws37003krcu907xb9oy3","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws3h003prcu9mh8esuek"},{"post_id":"cka6kws3b003nrcu9td4zqufo","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws3m003srcu9gailqwho"},{"post_id":"cka6kws3i003qrcu93m2mvy56","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws3r003vrcu9u733ys00"},{"post_id":"cka6kws3n003trcu9leszlppo","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws3x003yrcu9dz3xrw9r"},{"post_id":"cka6kws3s003wrcu9cz7lf2dx","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws420041rcu9agud26pn"},{"post_id":"cka6kws3y003zrcu9fw0qexyc","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws460044rcu9rppcymr2"},{"post_id":"cka6kws430042rcu9m5z0akyi","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws4a0047rcu97alomp14"},{"post_id":"cka6kws470045rcu93azdmpf3","tag_id":"cka6kinaj0076qgu9ec4ajnax","_id":"cka6kws4f004arcu992pwdcgm"},{"post_id":"cka6kws4b0048rcu9hnpxwd77","tag_id":"cka6kimyb000pqgu90qvwu16c","_id":"cka6kws4h004crcu9h6bc6nl4"},{"post_id":"cka6l2e2n0000c0u9pf87lrpm","tag_id":"cka6kin8b005zqgu9hwsizxnp","_id":"cka6l2e3a0002c0u9sr661gi3"},{"post_id":"cka6l2e320001c0u90c7eqrg9","tag_id":"cka6kin77005gqgu96561psjz","_id":"cka6l2e3g0004c0u9y4275bbr"},{"post_id":"cka6l2e3b0003c0u9ox8n2twx","tag_id":"cka6kin77005gqgu96561psjz","_id":"cka6l2e3p0007c0u9qlye6pdn"},{"post_id":"cka6l2e3j0005c0u9mw3m0r8x","tag_id":"cka6kin8b005zqgu9hwsizxnp","_id":"cka6l2e3v000ac0u9fusz664k"},{"post_id":"cka6l2e3p0008c0u9dcjfk1sz","tag_id":"cka6kin95006bqgu9iysyvdm4","_id":"cka6l2e46000dc0u9aw1ywhly"},{"post_id":"cka6l2e3w000bc0u9s8vcoqmr","tag_id":"cka6kin9p006nqgu9mgbngm75","_id":"cka6l2e4c000gc0u96tts2h6l"},{"post_id":"cka6l2e47000ec0u9l6bq50qq","tag_id":"cka6kina90070qgu9egtwn42t","_id":"cka6l2e4h000jc0u9x3uzg1w6"},{"post_id":"cka6l2e4d000hc0u9z6yl0brq","tag_id":"cka6kin9z006uqgu9719zku2s","_id":"cka6l2e4m000mc0u9l2xxj5bc"},{"post_id":"cka6l2e4m000nc0u9yicnqqp5","tag_id":"cka6kin77005gqgu96561psjz","_id":"cka6l2e4t000rc0u99g1tklh0"},{"post_id":"cka6l90240000v8u9yvx19qbh","tag_id":"cka6kin9f006hqgu9vif0a4ya","_id":"cka6l902o0001v8u9yqz7rxyo"},{"post_id":"cka6lc4vg0000aou9smbxcg7f","tag_id":"cka6kin9f006hqgu9vif0a4ya","_id":"cka6lc4vx0001aou9bpkeopty"}],"Tag":[{"name":"ES6","_id":"cka6kimwx0006qgu9imsc34k5"},{"name":"CSS","_id":"cka6kimyb000pqgu90qvwu16c"},{"name":"git","_id":"cka6kin130022qgu9nbyabwv3"},{"name":"npm","_id":"cka6kin27002sqgu9jybavlud"},{"name":"红宝书","_id":"cka6kin310039qgu9ecrwl45q"},{"name":"vue","_id":"cka6kin45003yqgu9gbzdpn7b"},{"name":"Electron","_id":"cka6kin77005gqgu96561psjz"},{"name":"博客搭建","_id":"cka6kin8b005zqgu9hwsizxnp"},{"name":"demo","_id":"cka6kin95006bqgu9iysyvdm4"},{"name":"安全","_id":"cka6kin9f006hqgu9vif0a4ya"},{"name":"操作系统","_id":"cka6kin9p006nqgu9mgbngm75"},{"name":"数据结构","_id":"cka6kin9z006uqgu9719zku2s"},{"name":"数据类型","_id":"cka6kina90070qgu9egtwn42t"},{"name":"JS","_id":"cka6kinaj0076qgu9ec4ajnax"},{"name":"前端","_id":"cka6kinjh00c4qgu9xkk39p8s"},{"name":"算法","_id":"cka6kinlr00dwqgu9tz6cot88"},{"name":"计网","_id":"cka6kinns00fkqgu9srrb5emv"}]}}