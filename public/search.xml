<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cocos creator踩坑记]]></title>
    <url>%2F2022%2F04%2F19%2Fcocos%2Fcocos%20creator%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[动画编辑 动画在普通模式下是不允许编辑的，只有在动画编辑模式下才可以编辑动画文件。 但是在动画编辑模式下，无法对节点进行添加/删除/重命名操作，并且没有记录在动画关键帧内的属性修改，在退出动画编辑器后也会被还原]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：父子组件通信]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[父组件向子组件通信由于react是单向数据流向的，父组件一般通过props向子组件传递相关的一些信息 12345// 父组件&lt;Test visible=&#123;visible&#125; /&gt;// 子组件this.props.visible 子组件向父组件通信父组件向子组件传递方法，子组件可以通过调用方法向父组件传递子组件的参数，或者操作父组件的数据。 12345// 父组件&lt;Test visible=&#123;visible&#125; onCancel=&#123;(visible)=&gt; this.setState(&#123; visible &#125;)/&gt;// 子组件this.props.onCancel(this.state.visible); 跨级组件通信通过context进行通信。 我们可以把组件之间的关系想象成一个组件树，原始的方法就是通过props一级一级的把状态往下传，在通过调用方法一级一级传回去。 另一种方法就是在他们之间设置一个区域，每个组件都可以访问到，相当于父组件下的一个全局变量。 123456789101112131415161718192021222324252627// 最顶部的父组件import PropTypes from &apos;prop-types&apos;;class Index extends Component &#123; static childContextTypes = &#123; themeColor: PropTypes.string &#125; constructor () &#123; super() this.state = &#123; themeColor: &apos;red&apos; &#125; &#125; getChildContext () &#123; return &#123; themeColor: this.state.themeColor &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125; 要在父组件设置这个context区域，在childContextTypes中设置允许子组件们访问的变量的名称，getChildContext（）会设置这个区域，这样所有的子组件都可以访问到themeColor这个参数了 12345678910111213141516// 子组件// 通过在this.context就可以访问import PropTypes from &apos;prop-types&apos;;class Title extends Component &#123; static contextTypes = &#123; themeColor: PropTypes.string &#125; render () &#123; return ( &lt;h1 style=&#123;&#123; color: this.context.themeColor &#125;&#125;&gt;React.js 小书标题&lt;/h1&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：初学react]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9A%E5%88%9D%E5%AD%A6react%2F</url>
    <content type="text"><![CDATA[chrome中的react插件 点击chrome浏览器右上角三个点-更多工具-&gt;扩展程序（或者在浏览器里面直接输入chrome://extensions/也可以进入到扩展程序里面） 点击左上角【扩展程序】-【打开Chrome网上应用店】 搜索React，将会出现一系列与react有关的插件，安装react developer tools插件。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：Antd组件踩坑记]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9AAntd%E7%BB%84%E4%BB%B6%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Form 问题：表单中的Select组件设置value值无效 解决：Select中增加key属性，取值与value值一致 问题：item中无法设置value， 解决：通过initialValues设置 Select 问题：动态设置的Select组件设置defaultValue值无效 解决：Select中增加key属性，取值与defaultValue值一致]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：路由跳转]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9A%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[路由跳转引入依赖1import &#123; withRouter, RouteComponentProps &#125; from &apos;react-router-dom&apos;; 组件继承上面依赖中的路由组件接口123class testPage extends React.Component&lt;RouteComponentProps, &#123;&#125;&gt; &#123; // ...&#125; 如果props有其他参数 123456type Props = RouteComponentProps &amp; &#123; // ...&#125;class testPage extends React.Component&lt;Props, &#123;&#125;&gt; &#123; // ...&#125; 导出使用 withRouter 包装 1export default withRouter(testPage); 如果有引入redux 1export default connect(stateToProps, dispatchToProps)(withRouter(testPage)); 使用123public clickSearch = (value: string) =&gt; &#123; this.props.history.push( &apos;/test/testpage&apos; );&#125; 路由传参路由表配置参数地址栏显示，刷新页面，参数不丢失1&lt;Route path=&quot;/test/testpage/:id&quot; component=&#123; OtherDetail &#125; /&gt; 需要获取参数的页面的类型声明 1234// RouteComponentProps里的参数必须为stringtype Props = RouteComponentProps&lt;&#123; id: string &#125;&gt; &amp; &#123; // ...&#125; 跳转1this.props.history.push( &apos;/test/testpage/2&apos; ); 获取1this.props.match.params.id query方法(新版本已废弃)路由不需要额外配置，参数地址栏不显示，刷新地址栏，参数丢失 跳转123456this.props.history.push(&#123; pathname: &apos;/test/testpage&apos;, query: &#123; id: &apos;0&apos; &#125;&#125;) 获取1this.props.location.query.id search方法（新版本）路由不需要额外配置，参数地址栏显示，刷新地址栏，参数不丢失 跳转12345this.props.history.push(&#123; pathname: &apos;/test/testpage&apos;, search: &apos;?id=1&apos; &#125;) 获取1this.props.location.search state方法路由不需要额外配置，参数地址栏不显示，刷新地址栏，参数不丢失 跳转123456this.props.history.push(&#123; pathname: &apos;/test/testpage&apos;, state: &#123; id: &apos;0&apos; &#125;&#125;) 获取1this.props.location.state.id]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：生命周期]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React的生命周期从广义上分为三个阶段：挂载、渲染、卸载 因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。 之前的生命周期挂载卸载过程 constructor componentWillMount render componentDidMount constructor()constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。 componentWillMount()componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。 componentDidMount()组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染 componentWillUnmount ()在此处完成组件的卸载和数据的销毁。 clear你在组建中所有的setTimeout,setInterval 移除所有组建中的监听 removeEventListener 有时候我们会碰到一个warning。 1234567891011121314原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning解决方法：componentDidMount() &#123; this.isMount === true axios.post().then((res) =&gt; &#123; this.isMount &amp;&amp; this.setState(&#123; // 增加条件ismount为true时 aaa:res &#125;)&#125;)&#125;componentWillUnmount() &#123; this.isMount === false&#125; 更新过程 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate componentWillReceiveProps (nextProps) 在接受父组件改变后的props需要重新渲染组件时用到的比较多 接受一个参数nextProps 通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件 12345678componentWillReceiveProps (nextProps) &#123; nextProps.openNotice !== this.props.openNotice&amp;&amp;this.setState(&#123; openNotice:nextProps.openNotice &#125;，() =&gt; &#123; console.log(this.state.openNotice:nextProps) //将state更新为nextProps,在setState的第二个参数（回调）可以打 印出新的state &#125;)&#125; shouldComponentUpdate(nextProps,nextState) 主要用于性能优化(部分更新) 唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新 因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断 componentWillUpdate (nextProps,nextState)shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。 componentDidUpdate(prevProps,prevState)组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。 render()render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。 React v16.4+ 的生命周期变更 React16废弃的三个生命周期函数 componentWillMount componentWillReceiveProps componentWillUpdate 目前在16版本中componentWillMount，componentWillReceiveProps，componentWillUpdate并未完全删除这三个生命周期函数，而且新增了UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps，UNSAFE_componentWillUpdate三个函数，官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们 取而代之的是两个新的生命周期函数 static getDerivedStateFromProps getSnapshotBeforeUpdate 挂载卸载过程 constructor getDerivedStateFromProps componentWillMount/UNSAVE_componentWillMount render componentDidMount getDerivedStateFromProps1static getDerivedStateFromProps(nextProps, prevState) 一个静态方法，所以不能在这个函数里面使用this，这个函数有两个参数props和state，分别指接收到的新参数和当前的state对象 这个函数会返回一个对象用来更新当前的state对象，如果不需要更新可以返回null 该函数会在挂载时，接收到新的props，调用了setState和forceUpdate时被调用 这个方法就是为了取代之前的componentWillMount、componentWillReceiveProps和componentWillUpdate 当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps 更新过程 componentWillReceiveProps/UNSAFE_componentWillReceiveProps getDerivedStateFromProps shouldComponentUpdate componentWillUpdate/UNSAFE_componentWillUpdate render getSnapshotBeforeUpdate componentDidUpdate getSnapshotBeforeUpdate1getSnapshotBeforeUpdate(prevProps, prevState) 这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state 这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，请返回null，不写的话控制台会有警告 这个方法一定要和componentDidUpdate一起使用，否则控制台也会有警告 这个方法时用来代替componentWillUpdate 参考链接 React的生命周期 我对 React v16.4 生命周期的理解]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：React Hooks]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9AReact%20Hooks%2F</url>
    <content type="text"><![CDATA[组件类的缺点React 的核心是组件。v16.8 版本之前，组件的标准写法是类（class） 12345678910111213141516171819import React, &#123; Component &#125; from &quot;react&quot;;export default class Button extends Component &#123; constructor() &#123; super(); this.state = &#123; buttonText: &quot;Click me, please&quot; &#125;; &#125; handleClick = () =&gt; &#123; this.setState(&#123; buttonText: &quot;Thanks, been clicked!&quot; ; &#125;); &#125; render() &#123; const &#123; buttonText &#125; = this.state; return &lt;button onClick=&#123;this.handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;; &#125;&#125; 这个组件类仅仅是一个按钮，但可以看到，它的代码已经很”重”了。真实的 React App 由多个类按照层级，一层层构成，复杂度成倍增长。再加入 Redux，就变得更复杂。 Redux 的作者 Dan Abramov 总结了组件类的几个缺点: 大型组件很难拆分和重构，也很难测试。 业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。 组件类引入了复杂的编程模式，比如 render props 和高阶组件。 函数组件React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 组件的最佳写法应该是函数，而不是类。 React 早就支持函数组件，下面就是一个例子。 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 但是，这种写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。 React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件 React HooksHook 这个单词的意思是”钩子”。 React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。 你需要什么功能，就使用什么钩子。React 默认提供了一些常用钩子，你也可以封装自己的钩子。 所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用use前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。 下面介绍 React 默认提供的四个最常用的钩子。 useState() useContext() useReducer() useEffect() useState()：状态钩子useState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。 本文前面那个组件类，用户点击按钮，会导致按钮的文字改变，文字取决于用户是否点击，这就是状态。使用useState()重写如下。 1234567891011import React, &#123; useState &#125; from &quot;react&quot;;export default function Button() &#123; const [buttonText, setButtonText] = useState(&quot;Click me, please&quot;); function handleClick() &#123; return setButtonText(&quot;Thanks, been clicked!&quot;); &#125; return &lt;button onClick=&#123;handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;&#125; Button 组件是一个函数，内部使用useState()钩子引入状态。 useState()这个函数接受状态的初始值，作为参数，上例的初始值为按钮的文字。 该函数返回一个数组，数组的第一个成员是一个变量（上例是buttonText），指向状态的当前值。第二个成员是一个函数，用来更新状态，约定是set前缀加上状态的变量名（上例是setButtonText）。 useContext()：共享状态钩子如果需要在组件之间共享状态，可以使用useContext()。 123456789101112131415161718192021222324252627import React, &#123; useState, useContext &#125; from &quot;react&quot;;const AppContext = React.createContext(&#123; title: &apos;&apos; &#125;);export default function Button () &#123; const First = () =&gt; &#123; const &#123; title &#125; = useContext(AppContext); return &lt;button&gt;&#123; title + 1 &#125;&lt;/button&gt;; &#125; const Second = () =&gt; &#123; const &#123; title &#125; = useContext(AppContext); return &lt;button&gt;&#123; title + 2 &#125; &lt;/button&gt; &#125; return ( &lt;AppContext.Provider value=&#123;&#123; title: &apos;test&apos; &#125;&#125;&gt; &lt;First&gt;&lt;/First&gt; &lt;Second&gt;&lt;/Second&gt; &lt;/AppContext.Provider&gt; )&#125; 第一步就是使用 React Context API，在组件外部建立一个 Context。需要保证父子组件使用的都是同一个AppContext。 AppContext.Provider提供了一个 Context 对象，这个对象可以被子组件共享。 useContext()钩子函数用来引入 Context 对象，从中获取title属性。 useReducer()：action 钩子React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。 Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。 useReducers()钩子用来引入 Reducer 功能。 1const [state, dispatch] = useReducer(reducer, initialState); 上面是useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。 1234567891011export const testReducer = (state, action) =&gt; &#123; switch(action.type) &#123; case(&apos;change&apos;): return &#123; ...state, title: &apos;test dispatch&apos; &#125; default: return state; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import React, &#123; useState, useContext, useReducer &#125; from &quot;react&quot;;import &#123; testReducer &#125; from &apos;../store/reducer&apos;;const AppContext = React.createContext(&#123; title: &apos;&apos; &#125;);export default function Button () &#123; const [buttonText, setButtonText] = useState(&apos;test&apos;); const [state, dispatch] = useReducer(testReducer, &#123; title: &apos;test reducer&apos; &#125;); const First = () =&gt; &#123; return &lt;button onClick=&#123; handleClickFirst &#125;&gt;&#123; buttonText &#125;&lt;/button&gt;; &#125; const Second = () =&gt; &#123; return &lt;button onClick=&#123; () =&gt; dispatch(&#123; type: &apos;change&apos; &#125;) &#125;&gt;change&lt;/button&gt; &#125; function handleClickFirst () &#123; return setButtonText(state.title); &#125; return ( &lt;AppContext.Provider value=&#123;&#123; title: &apos;test&apos; &#125;&#125;&gt; &lt;First&gt;&lt;/First&gt; &lt;Second&gt;&lt;/Second&gt; &lt;/AppContext.Provider&gt; )&#125; 由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。 useEffect()：副作用钩子useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。 123456useEffect(() =&gt; &#123; // do some side effects return () =&gt; &#123; // optional, clean up &#125;&#125;/* , [dependencies] */) 上面用法中，useEffect()接受两个参数。 第一个参数是一个函数，异步操作的代码放在里面。 第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。 第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。 123456789101112131415161718192021222324const Person = (&#123; personId &#125;) =&gt; &#123; const [loading, setLoading] = useState(true); const [person, setPerson] = useState(&#123;&#125;); useEffect(() =&gt; &#123; setLoading(true); fetch(`https://swapi.co/api/people/$&#123;personId&#125;/`) .then(response =&gt; response.json()) .then(data =&gt; &#123; setPerson(data); setLoading(false); &#125;); &#125;, [personId]) if (loading === true) &#123; return &lt;p&gt;Loading ...&lt;/p&gt; &#125; return &lt;div&gt; &lt;p&gt;You&apos;re viewing: &#123;person.name&#125;&lt;/p&gt; &lt;p&gt;Height: &#123;person.height&#125;&lt;/p&gt; &lt;p&gt;Mass: &#123;person.mass&#125;&lt;/p&gt; &lt;/div&gt;&#125; 上面代码中，每当组件参数personId发生变化，useEffect()就会执行。组件第一次渲染时，useEffect()也会执行。 自定义 Hooks上例的 Hooks 代码还可以封装起来，变成一个自定义的 Hook，便于共享。 1234567891011121314export default const usePerson = (personId) =&gt; &#123; const [loading, setLoading] = useState(true); const [person, setPerson] = useState(&#123;&#125;); useEffect(() =&gt; &#123; setLoading(true); fetch(`https://swapi.co/api/people/$&#123;personId&#125;/`) .then(response =&gt; response.json()) .then(data =&gt; &#123; setPerson(data); setLoading(false); &#125;); &#125;, [personId]); return [loading, person];&#125;; usePerson()就是一个自定义的 Hook。 Person 组件就改用这个新的钩子，引入封装的逻辑。 1234567891011121314151617import &#123; usePerson &#125; from &quot;./usePerson.ts&quot;;const Person = (&#123; personId &#125;) =&gt; &#123; const [loading, person] = usePerson(personId); if (loading === true) &#123; return &lt;p&gt;Loading ...&lt;/p&gt;; &#125; return ( &lt;div&gt; &lt;p&gt;You&apos;re viewing: &#123;person.name&#125;&lt;/p&gt; &lt;p&gt;Height: &#123;person.height&#125;&lt;/p&gt; &lt;p&gt;Mass: &#123;person.mass&#125;&lt;/p&gt; &lt;/div&gt; );&#125;; 参考链接React Hooks 入门教程]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：rematch]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9Arematch%2F</url>
    <content type="text"><![CDATA[rematch是对redux的二次封装，简化了redux是使用，极大的提高了开发体验。rematch仅仅是对redux的封装，没有依赖redux-saga，也没有关联react，因此其可以用在其他的视图库中，如vue等。 Redux vs Rematch item Redux Rematch simple setup ✅ less boilerplate ✅ readability ✅ configurable ✅ ✅ redux devtools ✅ ✅ generated action creators ✅ async thunks async/await 使用项目结构12345678├── index.html├── index.js # 项目的入口├── ....└── store ├── index.js # 引入modules的各个模块，初始化store的地方 └── modules ├── count.js # count模块 └── info.js # info模块 初始化rematch提供 init（）方法，返回一个store的实例。初始化store的时候rematch支持传入多个模块，在中、大型项目中可以根据业务的需要，拆分成多个模块，这样项目的结果就会变得清晰明了。123456789101112import &#123; init &#125; from &apos;@rematch/core&apos;;import count from &apos;./modules/count&apos;;import info from &apos;./modules/info&apos;;const store = init(&#123; models: &#123; count, info, &#125;&#125;)export default store; 业务代码123456789101112131415161718192021222324252627282930// count.jsexport const count = &#123; state: &#123; num: 0 &#125;, reducers: &#123; // 从第二个变量开始为调用 add 时传递进来的参数，后面依次类推，例如：dispatch.count.add(10, 20)时， num1 = 10 , num2 = 20. add(state, num1, num2) &#123; //... return &#123; ...state, num: num1 + num2 &#125; &#125;, remove() &#123; //... return &#123; ...state, num: 0 &#125; &#125; &#125;, effects: &#123; // 第二个变量为当前model的state的值，num1为调用 addAsync 时传递进来的第一个参数，num2为调用时传递的第二个参数，后面依次类推。例如：dispatch.count.ddAsync(10, 20)时，num1 = 10, num2 = 20 async addAsync (num1, rootState, num2) &#123; //... this.add(num1, num2); &#125; &#125;&#125; 事实上每一个模块就是一个对象，该对象包含三个属性：state、reducers、effects。 state：存放模块状态的地方。 educers：改变store状态的地方。 每个reducers函数都会返回一个对象作为模块最新的state。 reducers中的函数必须为同步函数，如果要异步处理数据需要在effects中处理。 注意：只能通过在reducers的函数中通过返回一个新的对象来改变模块中state的值，直接通过修改state的方式是是不能改变模块的state的值。 effects：处理异步数据的地方。比如：异步从服务端获取数据。 注意：在effects中是不能修改模块的state，需要在异步处理完数据后调用reducers中的函数修改模块的state。 获取和修改state有2种方法可以获取state和修改state： 使用redux的高阶组件connect将state、reducers、effects绑定到组件的props上。 使用rematch提供的dispatch和getState。 使用redux的高阶组件connect12345678910const mapStateToProps = (state) =&gt; (&#123; num: state.count.num&#125;)const mapDispatchToProps = (dispatch) =&gt; (&#123; add: (num1, num2) =&gt; &#123; dispatch.count.add(num1, num2); &#125;, remove: dispatch.count.remove&#125;)export default connect(mapStateToProps, mapDispatchToProps)(App); dispatch 和 getState getState：rematch提供的getState方法返回整个store的state对象 如果要单独访问count模块的state，只需要 getState( ).count即可。 dispatch：rematch提供的dispatch可以直接调用整个store中定义的reducers和effects。 例：dispatch.count.add(10, 20) ，其中count为store中的一个model， add 方法为count模块中提供的一个reducers。 调用effects的方法和调用reducers的方法一样。 123456789import React, &#123;Component&#125; from &apos;react&apos;;import &#123; dispatch, getState &#125; from &apos;@rematch/core&apos;;class App extends Component &#123; handleClick = () =&gt; &#123; console.log(getState().count); // &#123;num: 0&#125; dispatch.count.add(10, 20) &#125;;&#125; 参考 Rematchjs rematch：当你受不了redux繁琐写法的时候，是时候了解一波rematch了 Rematch 一个更好用的 Redux]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：重定向Redirect]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91Redirect%2F</url>
    <content type="text"><![CDATA[React-Router实战：重定向Redirect]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：踩坑记]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9A%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用useState时没有触发渲染，可能是因为将已有的对象传递过去，它认为没有改变，可以这样处理 1setNumbers([..old]); 多个表单不要放同一页面，拆分成多个组件 Redirect一般都放Switch里面，必须放在Switch最后一行（含义：如果上面的路由都匹配不到时，跳转到redirect配置的页面） 里不能使用div，否则会报错]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：useLayoutEffect和useEffect的区别]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9AuseLayoutEffect%E5%92%8CuseEffect%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[渲染流程 react 在 diff 后，会进入到 commit 阶段，准备把虚拟 DOM 发生的变化映射到真实 DOM 上。 在 commit 阶段的前期，会调用一些生命周期方法，对于类组件来说，需要触发组件的 getSnapshotBeforeUpdate 生命周期，对于函数组件，此时会调度 useEffect 的 create destroy 函数（注意是调度，不是执行）。 在这个阶段，会把使用了 useEffect 组件产生的生命周期函数入列到 React 自己维护的调度队列中，给予一个普通的优先级，让这些生命周期函数异步执行。 随后，就到了 React 把虚拟 DOM 设置到真实 DOM 上的阶段，这个阶段主要调用的函数是 commitWork，commitWork 函数会针对不同的 fiber 节点调用不同的 DOM 的修改方法，比如文本节点和元素节点的修改方法是不一样的。 commitWork 如果遇到了类组件的 fiber 节点，不会做任何操作，会直接 return，进行收尾工作，然后去处理下一个节点，这点很容易理解，类组件的 fiber 节点没有对应的真实 DOM 结构，所以就没有相关操作。 但在有了 hooks 以后，函数组件在这个阶段，会同步调用上一次渲染时 useLayoutEffect(create, deps) create 函数返回的 destroy 函数。 注意一个节点在 commitWokr 后，这个时候，我们已经把发生的变化映射到真实 DOM 上了。 但由于 JS 线程和浏览器渲染线程是互斥的，因为 JS 虚拟机还在运行，即使内存中的真实 DOM 已经变化，浏览器也没有立刻渲染到屏幕上。 此时会进行收尾工作，同步执行对应的生命周期方法，我们说的componentDidMount，componentDidUpdate 以及 useLayoutEffect(create, deps) 的 create 函数都是在这个阶段被同步执行。 对于 react 来说，commit 阶段是不可打断的，会一次性把所有需要 commit 的节点全部 commit 完，至此 react 更新完毕，JS 停止执行。 浏览器把发生变化的 DOM 渲染到屏幕上，到此为止 react 仅用一次回流、重绘的代价，就把所有需要更新的 DOM 节点全部更新完成。 浏览器渲染完成后，浏览器通知 react 自己处于空闲阶段，react 开始执行自己调度队列中的任务，此时才开始执行 useEffect(create, deps) 的产生的函数。 介绍useEffect 该 Hook 接收一个包含命令式、且可能有副作用代码的函数。在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。 useEffect 是异步执行的 执行时机是浏览器将所有变化渲染到屏幕后 useLayoutEffect其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 useLayoutEffect 是同步执行的 执行时机是浏览器把内容真正渲染到界面之前 useLayoutEffect的 create 函数的调用位置、时机都和 componentDidMount，componentDidUpdate 一致，且都是被 React 同步调用，都会阻塞浏览器渲染。 useLayoutEffect 的 detroy 函数的调用位置、时机与 componentWillUnmount 一致，且都是同步调用。 使用方式这两个函数的使用方式其实非常简单，他们都接受一个函数一个数组，只有在数组里面的值改变的情况下才会再次执行 effect。 12useEffect(() =&gt; &#123;&#125;, []);useLayoutEffect(() =&gt; &#123;&#125;, []); 实际应用 DOM操作在useLayoutEffect进行 其余一般在useEffect进行，如数据初始化 当需要进行DOM操作,并且会改变页面的样式时,就需要用useLayoutEffect,否则可能会出现出现闪屏问题。useLayoutEffect里面的callback函数会在DOM更新完成后立即执行,但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制。 可以看到在流程9/10期间，DOM 已经被修改，但但浏览器渲染线程依旧处于被阻塞阶段，所以还没有发生回流、重绘过程。由于内存中的 DOM 已经被修改，通过 useLayoutEffect 可以拿到最新的 DOM 节点，并且在此时对 DOM 进行样式上的修改，假设修改了元素的 height，这些修改会在步骤 11 和 react 做出的更改一起被一次性渲染到屏幕上，依旧只有一次回流、重绘的代价。 如果放在 useEffect 里，useEffect 的函数会在组件渲染到屏幕之后执行，此时对 DOM 进行修改，会触发浏览器再次进行回流、重绘，增加了性能上的损耗。 参考深入理解 React useLayoutEffect 和 useEffect 的执行时机]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ant-design：Form.list使用]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Fant-design%EF%BC%9AForm.list%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用1234567891011121314&lt;Form&gt; &lt;Form.List name=&apos;data&apos;&gt; &#123;(fields) =&gt; ( fields.map(field =&gt; ( &lt;Form.Item name=&#123;[field.name, &apos;name&apos;]&#125;&gt; &lt;Input style=&#123;&#123; width: 80 &#125;&#125; /&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&#123;[field.name, &apos;age&apos;]&#125;&gt; &lt;InputNumber style=&#123;&#123; width: 80 &#125;&#125; /&gt; &lt;/Form.Item&gt; )) )&#125; &lt;/Form.Lsit&gt;&lt;/Form&gt; 数据结构123456789101112&#123; data: [ &#123; name: &apos;aaa&apos;, age: 11 &#125;, &#123; name: &apos;aaa&apos;, age: 111 &#125; ]&#125; 实际应用 结构和数据一定要对应1234567891011121314151617181920212223242526// 数据结构const listFields = &#123; 1: [&#123;name:a&#125;, &#123;name:b&#125;], 2: [&#123;name:aa&#125;, &#123;name:bb&#125;],&#125;const data = &#123; 1: [&#123;a:11&#125;, &#123;b:10&#125;], 2: [&#123;aa:11&#125;, &#123;bb:10&#125;],&#125;// 使用&lt;Form&gt; &#123; Object.keys(listFields).map(name =&gt; ( &lt;Form.List name=&#123;name&#125;&gt; &#123;(fields) =&gt; ( listFields[name].map((item, index) =&gt; ( &lt;Form.Item name=&#123;[fields[index]?.name, item.name]&#125;&gt; &lt;Input style=&#123;&#123; width: 80 &#125;&#125; /&gt; &lt;/Form.Item&gt; )) )&#125; &lt;/Form.Lsit&gt; )) &#125;&lt;/Form&gt;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：useRef]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9AuseRef%2F</url>
    <content type="text"><![CDATA[介绍类组件、React 元素用 React.createRef，函数组件使用 useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 使用绑定DOM类组件123456789class App extends React.Component &#123; refInput = React.createRef(); componentDidMount() &#123; this.refInput.current &amp;&amp; this.refInput.current.focus(); &#125; render() &#123; return &lt;input ref=&#123;this.refInput&#125; /&gt;; &#125;&#125; 函数组件12345678function App() &#123; const refInput = React.useRef(null); React.useEffect(() =&gt; &#123; refInput.current &amp;&amp; refInput.current.focus(); &#125;, []); return &lt;input ref=&#123;refInput&#125; /&gt;;&#125; 父组件调用子组件方法一些应用场景,需要在父组件中调用子组件定义的方法.这就需要将组件抛出给父组件。 类组件父组件 1234567891011121314151617class ParentComponent extends Component &#123; refChild = React.createRef(); setChildText = () =&gt; &#123; if (this.refChild.current) &#123; this.refChild.current.setText(&quot;text updated by parent component&quot;); &#125; &#125;; render() &#123; return ( &lt;&gt; &#123;/* 父组件引用时,直接使用 ref 即可绑定子组件实例 */&#125; &lt;ChildComponent ref=&#123;this.refChild&#125; /&gt; &lt;button onClick=&#123;this.setChildText&#125;&gt;set text by parent&lt;/button&gt; &lt;/&gt; ); &#125;&#125; 子组件 123456789class ChildComponent extends Component &#123; state = &#123; text: &quot;&quot; &#125;; setText(text = &quot;&quot;) &#123; this.setState(&#123; text &#125;); &#125; render() &#123; return &lt;p&gt;text: &#123;this.state.text&#125;&lt;/p&gt;; &#125;&#125; 函数组件需要配合useImperativeHandle使用 父组件 useRef是一个方法，且useRef返回一个可变的ref对象，initialValue被赋值给其返回值的.current对象。 useRef会在每次渲染时返回同一个ref对象，即返回的ref对象在组件的整个生命周期内保持不变。 ref对象的值发生改变之后，不会触发组件重新渲染。有一个窍门，把它的改变动作放到useState()之前。 1234567891011121314151617function Parent() &#123; const ref = useRef(null); // &#123; current: null &#125; return ( &lt;&gt; &lt;ForwardChild ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; ref.current &amp;&amp; ref.current.setTextByParent(&quot;text updated by parent component&quot;); &#125;&#125; &gt; set text by parent &lt;/button&gt; &lt;/&gt; );&#125; 子组件 useImperativeHandle(ref,createHandle,[deps])可以自定义暴露给父组件的实例值。如果不使用，父组件的ref访问不到任何值（ref.current==null） useImperativeHandle应该与forwradRef搭配使用 React.forwardRef会创建一个React组件，这个组件能够将其接受的ref属性转发到其组件树下的另一个组件中。 React.forward接受渲染函数作为参数，React将使用prop和ref作为参数来调用此函数。 1234567891011121314// 函数组件需要使用 forwardRef 包裹forwardRef(function Child(props, ref) &#123; const [text, setText] = useState(&quot;&quot;); // 该 hook 需要定义抛出给父组件的可以使用的 api 方法 // 相当于代理了子组件的方法 useImperativeHandle(ref, () =&gt; (&#123; setTextByParent(text = &quot;&quot;) &#123; setText(text); &#125;, &#125;)); return &lt;p&gt;text: &#123;text&#125;&lt;/p&gt;;&#125;) 参考 useRef使用总结 关于 useRef 的使用]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：useCallback、useMemo、memo]]></title>
    <url>%2F2022%2F04%2F19%2Freact%2Freact%EF%BC%9AuseCallback%E3%80%81useMemo%E3%80%81memo%2F</url>
    <content type="text"><![CDATA[useMome、useCallback用法都差不多，都会在第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。 123const value = useMemo(fnM, [a]);const fnA = useCallback(fnB, [a]); memoReact.memo 为高阶组件。它与React.PureComponent非常相似，但它适用于函数组件，但不适用于 class 组件。 默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。这与shouldComponentUpdate 方法的返回值相反。 1234567891011function MyComponent(props) &#123; /* 使用 props 渲染 */&#125;function areEqual(prevProps, nextProps) &#123; /* 如果把 nextProps 传入 render 方法的返回结果与 将 prevProps 传入 render 方法的返回结果一致则返回 true， 否则返回 false */&#125;export default React.memo(MyComponent, areEqual); 当父组件引入子组件的情况下，往往会造成组件之间的一些不必要的浪费 每次父组件更新count，子组件都会更新。使用memo，count变化子组件没有更新。12345678910111213141516const Child = memo((props) =&gt; &#123; console.log(&apos;子组件?&apos;) return( &lt;div&gt;我是一个子组件&lt;/div&gt; );&#125;)const Page = (props) =&gt; &#123; const [count, setCount] = useState(0); return ( &lt;&gt; &lt;button onClick=&#123;(e) =&gt; &#123; setCount(count+1) &#125;&#125;&gt;加1&lt;/button&gt; &lt;p&gt;count:&#123;count&#125;&lt;/p&gt; &lt;Child /&gt; &lt;/&gt; )&#125; useCallback当父组件传递状态给子组件的时候，memo好像没什么效果，子组件还是执行了，这时候我们就要引入hooks的useCallback、useMemo这两个钩子了。 在上面代码基础上，父级调用子级时，在onClick参数上加上useCallback，参数为[]，则第一次初始化结束后，不再改变。 1234567891011121314151617181920212223242526272829//子组件没有必要渲染的例子interface ChildProps &#123; name: string; onClick: Function;&#125;const Child = memo((&#123; name, onClick&#125;: ChildProps): JSX.Element =&gt; &#123; console.log(&apos;子组件?&apos;) return( &lt;&gt; &lt;div&gt;我是一个子组件，父级传过来的数据：&#123;name&#125;&lt;/div&gt; &lt;button onClick=&#123;onClick.bind(null, &apos;新的子组件name&apos;)&#125;&gt;改变name&lt;/button&gt; &lt;/&gt; );&#125;)const Page = (props) =&gt; &#123; const [count, setCount] = useState(0); const [name, setName] = useState(&apos;Child组件&apos;); return ( &lt;&gt; &lt;button onClick=&#123;(e) =&gt; &#123; setCount(count+1) &#125;&#125;&gt;加1&lt;/button&gt; &lt;p&gt;count:&#123;count&#125;&lt;/p&gt; &lt;ChildMemo name=&#123;name&#125; onClick=&#123; useCallback((newName: string) =&gt; setName(newName), []) &#125;/&gt; &#123;/* useCallback((newName: string) =&gt; setName(newName),[]) */&#125; &#123;/* 这里使用了useCallback优化了传递给子组件的函数，只初始化一次这个函数，下次不产生新的函数 &lt;/&gt; )&#125; useCallback性能问题一般会觉得使用useCallback的性能会比普通重新定义函数的性能好。 123456789function App() &#123; const [val, setVal] = useState(&quot;&quot;); const onChange = useCallback(evt =&gt; &#123; setVal(evt.target.value); &#125;, []); return &lt;input val=&#123;val&#125; onChange=&#123;onChange&#125; /&gt;;&#125; 实际性能会更差，上面的写法几乎等同于下面： 12345const temp = evt =&gt; &#123; setVal(evt.target.value);&#125;;const onChange = useCallback(temp, []); 可以看到onChange的定义是省不了的，而且额外还要加上调用useCallback产生的开销，性能怎么可能会更好？ 真正有助于性能改善的，有 2 种场景： 函数定义时需要进行大量运算， 这种场景极少 需要比较引用的场景，如上文提到的useEffect，又或者是配合React.Memo使用 useMemo更新属性name为对象类型，这时子组件还是一样的执行了，在父组件更新其它状态的情况下，子组件的name对象属性会一直发生重新渲染改变，从而导致一直执行,这也是不必要的性能浪费。 解决这个问题，使用name参数使用useMemo，依赖于State.name数据的变化进行更新。 12345678910111213141516171819202122232425262728293031323334353637interface ChildProps &#123; name: &#123; name: string; color: string &#125;; onClick: Function;&#125;const Child = memo((&#123; name, onClick&#125;: ChildProps): JSX.Element =&gt; &#123; console.log(&apos;子组件?&apos;) return( &lt;&gt; &lt;div style=&#123;&#123; color: name.color &#125;&#125;&gt;我是一个子组件，父级传过来的数据：&#123;name.name&#125;&lt;/div&gt; &lt;button onClick=&#123;onClick.bind(null, &apos;新的子组件name&apos;)&#125;&gt;改变name&lt;/button&gt; &lt;/&gt; );&#125;)const Page = (props) =&gt; &#123; const [count, setCount] = useState(0); const [name, setName] = useState(&apos;Child组件&apos;); return ( &lt;&gt; &lt;button onClick=&#123;(e) =&gt; &#123; setCount(count+1) &#125;&#125;&gt;加1&lt;/button&gt; &lt;p&gt;count:&#123;count&#125;&lt;/p&gt; &lt;ChildMemo //使用useMemo，返回一个和原本一样的对象，第二个参数是依赖性，当name发生改变的时候，才产生一个新的对象 name=&#123; useMemo(()=&gt;(&#123; name, color: name.indexOf(&apos;name&apos;) !== -1 ? &apos;red&apos; : &apos;green&apos; &#125;), [name]) &#125; onClick=&#123; useCallback((newName: string) =&gt; setName(newName), []) &#125; &#123;/* useCallback((newName: string) =&gt; setName(newName),[]) */&#125; &#123;/* 这里使用了useCallback优化了传递给子组件的函数，只初始化一次这个函数，下次不产生新的函数 /&gt; &lt;/&gt; )&#125; 总结 在子组件不需要父组件的值和函数的情况下，只需要使用memo函数包裹子组件即可。 在使用函数的情况，需要考虑有没有函数传递给子组件使用useCallback。 在值有所依赖的项，并且是对象和数组等值的时候而使用useMemo（当返回的是原始数据类型如字符串、数字、布尔值，就不要使用useMemo了）。不要盲目使用这些hooks。 参考react Hook之useMemo、useCallback及memo你不知道的 useCallback]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos：生命周期]]></title>
    <url>%2F2022%2F04%2F19%2Fcocos%2Fcocos%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Cocos Creator 为组件脚本提供了生命周期的回调函数。开发者只需要定义特定的回调函数，Creator 就会在特定的时期自动执行相关脚本，开发者不需要手工调用它们。 目前提供给开发者的生命周期回调函数主要有（按生命周期触发先后排列）： onLoad onEnable start update lateUpdate onDisable onDestroy onLoad 组件脚本的初始化阶段，我们提供了 onLoad 回调函数。 onLoad 回调会在节点首次激活时触发，比如所在的场景被载入，或者所在节点被激活的情况下。 在 onLoad 阶段，保证了你可以获取到场景中的其他节点，以及节点关联的资源数据。 onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。 通常我们会在 onLoad 阶段去做一些初始化相关的操作。 1234567891011121314151617import &#123; _decorator, Component, Node, SpriteFrame, find &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;test&quot;)export class test extends Component &#123; @property(&#123;type:SpriteFrame&#125;) bulletSprite=null; @property(&#123;type:Node&#125;) gun=null; _bulletRect=null; onLoad()&#123; this._bulletRect=this.bulletSprite.getRect(); this.gun = find(&apos;hand/weapon&apos;, this.node); &#125;&#125; onEnable 当组件的 enabled 属性从 false 变为 true 时，或者所在节点的 active 属性从 false 变为 true 时，会激活 onEnable 回调。 倘若节点第一次被创建且 enabled 为 true，则会在 onLoad 之后，start 之前被调用。 start start 回调函数会在组件第一次激活前，也就是第一次执行 update 之前触发。 start 通常用于初始化一些中间状态的数据，这些数据可能在 update 时会发生改变，并且被频繁的 enable 和 disable。 1234567891011121314151617181920import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;starttest&quot;)export class starttest extends Component &#123; private _timer: number = 0.0; start () &#123; this._timer = 1.0; &#125; update (deltaTime: number) &#123; this._timer += deltaTime; if(this._timer &gt;= 10.0)&#123; console.log(&apos;I am done!&apos;); this.enabled = false; &#125; &#125;&#125; update游戏开发的一个关键点是在每一帧渲染前更新物体的行为，状态和方位。这些更新操作通常都放在 update 回调中。 12345678910import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;updatetest&quot;)export class updatetest extends Component &#123; update (deltaTime: number) &#123; this.node.setPosition(0.0,40.0*deltaTime,0.0); &#125;&#125; lateUpdateupdate 会在所有动画更新前执行，但如果我们要在动效（如动画、粒子、物理等）更新之后才进行一些额外操作，或者希望在所有组件的 update 都执行完之后才进行其它操作，那就需要用到 lateUpdate 回调。 12345678910import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;lateupdatetest&quot;)export class lateupdatetest extends Component &#123; lateUpdate (deltaTime: number) &#123; this.node.setPosition(0.0,50,0.0); &#125;&#125; onDisable当组件的 enabled 属性从 true 变为 false 时，或者所在节点的 active 属性从 true 变为 false 时，会激活 onDisable 回调。 onDestroy当组件或者所在节点调用了 destroy()，则会调用 onDestroy 回调，并在当帧结束时统一回收组件。]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos：计时器]]></title>
    <url>%2F2022%2F04%2F19%2Fcocos%2Fcocos%EF%BC%9A%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[下面是 Component 中所有关于计时器的函数： schedule：开始一个计时器 scheduleOnce：开始一个只执行一次的计时器 unschedule：取消一个计时器 unscheduleAllCallbacks：取消这个组件的所有计时器 schedule开始一个计时器 1234this.schedule(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, 5); 上面这个计时器将每隔 5s 执行一次。 更灵活的计时器 12345678910// 以秒为单位的时间间隔 let interval = 5; // 重复次数 let repeat = 3; // 开始延时 let delay = 10; this.schedule(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, interval, repeat, delay); 上面的计时器将在 10 秒后开始计时，每 5 秒执行一次回调，重复 3 次。 scheduleOnce只执行一次的计时器（快捷方式） 1234this.scheduleOnce(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, 2); 上面的计时器将在两秒后执行一次回调函数，之后就停止计时。 unschedule取消计时器 开发者可以使用回调函数本身来取消计时器： 12345678910this.count = 0; this.callback = function () &#123; if (this.count == 5) &#123; // 在第六次执行回调时取消这个计时器 this.unschedule(this.callback); &#125; this.doSomething(); this.count++; &#125; this.schedule(this.callback, 1); 注意：组件的计时器调用回调时，会将回调的 this 指定为组件本身，因此回调中可以直接使用 this。]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos：事件机制]]></title>
    <url>%2F2022%2F04%2F19%2Fcocos%2Fcocos%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[事件监听事件处理大多数是在节点（Node）中完成的。对于组件，可以通过访问节点 this.node 来注册和监听事件。监听事件可以通过 this.node.on() 函数来注册，方法如下： 12345// 该事件监听每次都会触发，需要手动取消注册xxx.on(type, func, target?);// 该事件监听在监听函数响应后就会关闭监听事件。xxx.once(type, func, target?); type 为事件注册字符串 func 为执行事件监听的回调 target 为事件接收对象 如果 target 没有设置，则回调里的 this 指向的就是当前执行回调的对象。 值得一提的是，事件监听函数 on 第三个参数 target，主要是绑定响应函数的调用者。以下两种调用方式，效果上是相同的 123456789// 使用函数绑定this.node.on(Node.EventType.MOUSE_DOWN, function ( event ) &#123; this.enabled = false;&#125;.bind(this));// 使用第三个参数this.node.on(Node.EventType.MOUSE_DOWN, (event) =&gt; &#123; this.enabled = false;&#125;, this); 事件取消当我们不再关心某个事件时，我们可以使用 off 方法关闭对应的监听事件。 off 方法的使用方式有两种： 1234// 取消对象身上所有注册的该类型的事件xxx.off(type);// 取消对象身上该类型指定回调指定目标的事件xxx.off(type, func, target); 需要注意的是，off 方法的参数必须和 on 方法的参数一一对应，才能完成关闭。 我们推荐的书写方法如下： 1234567891011121314151617import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass &#125; = _decorator;@ccclass(&quot;Example&quot;)export class Example extends Component &#123; onEnable () &#123; this.node.on(&apos;foobar&apos;, this._sayHello, this); &#125; onDisable () &#123; this.node.off(&apos;foobar&apos;, this._sayHello, this); &#125; _sayHello () &#123; console.log(&apos;Hello World&apos;); &#125;&#125; 事件派发触发事件有两种方式： emit dispatchEvent，可以做事件传递 emit12// 事件派发的时候可以指定派发参数，参数最多只支持 5 个事件参数xxx.emit(type, ...args); 在触发事件时，我们可以在 emit 函数的第二个参数开始传递我们的事件参数。同时，在 on 注册的回调里，可以获取到对应的事件参数。 1234567891011121314151617import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass &#125; = _decorator;@ccclass(&quot;Example&quot;)export class Example extends Component &#123; onLoad () &#123; this.node.on(&apos;foo&apos;, (arg1, arg2, arg3) =&gt; &#123; console.log(arg1, arg2, arg3); // print 1, 2, 3 &#125;); &#125; start () &#123; let arg1 = 1, arg2 = 2, arg3 = 3; // At most 5 args could be emit. this.node.emit(&apos;foo&apos;, arg1, arg2, arg3); &#125;&#125; 需要说明的是，出于底层事件派发的性能考虑，这里最多只支持传递 5 个事件参数。所以在传参时需要注意控制参数的传递个数。 dispatchEvent 通过 dispatchEvent 方法派发的事件，会进入事件派发阶段。 在 Cocos Creator 的事件派发系统中，我们采用冒泡派发的方式。 冒泡派发会将事件从事件发起节点，不断地向上传递给它的父级节点，直到到达根节点或者在某个节点的响应函数中做了中断处理 event.propagationStopped = true。 在 v3.0 中，我们移除了 Event.EventCustom 类，如果要派发自定义事件，需要先实现一个自定义的事件类，该类继承自 Event 类。 12345678910// Event 由 cc 模块导入import &#123; Event &#125; from &apos;cc&apos;;class MyEvent extends Event &#123; constructor(name: string, bubbles?: boolean, detail?: any) &#123; super(name, bubbles); this.detail = detail; &#125; public detail: any = null; // 自定义的属性&#125; 以上图为例，当我们从节点 c 发送事件 “foobar”，倘若节点 a，b 均做了 “foobar” 事件的监听，则事件会经由 c 依次传递给 b，a 节点。如： 12// 节点 c 的组件脚本中this.node.dispatchEvent( new MyEvent(&apos;foobar&apos;, true, &apos;detail info&apos;) ); 如果我们希望在 b 节点截获事件后就不再传递事件，我们可以通过调用 event.propagationStopped = true 函数来完成。具体方法如下： 1234// 节点 b 的组件脚本中this.node.on(&apos;foobar&apos;, (event: MyEvent) =&gt; &#123; event.propagationStopped = true;&#125;); 注意：在发送用户自定义事件的时候，请不要直接创建 cc 内的 Event 对象，因为它是一个抽象类。 系统内置事件123456789// 使用枚举类型来注册，推荐node.on(Node.EventType.MOUSE_DOWN, (event) =&gt; &#123; console.log(&apos;Mouse down&apos;);&#125;, this);// 使用事件名来注册node.on(&apos;mouse-down&apos;, (event) =&gt; &#123; console.log(&apos;Mouse down&apos;);&#125;, this); 触摸事件触摸事件冒泡触摸事件支持节点树的事件冒泡，以下图为例：在图中的场景里，假设 A 节点拥有一个子节点 B，B 拥有一个子节点 C。开发者对 A、B、C 都监听了触摸事件（以下的举例都默认节点监听了触摸事件）。 当鼠标或手指在 C 节点区域内按下时，事件将首先在 C 节点触发，C 节点监听器接收到事件。 接着 C 节点会将事件向其父节点传递这个事件，B 节点的监听器将会接收到事件。 同理 B 节点会将事件传递给 A 父节点。这就是最基本的事件冒泡过程。 需要强调的是，在触摸事件冒泡的过程中不会有触摸检测，这意味着即使触点不在 A B 节点区域内，A B 节点也会通过触摸事件冒泡的机制接收到这个事件。 触摸事件的冒泡过程与普通事件的冒泡过程并没有区别。所以，调用 event.propagationStopped = true; 可以主动停止冒泡过程。 同级节点间的触点归属问题 假设上图中 B、C 为同级节点，C 节点部分覆盖在 B 节点之上。 这时候如果 C 节点接收到触摸事件后，就宣布了触点归属于 C 节点，这意味着同级节点的 B 就不会再接收到触摸事件了， 即使触点同时也在 B 节点内。同级节点间，触点归属于处于顶层的节点。 此时如果 C 节点还存在父节点，则还可以通过事件冒泡的机制传递触摸事件给父节点。 不同 Canvas 的触点归属问题 不同 Canvas 之间的触点拦截是根据优先级决定的。 在下图中的场景里，节点树里的 Canvas 1-5 对应图片显示的 priority 1-5。 可以看出，即使 Canvas 节点 3、4、5 之间是按乱序排的，但是根据 Canvas 上的优先级（priority）关系，触点的响应先后顺序仍然是 Canvas5 -&gt; Canvas4 -&gt; Canvas3 -&gt; Canvas2 -&gt; Canvas1。 只有在优先级相同的情况下， Canvas 之间的排序是按节点树的先后顺序进行。 将触摸或鼠标事件注册在捕获阶段 有时候我们需要父节点的触摸或鼠标事件先于它的任何子节点派发，比如 ScrollView 组件就是这样设计的。 这时候事件冒泡已经不能满足我们的需求了，需要将父节点的事件注册在捕获阶段。 要实现这个需求，可以在给 node 注册触摸或鼠标事件时，传入第四个参数 true，表示 useCapture。 1this.node.on(Node.EventType.TOUCH_START, this.onTouchStartCallback, this, true); 当节点触发 touch-start 事件时，会先将 touch-start 事件派发给所有注册在捕获阶段的父节点监听器，然后派发给节点自身的监听器，最后才到了事件冒泡阶段。 只有触摸或鼠标事件可以注册在捕获阶段，其他事件不能注册在捕获阶段。 事件拦截 正常的事件是会按照以上说明的方式去派发。 但是如果节点身上带有 ==Button==,==Toggle== 或者 ==BlockInputEvents== 这几个组件的话，是会停止事件冒泡。 还是看下图。图中有两个按钮，Canvas0 下的 priority 1 和 Canvas1 下的 priority 2。 如果点击两个按钮的交汇处，也就是图中蓝色区域，会出现按钮 priority 2 成功接收到了触点事件，而按钮 priority 1 则没有。 那是因为按上述的事件接收规则，按钮 priority 2 优先接收到了触点事件，并且对事件进行了拦截（event.propagationStopped = true），防止事件穿透。 如果是非按钮节点，也可以通过添加 BlockInputEvents 组件来对事件进行拦截，防止穿透。 触摸事件举例以下图举例，总结下触摸事件的传递机制。图中有 A、B、C、D 四个节点，其中 A、B 为同级节点。具体层级关系如下： 若触点在 A、B 的重叠区域内，此时 B 接收不到触摸事件，事件的传递顺序是 A -&gt; C -&gt; D 若触点在 B 节点内（可见的绿色区域），则事件的传递顺序是 B -&gt; C -&gt; D 若触点在 C 节点内，则事件的传递顺序是 C -&gt; D 若以第 2 种情况为前提，同时 C D 节点的触摸事件注册在捕获阶段，则事件的传递顺序是 D -&gt; C -&gt; B]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos：cocos接入react组件]]></title>
    <url>%2F2022%2F04%2F19%2Fcocos%2Fcocos%EF%BC%9Acocos%E6%8E%A5%E5%85%A5react%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[接入redeem store，react组件，cocos不支持tsx ts把tsx编译成js引入 有引入别的文件使用，ts无法把两个文件打成一个文件 使用rolllup编译成js 引入文件过大，导致ts文件崩溃 把js改为插件脚本 把js导出项改为全局变量，直接引用 分包 需要把依赖一起打包到js进行分包 window不适用，继续使用引入的方式 load成功后引入redeem store process is not defined，打包时替换js里的process 部署时，无法获取process，无法替换，直接插入html，全局使用，production不替换 需求基于cocos的游戏接入基于react的兑换商店，即cocos接入react组件 tsx由于兑换商店暴露的是react组件，所以封装成一个tsx文件，接入cocos，html中增加一个节点，把兑换商店插入该节点 问题：cocos不支持接入tsx ts编译通过typescript把tsx编译成js 使用命令行参数–project（或-p）指定一个包含tsconfig.json文件的目录1$ tsc -p redeemStore/tsconfig.json 12345678910111213// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;allowSyntheticDefaultImports&quot;: true, &quot;jsx&quot;: &quot;react&quot;, &quot;module&quot;:&quot;esnext&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;rootDir&quot;: &quot;./redeemStore.tsx&quot;, // 用来指定编译文件的根目录，编译器会在根目录查找入口文件 &quot;outDir&quot;: &quot;../assets&quot;, // 用来指定输出文件夹 &quot;baseUrl&quot;: &quot;../&quot;, // 用于设置解析非相对模块名称的基本目录，相对模块不会受到baseUrl的影响 &#125;&#125; 由于有引入别的文件，希望可以全部编译成一个文件 12// 指定输出文件合并为一个文件，只有设置module的值为amd和system模块时才支持这个配置&quot;outFile&quot;: &quot;./&quot;, 问题：无法多个文件编译成一个文件输出 rollup打包123456789101112131415161718192021222324252627// rollup.config.jsimport typescript from &apos;rollup-plugin-typescript2&apos;;import resolve from &apos;rollup-plugin-node-resolve&apos;;import commonjs from &apos;rollup-plugin-commonjs&apos;;export default &#123; input: &apos;redeemStore/redeemStore.tsx&apos;, // 源文件入口 output: &#123; file: &apos;assets/script/page/ui/redeemStore/redeemStore.js&apos;, format: &apos;cjs&apos;, sourcemap: true, compact: true &#125;, plugins: [ resolve(), commonjs(), replace(&#123; &apos;process.env.NODE_ENV&apos;: JSON.stringify(process.env.NODE_ENV), &apos;process.env.country&apos;: JSON.stringify(process.env.cid || process.env.country), &apos;process.env.environment&apos;: JSON.stringify(process.env.env || process.env.environment), &#125;), typescript(), uglify() ],&#125; plugins是有顺序的 rollup-plugin-typescript2使rollup可作用于typescript rollup-plugin-node-resolve / @rollup/plugin-node-resolve rollup 不会去寻找从npm安装到你的node_modules文件夹中的软件包 该插件可以告诉 Rollup 如何查找外部模块 解析 node_modules 中的模块，将所有依赖编译进同一个文件 rollup-plugin-commonjs / @rollup/plugin-commonjs 将 CommonJS 模块转换为 ES6 npm中的大多数包都是以 CommonJS 模块的形式出现的。 在它们更改之前，我们需要将CommonJS模块转换为 ES2015 供 Rollup 处理 该插件应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏CommonJS的检测 rollup-plugin-commonjs 会有以下问题123[!] Error: &apos;createElement&apos; is not exported by node_modules/react/index.js, imported by node_modules/@gameplatform-fe-component/redeem-store/dist/es/index.mjshttps://rollupjs.org/guide/en/#error-name-is-not-exported-by-modulenode_modules/@gameplatform-fe-component/redeem-store/dist/es/index.mjs (1:25) 12345commonjs(&#123; namedExports: &#123; &apos;react&apos;: Object.keys(React), &#125;&#125;) rollup-plugin-replace / @rollup/plugin-replace编译过程中可以进行字符串替换 @rollup/plugin-replace 会含有如下警告，仅仅是警告⚠️，不会影响编译1(!) Plugin replace: @rollup/plugin-replace: &apos;preventAssignment&apos; currently defaults to false. It is recommended to set this option to `true`, as the next major version will default this option to `true`. rollup-plugin-uglify代码压缩，使编译后的包更小 全局变量 打包后直接import会导致脚本崩溃，失效。 把其设置为插件脚本。 用window，redeem store设为全局变量去调用。 以上，在分包后都不是问题，因此，这里只是一个小插曲，分包后依然是直接import 分包Asset Bundle 中的脚本 构建cocos可以把一个文件夹设置为bundle，其下的文件都会在构建时单独打包成一个子包，仅仅构建时生效，开发预览依然是一个整包。 加载12345678910111213141516171819enterRedeemPage() &#123; let bundle = assetManager.getBundle(&apos;redeemStore&apos;); if (!bundle) &#123; assetManager.loadBundle(&apos;redeemStore&apos;, err =&gt; &#123; if (err) &#123; return console.error(err); &#125; this.loadRedeemStore(); &#125;); &#125; else &#123; this.loadRedeemStore(); &#125;&#125;async loadRedeemStore() &#123; const store = await import(&apos;./redeemStore/redeemStore.js&apos;); store.default.openStore(app.data.gameConfig, app.data.player.uid, () =&gt; app.ui.open(UIDef.UILandingPage)); this.close();&#125; development vs productiondevelopment 开发环境，分包策略不生效，依然是整包。 直接通过特定的命令编译redeemStore，编译过程某些参数通过特定的命令注入。 若切换地区需要重新编译 1rollup:test:id&quot;: &quot;cross-env NODE_ENV=development cid=id env=test rollup -c&quot; production 部署的同时，对redeemStore进行编译 由于参数无法注入，因此在部署时，通过脚本把参数设为全局变量，以供redeemStore直接读取 1234567window.process = &#123; env: &#123; NODE_ENV: &apos;production&apos;, country: &apos;$&#123;buildConfig.COUNTRY&#125;&apos;, environment: &apos;$&#123;buildConfig.ENVIRONMENT&#125;&apos; &#125;&#125;;]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：cookie和session]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E5%85%A8%EF%BC%9Acookie%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[前言 会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份。 Session通过在服务器端记录信息确定用户身份。 cookie在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。 Web应用程序是使用HTTP协议传输数据的。==HTTP协议是无状态的协议==。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。 什么是cookiecookie其实是存储在浏览器中的纯文本，是服务器发送出来存储在浏览器上的一组组键值对，浏览器的安装目录下会专门有一个cookie文件夹来存放各个域下设置的cookie。 cookie怎么工作 存储cookie是浏览器提供的功能。 若客户端首次请求服务器，浏览器会添加请求头中的 cookie字段为{}，把请求的网址连同该Cookie一同提交给服务器。如果服务器需要记录该用户状态，就向客户端浏览器返回Cookie，客户端浏览器会把Cookie保存起来。 当网页要再次发http请求时，浏览器会先检查是否有相应的 cookie，有则自动把所有这个服务器Cookie添加在 request header中的 cookie字段中，把请求的网址连同该Cookie一同提交给服务器。这些是浏览器自动帮我们做的，而且每一次 http请求浏览器都会自动帮我们做。 服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容 cookie的存放有大小限制，不可以超过4kb, 每一个域名下的cookie数量最多是20个 获取cookiedocument.cookie，只能获取非HttpOnly类型的cookie。 打印出的结果是一个字符串类型，因为 cookie本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value构成，键值对之间由一个 分号和一个 空格隔开。 1key=value; key=value Cookie的不可跨域名性受同源策略限制，跨域的ajax请求默认不携带cookie，那为什么还会有csrf攻击呢？ 12由于script、img、iframe的src都不受同源策略影响，可以利用此来实现跨域请求，来实施攻击。浏览器会依据加载的域名附带上对应域名的cookie 例如，a.com是一个银行网站，用户在此网站登录且生成了授权的cookie，此时浏览器保存了这个cookie。随后访问 b.com，在这个网站中伪造一个请求a网站的请求，如转账、删除操作等，利用script、img、iframe来加载a网站的地址，浏览器就会携带上a网站此登陆用户的授权cookie信息，这样就构成了csrf攻击。 cookie的属性 属性名 数据类型 描述 name String 该Cookie的名称。Cookie一旦创建，名称便不可更改 value Object 该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码 maxAge int 该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1 secure boolean 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false path String 该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/” domain String 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.” comment String 该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明 version int 该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 cookie的修改和删除 服务器可以对cookie进行操作，浏览器只能对非HttpOnly类型的cookie进行操作（为了预防xss攻击）。 Cookie并不提供修改、删除操作。 如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。 注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。 session除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。 session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 什么是session 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。 客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 session对象是在客户端第一次请求服务器的时候创建的。session也是一种key-value的属性对 如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 session的生命周期session保存在服务器端。为了获得更高的存取速度，服务器一般把session放在内存里。每个用户都会有一个独立的session。如果session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，session里的信息应该尽量精简。 session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建session，只访问HTML、IMAGE等静态资源并不会创建session。如果尚未生成session，也可以使用request.getSession(true)强制生成session。 session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。用户每访问服务器一次，无论是否读写session，服务器都认为该用户的Session“活跃（active）”了一次。 为防止内存溢出，服务器会把长时间内没有活跃的session从内存删除。这个时间就是session的超时时间。如果超过了超时时间没访问过服务器，session就自动失效了。tomcat默认失效时间为20分钟。 session对浏览器的要求虽然session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为session需要使用Cookie作为识别标志。HTTP协议是无状态的，session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该session的id（也就是HttpSession.getId()的返回值）。session依据该Cookie来识别是否为同一用户。 如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。 URL地址重写URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户session的id信息重写到URL地址中。服务器能够解析重写后的URL获取session的id。这样即使客户端不支持Cookie，也可以使用session来记录用户状态。 两者区别 cookie数据存放在客户的浏览器上，session数据放在服务器上的，但名为JSESSIONID的Cookie（值为该Session的id）是放在客户端的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型) 两者最大的区别在于生存周期，session是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，cookie是预先设置的生存周期，或永久的保存于本地的文件。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：类数组对象]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类数组对象只包含使用从零开始，且自然递增的整数做键名，并且定义了length表示元素个数的对象。 1234var arr = [1,2,3];var obj = &#123;0: 1, 1: 2, 2: 3, length: 3&#125;;console.log(arr[0], obj[0])//1, 1console.log(arr[&apos;length&apos;], obj[&apos;length&apos;])//3，3 我们可以使用对象来模拟数组，只要我们定义的对象的每个元素的键名都使用数字并且让其保持递增，且动态的定义一个length属性来表示元素个数，那么从效果上来说，基本就和数组相同了。 argumentsarguments就是一个典型的类数组对象，为一个参数集 1234567891011121314151617181920212223242526// 数组function printArr () &#123; return [&apos;ming&apos;,18];&#125;printArr()// 打印结果(2) [&quot;ming&quot;, 18] 0: &quot;ming&quot; 1: 18 length: 2 __proto__: Array(0) // argumentsfunction printArg (name,age) &#123; return arguments;&#125;printArg(&apos;ming&apos;,18)// 打印结果Arguments(2) [&quot;ming&quot;, 18, callee: ƒ, Symbol(Symbol.iterator): ƒ] 0: &quot;ming&quot; 1: 18 callee: ƒ fn(name,age) length: 2 Symbol(Symbol.iterator): ƒ values() __proto__: Object arguments转换为数组1234567function toArr()&#123; var arr = []; for（var i in arguments）&#123; arr.push(arguments[i]); &#125; return arr;&#125; 12345function toArr()&#123; var arr = []; arr = Array.prototype.slice.call(arguments); return arr;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：关于闭包]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包对闭包的理解 闭包是有权访问另一个函数作用域中的变量的一个函数。 简单来说就是定义在一个函数内部的函数。 闭包可以访问到父级函数的变量，且该变量不会销毁。 闭包的原理利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条 闭包的体现闭包只能取得包含函数中的任何变量的最后一个值12345678910111213141516function person ()&#123; var age = 18; function cat()&#123; age ++; console.log(age); &#125; console.log(age) return cat;&#125;person() // 18var p = person(); // p相当于函数cat// 调用时会先在cat函数作用域内查找变量age，没有则顺着作用域链往上查找，找到person中的age// 经过首次调用后cat中存在age变量，这样每次调用都不经过age的初始值，就可以一直增加p() // 19，p()即cat()p() // 20person() // 18，每次调用person函数，进入该作用域，age都会重新赋值为18 闭包的作用 隐藏变量，避免全局污染 可以读取函数内部的变量 闭包的缺点 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。 闭包会导致局部变量能在函数作用域之外被访问，但是这不是变量不可被回收的充分条件，通常情况下是考虑局部变量是否被全局或者一个不可被回收的对象引用了。 闭包被引用后始终在内存中，不会在调用结束后被垃圾回收机制回收，可能会造成内存消耗。12// 释放闭包引用p = null; 闭包的应用场景封装变量为避免全局污染，把变量封装到函数作用域中 循环绑定事件处理函数1234567891011121314151617181920var lis = document.getElementsByTagName(&apos;li&apos;)// 每循环一次给lis添加一个function，最后lis是这样的 lis[function()&#123;&#125;,function()&#123;&#125;,function()&#123;&#125;]// 里面有3个function，在for里面声明了function，但还没有立即执行// 真正执行的时候是当点击li的时候才执行这个函数// 当执行的时候for循环已经结束，i已经变成最后一个取值了，所以每触发一次事件都访问的是等于最后一个取值的ifor(var i=0;i&lt;lis.length;i++)&#123; lis[i].onclick = function()&#123; console.log(i); &#125;; &#125;// 立即执行函数要保护j这个索引值的变量不被污染for(var i=0;i&lt;lis.length;i++)&#123; (function(j)&#123; lis[j].onclick = function()&#123; console.log(j); &#125;; &#125;)(i); //事件处理函数中闭包的写法&#125; 循环打印1234567891011// 定时器中的回调函数是一个在立即执行函数中的闭包，单独的立即执行函数能不能叫做闭包说法各有不同。function fn()&#123; for(var i = 1;i &lt;= 5;i ++)&#123; (function(j)&#123; setTimeout(function () &#123; console.log(j) &#125;, 1000) &#125;)(i); &#125;&#125;fn() // 1 2 3 4 5 拓展垃圾回收机制标记清除工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 工作流程： 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 再被加上标记的会被视为准备删除的变量。 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 引用计数工作原理：跟踪记录每个值被引用的次数。 工作流程： 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1. 当引用次数变成0时，说明没办法访问这个值了。 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。 引起内存泄漏 全局变量 闭包 原因：都是由于不能被回收]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：作用域]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。 全局作用域在代码任何地方都能访问到的对象拥有全局作用域。拥有作用域的情况： 程序最外层定义的函数或变量。 所有未定义直接赋值的变量，相当于在window对象上创建属性。（不推荐） 所有window对象的属性和方法。 局部作用域（函数作用域）局部作用域在函数内创建，在函数内可访问，函数外不可访问。 变量声明js引擎解析js代码时，会先把变量和函数的声明提前进行预解析，然后再去执行其他代码。 直接赋值不会引起变量提升，在执行期间创建，为window的属性，可删除。 函数声明 function name(){}直接创建 new Function构建函数创建 给变量赋值匿名函数方法创建1var name = function()&#123; &#125; 后两者，在声明前访问，返回undefined。函数名与变量名声明时相同，函数优先声明。 作用域链 当代码在一个环境中执行时，一般情况下，会到当前执行环境中访问变量。 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条（即这样逐层的作用域形成的链条）就叫做作用域链。 作用域链是函数被创建的作用域中对象的集合。作用域链保证了对变量和函数的有序访问。 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。 作用域链的前端，始终是当前执行代码所在环境的变量对象。如果当前环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含arguments对象（这个对象在全局环境中不存在）。 全局执行环境的变量对象始终都是作用域链的最后一个对象。 js每一个函数执行时，会先在自己创建的AO上找对应的属性值。若找不到，则往父函数的AO上找，直到找到全局作用域，这样就形成一条作用域链。 VO（变量对象）：函数创建阶段，js解析引擎进行预解析时，所有变量和函数的声明组成VO。 AO（活动对象）：函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，这些变量组成AO。 执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：浅拷贝与深拷贝]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[浅拷贝拷贝对象的内存地址，新旧对象共享同一块内存，修改新对象会导致旧对象也改变。 12345678910var obj = &#123; a: &#123;a:&quot;kobe&quot;,b:39&#125; &#125;;var arr = [&quot;a&quot;,&quot;b&quot;,&#123;name:&quot;kobe&quot;&#125;];//第一种var obj1 = obj;//第二种var obj2 = Object.assign(&#123;&#125;,obj);//当object只有一层时为深拷贝//第三种var arr1 = arr.concat();//第四种var arr2 = arr.slice(); 深拷贝创造一个一模一样的对象，，新旧对象不共享同一块内存，修改新对象不会导致旧对象改变。 递归实现深拷贝123456789101112131415161718192021222324252627282930function clone(target) &#123; var temp; if (target instanceof Array) &#123; temp = []; &#125; else if (target instanceof Object) &#123; temp = &#123;&#125;; &#125; else &#123; return target; &#125; for (var i in target) &#123; temp[i] = clone(target[i]); &#125; return temp;&#125;console.log(clone([&quot;111&quot;, &quot;222&quot;, &#123; a: &quot;1&quot; &#125;, [1, 1]]));console.log(clone(&#123; a: [1, 1], b: &#123; a: &quot;1&quot;, b: &quot;11&quot; &#125;, c: &quot;11&quot;&#125;));console.log(clone(&quot;111&quot;)); JSON.parse(JSON.stringify())123function clone(target)&#123; return JSON.parse(JSON.stringify(target));&#125; 原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。 这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：文件上传]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[获取文件内容1234567&lt;input type=&quot;file&quot; id=&quot;fileUpload&quot;/&gt;document.getElementById(&apos;fileUpload&apos;).onchange = function (e) &#123; var e = e || window.event; // files 为选择的所有文件 var files = e.target.files; &#125; files 为FileList，每一个元素为一个对象，里面包含： lastModified lastModifiedDate name size type webkitRelativePath 获取文件上传进度123456789101112131415161718192021222324252627282930313233343536373839var xhrOnProgress=function(fun) &#123; xhrOnProgress.onprogress = fun; //绑定监听 //使用闭包实现监听绑 return function() &#123; //通过$.ajaxSettings.xhr();获得XMLHttpRequest对象 var xhr = $.ajaxSettings.xhr(); //判断监听函数是否为函数 if (typeof xhrOnProgress.onprogress !== &apos;function&apos;) return xhr; //如果有监听函数并且xhr对象支持绑定时就把监听函数绑定上去 if (xhrOnProgress.onprogress &amp;&amp; xhr.upload) &#123; xhr.upload.onprogress = xhrOnProgress.onprogress; &#125; return xhr; &#125;&#125;function Submit()&#123; var fileObj = document.getElementById(&quot;FileUpload&quot;).files[0]; // js 获取文件对象 var formFile = new FormData(); formFile.append(&quot;file&quot;, fileObj); //加入文件对象 var data = formFile; $.ajax(&#123; url: &quot;http://up.qiniu.com/&quot;, data: data, type: &quot;Post&quot;, dataType: &quot;json&quot;, cache: false,//上传文件无需缓存 processData: false,//用于对data参数进行序列化处理 这里必须false contentType: false, //必须 xhr:xhrOnProgress(function(e)&#123; var percent=e.loaded/e.total; console.log(percent); &#125;), success: function (result) &#123; console.log(result); &#125;, &#125;)&#125; 断点续传指的是在上传/下载时，将任务（一个文件或压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。 它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range Range 1用于请求头中，指定第一个字节的位置和最后一个字节的位置。 Content-Range 1用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。 在响应完成后，返回的响应头内容也不同，根据返回的状态码判断是否使用断点续传 200 Ok（不使用断点续传方式） 206 Partial Content（使用断点续传方式）]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：事件委托]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[概述事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 为什么要用减少DOM操作，优化性能。 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。 原理事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件。 举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 1234567891011121314151617181920212223242526272829&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;window.onload = function()&#123; var oUl = document.getElementById(&quot;ul1&quot;); oUl.onclick = function()&#123; alert(123); &#125;&#125;//改进：只有点击li才会触发window.onload = function()&#123; var oUl = document.getElementById(&quot;ul1&quot;); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125;//target就可以表示为当前的事件操作的dom，但是不是真正操作dom。//这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement， e.target 和 e.currentTarget e.target指向触发事件监听的对象 e.currentTarget指向绑定事件监听的对象]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：__proto__和prototype]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A__proto__%E5%92%8Cprototype%2F</url>
    <content type="text"><![CDATA[__proto__每一个对象都有的属性（在JS里，万物皆对象），指向构造该对象的构造函数的原型。 prototype 每一个方法都有的属性，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。 原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。 方法也是对象，所以方法既有prototype属性又有proto属性 实例对象的proto和其自身构造函数的prototype都是指向构造函数的原型。 123456789101112131415var A = function()&#123;&#125; //A是一个方法，也是一个对象var a = new A() //a是由A创造出来的一个对象，不是方法//对象console.log(a.__proto__); //Objectconsole.log(a.prototype); //undefined,因为a不是方法，没有该属性//方法，也是对象console.log(A.__proto__); //function () &#123; [native code] &#125;console.log(A.prototype); //Objectconsole.log(a.__proto__==A.prototype); //trueconsole.log(a.prototype==undefined); //trueconsole.log(A.__proto__==Function.prototype); //trueconsole.log(A.prototype==a.__proto__); //true]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：基础类型和引用类型]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基础类型 undefined，null，boolean，string，number 在内存中是栈存储，自动分配内存，自动释放 引用类型 array，object，function，date，regExp，特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math) 在内存中是堆存储，动态分配内存，大小不定，不会自动释放]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：数组和链表]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[物理地址存储的连续性 数组的元素在内存中是连续存放的。 链表的元素在内存中不一定是连续存放的，通常是不连续的。 访问速度 数组的访问速度很快，因为数组可以根据数组可以根据下标进行快速定位。 链表的访问速度较慢，因为链表访问元素需要移动指针。 添加、删减元素速度 数组的元素增删速度较慢，因为需要移动大量的元素。 链表的元素增删速度较快，因为只需要修改指针即可。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：正则表达式]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则的三种属性 g：全局匹配 i：忽略大小写（默认区分大小写） m：多行模式 常用方法12let str = &apos;abc&apos;;let reg = /a/gi; test()在字符串中查找符合正则的内容，若找到返回true，否则false 12// 用法：正则.test(字符串)reg.test(str) search()在字符串中搜索符合正则的内容，返回出现的位置，从0开始。若匹配不止一个字符，则返回第一个字符的位置。搜索失败返回-1。 12// 用法：字符串.test(正则)str.test(reg) match()在字符串中搜索符合正则的内容，返回一个数组，里面包含相匹配的内容，失败返回null 12// 用法：字符串.test(正则)str.test(reg) 常用字符非打印字符 字符 描述 \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \d 匹配0-9之间的任意一个数字。等价于[0-9] \D 匹配所有非数字。等价于[\^0-9]，[]中的^代表非、除了 \w 匹配数字、字母、下划线。等价于[0-9a-zA-Z_] \W 匹配所有非数字、字母、下划线。等价于[\^0-9a-zA-Z_] \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 特殊字符 字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次到多次。要匹配 字符，请使用 \。 + 匹配前面的子表达式一次到多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 指明两项之间的一个选择。要匹配 ，请使用 \ 。 限定符 字符 描述 * 匹配前面的子表达式零次到多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次到多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。匹配n 次到多次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，匹配n次到m次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 \b 匹配一个单词边界，即字与空格间的位置。 \B 非单词边界匹配。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：简化运算]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E7%AE%80%E5%8C%96%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[三元运算12345678let type;if(type === &apos;a&apos;) &#123; type = &apos;typeA&apos;;&#125; else if (type === &apos;b&apos;) &#123; type = &apos;typeB&apos;&#125;// 简化let type = type === &apos;a&apos; ? &apos;typeA&apos; : &apos;typeB&apos; 四元运算12345678910let type;if(type === &apos;a&apos;) &#123; type = &apos;typeA&apos;;&#125; else if (type === &apos;b&apos;) &#123; type = &apos;typeB&apos;&#125; else if (type === &apos;c&apos;) &#123; type = &apos;typeC&apos;&#125;// 简化let type = type === &apos;a&apos; ? &apos;typeA&apos; : (type === &apos;b&apos; ? &apos;typeB&apos; : &apos;typeC&apos;)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：this指向]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9Athis%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[普通函数 普通函数被调用时，即运行时，才会确定该函数内this的指向。 this指向调用该函数的对象。 fn() 不带任何引用形式调用函数，this指向全局对象。 严格模式下this为undefined。12345var a = 1;function fn () &#123; console.log(this.a);&#125;fn(); // 1 obj.fn()this指向调用该函数的对象12345678var a = 1;var obj = &#123; a: 2, fn: function () &#123; console.log(this.a); &#125;&#125;obj.fn(); // 2 obj1.obj.fn()这种形式的调用结果一样，函数内的this只指向直接调用该函数的对象（obj）123456789101112var a = 1;var obj = &#123; a: 2, fn: function () &#123; console.log(this.a); &#125;&#125;var obj1 = &#123; a: 3, obj&#125;obj1.obj.fn(); // 2 另一种形式的fn()普通函数的this指向只在调用时确定，在调用前无论经过什么操作都不会改变this的指向。123456789var a = 1;var obj = &#123; a: 2, fn: function () &#123; console.log(this.a); &#125;&#125;var test = obj.fntest(); // 1 拓展的fn() 当setTimeout中的回调函数为普通函数时，回调函数中的this依然是指向全局对象。 当setTimeout中的回调函数为箭头函数时，this指向定义时函数所在作用域的父级作用域的this。（父级为普通函数this指向调用父级的对象，若父级仍为箭头函数，则需要继续往上找） 12345678var a = 1;var obj = &#123; a: 2, fn: function () &#123; console.log(this.a); &#125;&#125;setTimeout(obj.fn); // 1 setTimeout内部 1234function setTimeout (fn,time) &#123; // code... fn(); //没有指明调用的对象，指向全局&#125; fn.call()、fn.apply()、fn.bind()可以改变this的指向 new fn() new这个操作符其实是new一个新对象出来，而fn被称为构造函数，可以在这个构造函数中定义一些将要到来的新对象的一些属性。 在构造函数中就是用this来描述这个即将到来的新对象，所以构造函数中的this就是指向被new出来的新对象。123456var a = 1;function fn (a) &#123; this.a = a;&#125;var b = new fn(2);console.log(b.a); // 2 箭头函数this在定义时就已经确定，指向定义时箭头函数所在的作用域（而不是箭头函数的作用域）的父级作用域的this。 若父级作用域为普通函数，则this指向调用父级函数的对象。 若父级作用域为箭头函数，则this指向父级作用域的父级作用域。 如此往上找，直到全局 首先从它的父级作用域中找，如果父级作用域还是箭头函数，再往上找，如此直至找到this的指向，最后是到window。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：事件模型]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1&lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt; DOM0级事件模型DOM0级事件模型是早期的事件模型，所有的浏览器都是支持的，而且其实现也是比较简单。没有事件流的概念。 事件绑定监听函数直接在dom对象上注册事件1&lt;button onclick=&quot;console.log(&apos;DOM0&apos;)&quot;&gt; 123document.getElementById(&apos;btn&apos;).onclick = function()&#123; console.log(&apos;DOM0&apos;);&#125; 事件移除监听函数解除事件是将null复制给事件函数 1document.getElementById(&apos;btn&apos;).onclick = null; 一个dom对象只能注册一个同类型的函数，因为注册多个同类型的函数的话，就会发生覆盖，之前注册的函数就会无效。 IE事件模型事件流： 事件处理阶段：事件到达目标元素，触发目标元素的监听函数。 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。 事件绑定监听函数1234// attachEvent(&apos;事件名称&apos;,&apos;事件回调&apos;);document.getElementById(&apos;btn&apos;).attachEvent(&apos;onclick&apos;, function()&#123; console.log(&apos;IE&apos;);&#125;); 事件移除监听函数detachEvent(‘要移除的事件名称’,’要移除的函数’); DOM2级事件模型事件流阶段： 事件捕获阶段：事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。 处于目标阶段：事件到达目标元素，触发目标元素的监听函数。 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。 事件绑定监听函数一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。 DOM2事件函数不会覆盖DOM0事件函数。 12345678//addEventListener(&apos;事件名称&apos;,&apos;事件回调&apos;,&apos;捕获/冒泡&apos;)var click = document.getElementById(&apos;btn&apos;);click.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;DOM2 捕获&apos;);&#125;,true);click.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;DOM2 冒泡&apos;);&#125;,false); 第一个参数是事件名称，与DOM0级不同的是没有”on“，另外第三个参数代表是否在捕获阶段进行处理，true代表在捕获阶段进行处理，false代表在冒泡阶段进行处理，默认为false。 事件移除监听函数removeEventListener(‘要移除的事件名称’,’要移除的函数’)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：内存泄漏]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是内存泄露？应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。 编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了，操作系统可以回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。 JavaScript 内存管理JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可 达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。 JavaScript 内存泄露垃圾回收语言的内存泄露主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：ajax]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9Aajax%2F</url>
    <content type="text"><![CDATA[核心XMLHttpRequest，一个js对象，一个构造函数。 方法 open()：准备启动一个AJAX请求； setRequestHeader()：设置请求头部信息； send()：发送AJAX请求； getResponseHeader(): 获得响应头部信息； getAllResponseHeader()：获得一个包含所有头部信息的长字符串； abort()：取消异步请求； 另外，浏览器还为该对象提供了一个onreadystatechange监听事件，大明湖readyState属性改变时，就会触发该事件发送。 为了确保浏览器的兼容性，最好在调用open方法之前指定事件处理程序。 属性 responseText：包含响应主体返回文本； responseXML：如果响应的内容类型时 text/xml或 application/xml，该属性将保存包含着相应数据的XML DOM文档； status：响应的HTTP状态； statusText：HTTP状态的说明； readyState：表示“请求”/“响应”过程的当前活动阶段 拓展 什么是ajax？ajax作用是什么？ 1ajax是用来与后台交互的一种技术。用来实现客户端服务器的异步通信效果，实现页面的局部刷新。 原生js ajax发送http请求需要几个步骤？分别是什么？ 1234567891011121314151617181920//1：创建XMLHttpRequest对象var xhr = new XMLHttpRequest();//2：设置请求参数（请求方式，url，是否异步请求）xhr.open(&quot;GET&quot;,url,false);//3：设置请求头部(也可以不设置)xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);//支持跨域发送cookiexhr.withCredentials = true;//4：发送请求xhr.send(null);//5：设置事件处理程序xhr.onreadystatechange = function()&#123; if(xhr.readystate == 4)&#123; if(xhr.status == 200)&#123; console.log(xhr.responseText); &#125;else&#123; console.log(&quot;出错了&quot;); &#125; &#125;&#125; readyState的取值？ 123450：(未初始化)还没有调用open()方法。1：(启动)已调用open()方法，但send()方法还没调用。2：(发送)send()方法已经调用，请求已发送，但未接收到响应。3：(交互)服务器端发送响应，客户端正在解析响应内容。4：(完成)响应内容解析完成，可以在客户端调用了。 http的请求方法 12345678get：获取服务器中的资源。post：传输实体文本put：传输文件。要指出资源在服务器中的位置。head：获取页面的首部。delete：删除服务器中的某个资源。options：获取当前url所支持的方法。trace：追踪路径。connect：要求用隧道协议连接代理。 get和post的区别 1231. 发送方式：get请求传送的参数放在url上，即http的协议头；post把传送的参数放在http的包体中。2. 大小限制：get传的参数有长度限制；post理论上没有限制。3. 安全性：get请求传送的数据放在url上，会被缓存，请求保存在浏览器的历史记录中；post不能被缓存。 什么情况造成跨域？如何解决？ 123456789受同源策略限制。协议、子域名、主域名、端口号、ip地址、网址，任一不同都为不同源。1. jsonp 只能解决get跨域2. CORS：跨域资源共享，通过设置Access-Control-Allow-Origin来允许跨域（主要后台配置）3. 设置document.domain4. 代理请求解决接口跨域。jsonp通过script标签进行跨域请求①前端设置好回调函数，将回调函数名作为url携带的参数。②后端接到请求后，生成一个函数，函数名为前端传来的回调函数名，数据作为参数传入函数，返回js文档。③客户端解析并执行返回的js文档，将返回的数据传入回调函数执行。 http状态码（status） 状态码 含义 1xx 请求正在被处理 2xx 请求成功被处理 3xx 请求需求附加操作，如重定向 4xx 客户端出错导致请求无法被处理 5xx 服务端处理出错 常用状态码 200 请求成功处理，一切正常 301 永久重定向（新网址替换旧网址，旧网址清零） 302 临时重定向（也是替换，但是旧网址还能参与排名） 304 资源未修改 403 禁止访问 404 页面未找到 405 不允许此请求方法 500 服务器出错 回调函数 1231.一个函数作为参数传递给另一个函数，在功能下载完成后执行，作为参数的函数即为回调函数。2.可用于解决异步。3.典型例子即为ajax请求。 回调地狱 12345当许多功能需要连续调用,环环相扣依赖时。就会产生函数作为参数层层嵌套的一个效果，这就形成回调地狱。使得代码变得难以理解与维护。解决：1.保持代码简短，避免使用匿名函数。2.模块化。将不同功能的代码封装成不同的模块。3.处理每一个错误。为了让代码稳定，永远无法知道这些错误何时发生，所以必须对它们进行计划。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：字符串常用的方法]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[charAt(index) 1返回指定索引的字符。 charCodeAt(index) 1返回指定索引的unicode字符. indexOf(char) 1判断一个字符第一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。对大小写敏感。 lastIndexOf(char) 1判断一个字符最后一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。 concat() (返回一个新字符串) 123456拼接2个字符串，返回一个新字符串，对原有字符串没有任何改变。var str=&apos;qwe&apos;;var str1=&apos;abc&apos;;var str2=str.concat(str1);console.log(str2);//&quot;qweabc&quot; substr(start,number) (不修改原字符串) 1从索引start开始，截取number个字符，将截取的字符返回。start可正可负。 substring(start,end) (不修改原字符串) 1从索引start开始，截取到索引end,不包括end.将截取的字符返回。start,end正值。 slice(start,end) (不修改原字符串) 1从索引start开始，截取到索引end,不包括end。将截取的字符返回。start,end可正可负。 split(“分割符”[,limit]) (返回数组，不修改原字符串) 1用指定字符分割字符串，返回一个数组。默认每个字符都分割。 replace(reg,new) (不修改原字符串) 12345替换指定字符，返回替换后新的字符串，不会对原有字符串有改变。var str=&apos;aaaaee&apos;;var reg=/a/g;str.replace(reg,1); //&quot;1111ee&quot;console.log(str); //&quot;aaaaee&quot; match(reg) (返回一个数组) 1可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。把符合正则表达式的字符放在数组里，返回一个数组。 search(reg) 1方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配字符串的第一个字符的位置。没有匹配的则返回-1。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：递归和非递归实现中序遍历]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树结构1234567891011121314151617181920212223var TreeNode = &#123; val: 1, left: &#123; val: 2, left: &#123; val: 4, &#125;, right: &#123; val: 5 &#125; &#125;, right: &#123; val: 3, left: &#123; val: 6, &#125;, right: &#123; val: 7 &#125; &#125;&#125;;// 中序遍历，左根右// [4, 2, 5, 1, 6, 3, 7] 递归12345678function inOrderRecur (root，list=[]) &#123; if(root !== undefined) &#123; inOrderRecur(root.left,list); list.push(root.val); inOrderRecur(root.right,list); &#125; return list;&#125; 非递归123456789101112131415161718function inOrderUnRecur (root)&#123; var stack = []; var list = []; var head = root; while(stack.length !== 0 || head !== undefined)&#123; while(head !== undefined)&#123; stack.push(head); head = head.left; &#125; if(stack.length !== 0)&#123; head = stack.pop(); list.push(head.val); head = head.right; &#125; &#125; return list;&#125;;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：一些关于date的获取方法]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Edate%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[获知一个月的第一天是星期几123456789101112// 当月// 先获取第一天的时间戳var first = new Date().setDate(1); // 再通过getDay()获取var week = new Date(first).getDay();// 下个月// 先获取年份var year = new Date().getFullYear();// 获取下个月的月份var month = new Date().getMonth() + 2;var week = new Date(year, month-1, 1).getDay(); 获知一个月有多少天123456// 当月,下个月同理// 先获取年份var year = new Date().getFullYear();// 获取月份var month = new Date().getMonth() + 1;var total = new Date(year, month, 0).getDate();]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：不同类型之间的比较与运算]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1234561. 5+&apos;5&apos; // &apos;55&apos;2. 5-true // 43. 5-&apos;2&apos; // 34. &apos;21&apos;&gt;3 // true5. null===undefined // false6. NaN===NaN // false 无论字符串与什么做+运算，最终结果都是拼接而成的字符串 无论数字与什么做-运算，另一方都会被转换成数字进行运算，结果仍为数字 字符串与数字做比较时总会把字符串转换为数字进行比较，当字符串无法转换为数字时，结果总为false ===会进行类型比较，不会进行转换，其余比较均会]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：防抖和节流]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[优化高频率执行js代码 防抖在事件被触发后的某个时间限制内，事件处理函数只执行一次。 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 应用场景：搜索框搜索输入，最后一次输入完再发送请求；手机号、邮箱验证输入检测。 12345678910111213141516function debounce(fn,delay)&#123; var timer; return function()&#123; var _this = this; //取debounce执行作用域的this var args = arguments;//获取传入闭包函数中的参数 //以上两句为了debounce函数最终返回的函数this指向不变（否则指向全局）和依然可以获取参数。 //因为fn有可能需要传参 if(timer)&#123; //当前正在一个计时过程中，又触发相同事件，所以取消计时，重新计时 clearTimeout(timer); &#125; timer = setTimeout(function()&#123; fn.apply(_this,args); //把回调函数应用在这些对象上 &#125;,delay); &#125;;&#125; 缺点：若不断触发同一事件会导致回调函数无法执行 节流每隔一段时间，只执行一次函数 如果短时间内大量触发同一事件，那么函数在执行一次后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。 与防抖相比，多了防止不断触发同一事件而导致不执行回调函数的情况。 应用场景：滚动加载，加载更多或滚到底部监听 123456789101112131415161718192021222324252627282930//第一种：定时器function throttle(fn,delay)&#123; var timer; return function()&#123; var _this = this; var args = arguments; if(timer)&#123; return; &#125; timer = setTimeout(function()&#123; fn.apply(_this,args); timer = null; //在delay后执行完fn后把timer清空 &#125;,delay); &#125;;&#125;//第二种：时间戳function throttle(fn,delay)&#123; var previous = 0; return function()&#123; var _this = this; var args = arguments; var now = new Date(); //若时间差大于间隔时间，就执行回调函数，并更新上一次执行时间 if(now - previous &gt; delay)&#123; fn.apply(_this,args); previous = now; &#125; &#125;&#125; 相同点 都可以使用setTimeout实现 目的都是降低回调执行频率，节省计算资源 不同点 防抖，在一段连续操作结束后，处理回调函数。 节流，在一段连续操作中，每隔一段时间只执行一次回调函数。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：判断一个空对象或空数组]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%88%96%E7%A9%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[判断一个空对象1234567function isEmptyObject(obj)&#123; if(JSON.stringify(obj) == &quot;&#123;&#125;&quot;)&#123; console.log(&quot;是空对象&quot;); &#125;else&#123; console.log(&quot;不是空对象&quot;); &#125;&#125; 判断一个空数组1234567function isEmptyArray(arr)&#123; if(JSON.stringify(srr) == &quot;[]&quot;)&#123; console.log(&quot;是空数组&quot;); &#125;else&#123; console.log(&quot;不是空数组&quot;); &#125;&#125; 1234567function isEmptyArray(arr)&#123; if(arr == false)&#123; console.log(&quot;是空数组&quot;); &#125;else&#123; console.log(&quot;不是空数组&quot;); &#125;&#125; 1234567function isEmptyArray(arr)&#123; if(arr.length == 0)&#123; console.log(&quot;是空数组&quot;); &#125;else&#123; console.log(&quot;不是空数组&quot;); &#125;&#125; 拓展：判断数组12341. Array.isArray(arr)2. arr instanceof Array3. object.prototype.toString.call(arr) === &apos;[object Array]&apos;4. arr.constructor === Array]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：typeof和instanceof]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9Atypeof%E5%92%8Cinstanceof%2F</url>
    <content type="text"><![CDATA[typeof是一个一元运算，放在一个运算数之前，运算数可以是任意类型。返回一个用来表示表达式的数据类型的字符串。一般返回如下结果： number（NaN） string boolean object（对象、数组、null） undefined function instanceof语法：object instanceof constructor用来检测 constructor.prototype 是否存在于参数 object 的原型链上。用于判断一个变量是否某个对象的实例。 可以用来判断一个对象是否为数组 String和Date对象同时也属于Object类型 123456789内部实现方法while(object.__proto__!==null) &#123; if(object.__proto__===constructor.prototype) &#123; return true; break; &#125; object.__proto__ = object.__proto__.proto__;&#125;if(object.__proto__==null) &#123;return false;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：new一个函数发生了什么]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9Anew%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 12345678var obj = new O();var obj = (function()&#123; var obj = &#123;&#125;; //使新对象的__proto__属性指向构造函数的prototype obj.__proto__= O.prototype; //其他赋值语句 return obj;&#125;)();]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：数组去重]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[ES5 123456789function unique(arr)&#123; var temp = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(temp.indexOf(arr[i]==-1)&#123; temp.push(arr[i); &#125; &#125; return temp;&#125; 双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length 将重复值中右侧的值去除，并将指针重新指向该位置 1234567891011function unique(arr)&#123; for(var i=0;i&lt;arr.length-1;i++)&#123; for(var j=i+1;j&lt;arr.length;j++)&#123; if(arr[i]==arr[j])&#123; arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125; ES6 1234function unique(arr)&#123; var temp = [...new Set(arr)]; return temp;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：==和===]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%3D%3D%E5%92%8C%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[都是用来检测两个操作数是否相等 基础类型对于如string、number、null、undefined、boolean等基本数据类型==： 对于同一类型的比较，会直接进行值的比较。 对于不同类型的比较，会先进行类型转换，再进行值的比较。 如果一个是null，一个是undefined，那么相等。 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。 ===： 对于同一类型的比较，会直接进行值的比较。 对于不同类型的比较，结果一定是不相等。即不仅进行值的比较，还要进行类型的比较。 高级类型对于array、object等高级类型，\==和===是没有区别的，都是进行“指针地址”的比较。 基础类型和高级类型==： 将高级类型转换为基础类型，进行值的比较。 12console.log([66]==66); //trueconsole.log([66,1]==66); //false ===： 类型不同，结果一定为不相等。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：图片预加载和懒加载]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[页面加载过程如果页面不是第一次访问，那么可能会出现浏览器缓存现象，在本地调试代码的时候也会遇到这种问题，所以在实在想不通页面为什么没有变化的时候，可以清除一下浏览器的缓存。 如果页面是第一次访问，浏览器向服务器http请求后，服务器返回html文件，在整个页面加载过程中，总的来说是按顺序从上到下执行，这是基于js的单线程机制（浏览器为多进程），但是html和css是并行加载的。 根据 HTML 结构生成 DOM Tree 根据 CSS 生成 CSSOM 将 DOM 和 CSSOM 整合形成 RenderTree 根据 RenderTree 开始渲染和展示 遇到script标签时，会执行并阻塞渲染，因为 Javascript 代码有权利改变DOM树 在浏览器解析页面内容的时候，若页面引用了未加载的图片，就会发送请求获取资源。此时图片还没下载完全，在页面上并不会留下图片的位置，而html不会堵塞，将会继续执行下去。等到有图片请求下载完成，html又会重新渲染页面，将图片显示出来。 为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 预加载 图片等静态资源在使用前提前请求。 资源后续使用可以直接从缓存中加载，提升用户体验。 预加载不是为了减少页面加载时间。 预加载只是提前加载除首轮加载的图片之外以后要用到的图片，比如通过点击等事件才会用到的图片。 css 123#preload-01 &#123; background: url(img1.png); &#125;#preload-02 &#123; background: url(img2.png); &#125;#preload-03 &#123; background: url(img3.png); &#125; 像上面那样写，预加载和页面上其他内容一起加载，还会加长页面的加载时间，用户在点进页面时，等待时间加长，并没有达到我们提高用户体验的目的，我们可以封装一个函数，推迟预加载时间，等页面加载完成后再预加载。123456789101112131415161718192021function preload()&#123; if(document.getElementById)&#123; document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(img1.png)&quot;; document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(img2.png)&quot;; document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(img3.png)&quot;; &#125; &#125; function addLoadEvent(func)&#123; var oldonload = window.onload; if(type window.onload != &quot;function&quot;)&#123; window.onload = func; &#125;else&#123; window.onload = function()&#123; if(oldonload)&#123; oldonload(); &#125; func(); &#125; &#125; &#125; addLoadEvent(preload); 懒加载 仅显示可视区的图片资源，不可见区域的资源暂不请求。 使用懒加载可以减少页面的加载时间。 使用于需要大量图片的页面。 实现要点:将图片的src设为空，或者也可以将所有图片的src设一个底图，当图片还没加载完时，用这张底图来占图片的位置，防止页面结构混乱。再给一个自定义的data-url属性，用来存放图片的真实路径。lazyload属性用来标明哪些图片是需要懒加载。监听滚动事件，只在图片出现在可视区时，才动态地将图片的真实地址赋予图片的src属性。 1234567891011121314151617181920212223242526&lt;img src=&quot;&quot; lazyload=&quot;true&quot; data-url=&quot;1.jpg&quot;/&gt;var viewHeight = document.documentElement.clientHeight;//可视区域的高度function lazyload()&#123; var eles = document.querySelectorAll(&apos;img[data-url][lazyload]&apos;); Array.prototype.forEach.call(eles,function(item,index)&#123; var rect; if(item.dataset.url === &apos;&apos;)&#123;//html5 data 钩子的写法 return; &#125; rect = item.getBoundingClientRect();//getBoundingClientRect()返回一个矩形对象. if(rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight)&#123; !function()&#123;//感叹号表明这是一个函数表达式 var img = new Image(); img.src = item.dataset.url; img.onload = function()&#123; item.src = img.src; &#125; item.removeAttribute(&apos;data-url&apos;); item.removeAttribute(&apos;lazyload&apos;); &#125;() &#125; &#125;)&#125;lazyload();//首屏调用document.addEventListener(&apos;scroll&apos;,lazyload);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：事件循环机制]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6Event%20Loop%2F</url>
    <content type="text"><![CDATA[前言JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码script，setTimeout，setInterval 微任务：Promise.then(new Promise是定义后立即执行的)，process.nextTick(node中) 事件循环 先执行同步任务，同步任务立即执行，对于异步任务则是把函数放进event table中，等到满足触发条件后加载到对应的Event Queue中。 所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。 接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：数组的常用方法]]></title>
    <url>%2F2020%2F05%2F14%2Fjs%2Fjs%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[join(“分隔符”) 1将数组的元素放入一个字符串，默认用逗号为分隔符。 push() 1把参数逐个添加到数组末尾，返回修改后数组长度。 pop() 1从数组末尾移除最后一项，返回移除的项。 shift() 1移除数组中的第一个项并返回该项。 unshift() 1在数组前面添加任意个项，返回数组长度。 reverse() （会修改原数组） 1反转数组的顺序，返回经过排序后的数组，会修改原数组。 sort([function]) （会修改原数组） 123456789参数必须是函数，若无参数则默认按照字母编码（字符编码）的顺序进行排序。会修改原数组。//数字从小到大排序arr.sort(function(a,b)&#123; return a-b;&#125;);//数字从大到小排序arr.sort(function(a,b)&#123; return b-a;&#125;); concat() (不修改原数组) 123连接两个或多个数组。参数可以为具体的值，也可以为数组对象，可以有任意多个。返回当前数组的一个浅拷贝。 slice(start,end) (不修改原数组) 123基于当前数组的一个或多个项创建一个新数组。左闭右开，返回新数组，不影响原数组。没有参数则原数组的浅拷贝。 splice(start,number,new) (会修改原数组) 1删除原数组的一部份成员，并可以在被删除的位置添加入新的数组成员，会修改原数组。返回一个数组，里面包含被删除的项目。 indexOf(search,start) 1返回search首次出现的位置，没有则返回-1。默认从第0位开始。 lastIndexOf(search,start) 1从右往左找，返回search首次出现的位置，没有则返回-1。 includes(value) 1判断一个数组是否包含一个指定的值。 forEach(callback(value,index,array){}[,this]) (不修改原数组) 123对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容，对应的数组索引，数组本身。 map(callback(value,index,array){}[,this]) (不修改原数组) 1对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 filter(callback(value,index,array){}[,this]) (不修改原数组) 1“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 some(callback(value,index,array){}[,this]) (不修改原数组) 1判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 every(callback(value,index,array){}[,this]) (不修改原数组) 1判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 find(callback(value,index,array){}[,this]) (不修改原数组) 1返回数组中满足提供的测试函数的第一个元素的值。 findIndex(callback(value,index,array){}[,this]) (不修改原数组) 1返回数组中满足提供的测试函数的第一个元素的索引。 reduce(function(prev, cur, index, array){}[,初始值])和reduceRight(function(prev, cur, index, array){}[,初始值]) (不修改原数组) 123实现迭代数组的所有项，然后构建一个最终返回的值。前者从第一项开始，后者从最后一项开始。这个函数返回的任何值都会作为第一个参数自动传给下一项。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：垂直水平居中]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9A%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[基于绝对定位要求元素具有固定的高度和宽度123456789&#123; position:absolute; top:50%; left:50%; margin-top:-20px; margin-left:-20px; height:40px; width:40px;&#125; 局限性：不能自适应，边距大小与padding，box-sizing有关 借助calc()函数 1234567&#123; position:absolute; top:calc(50%-20px); left:calc(50%-20px); height:40px; width:40px;&#125; 不需要在偏移量中把元素尺寸写死123456&#123; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; 局限性：ie8不支持 基于Flex布局123456&#123; display:flex; justify-content:center;//使子元素水平居中 align-items:center;//使子元素垂直居中 height:40px;&#125; 局限性：ie7/8不兼容 基于table布局12345&#123; display: table-cell; vertical-align: middle;//使子元素垂直居中 text-align: center;//使子元素水平居中&#125; 局限性：需要额外html标记 基于inline-block12345&#123; display: inline-block; vertical-align: middle;//使元素垂直居中 text-align: center;//使元素水平居中&#125; 只有文字1234&#123; line-height: 24px;//使元素垂直居中 text-align: center;//使元素水平居中&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：line-height]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9Aline-height%2F</url>
    <content type="text"><![CDATA[line-height在应用到一个块级元素时，它定义了该元素中基线之间的最小距离 1234line-height:15px;//行间距为15pxline-height:150%;//行间距=当前的字体尺寸*150%line-height:1.5;//行间距=当前的字体尺寸*1.5line-height:1.5em;//行间距=当前的字体尺寸*1.5（若当前没有设置，继承父元素）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：圣杯布局和双飞翼布局]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9A%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[圣杯布局 header和footer占屏幕全部宽度，高度固定 中间的contaier部分是一个三栏布局 left和right宽度固定，middle自适应填满整个区域；高度为三栏中最大的高度 浮动1234567&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344.header&#123; height:50px; width:100%; border:1px solid black;&#125;// 中间部分center设置100%撑满// 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了.middle&#123; float: left; width: 100%; height:100%; background-color:pink;&#125;// 设置left的 margin-left: -100%;，让left回到上一行最左侧.left &#123; float: left; width: 100px; height: 100%; margin-left: -100%; background: black;&#125;// left回到第一行后，right位于第二行的最左侧// 设置margin-left把right拉回第一行的最右侧.right&#123; float: left; width:100px; height:100%; margin-left: -100px; background-color:black;&#125;// left和right这会把middle给遮住了// 所以这时给外层的container设置 padding，给left和right空出位置.container&#123; height: 300px; padding: 0 100px;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; flex布局1234567&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt; 123456789101112131415161718192021222324252627282930//middle占据除left和right之外的剩余所有空间，并不被遮挡.header&#123; height:50px; width:100%; border:1px solid black;&#125;.container&#123; display: flex; height:300px;&#125;.left&#123; width:100px; height:100%; background-color:black;&#125;.middle&#123; flex:1;//middle占据剩余所有空间 height:100%; background-color:pink;&#125;.right&#123; width:100px; height:100%; background-color:black;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; 绝对定位以上两种dom结构均可1234567891011121314151617181920212223242526272829303132333435.header&#123; height:50px; width:100%; border:1px solid black;&#125;.container&#123; height:300px; position: relative; padding: 0 100px;&#125;.left&#123; position: absolute; top: 0; left: 0; width:100px; height:100%; background-color:black;&#125;.middle&#123; height:100%; background-color:pink;&#125;.right&#123; position: absolute; top:0; right: 0; width:100px; height:100%; background-color:black;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; 双飞翼布局双飞翼布局和圣杯布局几乎一样，区别在于处理middle中被遮挡的部分。 圣杯布局是在三栏布局的父容器中设置padding。 双飞翼布局是在middle中再放一个div用来显示内容，为其设置margin。 123456789&lt;header&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;main&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer&gt;footer&lt;/footer&gt; 1234//使用圣杯布局的浮动和绝对定位时设置，同时把container中的padding去除.main&#123; margin:0 100px;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：选择器]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[选择器优先级从高到低 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。 内联样式，作为style属性写在元素内的样式 id选择器 class带伪类，如 .input:first-child 标签[指定属性]，如 input[type=’file’] 类选择器 标签带伪类，如input:first-child，与5、6按css的顺序排优先级 标签选择器 通配符选择器 属性选择器属性选择器支持正则匹配 选择器 含义 tag[attr] 匹配具有attr属性的所有元素，不考虑它的值 tag[attr=’val’] 匹配attr属性值等于val的所有元素 tag[attr^=’val’] 匹配attr属性值以指定的值val开头的所有元素 tag[attr$=’val’] 匹配attr属性值以指定的值val结尾的所有元素 tag[attr*=’val’] 匹配attr属性值中包含指定的值val的所有元素 tag为标签名 attr为属性 val为属性值 选择器解析 CSS选择器时==从右往左解析==的 尽量少使用不必要的层级关系]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：各种单位]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9A%E5%90%84%E7%A7%8D%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[% padding和margin的%垂直水平方向都是基于父元素的宽度计算px（pixel，像素）是一个虚拟长度单位，是计算机系统的数字化图像长度单位。物理像素（px）设备能控制显示的最小单位逻辑像素（px）又称css像素，浏览器使用的抽象单位，而不是实际存在的设备独立像素（dip或dp）独立于设备的用于逻辑上衡量像素的单位，包括了CSS像素设备像素缩放比（dpr） dpr=物理像素/逻辑像素 1px = (dpr)^2 * dp dpr=ppi/160屏幕像素密度（PPI） 每英寸内有多少个设备像素点（物理像素） PPI越高，像素数越高，图像越清晰 屏幕分辨率（XxY）指屏幕上垂直有x个物理像素，水平有y个物理像素。 屏幕尺寸（x in）指屏幕对角线的长度有x英寸 em（相对长度单位） 子元素字体大小的em是相对于父元素字体大小，如果自身定义了font-size按自身来计算。 元素的width/height/padding/margin用em的话是相对于自身的font-size。 最多取到小数点后三位。 rem（根em） 相对于html元素上字体的大小。 1rem等于html元素上字体设置的大小。 vw、vh 1vw等于视窗宽度的1%。 1vh等于视窗高度的1%。 单位 含义 vw 相对于视图窗口的宽度，视窗宽度为100vw vh 相对于视图窗口的高度，视窗高度为100vh vmin vw和vh中的较小值 vmax vw和vh中的较大值]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：隐藏元素]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9A%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[display:none visibility: hidden opacity: 0 空间占据 display隐藏后不占据空间，会产生回流和重绘 其余两个虽隐藏，但仍占据空间，只会引起重绘 子元素继承 display不会被继承，父元素都不存在了，子元素自然也不会显示 visibility会被子元素继承，可以通过设置子元素visibility为visible使其显示 opacity也会被子元素继承，但不能通过设置子元素opacity为1使其显示 事件绑定 display隐藏后已经不存在了，肯定也无法触发事件 其余两个虽隐藏，但仍存在，可以触发事件 过渡动画transition对display和visibility无效，对opacity有效]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：BFC]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9ABFC%2F</url>
    <content type="text"><![CDATA[BFC定义块级格式化上下文，是指一个独立的块级渲染区域。该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 BFC生成满足下列css声明之一的元素便会生成BFC 根元素或其它包含它的元素 float的值不为none； overflow的值不为visible； position的值不为static； display的值为inline-block、table-cell、table-caption； flex boxes (元素的display: flex或inline-flex)； BFC布局规则 内部的元素会在垂直方向一个接一个地排列，可以理解为是BFC中的一个常规流 元素垂直方向的距离由margin决定，即属于同一个BFC的两个相邻盒子的margin可能会发生重叠 每个元素的左外边距与包含块的左边界相接触(从左往右，否则相反)，即使存在浮动也是如此，这说明BFC中的子元素不会超出它的包含块 BFC的区域不会与float元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 位于不同BFC下的相邻元素之间不会发生margin重叠 BFC的应用解决margin塌陷和margin合并问题 margin塌陷为父子元素都设置margin，只取最大的一个。解决方法为父元素触发bfc，使其遵循bgc渲染规则。 margin合并的原理为它们处于同一个BFC中，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。解决方法为在其中一个元素外面包裹一层容器，并触发容器生成一个BFC（overflow：hidden），使两个元素处于不同的BFC。 解决高度塌陷问题当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。 给父元素设置overflow：hidden可以清除子元素的浮动是应用了BFC的原理：给父元素设置overflow：hidden触发了BFC，形成一个独立的渲染区域，所以内部的元素就不会影响外面的布局，BFC把浮动的子元素的高度当作自己的高度去处理溢出，从外面看起来就是清除了浮动 解决侵占浮动元素的问题当一个元素浮动，另一个元素不浮动时，浮动元素因为脱离文档流，就会盖在不浮动的元素上。 解决方法：不浮动的元素也设为浮动，或者添加overflow：hidden 原理：为不浮动的元素建立BFC环境，BFC不与float box重叠。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：margin塌陷和margin合并]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9Amargin%E5%A1%8C%E9%99%B7%E5%92%8Cmargin%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[margin塌陷 父子嵌套元素在垂直方向的margin,父子元素是结合在一起的,他们两个的margin会取其中最大的值。 正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位。 但由于margin的塌陷,父级相对浏览器定位.而子级没有相对父级定位,子级相对父级,就像坍塌了一样。 体现 红色方块margin-top为100px 现在给里面的小方块设置margin-top:100px，发现两个方块位置没动 而当给里面的小方块设置margin-top:150px，小方块带着大方块往下移动了50px（100和150取了150，里面的小方块依然紧贴大方块最上面） 解决 给父元素设置边框或内边距(不建议使用) 给父元素添加某些条件触发bfc(块级格式上下文),改变父级的渲染规则 position:absolute/fixed display:inline-block; float:left/right overflow:hidden margin合并 标准文档流中，两个兄弟结构的元素在垂直方向上的margin不叠加，是合并的，以较大的为准。 原因是他们处于同一个BFC中。 解决margin塌陷的原理是使两个元素处于不同的bfc中，不同的bfc是不会发生margin塌陷的 解决 给其中一个元素添加盒子div并触发bfc 给两个元素都添加盒子div并触发bfc position:absolute/fixed display:inline-block; float:left/right overflow:hidden]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：等宽的三栏布局]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9A%E7%AD%89%E5%AE%BD%E7%9A%84%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[12345&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; float1234567891011121314151617.box &#123; width: 100%; height: 200px; background: black;&#125;.left, .center, .right &#123; width: 33.33%; height: 100%; float: left; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125; flex1234567891011121314151617.box &#123; width: 100%; height: 200px; background: black; display: flex;&#125;.left, .center, .right &#123; width: 33.33%; height: 100%; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125; table123456789101112131415161718.box &#123; width: 100%; height: 200px; background: black; display: table;&#125;.left, .center, .right &#123; display: table-cell; width: 33.33%; height: 100%; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：position]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9Aposition%2F</url>
    <content type="text"><![CDATA[position:static没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。 position:fixed相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。 一定要设置宽度 position:relative 相对于元素自身正常位置定位，元素在正常的文档流中占位。 当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。 position:absolute 元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。 必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，margin和padding仍能影响其的位置，但脱离文档流，不占据位置，和其他元素形成折叠。 如果top、bottom都未指定，则其顶端将与原文档流位置一致，即垂直保持位置不变。 绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会 绝对定位对象头部超过可视区域会被裁掉。 position:inherit规定应该从父元素继承 position 属性的值。 z-index 如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。 需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：模块化]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[文件结构常见文件结构一个项目的CSS最基本结构通常是下面这样的： base.css common.css pages.css 复杂一点的项目可能是这样分： base.css header.css footer.css sidebar.css forms.css icons.css buttons.css dropdown.css modals.css layout.css index.css user.css admin.css pages.css 如果后期不打算合并CSS的，建议尽可能减少 CSS 文件的数量。 SMACSSSMACSS 的全称叫 Scalable and Modular Architecture for CSS。即可扩展和模块化的CSS架构。 SMACSS将样式分成5种类型：Base，Layout，Module，State，Theme Base: 基础样式表，定义了基本的样式，我们平时写CSS比如reset.css就是属于基础样式表，另外我认为清除浮动，一些动画也可以归类为基础样式。 Layout: 布局样式，用于实现网页的基本布局，搭起整个网页的基本骨架。 Module: 网页中不同的区域有这个不同的功能，这些功能是相对独立的，我们可以称其为模块。模块是独立的，可重用的组件，它们不依赖于布局组件，可以安全的删除修改而不影响其他模块。 State: 状态样式，通常和js一起配合使用，表示某个组件或功能不同的状态，比如菜单选中状态，按钮不可用状态等。 Theme: 主题皮肤，对于可更换皮肤的站点来说，这个是很有必要的，分离了结构和皮肤，根据不同的皮肤应用不同的样式文件。 css选择器命名规则它的每一条规则都是全局的，在 CSS 预处理出现之前，这很容易造成命名上的冲突。 当涉及到多人维护同一段 CSS 代码时，命名的意义表达，也会影响到维护效率。 使用独一无二的规则。命名唯一。 使用简短的命名。 嵌套层级不宜过深，建议控制在3层以内。 BEMBEM是Block，Element，Modifier的缩写。是比较流行的一种 CSS 命名方式。 Block：在BEM的理论中，一个网页是由block组成的，比如头部是个block，内容是block，logo也是block，一个block可能由几个子block组成。 Element：element是block的一部分，具有某种功能，element依赖于block，比如在logo中，img是logo的一个element，在菜单中，菜单项是菜单的一个element Modifier：modifier是用来修饰block或者element的，它表示block或者element在外观或行为上的改变 123456789命名规则如下：.block &#123;&#125;.block__element &#123;&#125;.block--modifier &#123;&#125;例如：.login &#123;&#125;.login__btn &#123;&#125;.login__btn--reset &#123;&#125;.login__btn--confirm &#123;&#125; 下划线（__）被用来区分元素，而用连字符(–)是用来修饰元素的。 SUITSuit起源于BEM，但是它对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：盒模型]]></title>
    <url>%2F2020%2F05%2F14%2Fcss%2Fcss%EF%BC%9A%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[标准模型12盒模型宽高 = margin + border + padding + content元素宽高（元素占据的位置） = content IE盒模型12盒模型宽高 = margin + 元素宽高元素宽高（元素占据的位置） = border + padding + content 修改盒模型（box-sizing）box-sizing content-box：默认属性，标准盒模型 border-box：使元素宽高包括padding和border，内容区的实际宽度会是元素宽高减去border + padding的计算值。（即IE盒模型）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构：树的深度遍历和广度遍历]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[普通树深度遍历先访问根结点，然后遍历左子树接着是遍历右子树。利用堆栈的先进后出。 广度遍历从根开始访问,按照根节点左右顺序访问.每次把同层节点左右孩子访问完毕.再访问下一层，所以用队列的先进先出实现。 二叉树前序遍历根 左 右 中序遍历左 根 右 后序遍历左 右 根]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：XSS和CSRF]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E5%92%8CCSRF%2F</url>
    <content type="text"><![CDATA[XSS攻击（跨站脚本攻击）原理恶意攻击者往web页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中web里面的脚本代码会被执行，从而达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 分类 存储型XSS恶意代码存储在数据库中 反射型XSS恶意代码存储在url中 DOM型XSS取出和执行恶意代码都是浏览器端完成防御开启CSP建立白名单，明确告诉浏览器哪些外部资源可以加载和执行。 设置http header中的Content-Security-Policy 设置meta标签1&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 输入输出过滤前端负责，后端也要做相同的过滤检查，因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。 转义字符转义输入输出的内容，对于引号、尖括号、斜杠进行转义。 cookieweb应用程序在设置cookie时，将其属性设为HttpOnly，这样设置的cookie，js就无法进行读写，就可以预防XSS攻击窃取用户cookie，保护用户cookie信息。 CSRF攻击（跨站请求伪造）原理攻击者通过一些技术手段欺骗用户的浏览器去訪问一个自己以前认证过的站点并运行一些操作。 利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以这么理解：攻击者盗用了你的身份，以你的名义发送恶意请求。 一般发起攻击的是第三方网站。是利用用户的登录凭证，冒用用户信息，不能获取用户的数据。 CSRF攻击是源于WEB的隐式身份验证机制。WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。 分类 get类型可以将get请求嵌入img标签，打开页面自动发送请求。 post类型可以利用自动提交的form表单，访问页面就会自动提交。 链接型需要用户点击链接才会触发。防御post尽量使用post请求，避免get请求。 cookie对cookie设置SameSite属性。该属性表示cookie不随跨域请求发送，可以很大程度减少csrf攻击。 token 用户访问某个表单页面。 服务端生成一个Token，放在用户的Session或者浏览器的Cookie中。 在页面表单附带上Token参数。 用户发送请求时以参数的形式带上本次页面中生成的token，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 仅仅用来防御csrf攻击，当加上xss攻击时，无用 验证码xss和csrf 通常来说csrf是由xss引起的 xss是代码注入问题，csrf是http问题 同源策略同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。 不受同源策略限制的： 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script标签的src属性、img标签、link标签、iframe标签等。 通过标签的方式发起的请求不受同源策略的限制。且发送请求时浏览器会携带对应的cookie。 SQL注入原理通过传入一些特殊字符，从而达到欺骗服务器执行恶意的SQL命令的目的。 如输入特殊的用户名 123456//理想中的输入：admin passwordSELECT * FROM user WHERE username=&apos;admin&apos; AND psw=&apos;password&apos;//特殊用户名：admin&apos; --SELECT * FROM user WHERE username=&apos;admin&apos; --&apos; AND psw=&apos;xxxx&apos;//在SQL中，--是注释后面的内容的意思 防御 严格限制web应用的数据库的操作权限。 后端代码检查输入的数据是否符合预期。 对特殊字符进行转义处理。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统：进程、线程、程序]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[程序只是一组指令的有序集合。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是资源分配的最小单位。 线程是程序执行的最小单位。 一个程序至少一个进程，一个进程至少一个线程。 一个线程只能属于一个进程，但是一个进程可以拥有多个线程 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 多线程处理就是允许一个进程中在同一时刻执行多个任务。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型：json和xml]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Ajson%E5%92%8Cxml%2F</url>
    <content type="text"><![CDATA[json json是一种轻量级的数据交换格式。 兼容性高。 格式简单，易读写。 易于解析。 xml xml是一种扩展标记语言。 可用来标记数据，定义数据类型。 格式统一。 文件庞大，格式复杂。 客户端和服务器端都需要大量代码来解析，导致代码复杂难以维护。]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：计算机网络体系结构]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[TCP/IP体系结构五层协议 应用层（http，ftp） 运输层（TCP，UDP） 网络层（IP） 数据链路层 物理层 四层协议 应用层（http，ftp） 运输层（TCP，UDP） 网际层IP 网络接口层 OSI模型 应用层（HTTP） 表示层 会话层（SSL\TLS） 运输层（TCP，UDP） 网络层（IP） 数据链路层 物理层]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http的header字段]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E7%9A%84header%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[http头 = 通用头 + 请求头 + 响应头 通用头(General)通用头域包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息。 header 含义 Request URL 请求的URL Request Method 请求的方法 Status Code HTTP 状态码 Remote Address 远程IP地址 Referrer Policy 记录了是从哪个链接跳来的 响应头(Response Headers) header 含义 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives/94.html Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic 请求头(Request Headers) header 含义 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：TCP]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9ATCP%2F</url>
    <content type="text"><![CDATA[TCP和UDP 都是运输层协议 tcp有连接，可靠：数据包校验、对失序数据包重排序、丢弃重复数据、应答机制、超时重传、流量控制。 udp无连接，快。只是传输数据，不管服务器是否收到。 TCP拥塞控制防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 慢开始 把初始拥塞窗口cwnd设置为1或2个发送方的最大报文段（SMSS），由小到大逐渐增大发送窗口。每经过一个传输轮次，cwnd加倍。 把拥塞窗口允许发送的报文段都连续发送出去，收到对已发送的最后一个字节的确认，为一个传输轮次，时间为一个往返时间。 拥塞避免 让拥塞窗口缓慢增大，没经过一个往返时间RTT就加1 快重传 让发送方尽早知道发生了个别报文段丢失 快恢复 发送方知道丢失报文段，则不启动慢开始，用快恢复，调整门限值cwnd/2. TCP建立连接——三次握手 客户端发送连接请求报文，将SYN位置设为1 服务器端收到报文后回复ACK+SYN报文。 客户端接收到报文后也向服务器端发送ACK报文，这个报文发送完毕后，完成了三次握手。 通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。 TCP释放连接——四次挥手（断开连接） 客户端向服务器传送断开的请求包。客户端进入FIN_WAIT_1状态。 服务器端确定收到断开的请求，回复ACK报文。客户端进入FIN_WAIT_2状态。 服务器端向客户端FIN报文，请求关闭连接。服务器端进入LAST_ACK状态。 客户端收到FIN报文后，回复ACK报文。客户端进入TIME_WAIT状态。服务器端收到ACK报文就会关闭连接（不然一直处于LAST_ACK状态），客户端没有收到服务器端的回复，证明服务器端已关闭连接，客户端也可以关闭连接了。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9ADNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[迭代+递归 在DNS解析器缓存中查找某主机的ip地址 向其本地域名服务器进行递归查找。 本地域名服务器查不到，就向根域名服务器进行迭代查询。 根域名服务器告诉本地域名服务器，下一步该向顶级域名服务器查找。 本地域名服务器向顶级域名服务器查找。 顶级域名服务器告诉本地域名服务器，下一步该向权限域名服务器查找。 权限域名服务器返回目标主机的ip地址。 本地域名服务器就把ip地址告诉目标主机。]]></content>
  </entry>
  <entry>
    <title><![CDATA[计网：cdn]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Acdn%2F</url>
    <content type="text"><![CDATA[是什么内容分发网络。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 cdn缓存用户浏览器和服务器端之间加入cdn 用户在浏览网站的时候，向服务器请求到资源后，cdn会在本地保存网站中的图片或者js、css等其他文件的副本，通过http响应头中的cache-control字段设置数据缓存时间，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。 再次浏览网站时，客户端浏览器会先向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求,来拉取最新的数据。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http和https]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[关于https用处： 建立一个信息安全通道，来保证数据传输的安全。 确认网站的真实性，防止钓鱼网站。 https就是在http下加入了ssl层，从而保护了交换数据隐私和完整性，提供了对网站服务器身份认证的功能，简单来说就是安全版的http。 http和https的区别 同属于应用层的协议 http协议是运行在tcp之上的，所有传输的内容都是未加密的，也就是明文的。https协议是运行在SSL\TLS之上的，而SSL\TLS协议运行在tcp之上，在http和tcp之间，所有传输的内容都经过加密的，比http更安全。（加密采用对称加密，而密钥的传输利用非对称加密） http默认使用端口80。https默认使用端口443。 https的工作原理 使用HTTPS的url访问服务器，客户端向服务器端请求建立SSL连接。（可以说TLS为SSL的新版本） 服务器收到客户端请求后，会将网站的证书信息（证书包含公钥）传送一份给客户端。 客户端浏览器和服务器端协商信息加密的等级。 客户端浏览器根据协商好的安全等级，建立会话密钥，然后利用网站的公钥加密会话密钥，并传送给服务器。 服务器利用私钥解密会话密钥，并利用会话密钥加密与客户端之间的通信。 非对称密码解密速度比较慢，但比较安全；对称密码解密速度比较快。所以用对称密码加密数据，非对称密码加密对称密钥。 非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http报文结构]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[http报文的产生HTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。 什么是HTTP报文呢？HTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。 报文结构 HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。 报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。 报文首部包括请求行和请求头部。 报文主体主要包含应被发送的数据。 通常，不一定有报文主体。 http请求报文一个HTTP请求报文由请求行、请求头部、空行和请求数据4个部分构成。 请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。12// 该部分位于数据首行，基本格式为：GET /index.html HTTP/1.1 该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。 http响应报文HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。 状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。格式为：1HTTP/1.1 200 OK 状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。 报文首部结构 由首部字段名和字段值构成的，中间用冒号“:”分割。 首部字段格式： 首部字段名:字段值。 类型 通用首部字段：请求报文和响应报文两方都会使用的首部。 请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面性能优化]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2Fweb%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[请求和响应减少http请求。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。 使用CDN加速（缓存）。CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。其本质上是一个缓存，而且将数据（js、css、image等静态资源）缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。 使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓存。 当用户发起访问时，他的访问请求被只能dns定位到最近的缓存服务器，当服务器中没有缓存时，就会去请求最近的服务器中的资源。 利用浏览器缓存通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,将网络资源存储到本地，下次请求资源时，如果命中可直接在本地获取，不需要重新向服务器请求资源 避免重定向。当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。 重定向和404将浪费加载请求。 HTML合理使用内联。脚本和样式，应按需选择内联或者外链。对于访问少、样式和脚本复用少的页面，可以考虑使用内联样式从而减少 HTTP 请求。 但如果页面访问频繁，样式脚本在多个页面经常复用，使用外链则是最优选择。 这样浏览器可以缓存它们，下次加载时可以直接从缓存加载。 减少dom过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）。 优化dom操作 使用事件委托来减少事件处理器的数量 减少重绘和回流 如果需要在 DOM操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 一个一个地操作样式。 删除HTML的默认属性。js优化js。 将所有script标签放置在页面的底部,紧靠 body 关闭标签的上方。因为页面解析生成dom树时遇到script标签会停下去加载执行js。此法可以保证页面在脚本运行之前完成解析。 将脚本成组打包。页面的标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。 由于浏览器渲染机制的设置，gui渲染线程和js引擎互斥，因此js的执行会阻塞dom的解析和渲染以及其他资源的加载。 css将样式表放在头部。css在head中通过link引入下载会阻塞页面的渲染，页面的渲染会等待css解析完生成cssom树，再结合dom树生成渲染树进行渲染。所以最好的做法是把css放在页面的最上面，让浏览器尽快下载css，减少首屏加载时间，避免白屏。 为了浏览器的渲染，能让页面显示的时候视觉上更好。避免某些情况，如：假设你放在页面最底部，则不会阻塞，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果 由于gui渲染机制和js引擎互斥，因此css加载会阻塞js的加载，但是cssom和dom是并行的，css加载并不阻塞dom的解析，也不阻塞其他资源的加载，但两者需要互相配合生成渲染树，因此会阻塞dom的渲染。 优化css，避免css表达式。会导致效率低下。 资源延迟加载图片。不直接给src路径，而是在页面加载完成后用js操作src，减少了页面加载图片的时间。 懒加载在进入可视区域之后在进行请求资源 预加载在静态资源使用前先加载，在使用时可直接在缓存中获取]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些调试小技巧]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E4%B8%80%E4%BA%9B%E8%B0%83%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些常用的快捷键 快捷键 功能 ctrl + o 搜索文件 ctrl + shift + F 在所有文件中搜索特定的文字 ctrl + shift + o 在某个文件中搜索特定的文字 ctrl + G 跳转到某一行 ctrl + L 清除控制台的信息 ctrl + [ / ctrl + ] 标签切换 ctrl + shift + c 审查元素 shift + Enter / sources -&gt; snippets 在控制台编写多行代码 选中，H 显示/隐藏元素 一些常用的功能 通过js代码来设置断点：debugger，或者直接在sources中打断点，查看堆栈，了解函数调用情况 elements的event listeners中可以查看元素事件监听器 选中元素，右击Break on.. -&gt; Attributes Modifications，元素改变时启动断点 开发者工具打开的情况下右击chrome的刷新按钮，可清除缓存并硬重载]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容问题]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[css不同浏览器的标签默认的margin和padding不同 12345//解决*&#123; padding:0; margin:0;&#125; 对于一些新特性，低版本浏览器不兼容，可以用渐进增强或优雅降级。 js阻止冒泡12345678function canclebubble(event)&#123; var event = event||window.event; //兼容火狐 if(event.stopPropagation)&#123; event.stopPropagation(); //标准浏览器 &#125;else&#123; event.cancaleBubble==true; //老ie &#125; &#125; 取消默认事件12345678function stopevent(event)&#123; var event = event||window.event; //兼容火狐 if(event.preventDefault)&#123; event.preventDefault(); //标准浏览器 &#125;else&#123; event.returnValue==false; //老ie &#125; &#125; 注意 event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等； event对象只在事件发生的过程中才有效。 firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。 在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2Fcanvas%2F</url>
    <content type="text"><![CDATA[Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 属性 height width 一个Canvas定义了一个指定尺寸的矩形框1&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 检测浏览器支持由于浏览器对HTML5标准支持不一致，所以，通常在canvas内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略canvas内部的HTML，如果浏览器不支持Canvas，它将显示canvas内部的HTML 123&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;p&gt;Current Price: 25.51&lt;/p&gt;&lt;/canvas&gt; 在使用Canvas前，还需要用canvas.getContext来测试浏览器是否支持Canvas 123456var canvas = document.getElementById(&apos;test-canvas&apos;);if (canvas.getContext) &#123; console.log(&apos;你的浏览器支持Canvas!&apos;);&#125; else &#123; console.log(&apos;你的浏览器不支持Canvas!&apos;);&#125; 方法canvas绘图以左上角的（0， 0）为基准原点1234let canvas = document.querySelector(&apos;#canvas&apos;); // 得到canvas//得到canvas上下文环境let ctx = canvas.getContext(&apos;2d&apos;)//绘制2d图形let gl = canvas.getContext(&quot;webgl&quot;);//绘制3d图形 绘制矩形ctx.rect(x,y,width,height); 创建矩形。 但并不会真正将矩形画出，只能调用stroke() 或 fill()后才会真正作用于画布。 先填充再描边。 可通过canvas.width或canvas.height获取画布的宽度和高度 ctx.fillRect(x,y,width,height) 执行填充操作，绘制一个已填色的、以(x,y)位置为起点、大小为width x height的矩形。 有填充颜色，默认为black。 ctx.fillStyle=””为图形设置填充颜色 ctx.strokeRect(x,y,width,height); 绘制一个不填色、以(x,y)位置为起点、大小为width x height的矩形。 有边框颜色，默认为black。 ctx.strokeStyle=””为图形设置边框颜色 ctx.clearRect(x,y,width,height); 将(x,y)位置大小为width x height的矩形变为透明。 Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 clearRect() 方法。 若canvas设置了背景颜色是不能被清除的，因为那是画布的背景颜色，clearRect清除的是绘制的图形，使绘制的图形变为透明，显现出画布背景色。 绘制复杂形状ctx.lineWidth=x;设置线宽为x，不需要加px ctx.fill();填充图形，可利用fillStyle设置填充颜色 ctx.stroke();绘制图形，可利用strokeStyle设置边框颜色 ctx.beginPath();清除原来的痕迹,绘制图形之前要先调用 ctx.closePath();自动完成闭合 ctx.moveTo(x,y);从(x,y)点开始绘图 ctx.lineTo(x,y);绘图终点为(x,y) ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针) 圆心为(x,y),半径为r 弧度 = Math.PI*角度 设置完弧线，要用moveTo()进行绘制 绘制文本ctx.font = “24px 宋体”设置字体大小、型号 ctx.fillText(“文字内容”,left,top); 绘制实心文字。 left为距画布最左边距离，top为距画布最上边距离。 可通过fillStyke设置文字填充颜色 ctx.strokeText(“文字内容”,left,top); 绘制空心文字。 left与top同上。 可通过strokeStyle设置文字边框颜色。 设置文字阴影这些要在设置文字内容之前设置 ctx.shadowOffsetX = x; x轴偏移量，默认位于元素正下方。 ctx.shadowOffsetY = y; y轴偏移量，默认位于元素正下方。 ctx.shadowBlur = num; 设置模糊系数。默认为0不模糊。 ctx.shadowColor = “”; 设置阴影颜色，同时要设置shadowBlur，否则看不见 用canvas画出一个(0,0)坐标绿色的100x100矩形框，再从(10,10)坐标将50x50的区域变成透明 123456789&lt;canvas id=&quot;test&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var canvas = document.getElementById(&quot;test&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.fillStyle = &quot;green&quot;;ctx.fillRect(0,0,100,100);ctx.clearRect(10,10,50,50);&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面渲染过程（输入一个url）]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%EF%BC%89%2F</url>
    <content type="text"><![CDATA[输入一个url到网页呈现 输入网址 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址。 与web服务器建立TCP连接 浏览器向web服务器发送http请求 web服务器响应请求，并返回指定url数据 浏览器下载web服务器返回的数据。 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件 CSS 文件下载完成,解析 CSS 文件生成cssom树，调用JS执行引擎执行JS代码，然后将DOM树和CSSOM树结合生成渲染树。 根据渲染树来布局，计算每个节点的布局信息，将各个节点绘制到屏幕上来渲染页面，直至显示完成。 若dom树生成过程中遇到script标签，则暂停，执行js直至完成再继续生成。 若执行js时需要操作cssom，还得等css加载执行完生成cssom才能继续执行。 因此，css资源要先于js资源加载，js放于页面底部，尽量少影响dom树的生成 各种拓展页面加载白屏原因： 在弱网络下，网络延迟，JS加载延迟，会阻塞页面。 客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html。 如果页面完全一片空白。极有可能是后端出现问题，后端配置无错误输出，并且服务状态500，这个时候页面就是一片空白。如果是前端导致的，那么极有可能是单页应用异常，比如到了一个没有设置的新的页面。1、打开能看到源码和request、response的浏览器，如chrome，查看源码输出2、如果是后端问题，那么后端查看accesslog、程序日志，看看是否有问题3、如果是前端问题，那么根据给出的js异常之类的排查 统计白屏数量：监听某个主div的变化，在规定时间内该DIV没有变化，那就可以进行白屏统计了。 监控白屏时间：监听某个主div的变化，直至页面渲染。 优化：尽量减少文件夹的嵌套，文件名不要过长。 一个网站很卡找原因首先用3g网络测试一下：如果卡就是http请求数据可能过大。可以合并JS脚本和CSS文件，css精灵图，对HTTP传输进行gzip压缩。css放顶部，javascript放底部。 可能服务端出问题：比如用户访问量大，并发量大。mysql没有优化好，造成死锁。 可以用CDN加速把数据放在离用户更近的位置。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端SEO（搜索引擎优化）和语义化]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AFSEO%EF%BC%88%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%EF%BC%89%E5%92%8C%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[合理的title、description、keywords title值强调重点，要靠前，不同页面title不要相同。 description对页面内容高度概括，长度合适，不同页面有所不同。 keywords列举重点关键词即可，不要过分堆砌关键词。 语义化语义化的标签，旨在让标签有自己的含义，就是用合理、正确的标签来展示内容，比如h1~h6定义标题。 优点 易于用户阅读，css样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 常见语义化标签12345678910111213141516171819202122&lt;title&gt;：页面主体内容。&lt;hn&gt;：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。&lt;ul&gt;：无序列表。&lt;li&gt;：有序列表。&lt;small&gt;：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。&lt;strong&gt;：和 em 标签一样，用于强调文本，但它强调的程度更强一些。&lt;em&gt;：将其中的文本表示为强调的内容，表现为斜体。&lt;mark&gt;：使用黄色突出显示部分文本。&lt;figure&gt;：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。&lt;figcaption&gt;：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。&lt;cite&gt;：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。&lt;blockquoto&gt;：定义块引用，块引用拥有它们自己的空间。&lt;q&gt;：短的引述（跨浏览器问题，尽量避免使用）。&lt;time&gt;：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。&lt;abbr&gt;：简称或缩写。&lt;dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。&lt;address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。&lt;del&gt;：移除的内容。&lt;ins&gt;：添加的内容。&lt;code&gt;：标记代码。&lt;meter&gt;：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）&lt;progress&gt;：定义运行中的进度（进程）。 h5新增语义化标签1234567&lt;header&gt; 定义文档或者文档的部分区域的页眉&lt;nav&gt; 描述一个含有多个超链接的区域&lt;main&gt; 定义文档的主要内容，该内容在文档中应当是独一无二的&lt;article&gt; 表示文档、页面、应用或网站中的独立结构&lt;aside&gt; 表示一个和其余页面内容几乎无关的部分&lt;footer&gt; 定义最近一个章节内容或者根节点元素的页脚&lt;section&gt; 表示文档中的一个区域（或节），比如，内容中的一个专题组。 重要内容的html代码放最前搜索引擎抓取html的顺序是从上到下，保证重要内容一定会被抓取 重要内容不要用js输出爬虫不会执行js获取内容 提高网站速度网站速度也是搜索引擎排序的一个重要指标]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素、块元素、行内块元素]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E5%85%83%E7%B4%A0%E3%80%81%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[行内元素 设置宽高无效。 margin水平方向有效，垂直方向无效。 padding水平方向有效，垂直方向在显示上有效果即会增大元素的内容范围，但对其他元素无影响。 不会自动进行换行。 123456789101112131415161718常见行内元素a - 锚点b - 粗体(不推荐)big - 大字体br - 换行em - 强调font - 字体设定(不推荐)i - 斜体img - 图片input - 输入框label - 表格标签select - 项目选择small - 小字体文本span - 常用内联容器，定义文本内区块strong - 粗体强调textarea - 多行文本输入框u - 下划线var - 定义变量 块元素 能够识别宽高。 margin和padding的上下左右均对其有效。 可以自动换行。 多个块状元素标签写在一起，默认排列方式为从上至下。 12345678910111213141516171819常见块元素address - 地址enter - 居中对齐块dir - 目录列表div - 常用块级容器，也是css layout的主要标签dl - 定义列表form - 交互表单h1 - 大标题h2 - 副标题h3 - 3级标题h4 - 4级标题h5 - 5级标题h6 - 6级标题hr - 水平分隔线menu - 菜单列表ol - 排序表单p - 段落table - 表格ul - 非排序列表（无序列表） 可变元素可变元素由上下文语境来决定是块元素还是内联元素 1234567button - 按钮del - 删除文本iframe - inline frameins - 插入的文本map - 图片区块（map）object - object对象script - 客户端脚本 行内块元素 不自动换行 能够识别宽高 默认排列方式为从左到右 三者转换使用display属性能够将三者任意转换： display:inline;转换为行内元素 display:block;转换为块状元素 display:inline-block;转换为行内块状元素]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回流（Reflow）和重绘（Repaint）]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E5%9B%9E%E6%B5%81%EF%BC%88Reflow%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98%EF%BC%88Repaint%EF%BC%89%2F</url>
    <content type="text"><![CDATA[浏览器渲染解析HTML，生成DOM树，解析CSS，生成CSSOM树。将DOM树和CSSOM树结合，生成渲染树（Render Tree）。 回流当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。 每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。 重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 回流必定触发重绘，而重绘不一定触发回流。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2FWebSocket%2F</url>
    <content type="text"><![CDATA[长连接和短连接长连接是存在于网络层的一种连接状态，而实现它则需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。 http http1.0不支持长连接，http1.1支持长连接 http1.x是文本协议，http2.0是二进制协议 HTTP作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于’Keep-Alive’请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。 短连接所谓短连接，即连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。 长连接长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。 轮询 所谓轮询，即是浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息这样一个机制。 然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 只要有请求的的地方，都可以实现轮询，譬如各种事件驱动模型。它的长短是在于某次请求的返回周期。 短轮询短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。 长轮询而长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。 由上可以看到，长短轮询的理想实现都应当基于长连接，否则若是循环周期太短，那么服务器的荷载会相当重；当然，即便是在长连接下，访问人数过多，长短轮询都有可能造成服务器的瞬时访问量庞大，这就需要一些相应的优化实践了。 websocket WebSocket是HTML5新增的一种在单个 TCP 连接上进行全双工通讯的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 为什么http不能实现这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。 用轮询是可以实现的，但这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。 websocket实现WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。 实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。 创建websocket连接首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下： 1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址； 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 安全的websocket安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染机制]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程和线程 进程时cpu资源分配的最小单位，是能拥有资源和独立运行的最小的单位。 线程是cpu调度的最小单位，是建立在进程基础上的一次程序运行单位。 对于操作系统来说，一个任务就是一个进程，一个进程至少有一个线程 浏览器的多进程架构 主进程负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。 第三方插件进程每种类型的插件对应一个进程,仅当使用该插件时才创建。 GPU 进程最多只有一个,用于 3D 绘制等 渲染进程称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。 渲染进程浏览器的渲染进程是多线程的 GUI 渲染线程 负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。 JS 引擎线程 Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎） JS 引擎线程负责解析 Javascript 脚本，运行代码。 JS 引擎一直等待着任务队列中任务的到来,然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解,JS 引擎自己都忙不过来，需要浏览器另开线程协助） 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行） 定时触发器线程 传说中的 setInterval 与 setTimeout 所在线程 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中，等待 JS 引擎空闲后执行） 注意，W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。 异步 http 请求线程 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。 题目1. 为什么 Javascript 要是单线程的 ? 如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。 如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源, 假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。 当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。 2. 为什么 JS 阻塞页面加载 ? 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。 3. css 加载会造成阻塞吗 ？ CSS 加载不会阻塞 DOM 的解析，会阻塞 Dom 的渲染 DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。 然而,由于 渲染树 是依赖于 DOM树 和 CSSOM树 的,所以他必须等待到 CSSOM树 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。因此,CSS 加载会阻塞 Dom 的渲染。 css 会阻塞后面 js 的执行。 由于 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行。 4. DOMContentLoaded 与 load 的区别 ? 当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。 当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。 当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。 DOMContentLoaded -&gt; load 5. defer 和 async 的区别 ? 没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。 有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。 总结 defer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析），差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，它是按照加载顺序执行脚本的；async 则是乱序执行的，反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行 仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：青蛙跳台阶和斐波那契数列]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E5%92%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[简单一次跳一层或两层，求跳上一个n级的台阶总共有多少种跳法。因为n级台阶，第一步有n种跳法：跳1级、跳2级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2) f(0)=0f(1)=1f(2)=2f(n)=f(n-1)+f(n-2) 1234567891011function jump(n)&#123; if(n==0)&#123; return 0; &#125;else if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 2; &#125;else&#123; return jump(n-1)+jump(n-2); &#125;&#125; 复杂一次可以跳上1级台阶，也可以跳上2级……也可以跳上n级。求跳上一个n级的台阶总共有多少种跳法。因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2)所以f(n)=f(n-1)+f(n-2)+…+f(1)因为f(n-1)=f(n-2)+f(n-3)+…+f(1)所以f(n)=2*f(n-1) 123456789function jumpII(number)&#123; if(number == 0)&#123; return 0; &#125;else if(number == 1)&#123; return 1; &#125; return 2*jumpII(number-1)&#125; 斐波那契数列斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…… 性能优化之缓存 缓存: 存储数据的容器(cache) 在js中, 可以使用数组或者是对象进行存储数据,用键存储值,这样就可以实现既能存值也能取值 用缓存的基本思路 创建一个空对象，作为缓存的容器。 首先去缓存容器中查看缓存中是否有对应的数据，如果有，直接取出来使用。 如果没有，就先计算结果，然后把结果存储到缓存容器中，方便下次复用。123456789101112131415161718var cache = &#123; &#125;;var count = 0;function fib(n)&#123; count++; if(n === 1 || n === 2)&#123; return 1; &#125; if(cache[n])&#123; return cache[n]; &#125;else&#123; var ret = fib(n - 1) + fib(n - 2); cache[n] = ret; return ret; &#125;&#125;console.log(fib(10));console.log(&quot;fib函数调用的次数 &quot; + count); 总结 缓存: 存数据(该案例中,用键存月份,值存的对数) 在js中,缓存中如何表示, 对象 || 数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二进制转十进制]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[解法一按权相加1234567function toDecimal(str)&#123; var res = 0; for(var i=str.length-1;i&gt;=0;i--)&#123; res = str[i]===&apos;1&apos; ? Math.pow(2,str.length-1-i) + res : res; &#125; return res;&#125; 123456789function toDecimal(str)&#123; var res = 0; var temp = 1; for(var i=str.length-1;i&gt;=0;i--)&#123; res = str[i]===&apos;1&apos; ? res + temp : res; temp *= 2; &#125; return res;&#125; 解法二parseInt 的第二个参数表示要解析的数字的基数123function toDecimal(str)&#123; return parseInt(str,2);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：多层数组转化为一层]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A4%9A%E5%B1%82%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%B8%80%E5%B1%82%2F</url>
    <content type="text"><![CDATA[题目给定一个数组，将多层数组转化为一层。 注意，数组元素不一定是数字，有可能为对象或字符串。 测试用例121. [&apos;1&apos;,[2,3],-1] // [&apos;1&apos;,2,3,-1]2. [&apos;1&apos;,[2,3],&#123;a:-1&#125;] // [&apos;1&apos;,2,3,&#123;a:-1&#125;] 解法思路 遍历数组，取出元素放入新数组，若元素为数组则递归取出 算法123456789101112131415/** * @param &#123;array&#125; arr * @param &#123;array&#125; res * @return &#123;array&#125; */var flatten = function (arr, res) &#123; for(let i in arr) &#123; if(arr[i] instanceof Array) &#123; test(arr[i],res) &#125; else &#123; res.push(arr[i]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：两数相加为0]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E4%B8%BA0%2F</url>
    <content type="text"><![CDATA[2数相加为0题目给定一个不重复的数字数组，找出该数组中两个数之和等于0的所有情况。 测试用例121. [1,2,3,-1] // [[1,-1]]2. [1,2,3,-3,-1] // [[1,1],[3,-3]] 解法思路 数组长度少于2则直接返回 取数组首元素，与剩余元素比较是否相加为0，若为0取该值，拼接为数组，否则undefined 递归剩余元素，将得到的返回值拼接，对于undefined的值不拼接 算法123456789101112131415161718192021222324252627/** * @param &#123;array&#125; arr * @return &#123;array&#125; */var addUpToZero = function (arr) &#123; if(arr.length &lt; 2) &#123; return; &#125; var left = arr.splice(0,1)[0]; var right, res; for(let i in arr) &#123; if(left + arr[i] === 0) &#123; right = arr.splice(i,1)[0]; &#125; &#125; if(right) &#123; res = [left, right]; &#125; var next = test(arr); if(res &amp;&amp; next)&#123; return [res].concat(next); &#125; else if (res) &#123; return [res]; &#125; else if (next) &#123; return next; &#125;&#125; n数相加为sum题目给定一个无序数组，找出该数组中n个数之和等于0的所有情况。 测试用例121. [1,2,3,-3,-1],2 // [[1,-1],[3,-3]2. [1,2,0,-1],3 // [[1,0,-1]] 解法思路算法12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：验证回文串]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 测试用例121. &quot;A man, a plan, a canal: Panama&quot; // true2. &quot;race a car&quot; // false 解法思路 先判空字符串 对非空字符串，先用正则把除字母和数字之外的字符去除，再全部转换为小写字母 把字符串分割为数组，翻转，再拼接为字符串，与原字符串进行对比 算法1234567891011121314/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isPalindrome = function(s) &#123; if(s === &apos;&apos;) &#123; return true; &#125; s = s.replace(/[^0-9a-zA-Z]/g, &apos;&apos;).toLowerCase(); if(s === s.split(&apos;&apos;).reverse().join(&apos;&apos;))&#123; return true; &#125; return false;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：有效的括号]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 测试用例123451. &quot;()&quot; // true2. &quot;()[]&#123;&#125;&quot; // true3. &quot;(]&quot; // false4. &quot;([)]&quot; // false5. &quot;&#123;[]&#125;&quot; // true 解法一思路 使用字符串的replace方法进行匹配替换，直到全部匹配成功，字符串长度为0，返回true 或直到没有相匹配的项，匹配前的字符串与匹配后的字符串相等，则返回false 算法12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; if(s.length === 0) &#123; return true; &#125; while(s.length !== 0) &#123; var temp = s; s = s.replace(&apos;()&apos;,&apos;&apos;); s = s.replace(&apos;[]&apos;,&apos;&apos;); s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;); if(s === temp) &#123; return false; &#125; &#125; return true;&#125;; 解法二思路 构造哈希表，遍历字符串 对于左括号，把相应的右括号放进栈里 对于右括号，若与栈顶匹配，则把栈顶去除；若是不匹配，则往栈顶添加undefined，为了防止开头就是右括号的情况 算法1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; var map = &#123; &apos;(&apos;: &apos;)&apos;, &apos;[&apos;: &apos;]&apos;, &apos;&#123;&apos;: &apos;&#125;&apos; &#125; var stack = []; for(let i in s) &#123; if(s[i] !== stack[stack.length-1]) &#123; stack.push(map[s[i]]) &#125; else &#123; stack.pop(); &#125; &#125; return stack.length === 0 ? true : false;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：罗马数字转整数]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 测试用例123451. &quot;III&quot; // 32. &quot;IV&quot; // 43. &quot;IX&quot; // 94. &quot;LVIII&quot; // 58 解释: L = 50, V= 5, III = 35. &quot;MCMXCIV&quot; // 1994 解释:M = 1000, CM = 900, XC = 90, IV = 4 解法思路 根据题目中的所有情况写出哈希表 先匹配特殊情况，由于是匹配两个字符串，所以应考虑到最后一个字符串没有下一个的情况，所以先判断是否到最后了 若匹配，直接加，并使指针跳过这两个字符串 若不匹配，则直接得出该字符串的值，指针正常指向下一个 算法12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123; var map = &#123; I: 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400, D: 500, CM: 900, M: 1000 &#125; var res = 0; for(let i=0;i&lt;s.length;i++) &#123; if(i+1 &lt; s.length &amp;&amp; map[s.substr(i,2)]) &#123; res += map[s.substr(i,2)]; i++; &#125; else &#123; res += map[s.substr(i,1)]; &#125; &#125; return res;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：如何找出单链表中的倒数第k个元素]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。 优化：设置两个指针p1和p2，p1在p2前，两者相差k-1个节点，当p1指向null时，p2刚好指向目标元素。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题（一）]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 123456789101112131415var reverse = function(x) &#123; var arr = x.toString().split(&apos;&apos;); if(arr[0]==&apos;-&apos;)&#123; var temp = arr.slice(1,arr.length); temp.reverse().unshift(&quot;-&quot;); x = parseInt(temp.join(&apos;&apos;)); &#125;else&#123; x = parseInt(arr.reverse().join(&apos;&apos;)); &#125; if(x&gt;=-Math.pow(2,31)&amp;&amp;x&lt;=Math.pow(2,31))&#123; return x; &#125;else&#123; return 0; &#125;&#125;; 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 123456789101112131415161718192021var longestCommonPrefix = function(strs) &#123; var str=&quot;&quot;; if(strs.length == 1)&#123; str = strs[0]; &#125;else if(strs.length &gt;= 2)&#123; for(var i=1;i&lt;=Math.min(strs[0].length,strs[1].length);i++)&#123; if(strs[0].slice(0,i)==strs[1].slice(0,i))&#123; str = strs[0].slice(0,i); continue; &#125;else&#123; break; &#125; &#125; for(var j=2;j&lt;strs.length;j++)&#123; while(str!=&quot;&quot;&amp;&amp;strs[j].substr(0,str.length)!=str)&#123; str = str.slice(0,str.length-1); &#125; &#125; &#125; return str;&#125;; 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。即先开的后闭合。 123&quot;([)]&quot; //false&quot;&#123;[]&#125;&quot; //true&quot;&quot; //true 注意空字符串可被认为是有效字符串。 123456789101112131415161718var isValid = function(s) &#123; var temp = []; for(var i in s)&#123; if(s[i]==&quot;(&quot;)&#123; temp.push(&quot;)&quot;); &#125;else if(s[i]==&quot;[&quot;)&#123; temp.push(&quot;]&quot;); &#125;else if(s[i]==&quot;&#123;&quot;)&#123; temp.push(&quot;&#125;&quot;); &#125;else if(s[i]!=temp.pop())&#123; return false; &#125; &#125; return !temp.length; //只开不闭temp.length为true //空字符串temp.length为false //其余有效字符串temp会被移除空&#125;; 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 12345678var searchInsert = function(nums, target) &#123; for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]&gt;=target)&#123; return i &#125; &#125; return nums.length;&#125;; 给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 123456789101112var lengthOfLastWord = function(s) &#123; var len = s.length; var count = 0; while(len!=0&amp;&amp;s[len-1]==&quot; &quot;)&#123; len--; &#125; while(s[len-1]!=&quot; &quot;&amp;&amp;len&gt;0)&#123; count++; len--; &#125; return count;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：把十六进制的ip地址转换为十进制的]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8A%8A%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%2F</url>
    <content type="text"><![CDATA[12345678910function change(ip)&#123; var temp = []; for(var i=0;i&lt;ip.length;i+=2)&#123; temp.push(ip.substr(i,2)) &#125; return temp.map(function(value)&#123; return parseInt(value,16); &#125;).join(&quot;.&quot;);&#125;console.log(change(&quot;C0A80000&quot;)); //&quot;192.168.0.0&quot; 拓展 12345在ip地址中，8位二进制取一个.且二进制的4位对应十六进制的1位因此8位二进制对应一个十进制整数2位十六进制对应一个十进制整数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：快速排序]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序分为交换排序、选择排序、插入排序、归并排序、基数排序快速排序和冒泡排序数据交换排序 首先，定义一个quickSort函数，它的参数是一个数组。 123function quickSort(arr)&#123; &#125; 然后，检查数组的元素个数，如果小于等于1，就返回。 12345function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125;&#125; 接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。 123456789function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = [];&#125; 然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于等于基准的元素放入右边的子集。 12345678910111213141516function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125;&#125; 最后，使用递归不断重复这个过程，就可以得到排序后的数组。1234567891011121314151617function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125; 优化：选一个好的基准：随机选取三个数，排序取中 时间复杂度：nlogn]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C：冒泡法和选择法]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2FC%EF%BC%9A%E5%86%92%E6%B3%A1%E6%B3%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡法算法示例用起泡法对10个整数按升序排序。 算法分析如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。 算法源代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt; int main() &#123; int a[10],i,j,t; printf(&quot;Please input 10 numbers: &quot;); /*输入源数据*/ for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); /*排序*/ for(j=0;j&lt;9;j++) /*外循环控制排序趟数，n个数排n-1趟*/ for(i=0;i&lt;9-j;i++) /*内循环每趟比较的次数，第j趟比较n-j次*/ if(a[i]&gt;a[i+1]) /*相邻元素比较，逆序则交换*/ &#123; t=a[i]; a[i]=a[i+1]; a[i+1]=t; &#125; /*输出排序结果*/ printf(&quot;The sorted numbers: &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\n&quot;); return 0; &#125; 选择法算法示例要求用选择法对10个整数按降序排序。 算法分析每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。 算法源代码12345678910111213141516171819202122#include &lt;stdio.h&gt; int main() &#123; int a[10],i,j,k,t,n=10; printf(&quot;Please input 10 numbers:&quot;); for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=0;i&lt;n-1;i++) /*外循环控制趟数，n个数选n-1趟*/ &#123; k=i; /*假设当前趟的第一个数为最值,记在k中 */ for(j=i+1;j&lt;n;j++) /*从下一个数到最后一个数之间找最值*/ if(a[k]&lt;a[j]) /*若其后有比最值更大的*/ k=j; /*则将其下标记在k中*/ if(k!=i) /*若k不为最初的i值，说明在其后找到比其更大的数*/ &#123; t=a[k]; a[k]=a[i]; a[i]=t; &#125; /*则交换最值和当前序列的第一 个数*/ &#125; printf(&quot;The sorted numbers: &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\n&quot;); &#125; 区别：（个人见解） 冒泡法要进行对n个数进行n-1趟，第j趟要进行n-j次比较，每次比较相邻的数不符合则要交换，每趟最多需要n-j次数的交换 选择法也要进行n-1趟，每趟是选出最值，而选最值是把下标交换，直到选出最值的下标，把最值和第一位交换，每趟最多仅需1次数的交换 简单地说，冒泡法每次都是数的交换（各个下标对应的数是变化的），而选择法是通过下标交换（这时候各个下标对应的数是不变的）选出最值的下标，最后再进行数的交换]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：apply、call和bind]]></title>
    <url>%2F2020%2F03%2F17%2FES6%2FES6%EF%BC%9Aapply%E3%80%81call%E5%92%8Cbind%2F</url>
    <content type="text"><![CDATA[都是为了改变某个函数运行时的上下文，即改变函数里的this的指向。将一个函数应用在其他对象上。 第一个参数要绑定给this的值，为nul或undefined时指向window。 apply、call绑定后会立即调用，bind绑定后不会立即调用。 apply第二个参数为数组，call后面为参数列表。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：let和const]]></title>
    <url>%2F2020%2F03%2F17%2FES6%2FES6%EF%BC%9Alet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[let是定义变量 const是定义常量。若定义基本数据类型，则不能再次改变；若定义复杂数据类型，如对象，则可以修改或者添加属性，但指针是不会变的。 let和const都不会变量提升，在声明之前使用会形成死区。 使用babel工具将es6转换为es5]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：箭头函数]]></title>
    <url>%2F2020%2F03%2F17%2FES6%2FES6%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[箭头函数体内的this对象是定义时所在的对象，而不是使用时所在的对象。 this指向调用箭头函数外层函数的对象（即箭头函数所在作用域的父级作用域），没有外层函数则指向window。 箭头函数相当于匿名函数。 箭头函数不可以当作构造函数，即不可以用new命令。 箭头函数不可以使用arguments对象，该对象在函数体内不存在。要用，就用rest参数代替。 箭头函数的this指向其上下文的this，通过call、apply也无法修改其指向。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：promise]]></title>
    <url>%2F2020%2F03%2F17%2FES6%2FES6%EF%BC%9Apromise%2F</url>
    <content type="text"><![CDATA[一句话概述什么是promisePromise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。 为什么用promise用于异步操作，除了promise还可以用异步回调解决异步操作。 那为什么有异步回调还要promise，promise可以多重链式调用，可以避免层层嵌套回调。可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。 注意 Promise在生命周期内有三种状态，分别是pending、fulfilled 和 rejected。 状态改变只能是pending-&gt;fulfilled(成功)，或者pending-&gt;rejected(失败)。而且状态一旦改变，就不能再次改变。 Promise中调用resolve或reject并不会终结 Promise 的参数函数的执行。 Promise的构造函数中代码是同步执行的，但是then方法是异步执行的，then方法需要等到resolve函数执行时才得到执行。 reject 和 catch 的区别 在resolve中发生异常的话，在reject中是捕获不到这个异常的。.then中产生的异常能在.catch中捕获 如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误。且catch之前的函数都不会执行。 每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据。 在异步回调中抛错，不会被catch到。 promise状态变为resolve或reject，就凝固了，不会再改变。 Promise一旦执行了resolve函数后，就不会再执行reject和其他的resolve函数了。一旦Promise执行了reject函数，将会被catch函数捕获，执行catch中的代码。 如何处理异步 promise 回调函数 12345678function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000);&#125;// 执行f1(f2) 发布订阅 事件监听 async/await 一个简单的promise对象12345new Promise(test).then(function (result) &#123; console.log(&apos;成功：&apos; + result);&#125;).catch(function (reason) &#123; console.log(&apos;失败：&apos; + reason);&#125;);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git：关于回退版本的一些小技巧]]></title>
    <url>%2F2020%2F03%2F17%2Fgit%2Fgit%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[先通过 git log 查看某次提交的id 使用git reset –hard [id] 回退到某一次提交 若不想保留原来的提交记录，可把原来的分支删除 1git push origin --delete [branchName] 再把本地的修改提交到新的分支 版本回退仅仅是本地版本回退]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git：git fetch和git pull]]></title>
    <url>%2F2020%2F03%2F17%2Fgit%2Fgit%EF%BC%9Agit%20fetch%E5%92%8Cgit%20pull%2F</url>
    <content type="text"><![CDATA[git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git：将在master分支上做的修改提交到分支]]></title>
    <url>%2F2020%2F03%2F17%2Fgit%2Fgit%EF%BC%9A%E5%B0%86%E5%9C%A8master%E5%88%86%E6%94%AF%E4%B8%8A%E5%81%9A%E7%9A%84%E4%BF%AE%E6%94%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[前提我在master上修复了某个bug，但是master被锁定了，我想提交到dev分支，那么使用 cherry-pick可以满足我们的要求 1234//先从主分支记下id$ git log//切换到dev分支上$ git cherry-pick &lt;id&gt;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git：添加到远程github仓库的一个错误]]></title>
    <url>%2F2020%2F03%2F17%2Fgit%2Fgit%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%9C%E7%A8%8Bgithub%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[问题今天使用git 添加到远程github仓库的时候提示错误：fatal: remote origin already exists. 解决办法 先删除远程 Git 仓库 1$ git remote rm origin 再添加远程 Git 仓库 1$ git remote add origin 仓库地址]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git：git使用]]></title>
    <url>%2F2020%2F03%2F17%2Fgit%2Fgit%EF%BC%9Agit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git的简介、安装就不罗嗦了，详细的教程可参考廖雪峰的git教程 创建版本库（初始化一个git仓库）第一步选择一个合适的地方，创建一个空目录learngit 123$ mkdir learngit$ cd learngit$ pwd pwd命令用于显示当前目录 第二步通过git init命令把这个目录变成Git可以管理的仓库 1$ git init 1、此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 2、如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 添加文件到Git仓库编写一个readme.txt文件内容为： 12Git is a version control system.Git is free software. 第一步用命令git add告诉Git，把文件添加到仓库 1$ git add readme.txt 1、执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功 2、add可反复多次使用，添加多个文件 第二步用命令git commit告诉Git，把文件提交到仓库 1$ git commit -m &quot;wrote a readme file&quot; 1、-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的 2、commit可以一次提交很多文件，所以你可以多次add不同的文件 修改文件并提交修改readme.txt文件，改成如下内容 12Git is a distributed version control system.Git is free software. git status运行git status命令看看结果 1$ git status git status命令可以让我们时刻掌握仓库当前的状态 git diff比如有一个项目，隔了好几天没碰过了，想要继续写的时候，又忘了上次是怎么修改的，那么运行git diff命令看看具体修改了什么内容 1$ git diff readme.txt git diff顾名思义就是查看difference 提交修改（与提交新文件一样）第一步git add 1$ git add readme.txt 第二步git commit 1$ git commit -m &quot;add distributed&quot; 版本回退现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了 版本一：wrote a readme file 12Git is a version control system.Git is free software. 版本二：add distributed 12Git is a distributed version control system.Git is free software. git log运行git log命令可以查看每次修改的历史记录 1$ git log 该命令显示从最近到最远的提交日志 回退git reset运行git reset命令把版本二回退到版本一 123$ git reset --hard HEAD //当前版本$ git reset --hard HEAD^ //回退到上一个版本$ git reset --hard HEAD^^ //回退到上上一个版本 若有多个版本，可继续使用git reset命令回退 cat 看看readme.txt的内容是不是版本一 1$ cat readme.txt 后悔回退，恢复版本此时，使用git log看一下版本库里的版本，哎呀，版本二不见了那如果此时我又后悔了，我想要回退之前的版本了 1$ git reset --hard 所需版本的commit id commit id不知道怎么办？？？1、不怕，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到回退前执行git log后的版本库，每一个版本的commit后那一长串乱码一样的东西就是该版本的commit id了当然，commit id很长，没必要写全，写前几位就好了（一般七位吧） 恢复版本二 1$ git reset --hard f3ab58 2、可是，当你关掉了命令行窗口后才后悔怎么办？？？不怕，在Git中，总是有后悔药可以吃的 Git提供了一个命令git reflog用来记录你的每一次命令 1$ git reflog 又可以找回所需版本的commit id了 工作区与暂存区工作区就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区 版本库工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 Git的版本库里存了很多东西1、最重要的就是称为stage（或者叫index）的暂存区2、还有Git为我们自动创建的第一个分支master3、以及指向master的一个指针叫HEAD 前面讲了提交新文件到Git版本库： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支 撤销修改git checkout – file场景一（仅修改了文件） 有一次头脑混乱，在readme.txt中加了一行乱码，死定了，要赶紧手动删掉，以为这样就没事了吗？不，事儿可大了，运行git status查看 1$ git status 会显示改动了readme.txt 这时候，运行git checkout – file丢弃工作区的修改即可 1$ git checkout -- readme.txt 有两种情况（都是修改了工作区的文件导致工作区与版本库不一致）： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态 git reset HEAD file场景二（修改文件后，git add到暂存区了） 有一次头脑更混乱，不仅在readme.txt中加了一行乱码，还git add到暂存区了 幸好，用git status查看 1$ git status 显示还没有提交 这时候运行命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区即可 1$ git reset HEAD readme.txt 再用git status查看 1$ git status 现在暂存区是干净的，工作区有修改，回到场景一即可 1$ git checkout -- readme.txt 版本回退场景三（改了文件，不仅添加了，还提交了） 回到上上一个内容版本回退了 删除文件一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了 1$ rm test.txt Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了 1$ git status 此时有两种情况 第一种情况确实要从版本库中删除该文件 运行命令git rm删掉 1$ git rm test.txt 并且git commit 1$ git commit -m &quot;remove test.txt&quot; 第二种情况删错了 因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 1$ git checkout -- test.txt git checkout – file 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原” 远程仓库git的杀手级功能—远程仓库这个世界上有个叫GitHub的神奇的网站，这个网站是提供Git仓库托管服务的，只要注册一个GitHub账号，就可以免费获得Git远程仓库 设置SSH Key由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的 第一步创建SSH Key 在用户主目录下，看看有没有.ssh目录；如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件；如果已经有了，可直接跳到下一步 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码 第二步登陆GitHub，打开“Account settings”，“SSH Keys”页面， 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 把本地项目添加到远程库第一步通过命令git init把项目文件夹变成Git可管理的仓库 1$ git init 第二步把项目粘贴到这个本地Git仓库里面 1$ git add . 第三步把项目提交到仓库 1$ git commit -m &quot;注释&quot; 第四步登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的 第五步在本地的learngit仓库下运行命令 1$ git remote add origin git@github.com:michaelliao/learngit.git michaelliao替换成自己的GitHub账户名使本地仓库关联远程库添加后，远程库的名字就是origin，这是Git默认的叫法 第六步把本地库的所有内容推送到远程库上 1$ git push -u origin master 最后的最后从现在起，只要本地作了提交，就可以运行命令把本地master分支的最新修改推送至GitHub 1$ git push origin master 从远程库克隆到本地库第一步登陆GitHub，创建一个新的仓库，名字叫gitskills勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件 第二步用命令git clone克隆一个本地库 1$ git clone git@github.com:michaelliao/gitskills.git michaelliao替换成自己的GitHub账户名 分支管理创建与合并分支一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长 第一步创建dev分支 1$ git branch dev 切换到dev分支 1$ git checkout dev 可合并为创建并切换到dev分支 1$ git checkout -b dev 第二步用git branch命令查看当前分支 123$ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号 第三步在dev分支上正常提交比如对readme.txt做个修改，加上一行 1Creating a new branch is quick. 然后提交 12$ git add readme.txt $ git commit -m &quot;branch test&quot; 第四步现在，dev分支的工作完成，我们就可以切换回master分支 1$ git checkout master 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变 第五步把dev分支的工作成果合并到master分支上 1$ git merge dev git merge命令用于合并指定分支到当前分支注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式 第六步合并完成后，就可以放心地删除dev分支了 1$ git branch -d dev 删除后，查看branch，就只剩下master分支了 12$ git branch* master 解决冲突第一步此时，创建了一个新的分支feature1 1$ git checkout -b feature1 在readme.txt最后添加一行并提交 1Creating a new branch is quick AND simple. 第二步切换到master分支 1$ git checkout master 在master分支上readme.txt最后添加一行并提交 1Creating a new branch is quick &amp; simple. 此时，master分支和feature1分支各自都分别有新的提交 第三步由于两个分支各自有修改，两者合并起来可能会有冲突 1$ git merge feature1 git status会告诉我们冲突的文件 1$ git status 也可以查看readme.txt的内容 1234567Git is a distributed version control system.Git is free software distributed under the GPL.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 第四步此时，需要手动修改冲突内容 123Git is a distributed version control system.Git is free software distributed under the GPL.Creating a new branch is quick and simple. 再提交 12$ git add readme.txt $ git commit -m &quot;conflict fixed&quot; 现在，master分支和feature1分支变成这样用带参数的git log也可以看到分支的合并情况 1$ git log --graph --pretty=oneline --abbrev-commit 第五步最后，删除feature1分支 1$ git branch -d feature1 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 第一步创建并切换dev分支 1$ git checkout -b dev 第二步修改readme.txt文件，并提交一个新的commit 12$ git add readme.txt $ git commit -m &quot;add merge&quot; 第三步切换回master 1$ git checkout master 第四步准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 加上-m参数，把commit描述写进去 合并后，我们用git log看看分支历史 1$ git log --graph --pretty=oneline --abbrev-commit Bug分支某天突然接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug 第一步把当前工作现场“储藏”起来，等以后恢复现场后继续工作 1$ git stash 现在，用git status查看工作区，就是干净的 第二步首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支 1$ git checkout master 1$ git checkout -b issue-101 第三步修复bug，然后提交 12$ git add readme.txt $ git commit -m &quot;fix bug 101&quot; 第四步修复完成后，切换到master分支，并完成合并，最后删除issue-101分支 1$ git checkout master 1$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 1$ git branch -d issue-101 第五步接着回到dev分支干活了 1$ git checkout dev 1$ git status 工作区是干净的，用git stash list命令看看刚才的工作现场存到哪去了？ 1$ git stash list 第六步恢复stash内容 一种是用git stash apply恢复，然后用git stash drop删除stash内容 另一种方式是用git stash pop，恢复的同时把stash内容也删了 1$ git stash pop 可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash 1$ git stash apply stash@&#123;0&#125; 疑问第一个问题在dev中工作，在master中创建分支修改bug，好像互不相干呀，为什么要stash呢？ 暂存区是公用的，如果不通过stash命令隐藏，会带到其它分支（issue-101）去 第二个问题为什么要创建分支修改bug呢，直接在master中改不就好了吗？ 实际项目中，这个bug可能很麻烦，你需要修复一天的时间才能搞定，如果你不创建101分支，那么这时候你们组内其他小伙伴也要紧急修复线上一个bug，但是他的bug可能就1分钟。他修复好了却不能上线，因为你没有创建分支，要等你一天，才能把你处理好的正确代码一起上线。可能也会觉得创建分支不够效率，但是工作中稳健很重要 Feature分支每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支 第一步开发并提交 1$ git checkout -b feature-vulcan 12$ git add vulcan.py$ git commit -m &quot;add feature vulcan&quot; 第二步切回dev，准备合并 1$ git checkout dev 第三步一切顺利的话，feature分支和bug分支是类似的，合并，然后删除但是，由于种种原因，新功能取消，这个分支必须就地销毁 1$ git branch -d feature-vulcan 销毁失败 Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改如果要强行删除，需要使用命令git branch -D feature-vulcan 1$ git branch -D feature-vulcan 多人协作查看远程库的信息 1$ git remote 显示更详细的信息 1$ git remote -v 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库 推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 1$ git push origin master 或推送其他分支 1$ git push origin dev 注意： 1、master分支是主分支，因此要时刻与远程同步； 2、dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； 3、bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； 4、feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支当push失败时，则因为远程分支比你的本地更新 先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 1$ git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接 设置dev和origin/dev的链接 1$ git branch --set-upstream dev origin/dev 再pull 1$ git pull git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样 解决后，提交，再push 标签管理创建标签首先，切换到需要打标签的分支上 12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 创建一个新标签 1$ git tag &lt;name&gt; 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字 1$ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; 查看所有标签 12$ git tag //按字母排序$ git show &lt;tagname&gt; 默认标签是打在最新提交的commit上的 有时候，如果忘了打标签 方法是找到历史提交的commit id 1$ git log --pretty=oneline --abbrev-commit 然后打上标签就可以了1$ git tag &lt;name&gt; &lt;commit id&gt; 未完待续]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git：分支管理之合并]]></title>
    <url>%2F2020%2F03%2F17%2Fgit%2Fgit%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E4%B9%8B%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[假设已存在分支dev，且修改部分代码 先把已修改的推上分支dev 把切换回主分支，下拉 运行合并指令 1git merge dev 合并后在本地修改冲突 再次commit并提交到主分支]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的程序设计]]></title>
    <url>%2F2020%2F03%2F17%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[理解对象面向对象和面向过程 面向过程是分析出解决问题所需要的步骤，然后用函数把步骤一步一步实现，使用时一个一个依次调用就可以了。 面向对象是把构成问题事务分解为各个对象，建立对象的目的是为了描述某个事物在整个解决问题的步骤中的行为。概念（我讲得通俗一点） 类：js中没有类的概念，取了一个新的名字—原型对象 原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物 对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物 对象的属性类型一般为基本数据类型，也可以是另外的对象 数据属性 访问器属性 其特性详见书中139，感觉不会常用 小结 在js中一切都是对象 原型对象其实也是对象 判断一个对象实例具体是什么类型用instanceof运算符（引用类型中有详讲） 面向对象三大要素：封装、继承、多态。 创建对象工厂模式（最古老）1234567891011这是一个能够根据接受的参数来构建一个包含所有必要信息的对象的函数function Person(name,age)&#123; var o=new Object(); //创建对象实例，但无法得知对象的类型 o.name=name; //添加属性 o.age=age; o.sayName=function()&#123; //添加方法 alert(this.name); &#125;; return o; //返回对象引用 &#125;var person1=Person(&quot;greg&quot;,27);//调用函数创建对象实例 构造函数模式12345678function Person(name,age)&#123; this.name=name; //实例属性 this.age=age; this.sayName=function()&#123; //实例方法（不同实例地址不一样） alert(this.name); &#125;;&#125;var person1=new Person(&quot;greg&quot;,27); 原型模式1234567891011121314151617function Person()&#123; &#125;Person.prototype=&#123; constructor:Person, //强制指向Person name:&quot;greg&quot;, //原型属性 friend:[&quot;blue&quot;,&quot;yellow&quot;], sayName:function()&#123; //原型方法（共享，地址一样） alert(this.name); &#125;&#125;;var person1=new Person();var person2=new Person();person1.name=&quot;Lee&quot;; //重写person1的名字alert(person1.name); //Leealert(person2.name); //Gregperson1.friend.push(&quot;black&quot;);alert(person1.friend); //blue，yellow,blackalert(person2.friend);//blue，yellow,black 小结： 属性的查找是先从实例中找，实例中没有该属性，便从原型中找 数组friend添加了一个项，是先从person1中找数组修改，由于没找到，所以顺着原型链找到原型中的数组并修改了 实例对象的proto指向，其构造函数的原型。构造函数的prototype获得构造函数的原型。构造函数原型的constructor指向对应的构造函数 组合使用构造函数模式和原型模式（最佳）构造函数模式定义实例属性原型模式定义方法和原型属性 123456789101112function Person(name,age)&#123; this.name=name; //实例属性 this.age=age;&#125;Person.prototype=&#123; constructor:Person, //原型属性（共享） sayName:function()&#123; //原型方法（共享） alert(this.name); &#125;&#125;;var person1=new Person(&quot;Greg&quot;,27);person1.sayName(); //&quot;Greg&quot; 动态原型模式123456789101112function Person(name,age)&#123; this.name=name; this.age=age; //仅在第一次调用时初始化 if(typeof this.sayName!=&quot;function&quot;)&#123; person.prototype.sayName=function()&#123; alert(this.name); //将原型方法封装在构造函数中 &#125;; &#125;&#125;var person1=new Person(&quot;Greg&quot;,27);person1.sayName(); //&quot;Greg&quot; 寄生构造函数模式（工厂模式+构造函数模式）123456789101112function Person(name,age)&#123; var o=new Object(); o.name=name; o.age=age; o.sayName=function()&#123; alert(this.name); &#125;; return o;&#125;var person1=new Person(&quot;Greg&quot;,27);person1.sayName();不能确定对象关系，不推荐使用 稳妥构造函数模式123456789101112function Person(name,age)&#123; var o=new Object(); //可以在这里定义*私有*属性和方法 o.sayName=function()&#123; alert(name); &#125;; return o;&#125;var person1=Person(&quot;Greg&quot;,27);person1.sayName();不引用this，不使用new操作符但除了sayName()方法没有别的方法访问原始数据，安全性很高 继承原型链继承123456789101112131415161718192021222324function Super()&#123; this.val=1; this.arr=[1];&#125;Super.prototype.getSuper=function()&#123; return true; //原型方法&#125;;function Sub()&#123; &#125;//继承Super，把Super的对象实例赋给Sub的原型Sub.prototype=new Super(); var sub1=new Sub();var sub2=new Sub();var super1=new Super();sub1.val=2;alert(sub1.val);//2alert(sub2.val);//1sub1.arr.push(2);alert(sub1.arr);//1,2alert(sub2.arr);//1,2Sub.prototype.getSuper=function()&#123; //重写方法 return false; &#125;;alert(sub1.getSuper());//false //调用重写后的方法alert(super1.getSuper());//true //调用原来的方法 小结： 重写方法或添加新方法需写在继承后 属性查找是先从对象实例中找，没有就顺着原型链继续向上查找 创建子类实例时，无法向父类构造函数传参 父类方法和属性得到复用，子类实例没有自己的属性 借用构造函数继承1234567891011121314function Super(val)&#123; this.val=val; this.arr=[1]; this.getSuper=function()&#123; &#125;;//方法在构造函数中，无法复用&#125;function Sub(val)&#123; Super.call(this,val); //继承Super，类似于对象冒充&#125;var sub1=new Sub(1);var sub2=new Sub(2);alert(sub1.val); //1alert(sub2.val); //2alert(sub1.getSuper==sub2.getSuper);//false每个子类实例都有新的方法地址，内存要爆炸了！！！ 小结：子类的每个实例都有自己的属性、方法，不会相互影响，但是占用内存。 组合继承（最常用）原型链：对原型属性和方法的继承借用构造函数：对实例属性的继承 12345678910111213141516function Super(val)&#123; this.val=val; this.arr=[1];&#125;Super.prototype.getSuper=function()&#123; return true; //原型方法&#125;;function Sub(val)&#123; Super.call(this,val); //继承Super&#125;Sub.prototype=new Super(); //继承Supervar sub1=new Sub(1);var sub2=new Sub(2);alert(sub1.val); //1alert(sub2.val); //2alert(sub1.getSuper==sub2.getSuper);//true 小结： 复用了方法，子类又有各自的属性。 因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例的属性覆盖掉，也存在内存浪费。 原型式继承（类似于对象复制）创建新对象–&gt;返回该对象–&gt;增强（添加属性/方法） 1234567891011121314151617181920// 生孩子函数 beget：龙beget龙，凤beget凤//创建新的obj的对象实例function beget(obj)&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; this.val = 1; this.arr = [1];&#125;// 生孩子var sub = beget(new Super()); // 核心// 添加属性sub.attr1 = 1;sub.attr2 = 2;alert(sub.val); // 1alert(sub.arr); // 1alert(sub.attr1); // 1不像继承？ 寄生式继承创建新对象–&gt;增强–&gt;返回该对象 12345678910111213141516171819202122232425// 生孩子函数 beget：龙beget龙，凤beget凤。function beget(obj)&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; this.val = 1; this.arr = [1];&#125;function getSubObject(obj)&#123; // 创建新对象 var clone = beget(obj); // 核心 // 添加属性 clone.attr1 = 1; clone.attr2 = 2; return clone;&#125; var sub = getSubObject(new Super());alert(sub.val); // 1alert(sub.arr); // 1alert(sub.attr1); // 1给原型式继承穿个马甲？ 寄生组合式继承（最佳，但组合继承最常用）有缺陷的寄生式继承+不完美的组合继承 123456789101112131415161718192021222324// 生孩子函数 beget：龙beget龙，凤beget凤//创建新的obj的对象实例function beget(obj)&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.getSuper = function()&#123;&#125;;function Sub()&#123; Super.call(this); // 继承&#125;//继承，把实例赋给Sub的原型var proto = beget(Super.prototype); proto.constructor = Sub; Sub.prototype = proto; var sub = new Sub();alert(sub.val); //1alert(sub.arr); //1 大总结：加油！棒棒哒！熬过这一章其余就轻松啦啦啦！已经写得尽可能详细了，多多复习！ ES6创建对象123456789101112class father &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; //方法与方法之间不需要逗号分隔 run()&#123; console.log(&quot;ok&quot;); &#125;&#125;var ming = new father(&quot;ming&quot;,20);ming.run(); //okconsole.log(ming.name); //ming 继承123456789101112131415class son extends father &#123; constructor(name,age,sex)&#123; super(); //super方法要放在最前面 this.sex = sex; //添加新属性 &#125; run()&#123; //重写run方法 console.log(&quot;true&quot;); &#125; get()&#123; //添加新方法 &#125;&#125;var hong = new son(&quot;hong&quot;,2,&quot;女&quot;);hong.run(); //trueconsole.log(hong.sex); //女 单词不要拼错：constructor]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型]]></title>
    <url>%2F2020%2F03%2F17%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概述在学习引用类型之前，先弄清楚一些概念性的问题可能会比较好。接下来我就以已经学习过的类型来简单说明一下几个概念之间的关系：首先，JavaScript包含数据类型和引用类型 数据类型 复杂数据类型：Object 简单数据类型：Boolean、Number、String、Undefined、Null 12可用typeof运算符检测给定变量的数据类型如：alert(typeof 95);//&quot;number&quot; 引用类型这是一个最大的概念，也称为本地对象或者类 内置对象：Global、Math 基本包装类型（特殊的引用类型）：Boolean、Number、String 与其他引用类型相似：具有与各自的基本类型相应的特殊行为。不同：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁。当然，可以使用new操作符显示创建对象，虽说绝对必要的情况才这样，但我觉得好像大多是这样做的（我的错觉？） 其他：Object、Array、Date、RegExp、Function 每一个引用类型都有相应的属性和方法，其中又分为静态和实例 静态属性、方法：无需创建对象实例，可直接通过引用类型调用（内置对象中的都为静态属性和方法） 实例属性、方法：每个对象实例都具有的（其他引用类型中常用的方法均为实例方法） 123由于无论引用的是什么类型的对象，typeof运算符都返回&quot;object&quot;可用instanceof运算符识别正在处理的对象的具体类型如：alert(95 instanceof Number);//true 数据类型和引用类型的不同在内存中的存储方式不同 原始数据类型在内存中是栈存储。是自动分配的内存，由系统自动释放。 引用类型在内存中是堆存储。是动态分配的内存，大小不定也不会自动释放。 引用类型内置对象 （不必实例化） Global对象 用法1window.属性(方法)/属性(方法) 小结1、这是最特别的一个对象，不管从什么角度看，它都是不存在的2、不属于任何其他对象的属性和方法，最终都是它的属性和方法3、在全局作用域中定义的属性和函数，都是Global对象的属性4、Web浏览器将这个全局对象作为window对象的一部分加以实现，因此，在全局作用域中声明的所有变量和函数，都成为window对象的属性 相关属性与方法详见书中131 Math对象 用法1Math.属性(方法) 为保存数学公式和信息提供了一个公共位置 相关属性与方法详见书中134 基本包装类型（使用new操作符） Boolean类型 用法调用Boolean构造函数并传入true或false值 1var booleanObject=new Boolean(true); 相关属性与方法详见书中120 Number类型 用法调用Number构造函数时向其传递相应的数值 1var numberObject=new Number(10); 相关属性与方法详见书中120 String类型 用法1var stringObject=new String(&quot;hello&quot;); 相关属性与方法详见书中122 其他引用类型（使用new操作符） Object类型用法1、使用Object构造函数 123var person=new Object();person.name=&quot;greg&quot;;person.age=27; 2、使用字面量表示法 1234var person=&#123; name:&quot;greg&quot;, age:27&#125;; 相关属性与方法详见书中83 Array类型用法1、使用Array构造函数 1234若知道数组要保存的项目数量，可传参，为length属性的值var colors=new Array();可省略new操作符var colors= Array(); 2、使用数组字面量表示法 12var colors=[&quot;red&quot;,&quot;yellow&quot;];var names=[];//空数组 相关属性与方法详见书中86 Date类型用法 12345678不传参，即获得当前日期和时间var now=new Date();传入表示某日期的毫秒数，返回该日期和时间其中有相应的方法可获取某日期的毫秒数Date.parse()和Date.UTC()var someDate=new Date(Date.parse(&quot;July 14,2017&quot;));等价于var someDate=new Date(&quot;July 14,2017&quot;);var someDate=new Date(Date.UTC(2017,6,14));等价于var someDate=new Date(2017,6,14);//UTC时间 相关属性与方法详见书中98 RegExp类型用法1、使用RegExp构造函数 1var pattern=new RegExp(&quot;pattern&quot;,&quot;gim&quot;); 2、使用字面量表达式（常用） 1234var pattern =/pattern/gim;g:全局模式i:不区分大小写m:多行模式 相关元字符、实例属性、实例方法、静态属性详见书中103 Function类型用法1、使用函数声明语法定义（常用） 1234解析器会率先读取函数声明，并使其在执行任何代码前可用function sum(num1,num2)&#123; return num1+num2;&#125; 2、使用函数表达式定义 123456必须等解析器执行到函数表达式所在的代码行，才会真正被解释执行var sum=function(num1,num2)&#123; return num1+num2;&#125;;无需函数名，通过变量即可引用函数PS：函数末尾有一个分号，同声明其他变量一样 3、使用Function构造函数（不推荐使用） 1var sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;); 小结 没有重载：当声明了两个同名函数时，后面的将覆盖前面的函数 作为值的函数：像传参一样把函数传递，即访问函数的指针，而不是执行函数 内部属性：（有点绕有点难懂，我觉得很少用）arguments.callee：指针，指向拥有 arguments对象的函数；arguments.callee.caller：指向（调用了（拥有arguments对象）的函数）的函数 相关属性与方法详见书中110]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue：数据双向绑定原理]]></title>
    <url>%2F2020%2F03%2F17%2Fvue%2Fvue%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()（相当于observer）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 observer：遍历data中的属性，使用Object.defineProperty()的get/set方法对其进行数据劫持。 dep：每个属性拥有自己的消息订阅器dep，用于存放所有订阅了该属性的观察者对象。 watcher：观察者（对象），通过dep实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。 要对数据进行劫持监听，我们需要设置数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并发布通知（给dep）。 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数。 当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 拓展Object.defineProperty12345//在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Object.defineProperty(obj, prop, descriptor)//obj 要在其上定义属性的对象。//prop 要定义或修改的属性的名称。//descriptor 将被定义或修改的属性描述符。 object.defineproperty()缺点 无法监听数组的变化（把对象属性换成数组就无法监听） 只能劫持对象的属性，不能劫持完整的对象（若对象属性为一个对象，则无法深度遍历劫持） 计算属性计算属性computed：一个属性通过其他属性计算而来 侦听器就是检测某一属性是否发生变化，一旦发生变化，我们就可以在侦听器里面写一下业务逻辑]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue：路由原理]]></title>
    <url>%2F2020%2F03%2F17%2Fvue%2Fvue%EF%BC%9A%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[单页面应用随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。 vue-router实现方式“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式： hash模式，url带#号，但是访问网页不会404。 history模式。url不带#号。前端的 URL 必须和实际向后端发起请求的 URL 一致，如果后端没有规定好路由，直接复制url会404。 1234// hashhttp://localhost:8080/#/test// historyhttp://localhost:8080/test mode在vue-router中是通过mode这一参数控制路由的实现模式的，创建VueRouter的实例对象时，mode以构造函数参数的形式传入。 123456789const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [...]&#125;)// mode 参数：- 默认hash- history 注：如果浏览器不支持history新特性,则采用hash方式- 如果不在浏览器环境则使用abstract（node环境下） history对象当选择mode类型之后，程序会根据你选择的mode 类型创建不同的history对象 HashHistory HTML5History AbstractHistory 1234567891011121314151617// 源码// 根据mode确定history实际的类并实例化switch (mode) &#123; case &apos;history&apos;: this.history = new HTML5History(this, options.base) break case &apos;hash&apos;: this.history = new HashHistory(this, options.base, this.fallback) break case &apos;abstract&apos;: this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(false, `invalid mode: $&#123;mode&#125;`) &#125;&#125; HashHistory替换路由的两个方法 HashHistory.push() HashHistory.replace() HashHistory.push()将新路由添加到浏览器访问历史的栈顶 1234561 $router.push() //调用方法2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶）（window.location.hash= XXX）3 History.transitionTo() //监测更新，更新则调用History.updateRoute()4 History.updateRoute() //更新路由5 &#123;app._route= route&#125; //替换当前app路由6 vm.render() //更新视图 HashHistory.replace()replace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由 12345678910111213replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.transitionTo(location, route =&gt; &#123; replaceHash(route.fullPath) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125; function replaceHash (path) &#123; const i = window.location.href.indexOf(&apos;#&apos;) window.location.replace( window.location.href.slice(0, i &gt;= 0 ? i : 0) + &apos;#&apos; + path )&#125; 监听地址栏在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此VueRouter还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在HashHistory中这一功能通过setupListeners实现 12345678910setupListeners () &#123; window.addEventListener(&apos;hashchange&apos;, () =&gt; &#123; if (!ensureSlash()) &#123; return &#125; this.transitionTo(getHash(), route =&gt; &#123; replaceHash(route.fullPath) &#125;) &#125;)&#125; 该方法设置监听了浏览器事件hashchange，调用的函数为replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法 HTML5History History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。 从HTML5开始，History interface有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改 当然了，HTML5History用到了HTML5的新特特性，是需要特定浏览器版本的支持的 window.history.pushState()和window.history.replaceState() window.history.pushState(stateObject, title, URL) window.history.replaceState(stateObject, title, URL) stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本 title: 所添加记录的标题 URL: 所添加记录的URL 监听地址变化在HTML5History的构造函数中监听popState（window.onpopstate） 在HTML5History中添加对修改浏览器地址栏URL的监听是直接在构造函数中执行的 1234567891011constructor (router: Router, base: ?string) &#123; window.addEventListener(&apos;popstate&apos;, e =&gt; &#123; const current = this.current this.transitionTo(getLocation(this.base), route =&gt; &#123; if (expectScroll) &#123; handleScroll(router, route, current, true) &#125; &#125;) &#125;)&#125; 两者区别 pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中 pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串 pushState可额外设置title属性供后续使用 一个问题用户直接在地址栏中输入并回车，浏览器重启重新加载应用时 hash模式仅改变hash部分的内容，而hash部分是不会包含在HTTP请求中的，故在hash模式下遇到根据URL请求页面的情况不会有问题。 12http://oursite.com/#/user/id // 如重新请求只会发送http://oursite.com/ 而history模式则会将URL修改得就和正常请求后端的URL一样。1http://oursite.com/user/id 如后端没有配置对应/user/id的路由处理，则会返回404错误。 官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue：组件间的传值]]></title>
    <url>%2F2020%2F03%2F17%2Fvue%2Fvue%EF%BC%9A%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[父组件向子组件传值 父组件把要传递的值绑定在调用的子组件上 子组件通过props[“”]来接收值来使用 子组件向父组件传值 子组件通过$emit(‘函数名’,’参数’)来抛出事件传递参数 父组件通过在调用的子组件上绑定函数名来使用参数（@函数名） vuex 兄弟之间传值 vuex 通过路由带参数进行传值 123this.$router.push(&#123; path: &apos;/conponentsB&apos;, query: &#123; orderId: 123 &#125; &#125;) // 跳转到Bthis.$route.query.orderId // 在B组件拿到的参数 通过设置本地存储，如Session Storage缓存的形式进行传递 123const orderData = &#123; &apos;orderId&apos;: 123, &apos;price&apos;: 88 &#125;sessionStorage.setItem(&apos;缓存名称&apos;, JSON.stringify(orderData))const dataB = JSON.parse(sessionStorage.getItem(&apos;缓存名称&apos;)) // 在其他组件拿到session Storage缓存的值]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue：MVVM、MVC、MVP]]></title>
    <url>%2F2020%2F03%2F17%2Fvue%2Fvue%EF%BC%9AMVVM%E3%80%81MVC%E3%80%81MVP%2F</url>
    <content type="text"><![CDATA[MVCM代表Model，代表数据模型。 V代表View，代表视图。 C代表Controller，代表控制器，用来处理数据。 工作模式用户操作视图View，当数据改变时，传到Controller进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知View，View通过观察者模式收到Model变更的消息后，向Model请求最新的数据，自己同步更新视图。 优点观察者模式可以做到多视图同时更新。 缺点 controller测试困难。 view无法组件化，它强依赖特定的Model，不同程序的Model不一样。 MVPM代表Model，代表数据模型。 V代表View，代表视图。 P代表Presenter，代表呈现。 工作模式用户操作视图View，当数据改变时，传到Presenter进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知Presenter，Presenter获取到Model变更的消息后，通过View提供的接口更新界面。 和MVC的不同M和V是隔离的。 优点 便于测试。 可以组件化缺点由于需要大量的手动同步View和Model，导致维护起来很困难。 MVVMvue和angular都为mvvm框架 M代表Model，代表数据模型，可以在Model中定义数据修改和操作的业务逻辑。 V代表View，代表视图，它负责将数据模型转化成UI展现出来。 VM代表ViewModel，负责监听模型数据的改变和控制视图行为、处理用户交互。简单理解就是一个同步View和Model的对象，连接View和Model。 MVVM是以双向数据传输为思想的。ViewModel通过双向数据绑定把View和Model连接起来，View数据的变化会同步到Model中，而Model数据的变化也会立即反映到View上。 优点解决MVP大量的手动同步View和Model的问题，提供双向绑定机制。 缺点 过于简单的图形界面不适用。 没法断点debug，数据绑定的声明是指令式地写在View的模板当中的。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F2020%2F03%2F17%2Fvue%2Fvue%EF%BC%9A%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[lib-flexible原理 在页面中引入flexible.js后，flexible会在html标签上增加一个data-dpr属性和font-size样式。 js首先会获取设备型号和对应的dpr，然后根据不同设备添加不同的data-dpr值，比如说1、2或者3，从源码中我们可以看到。 vue中适配通过npm下载1npm i lib-flexible --save 在main.js中引入 1import &apos;lib-flexible/flexible&apos; 把视觉稿中的px转换成remFlexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。 px2rem-loader在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，将下面代码加进cssLoaders方法中 123456const px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUint: 75 &#125;&#125; 同时，对generateLoaders方法进行修改 1const loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader] fastclick为了检测是否为双击，从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。 解决引入fastclick第三方库，其实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli脚手架]]></title>
    <url>%2F2020%2F03%2F17%2Fvue%2FVue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[vue-cli介绍Vue-cli是Vue的脚手架工具 脚手架：在工地上，是帮助工人们作业的搭建好的架子；在技术上，是编写好基础代码的工具。 安装环境查看版本（具体安装方法百度很多） 123$ node -v$ npm -v$ cnpm -v vue-cli 1.x或2.x全局安装12$ npm install -g vue-cli$ cnpm install -g vue-cli //国内镜像安装，较快 若安装失败，则先清理缓存，再重新安装 查看版本 1$ vue -V 生成项目生成项目文件夹1$ vue init &lt;template-name&gt; &lt;project-name&gt; 输入命令后，会跳出几个选项让你回答： Project name (baoge)：项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。 Project description (A Vue.js project)：项目描述，也可直接点击回车，使用默认名字 Author ()： 作者，输入你的大名 接下来会让用户选择： Runtime + Compiler: recommended for most users运行加编译，既然已经说了推荐，就选它了 Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y/n)是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y/n)是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。 接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车 Setup unit tests with Karma + Mocha? (Y/n)是否安装单元测试，我选择安装y回车 Setup e2e tests with Nightwatch(Y/n)?是否安装e2e测试 ，我选择安装y回车 一般一路回车就好了 Official Templates webpack（常用） webpack-simplae browaerify browserify-simple simple 自定义 运行 （在项目文件目录下运行）1$ cnpm install 1$ npm run dev 项目文件介绍 build和config文件夹：webpack配置相关 node_modules文件夹：npm install安装的依赖代码库 src文件夹：存放项目源码 static文件夹：存放第三方静态资源 .babelrc文件：babel的配置（大多数浏览器不能直接支持ES6，则需通过babel编译成ES5） .editorconfig文件：编译器的配置 .eslintignore文件：忽略语法检查的目录文件（忽略对build和config进行ES6语法检查） .eslintrc.js：eslint的配置文件 .gitignore文件：使git仓库忽略里边的文件或者目录 index.html：编译过程中会自动插入到这个html中 package.json：项目的配置文件 README.md：项目的描述文件 运行 创建组件 创建一个.vue对象，由三部分组成：template、script、style，其中在script中使用export default导出一个对象（里面为组件的各种选项、属性） 使用组件 打包上线 1$ npm run build 所遇到的坑 使用vue安装项目文件后，若提示版本过低，则需把node、npm、cnpm全部升级到最新版本 命令cnpm install需要在==项目文件目录下==运行，若还运行不了，再找其他原因 vue-cli 3.0]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue：生命周期]]></title>
    <url>%2F2020%2F03%2F17%2Fvue%2Fvue%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[8个阶段创建前(beforeCreate)在数据观测和初始化事件还未开始时。 创建后(created)完成数据观测，属性和方法的运算，初始化事件，el属性还没有显示出来。 载入前(beforeMount)在挂载开始之前被调用，相关的render函数首次被调用。vue实例的el和data都初始化了，生成了html，但还没有挂载html到页面上。 载入后(mounted)vue实例挂载完成，html页面成功渲染。 更新前(beforeUpdate)在数据更新之前调用。 更新后(updated)调用时，组件DOM已经更新，可以执行依赖于DOM的操作。 销毁前(beforeDestroy)在实例销毁之前调用。实例仍然完全可用。 销毁后(destroy)在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。 相关问题什么是vue生命周期？答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 vue生命周期的作用是什么？答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 vue生命周期总共有几个阶段？答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后 第一次页面加载会触发哪几个钩子？答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子 DOM 渲染、挂载在哪个周期中就已经完成？答：DOM 渲染、挂载在 mounted 中就已经完成了。 vue能不能挂载到body或html标签上？提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载vue实例到html或者body标签上。 简单描述每个周期具体适合哪些场景？答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：立即执行函数]]></title>
    <url>%2F2019%2F04%2F23%2Fjs%2Fjs%EF%BC%9A%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[立即执行函数12345//一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号( function()&#123;…&#125; )() //等价于( function ()&#123;…&#125; () )//一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中 注意： 函数体后面要有小括号()，函数体必须是函数表达式而不能是函数声明。 （）运算符将匿名函数或函数声明转换为函数表达式。 好处通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。 此时若是想访问全局对象，将全局对象以参数形式传进去即可 123(function(window)&#123; ...&#125;)(window); 拓展123456789101112131415161718192021222324252627282930313233343536for(var i = 0; i&lt;10; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;);&#125;改写：使打印 0-10//第一种：letfor(let i = 0; i&lt;10; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;);&#125;//第二种：闭包 + 立即执行函数for(var i = 0; i&lt;10; i++)&#123; (function(a)&#123; setTimeout(function()&#123; console.log(a) &#125;); &#125;)(i);&#125;上面的代码即可实现依次打印出0,1,2,3...此处利用闭包每次将i的值传入进去，里面使用参数a接受传过来的值然后setTimeout异步调用，进入异步队列，循环代码很快执行完然后从异步队列里返回执行后的结果，依次打印出0，1,2,3...//实现隔1秒依次打印一个结果for(var i = 0; i&lt;10; i++)&#123; (function(a)&#123; setTimeout(function()&#123; console.log(a) &#125;); &#125;,1000*a)(i);&#125;上面代码在延迟执行时间那块加了一个参数aa的值每次都会增加1，使时间每次扩大比上次大一倍从而实现了每隔一秒就打印出一个结果 异步调用：异步代码执行完后结果存放在队列中，等同步代码执行完，再输出结果]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：setTimeout和setInterval]]></title>
    <url>%2F2019%2F04%2F23%2Fjs%2Fjs%EF%BC%9AsetTimeout%E5%92%8CsetInterval%2F</url>
    <content type="text"><![CDATA[都是延迟一段时间调用回调函数。 setTimeout setTimeout只调用一次。 setTimeout最短间隔时间为4毫秒。setInterval setInterval会一直循环调用函数，不会自己停止。要用clearInterval(计数器编号)来停止。 setInterval最短间隔时间为10毫秒，小于会被调整为10ms。 拓展 使用setInterval有可能定时器代码可能在代码再次被添加到队列之前还没有完成执行，这样有可能导致代码连续运行。js引擎解决：队列无定时器代码才添加。这样有可能导致某些间隔被跳过。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM和DOM]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%89%8D%E7%AB%AF%2FBOM%E5%92%8CDOM%2F</url>
    <content type="text"><![CDATA[BOM和DOM DOM（文档对象模型）是 HTML 和 XML 的应用程序接口。 DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。 BOM （浏览器对象模型）主要处理浏览器窗口和框架。 javacsript是通过访问BOM对象来访问、控制、修改客户端浏览器。 由于BOM的window包含了document，document对象又是DOM的根节点。可以说，BOM包含了DOM。 浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。 拓展：遍历dom树]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二分查找]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。 首先，从有序数组的中间的元素开始搜索， 如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。 如果目标元素大于或者小于中间元素， 则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。 如果某一步数组为空，则表示找不到目标元素。 12345678910111213141516171819function search(arr,key)&#123; var low = 0; var high = arr.length-1; while(low &lt;= high)&#123; var mid = parseInt((low+high)/2); if(key == arr[mid])&#123; return mid; &#125;else if(key &lt; arr[mid])&#123; high = mid-1; &#125;else if(key &gt; arr[mid])&#123; low = mid+1; &#125;else&#123; return -1; &#125; &#125;&#125;console.log(search([0,1,2,3,5,6,7],5));//4console.log(search([0,1,2,3,5,6,7],4));//undefined]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：优先级]]></title>
    <url>%2F2019%2F04%2F23%2Fcss%2Fcss%EF%BC%9A%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[从高到低 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。 内联样式，作为style属性写在元素内的样式 id选择器 标签[指定属性] 如 button[type=file] 类选择器 标签选择器 通配符选择器]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：时间复杂度]]></title>
    <url>%2F2019%2F04%2F23%2Fjs%2Fjs%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度原则 如果运行时间是常数量级，用常数1表示； 只保留时间函数中的最高阶项； 如果最高阶项存在，则省去最高阶项前面的系数。 场景一给小灰一条长n寸的面包，小灰每3天吃掉1寸，那么吃掉整个面包需要几天？ 12345678//T（n） = 3n，执行次数是线性的。void eat1(int n)&#123; for(int i=0; i&lt;n; i++)&#123;; System.out.println(&quot;等待一天&quot;); System.out.println(&quot;等待一天&quot;); System.out.println(&quot;吃一寸面包&quot;); &#125;&#125; 时间复杂度为：T（n） = O（n） 场景二给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸……那么小灰把面包吃得只剩下1寸，需要多少天呢？ 这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为log16。因此，把面包吃得只剩下1寸，需要 5 X log16 = 5 X 4 = 20 天。 如果面包的长度是 N 寸呢？需要 5 X logn = 5logn天，记作 T（n） = 5logn。12345678910//T（n） = 5logn，执行次数是对数的。void eat2(int n)&#123; for(int i=1; i&lt;n; i*=2)&#123; System.out.println(&quot;等待一天&quot;); System.out.println(&quot;等待一天&quot;); System.out.println(&quot;等待一天&quot;); System.out.println(&quot;等待一天&quot;); System.out.println(&quot;吃一半面包&quot;); &#125;&#125; 时间复杂度为：T（n） = O（logn） 场景三给小灰一条长10寸的面包和一个鸡腿，小灰每2天吃掉一个鸡腿。那么小灰吃掉整个鸡腿需要多少天呢？ 12345//T（n） = 2，执行次数是常量的。void eat3(int n)&#123; System.out.println(&quot;等待一天&quot;); System.out.println(&quot;吃一个鸡腿&quot;);&#125; 时间复杂度为：T（n） = O（1） 场景四给小灰一条长10寸的面包，小灰吃掉第一个一寸需要1天时间，吃掉第二个一寸需要2天时间，吃掉第三个一寸需要3天时间…..每多吃一寸，所花的时间也多一天。那么小灰吃掉整个面包需要多少天呢？ 答案是从1累加到10的总和，也就是55天。 如果面包的长度是 N 寸呢？此时吃掉整个面包，需要 1+2+3+……+ n-1 + n = (1+n)*n/2 = 0.5n^2 + 0.5n。123456789//T（n） = 0.5n^2 + 0.5n，执行次数是一个多项式。void eat4(int n)&#123; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;i; j++)&#123; System.out.println(&quot;等待一天&quot;); &#125; System.out.println(&quot;吃一寸面包&quot;); &#125;&#125; 时间复杂度为：T（n） = O（n^2） 总结四种时间复杂度究竟谁用时更长，谁节省时间呢？ 1O（1）&lt; O（logn）&lt; O（n）&lt; O（n^2） 除了上述的四个场景，还有许多不同形式的时间复杂度，比如： 1O（nlogn）, O（n^3）, O（m*n），O（2^n），O（n！）]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：flex布局]]></title>
    <url>%2F2019%2F04%2F23%2Fcss%2Fcss%EF%BC%9Aflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言flex布局称为弹性布局。任何一个容器都可以指定为 Flex 布局。 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 基本概念采用 Flex 布局的元素，称为 Flex 容器，简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目，简称”项目”。 水平的主轴（main axis） 垂直的交叉轴（cross axis） 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性flex-directionflex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow flex-grow属性定义项目的放大比例，默认为0。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。（即把剩余空间划分为四份，属性为2的占两份，属性为1的占一份）。 flex-shrink flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。数值大的缩小得多。 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;; &#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 auto：表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟dom]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%89%8D%E7%AB%AF%2F%E8%99%9A%E6%8B%9Fdom%2F</url>
    <content type="text"><![CDATA[是什么可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。 为什么之前使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，且在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的。在js做dom对比，减少对dom的操作，而不是每一次都要渲染，这样效率会提高。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（三）]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[有一个字符串有很多is，写一个方法只保留一个is？ 123456789function deleteIs(str)&#123; var index = str.search(&quot;is&quot;); var left = str.slice(0,index+2); var right = str.slice(index+2,str.length); right = right.split(&quot;is&quot;).join(&quot;&quot;); return left.concat(right); &#125;console.log(deleteIs(&quot;thisismybook&quot;));//thismybook 有3个-10-10之间的整数，写一个方法这三个数一共有多少可能相加等于10。 改写数组的push方法，保持原有逻辑，添加一个console.log(arguments)，即push什么打印什么。 12345Array.prototype.push = function(val)&#123; console.log(val);&#125;var temp = [1,2,5];temp.push(7);//打印7 传入一个无序数组，要求n数相加，获取特定的sum 12345678910111213141516 function getResult(arr,n,sum)&#123; if(n==0&amp;&amp;sum==0)&#123; return true; &#125; if(n&lt;0)&#123; return false; &#125; if(n&gt;0)&#123; for(var i in arr)&#123; var temp = arr.slice(i+1,arr.length); return getResult(temp,n-1,sum-arr[i]) || getResult(temp,n,sum); &#125; &#125;&#125;console.log(getResult([1,2,3,4],2,7)); //true 用正则表达式去掉两边的空格 123456function remove(str)&#123; var reg = /(^\s+)|(\s+?)/g; return str.replace(reg,&quot;&quot;);&#125;console.log(remove(&quot;this is book&quot;));//&quot;thisisbook&quot; 给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项 12345678910111213function getSingleNumber(arr)&#123; var temp = []; for(var i in arr)&#123; if(temp.indexOf(arr[i]) == -1)&#123; temp.push(arr[i]); &#125;else&#123; temp.splice(temp.indexOf(arr[i]),1); &#125; &#125; return temp[0];&#125;console.log(getSingleNumber([0,1,0,0])); //1 请实现一个函数merge，传入一个数组，合并数组中【相邻且重复】的元素 123456789101112function merge(arr)&#123; var reg = /(.)\1*/g; var str = arr.join(&quot;&quot;); str = str.replace(reg,&quot;$1&quot;); arr = str.split(&quot;&quot;); arr = arr.map(function(val)&#123; return parseInt(val); &#125;) return arr;&#125;console.log(merge([3,2,2,4,5,5,6,2,1]));//[3,2,4,5,6,2,1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（二）]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[求“123456789876543212345678987654321…”中的第n位123456789function index(n)&#123; if(n%16&lt;10)&#123; return n%16; &#125;else&#123; return 9-(n%16-9); &#125;&#125;console.log(index(26));//8 实现add(1);//1add(1)(2); //3add(1)(2)(3); //6 12345678910111213141516171819var add = function(a) &#123; var sum = a; var s = function(b) &#123; sum += b; //s，继续累加后面的执行参数。 return s; &#125;; //当要打印一个对象时，会自动调用 valueOf()或 toString方法 s.toString = function() &#123; return sum; &#125;; //获取第一个参数赋值给sum后，s。 return s;&#125;;add(1)(2)(3);//6//第一次调用add(),初始化了s，并将a保存在s的作用链中。//然后返回s保证了第二次调用的是s函数。//第二次之后的调用也是调用s，而在s中将传入的参数与保存在作用链中a相加并付给sum。 给定一个数组，返回所有的数字。如[1,’3’,false,null,100]=&gt;[1,3,100] 123456789101112131415function search(arr)&#123; var temp = []; for(var i in arr)&#123; if(typeof arr[i] == &quot;string&quot; || typeof arr[i] == &quot;number&quot;)&#123; temp.push(arr[i]); &#125; &#125; temp = temp.map(function(val)&#123; if（typeof parseInt（val） == &quot;number&quot;） return parseInt(val); &#125;) return temp;&#125;console.log(search([1,&apos;3&apos;,false,null,100])); //[1,3,100]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器本地缓存]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[定义缓存是性能优化中简单高效的一种优化方式。 和本地存储不一样，浏览器缓存是浏览器请求网站留下的资源副本。 好处 减少带宽消耗 提升性能 缓解服务器压力 缓存位置 Service Worker Memory Cache Disk Cache Push Cache 缓存策略浏览器第一次向服务器发起请求拿到请求结果后，根据请求资源时返回的响应头来确定该不该缓存。 浏览器常见字段 Expires：告知客户端资源缓存失效的绝对时间。 Cache-Control：告知客户端或服务器如何处理缓存 max-age=xxx：表示缓存内容将在缓存时间的xxx秒后失效 no-cache：表示可以缓存，但每次用都要去向服务器验证缓存是否可用。 no-store：表示所有内容都不会缓存。 private：客户端可以缓存。 public：客户端和代理服务器都可以缓存。默认值。 Last-Modified：资源最后一次修改时间。 Etag：文件的特殊标识。用于文件内容对比，判断内容是否修改。 Cache-Control优先级高于Expires。 Etag优先级高于Last-Modified。 强缓存 根据本地缓存资源的header中的Expires和Cache-Control来判断是否命中强缓存。 如果命中强缓存则返回缓存的数据。 如果没有命中则进入协商缓存。 协商缓存 如果没有命中强缓存，浏览器会将本地缓存资源的header中的Last-Modified和Etag的值分别放入请求头的IF-Modified-Since和IF-None-Match字段中，向服务器发送请求，由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。 若命中即资源未更新，则服务器返回新的响应header信息且返回的http状态为304，但是并不返回资源内容，它会显示一个Not Modified的字符串，来告知浏览器使用缓存。 否则返回最新的数据，并将新数据存入缓存。 总结当浏览器再次访问一个已经访问过的资源时，会 先判断是否存在缓存，再看是否命中强缓存，如果命中，就直接使用缓存了。 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。 如果命中协商缓存，服务器会返回 304。 告诉浏览器使用本地缓存。 否则，返回最新的资源。 拓展ctrl+F5和F5的区别F5只是刷新本地缓存，强缓存无效，协商缓存有效；ctrl+F5是强缓存与协商缓存均无效，重新向服务器请求。 禁止浏览器缓存方法 设置响应头 12//把Cache-Control设置为no-cache&lt;meta HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt; 在访问的url后添加一个参数，可以是随机数或者时间戳。这样url时刻在变化，就要重新发送http请求]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：瀑布流布局]]></title>
    <url>%2F2019%2F03%2F27%2Fjs%2Fjs%EF%BC%9A%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[瀑布流布局的要求要进行布置的元素等宽； 然后计算元素的宽度， 与浏览器宽度之比，得到需要布置的列数； 创建一个数组，长度为列数， 里面的值为以已布置元素的总高度（最开始为0）； 然后将未布置的元素的依次布置到高度最小的那一列， 就得到了瀑布流布局； 滚动加载，scroll事件得到scrollTop， 与最后盒子的offsetTop对比， 符合条件就不断滚动加载。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（一）]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[求1+2+3+…+n1234567function Sum_Solution(n) &#123; var result = n; if(n &gt; 0) result += Sum_Solution(n-1); return result;&#125;console.log(Sum_Solution(3)); //6 统计一个数字在无序数组中出现的次数123456789101112131415function count(arr,num)&#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var result; var left = arr.indexOf(num); var right = arr.lastIndexOf(num,arr.length-1); if(arr.indexOf(num) == -1)&#123; result = 0; &#125;else&#123; result = right-left+1; &#125; return result;&#125;console.log(count([5,5,5,5,5,2,3],5)); //5 找出数组中任意一个重复的数字12345678910111213141516function duplicate(numbers, duplication)&#123; // write code here //这里要特别注意~找到任意重复的一个值并赋值到duplication[0] //函数返回True/False var temp = []; for(var i in numbers)&#123; if(temp.indexOf(numbers[i])==-1)&#123; temp.push(numbers[i]); &#125;else&#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false;&#125;console.log(duplicate([5,5,5,5,5,2,3],[]));//true 快速排序 1234567891011121314151617function quickSort(arr)&#123; if(arr.length &lt;= 1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%89%8D%E7%AB%AF%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。123456.transition&#123; -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s; &#125; 优雅降级一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。123456.transition&#123; transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 区别 渐进增强观点认为应该关注于内容本身。 优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：实现给数字添加千分位符的方法]]></title>
    <url>%2F2019%2F03%2F26%2Fjs%2Fjs%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E7%AC%A6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[toLocaleString方法12const num = 12345678;num.toLocaleString(); toLacalString：返回这个数字在特定语言环境下的表示字符串。 在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串。 正则表达式1234567const num = 12345678;var reg=/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g;num.replace(reg,&quot;$&amp;,&quot;);1. 正则表达式 \d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$) 表示前面有1~3个数字，后面的至少由一组3个数字结尾。2. ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。3. $&amp; 表示与正则表达式相匹配的内容。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue：其他]]></title>
    <url>%2F2019%2F03%2F26%2Fvue%2Fvue%EF%BC%9A%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[如何理解vuevue是一套用于构建用户界面的渐进式框架，采用MVVM架构。其核心库只关注视图层，采用自底向上增量开发的设计。vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。 优势： 低耦合。视图可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 简单的语法及项目创建，提供vue-cli脚手架，能非常容易地构建项目。 更快的渲染速度和更小的体积。 缺点：不支持IE8。 vuex(可以在vue1.0使用)vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。 场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 vue1.0和vue2.0的区别生命周期不一样vue1.0：init、created、beforeCompile、compiled、ready、beforeDestroy、destroyed vue2.0：beforeCreate、created、beforeMount、mounted、beforeUpload、uploaded、beforeDestroy、destroyed 绑定一次12vue1.0：&#123;&#123;*msg&#125;&#125;vue2.0：v-once，上述已废除 绑定html代码12vue1.0：&#123;&#123;&#123;msg&#125;&#125;&#125;vue2.0：v-html，上述已废除]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：发布-订阅和观察者]]></title>
    <url>%2F2019%2F03%2F26%2Fjs%2Fjs%EF%BC%9A%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%2F</url>
    <content type="text"><![CDATA[观察者模式（自定义事件）目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 观察者(订阅者)function Observer(name) &#123; this.name = name;&#125;Observer.prototype = &#123; update: function(context) &#123; console.log(this.name + &quot;：&quot; + context); &#125;&#125;// 观察者(订阅者)列表function ObserverList() &#123; this.observerList = [];&#125;ObserverList.prototype = &#123; add: function(obj) &#123; return this.observerList.push(obj); &#125;, count: function() &#123; return this.observerList.length; &#125;, get: function(index) &#123; if (index &gt; -1 &amp;&amp; index &lt; this.observerList.length) &#123; return this.observerList[index]; &#125; &#125;, removeAt: function(index) &#123; this.observerList.splice(index, 1); &#125;&#125;// 目标(发布者)function Subject() &#123; this.observers = new ObserverList();&#125;Subject.prototype = &#123; addObsever: function(observer) &#123; this.observers.add(observer); &#125;, removeObsever: function(observer) &#123; this.observers.removeAt(this.observers.indexOf(observer, 0)); &#125;, notify: function(context) &#123; var observerCount = this.observers.count(); for (var i = 0; i &lt; observerCount; i++) &#123; this.observers.get(i).update(context); &#125; &#125;&#125;var mySubject = new Subject();mySubject.addObsever(new Observer(&quot;小明&quot;));mySubject.addObsever(new Observer(&quot;小红&quot;));mySubject.notify(&quot;hello world&quot;); 发布-订阅理解发布-订阅模式，用个对象作为调度中心，绑定事件名为属性。订阅者把自己想订阅的事件注册到调度中心，发布者发布事件到调度中心时，即触发这个事件，由调度中心统一调度订阅者注册到调度中心的处理代码。 优点 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。 缺点 创建订阅者需要消耗一定的时间和内存。 虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。 一个简单的发布订阅123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var event = &#123; clientList: &#123;&#125;, listen: function( key, fn )&#123; //添加订阅对象 if( !this.clientList[ key ] )&#123; this.clientList[ key ] = []; &#125; this.clientList[ key ].push( fn ); &#125;, trigger: function()&#123; //绑定发布事件 var key = Array.prototype.shift.apply( arguments ), fns = this.clientList[ key ]; for( var i = 0, fn; fn = fns[ i++]; )&#123; fn.apply( this, arguments ); &#125; &#125;, remove: function( key, fn )&#123; //取消订阅的事件 var fns = this.clientList[ key ]; if( !fns )&#123; //如果key对应的消息没有被人订阅，则直接返回 return false; &#125;; if( !fn )&#123; //如果没有传入具体的回调函数，标示取消key对应消息的所有订阅 fns = []; &#125;else&#123; for( var i = fns.length - 1; i &gt;= 0 ; i-- )&#123; //取消key对应的订阅消息 if( fn === fns[ i ] )&#123; fns.splice( i, 1 ); &#125; &#125; &#125; &#125;&#125;;var saleOffices = &#123;&#125;;//给对象绑定一个调度中心var installEvent = function( obj )&#123; for( i in event )&#123; obj[ i ] = event[ i ]; &#125;&#125;;installEvent( saleOffices );saleOffices.listen( &quot;squareMeter88&quot;, fn1 = function( price )&#123; console.log( &quot;价格&quot; + price );&#125; );saleOffices.listen( &quot;squareMeter88&quot;, function( price )&#123; console.log( &quot;价格&quot; + price );&#125; );saleOffices.remove( &quot;squareMeter88&quot;, fn1 );saleOffices.trigger( &quot;squareMeter88&quot;, 200000 ); 不同观察者模式的订阅者和发布者之间是存在依赖的，发布订阅模式的不会。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js：Math的常用方法]]></title>
    <url>%2F2019%2F03%2F26%2Fjs%2Fjs%EF%BC%9AMath%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111. Math.sqrt()：计算平方根2. Math.cbrt()：计算立方根3. Math.pow(a, b)：计算a的b次方4. Math.max(a,b,c...)：计算最大值5. Math.min(a,b,c...)：计算最小值6. Math.abs()：求绝对值 7. Math.ceil()：向上取整8. Math.floor()：向下取整9. Math.random()：取得一个[0.0,1.0)的随机数 10. Math.rint()： 四舍五入，返回double值。注意.5的时候会取偶数11. Math.round()： 四舍五入，float时返回int值，double时返回long值]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：margin塌陷]]></title>
    <url>%2F2019%2F03%2F26%2Fcss%2Fcss%EF%BC%9Amargin%E5%A1%8C%E9%99%B7%2F</url>
    <content type="text"><![CDATA[标准文档流中，垂直方向的margin不叠加，以较大的为准。原理是他们处于同一个BFC中。 给父盒子添加border。 给父盒子添加padding。 给父盒子添加overflow:hidden。 给父盒子添加position:fixed。 给父盒子添加display:table。 给子元素的前面加一个兄弟元素12content:&quot;&quot;;overflow:hidden;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：垂直居中]]></title>
    <url>%2F2019%2F03%2F26%2Fcss%2Fcss%EF%BC%9A%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[基于绝对定位要求元素具有固定的高度和宽度123456789&#123; position:absolute; top:50%; left:50%; margin-top:-20px; margin-left:-20px; height:40px; width:40px;&#125; 12345678//借助calc()函数&#123; position:absolute; top:calc(50%-20px); left:calc(50%-20px); height:40px; width:40px;&#125; 不需要在偏移量中把元素尺寸写死123456&#123; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; 基于Flex布局123456&#123; display:flex; justify-content:center;//使子元素水平居中 align-items:center;//使子元素垂直居中 height:40px;&#125; 基于table布局12345&#123; display: table-cell; vertical-align: middle;//使子元素垂直居中 text-align: center;//使子元素水平居中&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：position]]></title>
    <url>%2F2019%2F03%2F26%2Fcss%2Fcss%EF%BC%9Apositon%2F</url>
    <content type="text"><![CDATA[position:static没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。 position:fixed相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。 position:relative 相对于元素自身正常位置定位，元素在正常的文档流中占位。 当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。 position:absolute 元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。 必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，但是不占位。 绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会 绝对定位对象头部超过可视区域会被裁掉。 position:inherit规定应该从父元素继承 position 属性的值。 z-index 如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。 需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：清除浮动]]></title>
    <url>%2F2019%2F03%2F26%2Fcss%2Fcss%EF%BC%9A%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动产生影响 给父元素设置高度。 给父元素设置overflow:hidden; 父元素也设置浮动。 在结尾处添加空div标签clear:both 父元素定义伪类::after 12345::after&#123; clear: both; content: &quot;&quot;; display: block; &#125; 父元素定义display:table]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5和css3的新特性]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%89%8D%E7%AB%AF%2Fh5%E5%92%8Ccss3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[HTML5绘画标签canvas用于媒介回放的video、audio本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失 sessionStorage数据在浏览器关闭后自动删除； 语义化更好的内容元素比如article、footer、header、nav、section； 表单控件calendar、data、time、email、url、search； webworker、websocket、Geolocation； 移除的元素： 纯表现的元素：basefont、big、center、font、s、strike、tt 对可用性产生负面影响的元素：frame、frameset、noframes CSS3RGBA和透明度word-wrap（对长的不可分割单词换行）1word-wrap: normal|break-word; 文字阴影12text-shadow：5px 5px 5px #FF0000;//水平阴影，垂直阴影，模糊距离，阴影颜色 @font-face规则定义自己的字体 圆角（边框半径）border-radius 属性用于创建圆角 边框图片border-image box-sizing盒阴影1box-shadow:10px 10px 5px #88888 媒体查询定义两套css，当浏览器的尺寸变化时会采用不同的属性]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储方式]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%89%8D%E7%AB%AF%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[cookie、localStorage、sessionStorage相同：在本地（浏览器端）存储数据。 不同 localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。 sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。 localStorage是永久存储，除非手动删除。 sessionStorage当会话结束（当前页面关闭的时候，自动销毁） cookie的数据会在每一次发送http请求的时候，同时发送给服务器，而localStorage、sessionStorage不会。 每个cookie存放的内容大小有限制，一般为4kb。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron进阶：打开新窗口]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%85%B6%E4%BB%96%2FElectron%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[标签实现新窗口打开 增加 target=”_blank”属性 router-link标签只有tag=”a”模式下 target=”_blank” 属性才会生效（vue2） 编程式导航123456let routeData = this.$router.resolve(&#123; name: &quot;searchGoods&quot;, query: params, params:&#123;catId:params.catId&#125; &#125;); window.open(routeData.href, &apos;_blank&apos;);]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron：结合vue创建桌面应用]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%85%B6%E4%BB%96%2FElectron%EF%BC%9A%E7%BB%93%E5%90%88vue%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先创建项目并安装好依赖12345vue init webpack test-electroncd test-electronnpm installnpm install electron --save-devnpm install electron-packager --save-dev 其次将零基础中的main.js拷贝到新建项目的build目录下，并更名为electron.js 按照实际项目路径更改electron.js中的路径 12345mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, &apos;../dist/index.html&apos;), protocol: &apos;file:&apos;, slashes: true &#125;)) 最后在新建项目package.json文件中增加一条指令 1234567&quot;scripts&quot;: &#123; ... &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, //增加这条,JSON文件不支持注释，引用时请清除 &quot;electron_dev&quot;: &quot;npm run build &amp;&amp; electron build/electron.js&quot; &#125;, 启动12npm run build //生成dist目录npm run electron_dev //启动electron PS 打包前：更改config/index.js中生产模式下（build）的assetsPublicPth, 原本为 /, 改为 ./ 。]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron：从零到完成一个桌面应用]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%85%B6%E4%BB%96%2FElectron%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Electron 开发环境 安装node 安装cnpm（或者npm） 安装electron 安装打包工具 1npm install -g electron-packager 经典例子electron-quick-start一个简约的记事本12345678//克隆这仓库 git clone https://github.com/electron/electron-quick-start//进入仓库 cd electron-quick-start//安装依赖库 cnpm install//运行应用，也可以用： cnpm run start cnpm start electron-api-demos介绍了主要的一些功能及实现代码 1234git clone https://github.com/electron/electron-api-demoscd electron-api-demoscnpm installcnpm start 开始开发安装electron推荐的安装方法是把electron作为您 app 中的开发依赖项，使您可以在不同的 app 中使用不同的 Electron 版本 在根目录下运行 1npm install --save-dev electron 当然，也可以在 $PATH 中全局安装1npm install electron -g 创建Electron简单文件结构在根目录下创建package.json文件，内容如下 1234567891011&#123; &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;electron&quot;: &quot;^3.0.4&quot; &#125;&#125; 在根目录下创建main.js，内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const &#123; app, BrowserWindow &#125; = require(&apos;electron&apos;) // Keep a global reference of the window object, if you don&apos;t, the window will // be closed automatically when the JavaScript object is garbage collected. let win function createWindow () &#123; // 创建浏览器窗口。 win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) // 然后加载应用的 index.html。 win.loadFile(&apos;index.html&apos;) // 打开开发者工具 win.webContents.openDevTools() // 当 window 被关闭，这个事件会被触发。 win.on(&apos;closed&apos;, () =&gt; &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null &#125;) &#125; // Electron 会在初始化后并准备 // 创建浏览器窗口时，调用这个函数。 // 部分 API 在 ready 事件触发后才能使用。 app.on(&apos;ready&apos;, createWindow) // 当全部窗口关闭时退出。 app.on(&apos;window-all-closed&apos;, () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== &apos;darwin&apos;) &#123; app.quit() &#125; &#125;) app.on(&apos;activate&apos;, () =&gt; &#123; // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) &#123; createWindow() &#125; &#125;) // 在这个文件中，你可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 然后创建index.html文件，内容如下 12345678910&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;TEST&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span style=&quot;color:#fff;&quot;&gt;Hello World&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 启动app1npm start 或者在package.json中配置1&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;electron .&quot;&#125; 则可以输入一下命令启动1electron . 打包全局安装electron-packager]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+axios解决文件上传问题]]></title>
    <url>%2F2019%2F02%2F26%2Fvue%2Fvue%2Baxios%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前因关于文件上传，可以使用element-ui中的组件，也可以直接使用input，最近做的一个项目中有用到，查了挺多资料研究了一下，最终就实用性来说还是后者bug少。 现在就这两个介绍一下，如果有错误请提出纠正，或者有更好的可以来分享一下。 Element-UI直接action这个方法很简单，文档中有一一详细列出，重点是下一个 可参考官方文档 利用before-upload属性直接action很方便简单，但是总会有各种难以解决的错误出现如：后台要求请求方式为multipart/form-data时，不能使用data传参数，这时候就要使用formdata对象了。 使用new一个formdata对象，然后对这个对象追加key和value 12345678910//网上给出的例子beforeUpload (file,id) &#123; let fd = new FormData() fd.append(&apos;file&apos;, file) fd.append(&apos;id&apos;,id) axios.post(url, fd, &#123; &#125;) return false // false就是不自动上传&#125;, 改进后我的例子 12345678910111213141516171819202122232425&lt;el-dialog title=&quot;导入报表&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot; :append-to-body=&apos;true&apos;&gt; &lt;el-upload class=&quot;upload-demo&quot; ref=&quot;upload&quot; action=&quot;/super_admin/factory/device/import&quot; :limit=&quot;1&quot; :on-exceed=&quot;handleExceed&quot; :file-list=&quot;fileList&quot; :auto-upload=&quot;false&quot; :before-upload=&quot;beforeAvatarUpload&quot; :on-error=&quot;error&quot; :before-remove=&quot;beforeRemove&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;/el-upload&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click.native=&quot;importTable()&quot;&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; ``` data() { return { dialogVisible: false, // 所上传的文件 fileList: [] } }, 12 methods: { // 限制上传文件为一个 handleExceed() { this.$message.warning(‘当前限制上传 1 个文件’); }, // 对文件类型进行判断并上传（重点！） beforeAvatarUpload(file) { const isXLSX = file.type === “application/vnd.openxmlformats-officedocument.spreadsheetml.sheet”; if (!isXLSX) { this.$message.error(“上传的文件只能是 xlsx 格式!”); this.fileList = []; }else { let factoryId = this.factoryId; let fd = new FormData(); fd.append(‘file’, file); fd.append(‘factoryId’, factoryId); api.importTable((err, res) =&gt; { if (err || res.status !== 200) { this.$message.error(“出错了，刷新一下吧”); return; } if (res.data.code == 403) { this.$message.error(“该账号没有此操作权限”); } else if (res.data.code == 200) { this.$message({ message: ‘文件上传成功！’, type: ‘success’ }); } else { this.$message.error(“出错了，刷新一下吧”); } },fd); return true } }, // 文件上传失败 error(err) { this.$message({ message: ‘文件上传失败！’, type: ‘warning’ }); }, // 移除已上传的文件 beforeRemove(file) { return this.$confirm(‘确定移除 ‘+file.name+’ ？’); }, // 导入报表至后台 importTable() { this.$refs.upload.submit(); this.dialogVisible = false; }, }12 // 引用instanceimport instance from ‘./instance.js’ function importTable(fn,data) { return instance({ method: “post”, url: ‘/super_admin/factory/device/import’, data: data, headers: { “Content-Type”: “multipart/form-data” } })} export{ importTable} 12345678910### 注意1. 这种方法也有弊端，action作为必填参数，无论是填任意数或者填写重复地址，控制台总会报404。2. FormData对象是不可以通过console.log在控制台直接打印出来的，但可以通过FormData.get()获取值。## input上传这个是重点，就实用来说，掌握一种方法就可以了，这个是目前最成功的（结合后台）。### 使用 12 data() { return { // 上传文件所需的参数 upload: { CurrentfactoryId: “” }, }} 12 methods: { // 打开上传文件的弹出框 handleUpload(index, row) { this.upload.CurrentfactoryId = row.factoryId; this.$refs.importFile.click(); }, // 确认导入列表 confirmUpload() { this.$confirm(‘此操作将上传 ‘+this.$refs.importFile.files[0].name+’ , 是否继续?’, ‘提示’, { confirmButtonText: ‘确定’, cancelButtonText: ‘取消’, type: ‘warning’ }).then(() =&gt; { this.$message.info(‘该过程耗时较长，请耐心等待’); this.importTable(); }).catch(() =&gt; { this.$message({ type: ‘info’, message: ‘已取消上传’ }); this.$refs.importFile.value = null; }); }, // 导入报表至后台 importTable() { let fd = new FormData(document.getElementById(“uploadform”)); // fd.append(“file”, this.upload.importFile); // fd.append(“factoryId”, this.upload.CurrentfactoryId); // console.log(fd.get(‘importFile’)); api.importTable((err, res) =&gt; { if (err) { if (err.response.status === 403 &amp;&amp; err.response.data.code==-2) { this.$message.error(“请登录”); session.clear(); this.$router.push({ path: “/login” }); } else if ( err.response.status === 500) { this.$message.error(“系统出错，请稍后再试”); } else if (err.response.status == 403) { this.$message.error(“该账号没有此操作权限”); } return; } if (res.data.code == 200) { this.$message({ message: “文件上传成功！”, type: “success” }); this.visible = false; } else { this.$message.error(“出错了，刷新一下吧”); } },fd); },} 12 // 引用instanceimport instance from ‘./instance.js’ function importTable(fn,data) { instance.post(‘/super_admin/factory/device/import’, data) .then(function (res) { fn(false, res); }).catch(function (err) { fn(err); });} export{ importTable} ` 注意 如果对于input的样式不满意，可以使用opacity把原来的input透明化来进行美化。 依然是使用formdata对象，虽然使用vue，但不知道为什么用append无法把文件传到后台，因此通过操作节点来新建，如果有人知道可以分享一下。 headers可以不手动添加，浏览器会判定界限，也可以加上。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm install 出错]]></title>
    <url>%2F2019%2F02%2F26%2Fgit%2Fnpm%20install%20%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[第一种问题123$ npm installnpm WARN registry Unexpected warning for or http://registry.cnpmjs.org/: Mis Miscellaneous Warning ECONNRESET: request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/acorn/-/acorn-5.7.1.tgz fai failed, reason: read ECONNRESETnpm WARN registry Using stale package data from om http://registry.cnpmjs.org/ du/ due to a request error during revalidation. 解决方法12$ npm config set registry ry http://registry.cnpmjs.org$ npm install 第二种问题1234567891011$ npm installnpm ERR! code ECONNRESETnpm ERR! errno ECONNRESETnpm ERR! network request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/arrify/-/arrify-1.0.1.tgz fai failed, reason: read ECONNRESETnpm ERR! network This is a problem related to network connectivity.npm ERR! network In most cases you are behind a proxy or have bad network settings.npm ERR! networknpm ERR! network If you are behind a proxy, please make sure that thenpm ERR! network &apos;proxy&apos; config is set properly. See: &apos;npm help config&apos;npm ERR! A complete log of this run can be found in: 解决方法12$ npm config delete proxy$ npm install 第三种问题12$ npm installnpm ERR! write after end 解决方法降低版本 1npm i -g npm@5.6.0]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建属于自己的博客（进阶）NexT主题]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%85%B6%E4%BB%96%2FHexo%2BGithub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89NexT%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[主题安装安装NexT在站点目录下（hexo），输入命令： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在站点目录中（blog），打开配置文件_config.yml，修改1theme：next 验证主题1$ hexo s 主题设定以下所有设置注意格式 NexT主题设定可以在next主题目录下的_config.yml文件中修改 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 基础设置在站点目录下的配置文件_cofig.yml中修改 12345678# Sitetitle: your blog titlesubtitle:description: describe yourselfkeywords:author: yournamelanguage: zh-Hans //简体中文timezone: 修改菜单项在主题目录下修改配置文件_cofig.yml中的menu 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 限定主页文章高度修改主题目录下的值 123auto_excerpt: enable: true length: 150 设置头像修改主题目录下Sidebar Avatar的avatar值1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 添加标签页面点击标签，跳转的页面会显示page not found 此时需要在站点目录的source文件夹里新建tags文件夹，并新建index.md，添加： 12345---title: tagsdate: type: &quot;tags&quot;--- 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可 实现点击出现桃心效果将代码copy到/themes/next/source/js/src里面新建的love.js中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950! function(e, t, a) &#123; function n() &#123; c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;); requestAnimationFrame(r) &#125; function o() &#123; var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement(&quot;div&quot;); a.className = &quot;heart&quot;, d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) &#125; function s() &#123; return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; &#125; var d = []; e.requestAnimationFrame = function() &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js 1&lt;script src=&quot;/js/src/love.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 添加动态背景打开\themes\next\layout_layout.swig文件，在 之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开开\themes\next_config.yml,在里面修改为如下代码 1canvas_nest: true 在网站底部加上访问量打开\themes\next\layout_partials\footer.swig文件,在类copyright前加上这段代码： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后在合适的位置添加显示统计的代码： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在每篇文章末尾添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件,在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 侧边栏社交链接在主题配置文件中修改： 12345678910111213# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 添加小图标在主题配置文件中修改： 123favicon: #small: /images/favicon.ico medium: /images/favicon.ico NexT主题美化 除了NexT还有很多其他好看的主题，百度会有很多方法的]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2018%2F05%2F03%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件流 事件冒泡事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） 事件捕获不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件事件捕获用意在于在事件到达预定目标之前捕获它 DOM事件流（事件流描述的是从页面中接收事件的顺序） 事件捕获阶段（从document开始） 处于目标阶段 事件冒泡阶段 事件处理程序HTMl事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定 特性的值 可以是能够执行的js代码 1&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&apos;Clicked&apos;)&quot;/&gt; 也可以调用在页面其他地方定义的脚本 123456&lt;input id=&quot;btn&quot; value=&quot;click me&quot; onclick=&quot;showMessage()&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; function showMessage()&#123; alert(&quot;clicked&quot;); &#125;&lt;/script&gt; 扩展作用域 12345678function()&#123; with(document)&#123; eith(this)&#123; //元素属性值 &#125; &#125;&#125; 在这个函数内部，可以像访问局部变量一样访问document 及该元素本身的成员 DOM0级事件处理程序（主要）通过JavaScript指定处理程序的传统方式，将一个函数赋值给一个事件处理程序属性。每个元素（包括document和window）都有自己的事件处理程序属性以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理 123456789var btn = document.getElementById(&quot;btn&quot;);btn.onclick = function()&#123; alert(&quot;Clicked&quot;); //指定事件处理程序&#125;;btn.onclick=function()&#123; alert(this.id);//btn //其作用域为元素的作用域&#125;//想要取消事件处理程序的话，只需将事件处理程序属性设为null即可btn.onclick = null; DOM2级事件处理程序用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener() 12345678//指定事件处理程序 btn.addEventListener(&quot;click&quot;,fucntion()&#123;alert(&quot;clicked&quot;);&#125;,false);//取消事件处理程序btn.removeEventListener(&quot;click&quot;,function()&#123;alert(&quot;clicked&quot;);&#125;,false);//无效//指定和取消的参数必须完全相同才有效//而匿名函数是两个不同的函数，所以无效 为了能够取消，最好函数采用函数表达式 1234567var handler = function()&#123; alert(&quot;clicked&quot;); &#125;;//添加事件处理程序btn.addEventListener(&quot;click&quot;,handler,false);//取消事件处理程序btn.removeEventListener(&quot;click&quot;,handler,false);//有效 IE事件处理程序用于处理指定和删除事件处理程序的操作：attachEvent()和detachEvent() IE事件处理程序与DOM事件处理程序的最大区别：DOM0/2级事件处理程序的作用域是元素作用域；而IE事件处理程序是全局作用域，即this等于widow 123456789var handler = function()&#123; alert(&quot;clicked&quot;); &#125;;//指定事件处理程序btn.attachEvent(&quot;onclick&quot;,handler);//取消事件处理程序btn.detachEvent(&quot;onclick&quot;,handler);//取消参数必须与添加完全相同所以事件处理程序函数(同DOM2级事件中的分析一样)不要是匿名函数。 跨浏览器的事件处理程序用于处理指定和删除事件处理程序的操作：addHandler()和removeHandler()这两个方法属于一个名叫EventUtil的对象 1234567var handler = function()&#123; alert(&quot;Clicked&quot;);&#125;;//指定事件处理程序EventUtil.addHandler(btn,&quot;click&quot;,handler);//移除事件处理程序EventUtil.removeHandler(btn,&quot;click&quot;,handler); 事件对象在触发DOM上的某个事件时，会产生一个事件对象event。这个对象中包含着所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息所有浏览器都支持event对象，event对象会传入DOM0级，DOM2级，HTML指定的事件处理程序中，但支持的方式不同，所以也会涉及跨浏览器的部分 DOM中的事件对象 相关属性方法详见书355 两个有点难区分的属性： currentTarget：this对象始终是指向它的值，为其事件处理程序当前正在处理事件的那个元素 target：只包含事件的目标 IE中的事件对象 相关属性方法详见书359 跨浏览器的事件对象对前面介绍到的EventUtil对象加以增强添加如下方法 ，写一个通用的事件侦听函数即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546听说面试会问到，这样写就可以了var EventUtil=&#123;getEvent:function(event)&#123; return event||window.event;&#125;,getTarget:function(event)&#123; return event.target||event.srcElement;&#125;,preventDefault:function()&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue=false; &#125;&#125;,stopPropagation:function()&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble=true; &#125;&#125;,addHandler:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler,false); &#125;else if(element.attachEvent)&#123; element[&quot;e&quot;+type]=function()&#123; handler.call(element) &#125; element.attachEvent(&quot;on&quot;+type,element[&quot;e&quot;+type]); &#125;else&#123; element[&quot;on&quot;+type]=handler; &#125;&#125;,removeHandler:function(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125;else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot;+type,element[&quot;e&quot;+type]); element[&quot;e&quot;+type]=null; &#125;else&#123; element[&quot;on&quot;+type]=null; &#125;&#125; &#125;; 事件类型 好像没什么必要一一列出来了，详见书中362 内存和性能事件委托 利用冒泡的原理，把事件加到父级上，触发执行效果 通俗的讲，就是这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件 使用事件委托，只需在DOM树中尽量最高的层次上添加一个事件处理程序 移除事件处理程序 从文档中移除带有事件处理程序的元素时 卸载页面时 模拟事件DOM中的事件模拟 调用document.createEvent()方法创建event对象 初始化对象，为对象添加相关信息 调用dispatchEvent()方法触发事件 IE中的事件模拟 调用document.createEventObject()方法创建event对象 初始化对象，为对象添加相关信息 调用fireEvent()方法触发事件]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数表达式]]></title>
    <url>%2F2018%2F05%2F03%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数表达式定义函数的方式使用函数声明12345function 函数名(参数)&#123; //函数体&#125;可通过name属性访问函数名（即标识符）（有何意义？）alert(函数名.name);//函数名 使用函数表达式这种情况下创建的函数叫匿名函数顾名思义，因为 function关键字后面没有函数名（即标识符）123var 变量=function()&#123; //函数体&#125;; 两者的主要区别（1） 函数声明无论置于调用语句前后，解析器都会先读取函数声明 后面不能跟圆括号 由于函数声明的一个重要特征—函数声明提升（在执行代码之前会先读取函数声明）这意味着可以把函数声明放在调用它的语句后面 （2）函数表达式则要等到解析器执行到它所在代码行才被真正执行 后面可以跟圆括号，表示立即自我执行 则函数表达式需要先把函数赋值给变量，再调用函数 递归递归函数是在一个函数通过名字调用自身的情况下构成的 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125; 缺点：把该函数保存在另一个变量中，且将factorial变量设置为null时（即当函数名改变了时），导致错误 改进arguments.callee是一个指向正在执行的函数的指针，通俗一点讲就是指向拥有arguments对象的函数 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; //arguments.callee代替函数名 return num*arguments.callee(num-1); &#125;&#125; 闭包概念在讲述闭包之前必须先引入几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)以函数a从定义到执行的过程为例阐述： ① 当定义函数a的时候，js解释器会将函数a的作用域链设置为定义a时a所在的“环境”，如果a是一个全局函数，则作用域链中只有全局变量对象。 ② 当执行函数a的时候，a会进入相应的执行环境。 ③ 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中作用域链。 ④ 然后执行环境会创建一个活动对象（活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问）。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。 ⑤下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。 ⑥ 最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 a的作用域链（本质上是一个指向变量对象的指针列表）包含 本地活动对象：arguments属性，a的变量，函数 全局变量对象 小结 闭包是指有权访问另一个函数作用域中的变量的函数，通过模拟全局作用域，使局部变量变为全局变量闭包就是将函数内部和函数外部连接起来的一座桥梁 创建闭包的常用方式：在一个函数内部创建另一个函数 JavaScript中所有的function都是一个闭包。 不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。 闭包的用途 1、使其可以访问其外部函数作用域中的变量2、可以实现局部变量驻留在内存中从而累加通常函数的作用域及其所有变量会在函数执行结束后被销毁。 但由于闭包（内部函数）的作用域链包含外部函数（非全局）的活动对象。当函数返回一个闭包时，函数的作用域将会一直在内存中保存到闭包不存在为止 关于this对象 闭包运行时this指向window 12345678910var name=&quot;The window&quot;;var object=&#123; name:&quot;The Object&quot;, getNameFunc:function()&#123; return function()&#123; return this.name; //这里的作用域，this指向window &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;The window&quot; 改进1 可适用对象冒充的方式使this指向object 1alert(object.getNameFunc().call(object)); //对象冒充 改进2 访问作用域中的this/arguments对象，必须将对该对象的引用（this）保存到另一个闭包能够访问的变量中 12345678910111213var name=&quot;The window&quot;;var object=&#123; name:&quot;The Object&quot;, getNameFunc:function()&#123; var that=this; //这里的作用域，this指向object return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;The Object&quot;不过这个不会常用，太绕了！！！理解思路即可 改进3 这不是闭包，也不算改进，只是通常是用这种来表示 12345678var name=&quot;The window&quot;;var object=&#123; name:&quot;The Object&quot;, getNameFunc:function()&#123; return this.name; &#125;&#125;;alert(object.getNameFunc()); //&quot;The Object&quot; 模仿块级作用域在JavaScript中，从变量有定义开始，就可以在函数内部随处访问它，即使错误地重新声明同一个变量，也不会改变它的值，当然，重新赋值是会改变的 1234567(function()&#123; //这里是块级作用域&#125;)();JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号，给函数声明加上一对圆括号即转换成函数表达式，后面就可以跟圆括号了 使用块级作用域，匿名函数中定义的任何变量，都会在执行结束时被销毁这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数，能有效防止命名冲突 私有变量严格来讲，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过有一个私有变量的概念私有变量包括函数的参数、局部变量和在函数内部定义的其他函数 特权方法有权访问私有变量的公有方法，在公共域可见，不可被修改，只能替换/删除 在这里提出一个问题：在函数外部私有变量不可访问，又为什么用特权方法使之可以访问呢？为什么不直接舍弃而用公有方法呢？（个人理解）私有变量除了不可访问还不可修改，可隐藏那些不该被直接修改的数据，但私有变量在函数外部不可见，因此通过特权方法访问它们但也仅仅是访问而已 创建特权方法的方式方法1在构造函数中定义特权方法 123456789101112function MyObject()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return true; &#125; //特权方法 this.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;;&#125; 方法2在私有作用域中定义私有变量和函数，通过构造函数的原型定义特权方法 1234567891011121314(function()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return true; &#125; //构造函数,在函数中不带var的变量为全局变量 MyObject=function()&#123; &#125;; //有点像原型模式创建对象 //公有/特权方法 MyObject.prototype.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); //匿名函数的自我执行 方法3模块模式前两种方法是用于以构造函数的方式创建私有变量和特权方法的这种是用于以对象字面量的方式为单例创建私有变量和特权方法的 单例：只有一个实例的对象，其实为对象字面量声明方式，永远实例化一次 1234567891011121314151617181920212223//以对象字面量的方式创建单例对象var singleton=&#123; name:value, method:function()&#123; //这里是方法的代码 &#125;&#125;//为单例对象添加私有变量和特权方法使其增强var singleton=function()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return true; &#125; //公有/特权方法和属性 return&#123; publicProperty:true, publicMethod:function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); //匿名函数的自我执行 方法4增强的模块模式在返回对象之前加入对其增强的代码适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况 1234567891011121314151617var singleton=function()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return true; &#125; //创建对象 var object=new CustomType(); //公有/特权方法和属 object.publicProperty:true, object.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;; //返回这个对象 return object;&#125;(); //匿名函数的自我执行]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON与Ajax]]></title>
    <url>%2F2018%2F05%2F03%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2FJSON%E4%B8%8EAjax%2F</url>
    <content type="text"><![CDATA[JSON语法 简单值字符串、数值、布尔值、null，但不支持undefined JSON字符串必须使用双引号 对象 12345678910JavaScript: var object=&#123; name:&quot;Greg&quot;, age:27 &#125;;JSON: &#123; &quot;name&quot;:&quot;Greg&quot;, &quot;age&quot;:27 &#125; 1、JSON对象没有声明变量（JSON没有变量）2、JSON对象没有末尾的分号 PS：JSON对象的属性必须加双引号 数组 12JavaScript： var values=[25,&quot;hi&quot;,true];JSON: [25,&quot;hi&quot;,true] JSON数组没有变量和分号 解析与序列化全局对象JSON有两个方法：stringify() 把JavaScript对象序列化成JSON字符串parse() 把JSON字符串解析为原生JavaScript值 序列化选项 stringify()参数：第一个是过滤器数组过滤器：JSON.stringify()的结果中只包含数组中列出的属性函数过滤器：函数接收属性（键）名和属性值，返回结果为相应值第二个是一个选项表示是否在JSON字符串中保留缩进第三个控制结果中的缩进和空白符 toJSON()方法可以给对象定义toJSON()方法，返回其自身的JSON数据格式 解析选项JSON.parse()接收一个参数：还原函数与JSON.stringify()接收的替换（过滤）函数，两者签名相同 JSON小结 JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据 JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量 JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式 JSON字符串和JSON对象属性必须加双引号 Ajax还没学JQ，暂用原生JS 123456789101112131415161718192021兼容function createXHR()&#123; if(typeof XMLHttpRequest !=&quot;undefined&quot;)&#123; return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject !=&quot;undefined&quot;)&#123; var version=[ &quot;MSXML2.XMLHttp6.0&quot;, &quot;MSXML2.XMLHttp3.0&quot;, &quot;MSXML2.XMLHttp&quot; ]; for(var i=0;i&lt;version.length;i++)&#123; try&#123; return new ActiveXObject(version[i]); &#125;catch(e)&#123; //跳过 &#125; &#125; &#125;else&#123; throw new Error(&quot;您的系统浏览器不支持XHR对象!&quot;) &#125;&#125; XMLHttpRequest 属性 说明 responseText 作为响应主体被返回的文本 responseXML …… status 响应HTTP状态（200为成功） statusText HTTP状态的说明 HTTP状态码2字头：成功3字头：重定向4字头：请求错误5、6字头：服务器错误 HTTP两种头部信息响应头部信息：服务器返回的信息，客户端可以获取但不可以设置请求头部信息：客户端发送的信息，客户端可以设置但不可以获取 同步与异步 同步 12345678910addEvent(document,&quot;click&quot;,function()&#123; var xhr=createXHR(); xhr.open(&quot;get&quot;,demo.txt,false); xhr.send(null); if(xhr.status==200)&#123; alert(xhr.respenseText); &#125;else&#123; alert(&quot;获取数据错误 错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText); &#125;&#125;); 异步 123456789101112131415addEvent(document,&quot;click&quot;,function()&#123; var xhr=createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; alert(xhr.respenseText); &#125;else&#123; alert(&quot;获取数据错误 错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText); &#125; &#125; &#125;; xhr.open(&quot;get&quot;,demo.txt,true); //xhr.abort(); 取消异步请求，在接收到响应之前使用 xhr.send(null);&#125;); GET与POST在Web程序上，GET一般是URL提交请求，如demo.php?nme=Lee&amp;age=27POST一般是Web表单提交 GET请求 12345678demo1.php&lt;?php$username = $_GET[&apos;username&apos;];$age = $_GET[&apos;age&apos;];echo &quot;你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;&quot;;?&gt; 1234567891011121314addEvent(document,&quot;click&quot;,function()&#123; var xhr=createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; alert(xhr.respenseText); &#125;else&#123; alert(&quot;获取数据错误 错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText); &#125; &#125; &#125;; xhr.open(&quot;get&quot;,&quot;demo1.php?username=Lee&amp;age=27&quot;,true); xhr.send(null);&#125;); POST请求 12345678demo2.php&lt;?php$username = $_POST[&apos;username&apos;];$age = $_POST[&apos;age&apos;];echo &quot;你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;&quot;;?&gt; 123456789101112131415161718addEvent(document,&quot;click&quot;,function()&#123; var xhr=createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; alert(xhr.respenseText); &#125;else&#123; alert(&quot;获取数据错误 错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText); &#125; &#125; &#125;; //第一步：改为post xhr.open(&quot;post&quot;,&quot;demo2.php&quot;,true); //第三步：模拟表单提交，申明发送的数据类型 xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/x-www-form-urlencoded&apos;); //第二步：将名值对放入send()方法里 xhr.send(&quot;username=Lee&amp;age=27&quot;);&#125;); Ajax步骤 创建对象 调用open()启动一个请求以备发送 调用send()发送请求 接收响应]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建属于自己的博客（基础）]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%85%B6%E4%BB%96%2FHexo%2BGithub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[搭建环境准备Node.js 的安装和准备12$ node -v$ npm -v git的安装和准备1$ git --version github账户的配置 github账户注册 创建新仓库 注意：仓库名称一定为 github用户名.github.io 仓库设置 接下来开启github pages功能 ，点击界面右侧的 Settings，你将会打开这个库的settings页面，向下拖动，直到看见GitHub Pages 安装hexo在任意一个地方创建文件夹hexo，进入到该目录输入： 1$ npm install hexo-cli -g 然后可能会看到一个WARN，并不会影响操作，继续输入： 1$ npm install hexo --save 1$ hexo -v hexo的相关配置 初始化hexo 12$ hexo init &lt;新文件夹&gt; $ cd &lt;新文件夹&gt; 首次体验hexo 123$ hexo g$ hexo s //若一直无法跳转，则是端口被占用$ hexo server -p 5000 //改变端口号 配置Git个人信息如果之前已经配置好git个人信息，请跳过这一个步骤 设置Git的user name和email 12$ git config --global user.name &quot;yourusername&quot;$ git config --global user.email &quot;youremail&quot; 生成密钥 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 配置Deployment在_config.yml文件中，找到Deployment，然后按照如下修改： 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 写博客、发布新文章 新建一篇博客 1$ hexo new post &quot;article title&quot; 用MarDown编辑器打开就可以编辑文章了 生成、部署 12$ hexo g // 生成$ hexo d // 部署 1$ hexo d -g //在部署前先生成 踩坑提醒 注意需要提前安装一个扩展 1npm install hexo-deployer-git --save 如果没有执行这行命令，将会提醒 deloyer not found:git]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2018%2F05%2F03%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2FDOM%2F</url>
    <content type="text"><![CDATA[节点层次小结 DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。 节点之间的关系构成层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构 文档节点是每个文档的根节点，通过文档节点表示的元素称之为文档元素 文档元素是文档的最外层元素，文档中的其他元素都包含在文档元素中 每个文档只能有一个文档元素，在HTML页面中，文档元素始终都是元素 HTML元素通过元素节点表示，特性(属性）通过特性节点表示，注释通过注释节点表示…… 以下类型属性和方法的详细内容可参考红宝书，也可参考第19章DOM基础的pdf，在这里就不一一列出了 Node类型JavaScript中的所有节点类型都继承自Node类型 节点属性（所有节点都有） 属性 用途 nodeName 获取元素的标签名 nodeValue 返回节点的节点值 childNodes 获取当前元素节点的所有子节点 firstChild 获取当前元素节点的第一个子节点 lastChild 获取当前元素节点的最后一个子节点 ownerDocument 获取该文档的文档根节点 parentNode 获取当前节点的父节点 previousSibling 获取当前节点的前一个同级节点 nextSibling 获取当前节点的后一个同级节点 childNodes属性保存着一个NodeList对象，是一种类数组对象，用于保存一组有序的节点 操作节点（所有节点都可用） 方法 用途 appendChild() 将新节点追加到子节点列表的末尾 insertBefore() 将新节点插入到参考节点的前面 replaceChild() 将新节点替换掉旧节点 removeChild() 移除节点 cloneNode() 复制节点 Document类型JavaScript通过Document类型表示文档 查找元素 方法 作用 getElementsByTagName() 获取相同元素的节点列表 getElementByName() 获取相同名称的节点列表 getElementById() 获取特定id元素的节点 文档写入 方法 用途 write() 原样写入 writeln() 在字符串末尾添加换行符（\n） open() 打开网页的输出流 close() 关闭网页的输出流 Element类型 在HTML中，标签名始终都以全部大写表示 1alert(div.tagname);//DIV title特性：鼠标移动到该元素之上时显示的内容 操作特性 方法 用途 getAttribute() 获取特定元素节点属性的值 setAttribute() 设置特定元素节点属性的值 removeAttribute() 移除特定元素节点属性 attributes属性Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NameNodeMap，是一个“动态”的集合，里面每一项为元素的特性 创建元素 1document.createElement(要创建元素的标签名); 创建的新元素尚未被添加在文档树中，因此浏览器无法显示可以用appendChild()等方法把其添加到文档树中 Text类型文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容 创建文本节点 1document.createTextNode(要插入节点中的文本); 同样，除非把新节点添加到文档树中已经存在的节点中，否则不会在浏览器看到新节点 规范文本节点normalize() 将所有文本节点合并成一个节点 分割文本节点splitText()将一个文本节点分为两个文本节点 Comment类型表示注释 CDATASection类型表示CDATA区域，只针对基于XML的文档 DocumentType类型包含着与文档的doctype有关的所有信息，不常用 DocumentFragment类型表示文档片段 Attr类型表示元素的特性 DOM操作技术以下两种技术均建议插入外部文件 动态脚本 使用script元素包含js代码直接插入head元素中 插入外部文件（建议）可添加到head元素中，也可添加到页面中 1&lt;scripr type=&quot;text/javascript&quot; src=&quot;URL&quot;&gt;&lt;/script&gt; 动态样式 使用style元素包含指定嵌入的样式插入head元素中 插入外部文件（建议）必须将link元素添加到head元素中 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;URL&quot;/&gt;]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习路线规划]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[前端学习路线规划一、代码编写工具sublime Text 3: sublime text编辑器单从界面看非常简洁，可以说让人一见倾心的感觉。完全符合码农的口味~~。功能上也不复杂，就跟记事本似的，很容易上手。 可以自由扩展，sublime提供了安装插件的方式，可以任意安装你想要的插件. 二、学习路线规划1. 熟练使用 HTML、CSSHTML 是标签语言，可以构建前端页面的骨架；CSS是层叠样式控制表，可以构建前端页面的外貌 这部分比较简单，到网上搜资料，书籍视频非常多。css中盒子模型，流动，block，inline，层叠，样式优先级等这些比较重要。最后再深入了解下浏览器差异性，ie9以下兼容简单了解就行了，ie9以下浏览器被淘汰掉是趋势，低版本没必要浪费大量时间去学习兼容主流浏览器，google chrome浏览器、firefox浏览器、safari浏览器、opera浏览器即可。浏览器差异内容很多，建议在实践中多多积累。 12推荐书籍：《Head First HTML 与 CSS (第2版)》 《CSS 禅意花园(修订版)》 2.javascript部分（最重要的部分）难点，也是重点，要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，有很多比较抽象的概念，必须要深入理解，比如闭包、原型、面向对象、封装等，要理解透彻。看书是必不可少的，找一本优秀的js书从头到尾深入学习了。另外，js面向对象编程必须要学习，非常重要，个人推荐一本书《javascript高级程序设计》。边学边练，实践出真知。 1234推荐教程：网易云课堂上 李炎恢老师的视频，讲得很详细，讲的是和那本红宝书一样的内容 多动手写demo推荐书籍：《Javascript 权威指南》 《JavaScript 高级程序设计(第3版)》 3.jQuery学习（这不是一个框架，是一个类库）这些基础知识掌握好之后，还需要学jQuery，这是一个非常优秀的Javascript库，大型开发必备。它简化了Javascript的复杂操作，消除了Javascript跨平台兼容问题，提供了大量实用方法，有良好的文档和帮助手册，是一个非常成熟的Javascript库。 12推荐教程：网易云课堂上 李炎恢老师的视频，多动手写demo推荐书籍：《锋利的jquery》 4.ajax的学习通过在后台与服务器进行数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，ajax是现在前端后台交互的主要方式。 12掌握的知识点：js原生的发送ajax的方法 jq的简便的发送ajax的方法 5.gitGit是目前世界上最先进的分布式版本控制系统，适合于在团队合作时进行版本控制，提高开发效率 1推荐教程：廖雪峰老师的关于git的教程博客 6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性熟练使用 HTML、CSS、JavaScript 还需要我们理解其语言最新相关标准：HTML5、CSS3 和 ES6(ECMAScript6)。 HTML 5 里新增了许多特性：语义化和新的音频、视频支持等； CSS 3 被划分为模块，解决了 CSS2 为等待各个标准统一而耗费大量时间才能推进的不足之处，同时也提供了 2D、3D、动画效果等新特性； ECMAScript6 等于 JavaScript - DOM - BOM，是 JavaScript 在 2015 年的最新标准，因为 ES6 对标准改动较大，前端开发者常常将一个前端项目是否支持 ES6 作为推进前端新技术的重要桥梁之一。ES6 将箭头函数、let 变量声明命令、Promise 编程、模块化编程等新特性纳入其标准中，得到了各大浏览器最新版本的支持。 12扩展阅读：《ES6 标准入门(第2版)》 《深入理解ES6》 7.掌握浏览器兼容、响应式布局相关解决方案早期占据浏览器半壁江山的IE浏览器上存在的众多浏览器兼容问题，耗费了当时前端开发者的大量开发时间。虽然说现在的前端开发者已经不需要考虑太多的浏览器兼容问题，对其概念的了解有利于了解前端历史包袱或在未来足以应对一些面向特殊群体(早期 IE 浏览器使用者)的前端项目。关于IE浏览器的兼容性问题在李炎恢老师的那个视频有详细的讲解 响应式布局和单页面应用是当代前端开发者的必备技能。从 Web Pages 到 Web App 时代，我们开发的前端项目有越来越多的可能需要同时在电脑端和手机端进行访问，一个有良好响应式布局的前端项目可以一个代码运行在多种不同分辨率的平台之上。 三、现在前端主流的框架1. vuejs :2016年最火的前端框架（MVVC框架）是一套用于构建用户界面的渐进式框架Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 常用于单页面应用的开发 12345678掌握的要点：(vue全家桶) 1.vue-router 2.vuex 3.vue-resource 4.vue-cli 5.Element-ui 推荐教程：详细阅读官网教程，中国人自己研发的，有中文版，不难 2. ReactjsReact 是一个用于构建用户界面的 javascript 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。 React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React特点： 1234561.声明式设计 −React采用声明范式，可以轻松描述应用。2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活 −React可以与已知的库或框架很好地配合。4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6.单向响应的数据流 − React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 123456掌握的知识点：（React全家桶技术） 1.Reactjs 2.React生命周期 3.React Router 4.Redux 5.React Native(主要用于移动端的开发) 3.AngularJS（国外开发大型项目常用框架）AngularJS的四大功能： MVC 将后台的MVC模式写入了前端语言中。我总觉得前端语言将来会很叼，从node.js开始我就又一种这样的感觉。可能在很久之后取代后端语言不是没有可能的。 模块化 就是一系列函数的集合，当应用被启动时，这些函数就会被执行。主要利用angular.module来定义模块。也是Angular.js的亮点。 指令属性 我自己的理解就是比html标签更加具有属性和方法的指令标签 双向数据绑定 传统的数据绑定是单向绑定，数据只能从model和controller生成需要的html，但是不能返过来使用。只是单方向的。双向数据绑定:也就是说我在前面填写，后面直接生成代码，将填写的显示出来。双向的意思就是如果view修改了属性值，那么model机会看到这个改变。相反也是一样的。 4. 小程序（类似一个前端开发框架）1推荐教程：官网上的小程序开发文档，尝试动手写一下小程序 5.nodejs(前端用来写后台的工具)简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。1推荐教程：官网的教程 四、一些常用的ui框架1. Bootstrape：最好的响应式css框架2. Element-ui：完美适应vuejs的ui框架3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。4. Aliceui5.Echart：最好的图表制作框架·····六、前端最好掌握的一些常用技能 Markdown笔记的使用，程序员专用笔记本 github的使用：全球最大的开源代码网站，在上面你可以找到全世界所有出名项目的源代码，被称为人类的知识宝库。 用github page搭建个人博客，上传个人项目到github上，面试加分必备项 移动端的开发 前端web开发命名规范，谷歌、百度命名标准 等等·······]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm清理缓存]]></title>
    <url>%2F2018%2F05%2F03%2Fgit%2Fnpm%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[旧版本（4及以下）1$ npm cache clean 新版本（5）先尝试1$ npm cache clean --force 若不行则使用下面的命令 1$ npm cache clear --force &amp;&amp; npm install --no-shrinkwrap --update-binary]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B6%E4%BB%96%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
</search>
